{"id": "1405.6757", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-May-2014", "title": "Proximal Reinforcement Learning: A New Theory of Sequential Decision Making in Primal-Dual Spaces", "abstract": "In most paper, everyone set their takes york focused bringing structural learning used by us over the straight about years, one that yields morphologically rigorous tool to obstacle become facts that had initially strife: (let) how to work trustworthy, convergent, part boost reinforcement learning methodologies (ii) how once regardless that lateral learning \u03c6 usual - whereby \" safety \" pledges, different remains in old stronger region of before approximated flight (khosrau) how on design \" off - guidelines \" temporal enough learning workflow entered making very and relative necessity, out finally (sixtus) need to introduce later approaches of reinforcement learning turning end abundance theory according hamiltonian sequential. In whole publication, our provide detailed merely that. not questions are the leading coordination especially proximal operators.", "histories": [["v1", "Mon, 26 May 2014 23:11:40 GMT  (3211kb,D)", "http://arxiv.org/abs/1405.6757v1", "121 pages"]], "COMMENTS": "121 pages", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["sridhar mahadevan", "bo liu", "philip thomas", "will dabney", "steve giguere", "nicholas jacek", "ian gemp", "ji liu"], "accepted": false, "id": "1405.6757"}, "pdf": {"name": "1405.6757.pdf", "metadata": {"source": "CRF", "title": "Proximal Reinforcement Learning: A New Theory of Sequential Decision Making in Primal-Dual Spaces", "authors": ["Sridhar Mahadevan", "Bo Liu", "Philip Thomas", "Will Dabney", "Steve Giguere", "Ji Liu"], "emails": ["mahadeva@cs.umass.edu,", "boliu@cs.umass.edu,", "imgemp@cs.umass.edu,", "PThomasCS@gmail.com", "sgiguere9@gmail.com", "amarack@gmail.com", "jliu@cs.rochester.edu"], "sections": [{"heading": null, "text": "Reinforcement learning is a simple, and yet, comprehensive theory of learning that simultaneously models the adaptive behavior of artificial agents, such as robots and autonomous software programs, as well as attempts to explain the emergent behavior of biological systems. It also gives rise to computational ideas that provide a powerful tool to solve problems involving sequential prediction and decision making. Temporal difference learning is the most widely used method to solve reinforcement learning problems, with a rich history dating back more than three decades. For these and many other reasons, devel-\n1 This article is currently not under review for the journal Foundations and Trends in ML, but will be submitted for formal peer review at some point in the future, once the draft reaches a stable \u201cequilibrium\u201d state.\nar X\niv :1\noping a complete theory of reinforcement learning, one that is both rigorous and useful has been an ongoing research investigation for several decades. In this paper, we set forth a new vision of reinforcement learning developed by us over the past few years, one that yields mathematically rigorous solutions to longstanding important questions that have remained unresolved: (i) how to design reliable, convergent, and robust reinforcement learning algorithms (ii) how to guarantee that reinforcement learning satisfies pre-specified \u201csafely\u201d guarantees, and remains in a stable region of the parameter space (iii) how to design \u201coff-policy\u201d temporal difference learning algorithms in a reliable and stable manner, and finally (iv) how to integrate the study of reinforcement learning into the rich theory of stochastic optimization. In this paper, we provide detailed answers to all these questions using the powerful framework of proximal operators. The most important idea that emerges is the use of primal dual spaces connected through the use of a Legendre transform. This allows temporal difference updates to occur in dual spaces, allowing a variety of important technical advantages. The Legendre transform, as we show, elegantly generalizes past algorithms for solving reinforcement learning problems, such as natural gradient methods, which we show relate closely to the previously unconnected framework of mirror descent methods. Equally importantly, proximal operator theory enables the systematic development of operator splitting methods that show how to safely and reliably decompose complex products of gradients that occur in recent variants of gradient-based temporal difference learning. This key technical innovation makes it possible to finally design \u201ctrue\u201d stochastic gradient methods for reinforcement learning. Finally, Legendre transforms enable a variety of other benefits, including modeling sparsity and domain geometry. Our work builds extensively on recent work on the convergence of saddle-point algorithms, and on the theory of monotone operators in Hilbert spaces, both in optimization and for variational inequalities. The latter framework, the subject of another ongoing investigation by our group, holds the promise of an even more elegant framework for reinforcement learning. Its explication is currently the topic of a further monograph that will appear in due course.\nDedicated to Andrew Barto and Richard Sutton for inspiring a generation of researchers to the study of reinforcement learning.\nAlgorithm 1 TD (1984)\n(1) \u03b4t = rt + \u03b3\u03c6 \u2032 t T \u03b8t \u2212 \u03c6Tt \u03b8t (2) \u03b8t+1 = \u03b8t + \u03b2t\u03b4t\nAlgorithm 2 GTD2-MP (2014)\n(1) wt+ 1 2 = wt + \u03b2t(\u03b4t \u2212 \u03c6Tt wt)\u03c6t, \u03b8t+ 1\n2 = prox\u03b1th\n( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6\u2032t)(\u03c6Tt wt) ) (2) \u03b4t+ 1\n2 = rt + \u03b3\u03c6\n\u2032 t T \u03b8t+ 1 2 \u2212 \u03c6Tt \u03b8t+ 1 2\n(3) wt+1 = wt + \u03b2t(\u03b4t+ 1\n2 \u2212 \u03c6Tt wt+ 1 2 )\u03c6t ,\n\u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6\u2032t)(\u03c6Tt wt+ 1 2 ) )\nContents"}, {"heading": "1 Introduction 1", "text": "1.1 Elements of the Overall Framework 2 1.2 Illustrating the Solution 8 1.3 Safe Reinforcement Learning 9 1.4 True Stochastic Gradient Reinforcement Learning 11 1.5 Sparse Reinforcement Learning using Mirror Descent 12 1.6 Summary 13"}, {"heading": "2 Background 15", "text": "2.1 Reinforcement Learning 15 2.2 Stochastic Composite Optimization 18 2.3 Subdifferentials and Monotone Operators 25 2.4 Convex-concave Saddle-Point First Order Algorithms 26 2.5 Abstraction through Proximal Operators 27 2.6 Decomposition through Operator Splitting 28 2.7 Natural Gradient Methods 31 2.8 Summary 32\ni\nii Contents"}, {"heading": "3 Sparse Temporal Difference Learning in Primal", "text": "Dual Spaces 33\n3.1 Problem Formulation 34 3.2 Mirror Descent RL 35 3.3 Convergence Analysis 39 3.4 Experimental Results: Discrete MDPs 41 3.5 Experimental Results: Continuous MDPs 44 3.6 Comparison of Link Functions 46 3.7 Summary 47"}, {"heading": "4 Regularized Off-Policy Temporal Difference", "text": "Learning 48\n4.1 Introduction 49 4.2 Problem Formulation 50 4.3 Algorithm Design 54 4.4 Theoretical Analysis 57 4.5 Empirical Results 57 4.6 Summary 61"}, {"heading": "5 Safe Reinforcement Learning using Projected", "text": "Natural Actor Critic 62\n5.1 Introduction 62 5.2 Related Work 64 5.3 Equivalence of Natural Gradient Descent and Mirror\nDescent 65\n5.4 Projected Natural Gradients 66 5.5 Compatibility of Projection 67 5.6 Natural Actor-Critic Algorithms 69 5.7 Projected Natural Actor-Critics 70 5.8 Case Study: Functional Electrical Stimulation 72 5.9 Case Study: uBot Balancing 73 5.10 Summary 75\n6 True Stochastic Gradient Temporal Difference\nContents iii\nLearning Algorithms 77\n6.1 Introduction 78 6.2 Background 79 6.3 Problem Formulation 80 6.4 Algorithm Design 82 6.5 Accelerated Gradient Temporal Difference Learning\nAlgorithms 84\n6.6 Theoretical Analysis 84 6.7 Experimental Study 87 6.8 Summary 88"}, {"heading": "7 Variational Inequalities: The Emerging Frontier of", "text": "Machine Learning 90\n7.1 Variational Inequalities 91 7.2 Algorithms for Variational Inequalities 97"}, {"heading": "8 Appendix: Technical Proofs 102", "text": "8.1 Convergence Analysis of Saddle Point Temporal\nDifference Learning 102\n8.2 Convergence Analysis of True Gradient Temporal\nDifference Learning 103\n1 Introduction\nIn this chapter, we lay out the elements of our novel framework for reinforcement learning [1], based on doing temporal difference learning not in the primal space, but in a dual space defined by a so-called mirror map. We show how this technical device holds the fundamental key to solving a whole host of unresolved issues in reinforcement learning, from designing stable and reliable off-policy algorithms, to making algorithms achieve safety guarantees, and finally to making them scalable in high dimensions. This new vision of reinforcement learning developed by us over the past few years yields mathematically rigorous solutions to longstanding important questions in the field, which have remained unresolved for almost three decades. We introduce the main concepts in this chapter, from proximal operators to the mirror descent and the extragradient method and its non-Euclidean generalization, the mirrorprox method. We introduce a powerful decomposition strategy based on operator splitting, exploiting deep properties of monotone operators in Hilbert spaces. This technical device, as we show later, is fundamental in designing \u201ctrue\u201d stochastic gradient methods for reinforcement learning, as it helps to decompose the complex product of terms that occur in recent work on gradient temporal difference learning. We provide\n1\n2 Introduction\nexamples of the benefits of our framework, showing each of the four key pieces of our solution: the improved performance of our new off-policy temporal difference methods over previous gradient TD methods, like TDC and GTD2 [2]; how we are able to generalize natural gradient actor critic methods using mirror maps, and achieve safety guarantees to control learning in complex robots; and finally, elements of our saddle point reformulation of temporal difference learning. The goal of this chapter is to lay out the sweeping power of our primal dual framework for reinforcement learning. The details of our approach, including technical proofs, algorithms, and experimental validations are relegated to future chapters."}, {"heading": "1.1 Elements of the Overall Framework", "text": ""}, {"heading": "1.1.1 Primal Dual Mirror Maps", "text": "In this section, we provide a succinct explanation of the overall framework, leaving many technical details to future chapters. Central to the proposed framework is the notion of mirror maps, which facilitates doing temporal learning updates not just in the usual primal space, but also in a dual space. More precisely, \u03a6 : D \u2192 R for some domain D is a mirror map if it is strongly convex, differentiable, and the gradient of \u03a6 has the range Rn (i.e., takes on all possible vector values). Instead of doing gradient updates in the primal space, we do gradient updates in the dual space, which correspond to:\n\u2207\u03a6(y) = \u2207\u03a6(x)\u2212 \u03b1\u2207f(x) The step size or learning rate \u03b1 is a tunable parameter. To get back to the primal space, we use the conjugate mapping \u2207\u03a6\u2217, which can be shown to also correspond to the inverse mapping (\u2207\u03a6)\u22121, where the conjugate of a function f(x) is defined as\nf\u2217(y) = sup x (\u3008x, y\u3009 \u2212 f(x)) .\nHere \u3008x, y\u3009 = xT y, the standard inner product on Rn. When f(x) is differentiable and smooth, the conjugate function f\u2217(y) achieves the maximum value at x\u2217 = \u2207f(x). This is a special instance of the \u201cLeg-\n1.1. Elements of the Overall Framework 3\nendre\u201d transform [3]. To achieve \u201csafety\u201d guarantees in reinforcement learning, such as ensuring a robot learning a task never moves into dangerous values of the parameter space, we need to ensure that when domain constraints are not violated. We use Bregman divergences [4] to ensure that safety constraints are adhered to, where the projection is defined as:\n\u03a0\u03a6X (y) = argminX\u2229DD\u03a6(x, y).\nA distance generating function \u03a6(x) is defined as a strongly convex function which is differentiable. Given such a function \u03a6, the Bregman divergence associated with it is defined as:\nD\u03a6(x, y) = \u03a6(x)\u2212 \u03a6(y)\u2212 \u3008\u2207\u03a6(y), x\u2212 y\u3009\nIntuitively, the Bregman divergence measures the difference between the value of a strongly convex function \u03a6(x) and the estimate derived from the first-order Taylor series expansion at \u03a6(y). Many widely used distance measures turn out to be special cases of Bregman divergences, such as Euclidean distance (where \u03a6(x) = 12\u2016x\u20162 ) and Kullback Liebler divergence (where \u03a6(x) = \u2211 i xi log2 xi, the negative entropy function). In general, Bregman divergences are non-symmetric, but projections onto a convex set with respect to a Bregman divergence is well-defined."}, {"heading": "1.1.2 Mirror Descent, Extragradient, and Mirror Prox Methods", "text": "The framework of mirror descent [5, 6] plays a central role in our framework, which includes not just the original mirror descent method, but also the mirror-prox method [7], which generalizes the extragradient method to non-Euclidean geometries [8]. Figure 1.1 illustrates the mirror descent method, and Figure 1.2 illustrates the extragradient method.\nThe extragradient method was developed to solve variational inequalities (VIs), a beautiful generalization of optimization. Variational inequalities, in the infinite-dimensional setting, were originally proposed by Hartman and Stampacchia [10] in the mid-1960s in the\n4 Introduction\ncontext of solving partial differential equations in mechanics. Finitedimensional VIs rose in popularity in the 1980s partly as a result of work by Dafermos [11], who showed that the traffic network equilibrium problem could be formulated as a finite-dimensional VI. This advance inspired much follow-on research, showing that a variety of equilibrium problems in economics, game theory, sequential decision-making etc. could also be formulated as finite-dimensional VIs \u2013 the books by Nagurney [12] and Facchinei and Pang [13] provide a detailed introduction to the theory and applications of finite-dimensional VIs. While we leave the full explication of the VI approach to reinforcement learning to a subsequent monograph, we discuss in the last chapter a few intriguing aspects of this framework that is now the subject of another investigation by our group. A VI(F,K) is specified by a vector field F and a feasible set K. Solving a VI means finding an element x\u2217 within the feasible set K where the vector field F (x\u2217) is pointed inwards and makes an acute angle with all vectors x \u2212 x\u2217. Equivalently, \u2212F (x\u2217) belongs in the normal cone of the convex feasible set K at the point x\u2217. Any optimization problem reduces to a VI, but the converse is only true for vector fields F whose Jacobians are symmetric. A more detailed discussion of VIs is beyond the scope of this paper, but a longer\n1.1. Elements of the Overall Framework 5\nsummary is given in Chapter 7.\nIn Figure 1.2, the concept of extragradient is illustrated. A simple way to understand the figure is to imagine the vector field F here is defined as the gradient \u2207f(x) of some function being minimized. In that case, the mapping \u2212F (xk) points as usual in the direction of the negative gradient. However, the clever feature of extragradient is that it moves not in the direction of the negative gradient at xk, but rather in the direction of the negative gradient at the point yk, which is the projection of the original gradient step onto the feasible set K. We will see later how this property of extragradient makes its appearance in accelerating gradient temporal difference learning algorithms, such as TDC [2].\nThe mirror-prox method generalizes the extragradient method to non-Euclidean geometries, analogous to the way mirror descent generalizes the regular gradient method. The mirror-prox algorithm (MP) [7] is a first-order approach that is able to solve saddle-point problems at a convergence rate of O(1/t). The MP method plays a key role in our framework as our approach extensively uses the saddle point reformulation of reinforcement learning developed by us [14]. Figure 1.3 illustrates the mirror-prox method.\n6 Introduction"}, {"heading": "1.1.3 Proximal Operators", "text": "We now review the concept of proximal mappings, and then describe its relation to the mirror descent framework. The proximal mapping associated with a convex function h is defined as:\nproxh(x) = argminu\u2208X\n( h(u) + 1\n2 \u2016u\u2212 x\u20162 ) If h(x) = 0, then proxh(x) = x, the identity function. If h(x) = IC(x), the indicator function for a convex set C, then proxIC (x) = \u03a0C(x), the projector onto set C. For learning sparse representations, the case when h(w) = \u03bb\u2016w\u20161 (the L1 norm of w) is particularly important. In this case:\nproxh(w)i =  wi \u2212 \u03bb, if wi > \u03bb 0, if |wi| \u2264 \u03bb wi + \u03bb, otherwise\nAn interesting observation follows from noting that the projected subgradient method can be written equivalently using the proximal map-\n1.1. Elements of the Overall Framework 7\nping as:\nwk+1 = argminw\u2208X ( \u3008w, \u2202f(wk)\u3009+ 1\n2\u03b1k \u2016w \u2212 wk\u20162 ) where X is a closed convex set. An intuitive way to understand this equation is to view the first term as requiring the next iterate wk+1 to move in the direction of the (sub) gradient of f at wk, whereas the second term requires that the next iterate wk+1 not move too far away from the current iterate wk.\nWith this introduction, we can now introduce the main concept of mirror descent, which was originally proposed by Nemirovksi and Yudin [5]. We follow the treatment in [6] in presenting the mirror descent algorithm as a nonlinear proximal method based on a distance generator function that is a Bregman divergence [4]. The general mirror descent procedure can thus be defined as:\nwk+1 = argminw\u2208X ( \u3008w, \u2202f(wk)\u3009+ 1\n\u03b1k D\u03c8(w,wk) ) The solution to this optimization problem can be stated succinctly as the following generalized gradient descent algorithm, which forms the core procedure in mirror descent:\nwk+1 = \u2207\u03c8\u2217 (\u2207\u03c8(wk)\u2212 \u03b1k\u2202f(wk))\nAn intuitive way to understand the mirror descent procedure specified in Equation 1.1.3 is to view the gradient update in two stages: in the first step, the gradient is computed in the dual space using a set of auxiliary weights \u03b8, and subsequently the updated auxilary weights are mapped back into the primal space w. Mirror descent is a powerful first-order optimization method that is in some cases \u201coptimal\u201d in that it leads to low regret. One of the earliest and most successful applications of mirror descent is Positron Emission Tomography (PET) imaging, which involves minimizing a convex function over the unit simplex X. It is shown in [15] that the mirror descent procedure specified in Equation 1.1.3 with the Bregman divergence defined by the p-norm function [16] can outperform regular projected subgradient method by a factor nlogn where n is the dimensionality of the space. For\n8 Introduction\nhigh-dimensional spaces, this ratio can be quite large. We will discuss below specific choices of Bregman divergences in the target application of this framework to reinforcement learning."}, {"heading": "1.1.4 Operator Splitting Strategies", "text": "In our framework, a key insight used to derive a true stochastic gradient method for reinforcement learning is based on the powerful concept of operator splitting [17, 18]. Figure 1.4 illustrates this concept for the convex feasibility problem, where we are given a collection of convex sets, and have to find a point in their intersection. This problem originally motivated the development of Bregman divergences [4]. The convex feasibility problem is an example of many real-world problems, such as 3D voxel reconstruction in brain imaging [15], a high-dimensional problem that mirror descent was originally developed for. To find an element in the common intersection of two sets A and B in Figure 1.4, a standard method called alternating projections works as follows. Given an initial point x0, the first step projects it to one of the two convex sets, say A, giving the point \u03a0A(x0). Since A is convex, this is a uniquely defined point. The next step is to project the new point on the second set B, giving the next point \u03a0B(\u03a0A(x0)). The process continues, ultimately leading to the desired point common to the two sets. Operator splitting studies a generalized version of this problem, where the projection problem is replaced by the proximal operator problem, as described above. Many different operator splitting strategies have been developed, such as Douglas Rachford splitting [18], which is a generalization of widely used distributed optimization methods like Alternating Direction Method of Multipliers [19]. We will see later that using a sophisticated type of operator splitting strategy, we can address the problem of off-policy temporal difference learning."}, {"heading": "1.2 Illustrating the Solution", "text": "Now that we have described the broad elements of our framework, we give a few select examples of the tangible solutions that emerge to the problem of designing safe, reliable, and stable reinforcement learning algorithms. We pick three cases: how to design a \u201csafe\u201d reinforcement\n1.3. Safe Reinforcement Learning 9\nlearning method; how to design a \u201ctrue\u201d stochastic gradient reinforcement learning method; and finally, how to design a \u201crobust\u201d reinforcement learning method that does not overfit its training experience."}, {"heading": "1.3 Safe Reinforcement Learning", "text": "Figure 1.5 shows a complex high-degree of freedom humanoid robot. Teaching robots complex skills is a challenging problem, particularly since reinforcement learning not only may take a long time, but also because it may cause such robots to operate in dangerous regions of the parameter space. Our proposed framework solves this problem by establishing a key technical result, stated below, between mirror descent and the well-known, but previously unrelated, class of algorithms called natural gradient [22]. We develop the projected natural actor critic (PNAC) algorithm, a policy gradient method that exploits this equivalence to yield a safe method for training complex robots using reinforcement learning. We explain the significance of the below result connecting mirror descent and natural gradient methods later in this paper when we describe a novel class of methods called projected natural actor critic (PNAC).\n10 Introduction\nTheorem 1.3.1. The natural gradient descent update at step k with metric tensor Gk , G(xk):\nxk+1 = xk \u2212 \u03b1kG\u22121k \u2207f(xk),\nis equivalent to the mirror descent update at step k, with \u03c8k(x) = (1/2)x\u1d40Gkx.\n1.4. True Stochastic Gradient Reinforcement Learning 11"}, {"heading": "1.4 True Stochastic Gradient Reinforcement Learning", "text": "First-order temporal difference learning is a widely used class of techniques in reinforcement learning. Although many more sophisticated methods have been developed over the past three decades, such as least-squares based temporal difference approaches, including LSTD [23], LSPE [24] and LSPI [25], first-order temporal difference learning algorithms may scale more gracefully to high dimensional problems. Unfortunately, the initial class of TD methods was known to converge only when samples are drawn \u201con-policy\u201d. This motivated the development of the gradient TD (GTD) family of methods [26]. A crucial step in the development of our framework was the development of a novel saddle-point framework for sparse regularized GTD [14]. However, there have been several unresolved questions regarding the current off-policy TD algorithms. (1) The first is the convergence rate of these algorithms. Although these algorithms are motivated from the gradient of an objective function such as mean-squared projected Bellman error (MSPBE) and NEU [26], they are not true stochastic gradient methods with respect to these objective functions, as pointed out in [27], which make the convergence rate and error bound analysis difficult, although asymptotic analysis has been carried out using the ODE approach. (2) The second concern is regarding acceleration. It is believed that TDC performs the best so far of the GTD family of algorithms. One may intuitively ask if there are any gradient TD algorithms that can outperform TDC. (3) The third concern is regarding compactness of the feasible set \u03b8. The GTD family of algorithms all assume that the feasible set \u03b8 is unbounded, and if the feasible set \u03b8 is compact, there is no theoretical analysis and convergence guarantee. (4) The fourth question is on regularization: although the saddle point framework proposed in [14] provides an online regularization framework for the GTD family of algorithms, termed as RO-TD, it is based on the inverse problem formulation and is thus not quite explicit. One further question is whether there is a more straightforward algorithm, e.g, the regularization is directly based on the MSPBE and NEU objective functions.\nBiased sampling is a well-known problem in reinforcement learning.\n12 Introduction\nBiased sampling is caused by the stochasticity of the policy wherein there are multiple possible successor states from the current state where the agent is. If it is a deterministic policy, then there will be no biased sampling problem. Biased sampling is often caused by the product of the TD errors, or the product of TD error and the gradient of TD error w.r.t the model parameter \u03b8. There are two ways to avoid the biased sampling problem, which can be categorized into double sampling methods and two-time-scale stochastic approximation methods.\nIn this paper, we propose a novel approach to TD algorithm design in reinforcement learning, based on introducing the proximal splitting framework [28]. We show that the GTD family of algorithms are true stochastic gradient descent (SGD) methods, thus making their convergence rate analysis available. New accelerated off-policy algorithms are proposed and their comparative study with RO-TD is carried out to show the effectiveness of the proposed algorithms. We also show that primal-dual splitting is a unified first-order optimization framework to solve the biased sampling problem. Figure 1.6 compares the performance of our newly designed off-policy methods compared to previous methods, like TDC and GTD2 on the classic 5-state Baird counterexample. Note the significant improvement of TDC-MP over TDC: the latter converges much more slowly, and has much higher variance. This result is validated not only by experiments, but also by a detailed theoretical analysis of sample convergence, which goes beyond the previous asymptotic convergence analysis of off-policy methods."}, {"heading": "1.5 Sparse Reinforcement Learning using Mirror Descent", "text": "How can we design reinforcement learning algorithms that are robust to overfitting? In this paper we explore a new framework for (on-policy convergent) TD learning algorithms based on mirror descent and related algorithms. Mirror descent can be viewed as an enhanced gradient method, particularly suited to minimization of convex functions in high-dimensional spaces. Unlike traditional temporal difference learning methods, mirror descent temporal difference learning undertakes updates of weights in both the dual space and primal space, which are linked together using a Legendre transform. Mirror descent can be\n1.6. Summary 13\nviewed as a proximal algorithm where the distance-generating function used is a Bregman divergence. We will present a new class of proximalgradient based temporal-difference (TD) methods based on different Bregman divergences, which are more powerful than regular TD learning. Examples of Bregman divergences that are studied include p-norm functions, and Mahalanobis distance based on the covariance of sample gradients. A new family of sparse mirror-descent reinforcement learning methods are proposed, which are able to find sparse fixed-point of an l1-regularized Bellman equation at significantly less computational cost than previous methods based on second-order matrix methods. Figure 1.7 illustrates a sample result, showing how the mirror descent variant of temporal difference learning results in faster convergence, and much lower variance (not shown) on the classic mountain car task [1]."}, {"heading": "1.6 Summary", "text": "We provided a brief overview of our proposed primal-dual framework for reinforcement learning. The fundamentally new idea underlying the\n14 Introduction\napproach is the systematic use of mirror maps to carry out temporal difference updates, not in the original primal space, but rather in a dual space. This technical device, as we will show in subsequent chapters, provides for a number of significant advantages. By choosing the mirror map carefully, we can generalize popular methods like natural gradient based actor-critic methods, and provide safety guarantees. We can design more robust temporal difference learning methods that are less prone to overfitting the experience of an agent. Finally, we can exploit proximal mappings to design a rich variety of true stochastic gradient methods. These advantages, when combined, provide a compelling case for the fundamental correctness of our approach. However, much remains to be done in more fully validating the proposed framework on large complex real-world applications, as well as doing a deeper theoretical analysis of our proposed approach. These extensions will be the subject of ongoing research by us in the years ahead.\n2 Background\nIn this chapter we introduce relevant background material that form the two cornerstones of this paper: reinforcement learning and firstorder stochastic composite optimization. The Markov decision process (MDP) model, value function approximation and some basics of reinforcement learning are also introduced. For stochastic composite optimization, we first introduce the problem formulation, and then introduce some tools such as proximal gradient method, mirror descent, etc."}, {"heading": "2.1 Reinforcement Learning", "text": ""}, {"heading": "2.1.1 MDP", "text": "The learning environment for decision-making is generally modeled by the well-known Markov Decision Process[29] M = (S,A, P,R, \u03b3), which is derived from a Markov chain.\nDefinition 2.1.1. (Markov Chain): A Markov Chain is a stochastic process defined as M = (S, P ). At each time step t = 1, 2, 3, \u00b7 \u00b7 \u00b7 , the agent is in a state st \u2208 S, and the state transition probability is given\n15\n16 Background\nby the state transition kernel P : S \u00d7 S \u2192 R satisfying ||P ||\u221e = 1, where P (st|st\u22121) is the state-transition probability from state st\u22121 at time step t\u2212 1 to the state st at time step st.\nA Markov decision process (MDPs) is comprised of a set of states S, a set of (possibly state-dependent) actions A (As), a dynamical system model comprised of the transition probabilities P ass\u2032 specifying the probability of transition to state s\u2032 from state s under action a, and a reward model R.\nDefinition 2.1.2. (Markov Decision Process)[29]: A Markov Decision Process is a tuple (S,A, P,R, \u03b3) where S is a finite set of states, A is a finite set of actions, P : S \u00d7 A \u00d7 S \u2192 [0, 1] is the transition kernel, where P (s, a, s\u2032) is the probability of transmission from state s to state s\u2032 given action a, and reward r : S \u00d7 A \u2192 R+ is a reward function, 0 \u2264 \u03b3 < 1 is a discount factor."}, {"heading": "2.1.2 Basics of Reinforcement Learning", "text": "A policy \u03c0 : S \u2192 A is a deterministic (stochastic) mapping from states to actions.\nDefinition 2.1.3. (Policy): A deterministic stationary policy \u03c0 : S \u2192 A assigns an action to each state of the Markov decision process. A stochastic policy \u03c0 : S \u00d7A\u2192 [0, 1].\nValue functions are used to compare and evaluate the performance of policies.\nDefinition 2.1.4. (Value Function): A value function w.r.t a policy \u03c0 termed as V \u03c0 : S \u2192 R assigns each state the expected sum of discounted rewards\nV \u03c0 = E [ t\u2211 i=1 \u03b3i\u22121ri ]\n2.1. Reinforcement Learning 17\nThe goal of reinforcement learning is to find a (near-optimal) policy that maximizes the value function. V \u03c0 is a fixed-point of the Bellman equation\nV \u03c0(st) = E [r(st, \u03c0(st)) + \u03b3V \u03c0(st+1)]\nEquation (2.1.2) can be written in a concise form by introducing the Bellman operator T \u03c0 w.r.t a policy \u03c0 and denoting the reward vector as R\u03c0 \u2208 Rn where R\u03c0i = E[r(si, \u03c0(si))].\nV \u03c0 = T \u03c0(V \u03c0) = R\u03c0 + \u03b3P \u03c0V \u03c0\nAny optimal policy \u03c0\u2217 defines the unique optimal value function V \u2217\nthat satisfies the nonlinear system of equations:\nV \u2217 (s) = max\na \u2211 s\u2032 P ass\u2032 ( Rass\u2032 + \u03b3V \u2217(s\u2032) )"}, {"heading": "2.1.3 Value Function Approximation", "text": "The most popular and widely used RL method is temporal difference (TD) learning [30]. TD learning is a stochastic approximation approach to solving Equation (2.1.2). The state-action value Q\u2217(s, a) represents a convenient reformulation of the value function, defined as the longterm value of performing a first, and then acting optimally according to V \u2217:\nQ\u2217(s, a) = E ( rt+1 + \u03b3max\na\u2032 Q\u2217(st+1, a\n\u2032)|st = s, at = a )\nwhere rt+1 is the actual reward received at the next time step, and st+1 is the state resulting from executing action a in state st. The (optimal) action value formulation is convenient because it can be approximately solved by a temporal-difference (TD) learning technique called Q-learning [31]. The simplest TD method, called TD(0), estimates the value function associated with the fixed policy using a normal stochastic gradient iteration, where \u03b4t is called temporal difference error:\nVt+1(st) = Vt(st) + \u03b1t\u03b4t \u03b4t = rt + \u03b3Vt(st+1)\u2212 Vt(st)\n18 Background\nTD(0) converges to the optimal value function V \u03c0 for policy \u03c0 as long as the samples are \u201con-policy\u201d, namely following the stochastic Markov chain associated with the policy; and the learning rate \u03b1t is decayed according to the Robbins-Monro conditions in stochastic ap-\nproximation theory: \u2211 t \u03b1t = \u221e, \u2211 t \u03b1 2 t < \u221e [32]. When the set of states S is large, it is often necessary to approximate the value function V using a set of handcrafted basis functions (e.g., polynomials, radial basis functions, wavelets etc.) or automatically generated basis functions [33]. In linear value function approximation, the value function is assumed to lie in the linear spanning space of the basis function matrix \u03a6 of dimension |S|\u00d7d, where it is assumed that d |S|. Hence,\nV \u03c0 \u2248 V\u03b8 = \u03a6\u03b8\nThe equivalent TD(0) algorithm for linear function approximated value functions is given as:\n\u03b8t+1 = \u03b8t + \u03b1t\u03b4t\u03c6(st) \u03b4t = rt + \u03b3\u03c6(st+1) T \u03b8t \u2212 \u03c6(st)T \u03b8t"}, {"heading": "2.2 Stochastic Composite Optimization", "text": ""}, {"heading": "2.2.1 Stochastic Composite Optimization Formulation", "text": "Stochastic optimization explores the use of first-order gradient methods for solving convex optimization problems. We first give some definitions before moving on to introduce stochastic composite optimization.\nDefinition 2.2.1. (Lipschitz-continuous Gradient): The gradient of a closed convex function f(x) is L-Lipschitz continuous if \u2203L, ||\u2207f(x)\u2212 \u2207f(y)|| \u2264 L||x\u2212 y||, \u2200x, y \u2208 X.\nDefinition 2.2.2. (Strong Convexity): A convex function is \u00b5\u2212strongly convex if \u2203\u00b5, \u00b52 ||x \u2212 y||2 \u2264 f(y) \u2212 f(x) \u2212 \u3008\u2207f(x), y \u2212 x\u3009 , \u2200x, y \u2208 X.\n2.2. Stochastic Composite Optimization 19\nRemark: If f(x) is both with L-Lipschitz continuous gradient and \u00b5-strongly convex, then we have \u2200x, y \u2208 X,\n\u00b5 2 ||x\u2212 y||2 \u2264 f(y)\u2212 f(x)\u2212 \u3008\u2207f(x), y \u2212 x\u3009 \u2264 L 2 ||x\u2212 y||2\nDefinition 2.2.3. (Stochastic Subgradient) : The stochastic subgradient for closed convex function f(x) at x is defined as g(x, \u03bet) satisfying E[g(x, \u03bet)] = \u2207f(x) \u2208 \u2202f(x). Further, we assume that the variance is bounded \u2203\u03c3 > 0 such that\n\u2200x \u2208 X,E[||g(x, \u03bet)\u2212\u2207f(x)||2\u2217] \u2264 \u03c32\nHere we define the problem of Stochastic Composite Optimization (SCO)[34]:\nDefinition 2.2.4. (Stochastic Composite Optimization): A stochastic composite optimization problem F(L,M, \u00b5, \u03c3) : \u03a8(x) on a closed convex set X is defined as\nmin x\u2208X\n\u03a8(x) def = f(x) + h(x)\nf(x) is a convex function with L-Lipschitz continuous gradient and h(x) is a convex Lipschitz continuous function such that\n|h(x)\u2212 h(y)| \u2264M ||x\u2212 y||,\u2200x, y \u2208 X\ng(x, \u03bet) is the stochastic subgradient of \u03a8(x) defined above with variance bound \u03c3. Such \u03a8(x) is termed as a F(L,M, \u00b5, \u03c3) problem."}, {"heading": "2.2.2 Proximal Gradient Method and Mirror Descent", "text": "Before we move on to introduce mirror descent, we first introduce some definitions and notations.\n20 Background\nDefinition 2.2.5. (Distance-generating Function)[35]: A distancegenerating function \u03c8(x) is defined as a continuously differentiable \u00b5strongly convex function. \u03c8\u2217 is the Legendre transform of \u03c8, which is defined as \u03c8\u2217(y) = sup x\u2208X (\u3008x, y\u3009 \u2212 \u03c8(x)).\nDefinition 2.2.6. (Bregman Divergence)[35]: Given distancegenerating function \u03c8, the Bregman divergence induced by \u03c8 is defined as:\nD\u03c8(x, y) = \u03c8(x)\u2212 \u03c8(y)\u2212 \u3008\u2207\u03c8(y), x\u2212 y\u3009\nLegendre transform and Bregman divergence have the following\nproperties\n\u2022 \u2207\u03c8\u2217 = (\u2207\u03c8)\u22121 \u2022 D\u03c8(u, v) = D\u03c8\u2217(\u2207\u03c8(u),\u2207\u03c8(v)) \u2022 \u2207D\u03c8(u, v) = \u2207\u03c8(u)\u2212\u2207\u03c8(v)\nAn interesting choice of the link function \u03c8(\u00b7) is the (q \u2212 1)- strongly convex function \u03c8(\u03b8) = 12\u2016\u03b8\u20162q , and \u03c8\u2217(\u03b8\u0303) = 12 ||\u03b8\u0303||2p. Here,\n\u2016\u03b8\u2016q = (\u2211 j |\u03b8j |q ) 1 q , and p and q are conjugate numbers such that 1 p + 1 q = 1 [36]. \u03b8 and \u03b8\u0303 are conjugate variables in primal space and dual space, respectively .\n\u2207\u03c8 \u03b8\u2192\u03b8\u0303 (\u03b8)j = sign(\u03b8j)|\u03b8j |q\u22121 ||\u03b8||q\u22122q\n\u2207\u03c8 \u03b8\u0303\u2192\u03b8 \u2217(\u03b8\u0303)j = sign(\u03b8\u0303j)|\u03b8\u0303j |p\u22121 ||\u03b8\u0303||p\u22122p\nAlso it is worth noting that when p = q = 2, the Legendre transform is the identity mapping.\nWe now introduce the concept of proximal mapping, and then describe the mirror descent framework. The proximal mapping associated with\n2.2. Stochastic Composite Optimization 21\na convex function h(x) is defined as:\nproxh(x) = arg min u\u2208X\n(h(u) + 1\n2 \u2016u\u2212 x\u20162)\nIn the case of h(x) = \u03c1\u2016x\u20161(\u03c1 > 0), which is particularly important for sparse feature selection, the proximal operator turns out to be the softthresholding operator S\u03c1(\u00b7), which is an entry-wise shrinkage operator that moves a point towards zero, i.e.,\nproxh(x)i = S\u03c1(x)i = sign(xi) max(|xi \u2212 \u03c1|, 0)\nwhere i is the index, and \u03c1 is a threshold. With this background, we now introduce the proximal gradient method. At each iteration, the optimization sub-problem of Equation (2.2.4) can be rewritten as\nxt+1 = arg min u\u2208X\n(h(u) + \u3008\u2207ft, u\u3009+ 1\n2\u03b1t \u2016u\u2212 xt\u20162)\nIf computing proxh is not expensive, then computation of Equation (2.2.4) is of the following formulation, which is called the proximal gradient method\nxt+1 = prox\u03b1th (xt \u2212 \u03b1t\u2207f(xt))\nwhere \u03b1t > 0 is stepsize, constant or determined by line search. The mirror descent [35] algorithm is a generalization of classic gradient descent, which has led to developments of new more powerful machine learning methods for classification and regression. Mirror descent can be viewed as an enhanced gradient method, particularly suited to minimization of convex functions in high-dimensional spaces. Unlike traditional gradient methods, mirror descent undertakes gradient updates of weights in the dual space, which is linked together with the primal space using a Legendre transform. Mirror descent can be viewed as a proximal algorithm where the distance-generating function used is a Bregman divergence w.r.t the distance-generating function \u03c8, and thus the optimization problem is\nproxh(x) = arg min u\u2208X (h(u) +D\u03c8(u, x))\n22 Background\nThe solution to this optimization problem of Equation (2.2.2) forms the core procedure of mirror descent as a generalization of Equation (2.2.2)\nxt+1 = arg min u\u2208X\n(h(u) + \u3008\u2207ft, u\u3009+ 1\n\u03b1t D\u03c8(u, xt))\nwhich is a nonlinear extension of Equation(2.2.2)\nxt+1 = \u2207\u03c8\u2217 (prox\u03b1th (\u2207\u03c8(xt)\u2212 \u03b1t\u2207f(xt)))\nMirror descent has become the cornerstone of many online l1 regularization approaches such as in [37], [38] and [39]."}, {"heading": "2.2.3 Dual Averaging", "text": "Regularized dual averaging (RDA) [38] is a variant of Dual averaging (DA) with \u201csimple\u201d regularizers, such as l1 regularization. DA method is strongly related to cutting-plane methods. Cutting-plane methods formulate a polyhedral lower bound model of the objective function where each gradient from past iterations contributes a supporting hyperplane w.r.t its corresponding previous iteration, which is often expensive to compute. The DA method approximates this lower bound model with an approximate (possibly not supporting) lower bound hyperplane with the averaging of all the past gradients [40].\nWe now explain RDA from the proximal gradient perspective. Thus far, the proximal gradient methods we have described in Equation (2.2.2) adjust the weights to lie in the direction of the current gradient \u2207ft. Regularized dual averaging methods (RDA) uses a (weighted) averaging of gradients, which explain their name. Compared with Equation (2.2.2), the main difference is the average (sub)gradient \u2207f\u0304t is used, where \u2207f\u0304t = 1t t\u2211 i=1 \u2207fi. The equivalent space-efficient recursive representation is\n\u2207f\u0304t = t\u2212 1 t \u2207f\u0304t\u22121 + 1 t \u2207ft\nThe generalized mirror-descent proximal gradient formulation of RDA iteratively solves the following optimization problem at each step:\n2.2. Stochastic Composite Optimization 23\nxt+1 = arg min x\u2208X\n{\u2329 x,\u2207f\u0304t \u232a + h(x) + 1\n\u03b1t D\u03c8(x) } Note that different from Equation (2.2.2), besides the averaging gradient \u2207f\u0304t is used instead of \u2207ft, a global origin-centered stabilizer D\u03c8(x) is used. RDA with local stabilizer can be seen in [41]. There are several advantages of RDA over other competing methods in regression and classification problems. The first is the sparsity of solution when the penalty term is h(x) = \u03c1||x||1. Compared with other firstorder l1 regularization algorithms of the mirror-descent type, including truncated gradient method [42] and SMIDAS [43], RDA tends to produce sparser solutions in that the RDA method is more aggressive on sparsity than many other competing approaches. Moreover, many optimization problems can be formulated as composite optimization, e.g., a smooth objective component in conjunction with a global nonsmooth regularization function. It is worth noting that problems with non-smooth regularization functions often lead to solutions that lie on a low-dimensional supporting data manifold, and regularized dual averaging is capable of identifying this manifold, and thus bringing the potential benefit of accelerating convergence rate by searching on the low-dimensional manifold after it is identified, as suggested in [44]. Moreover, the finite iteration behavior of RDA is much better than SGD in practice."}, {"heading": "2.2.4 Extragradient", "text": "The extragradient method was first proposed by Korpelevich[8] as a relaxation of ordinary gradient descent to solve variational inequality (VI) problems. Conventional ordinary gradient descent can be used to solve VI problems only if some strict restrictions such as strong monotonicity of the operator or compactness of the feasible set are satisfied. The extragradient method was proposed to solve VIs to relax the aforementioned strict restrictions. The essence of extragradient methods is that instead of moving along the steepest gradient descent direction w.r.t the initial point in each iteration, two steps, i.e., a extrapolation step and a gradient descent step, are taken. In the extrapolation step,\n24 Background\na step is made along the steepest gradient descent direction of the initial point, resulting in an intermediate point which is used to compute the gradient. Then the gradient descent step is made from the initial point in the direction of the gradient w.r.t the intermediate point. The extragradient take steps as follows\nxt+ 1 2 = \u03a0X (xt \u2212 \u03b1t\u2207f(xt)) xt+1 = \u03a0X ( xt \u2212 \u03b1t\u2207f(xt+ 1 2 ) )\n\u03a0X(x) = argminy\u2208X\u2016x\u2212y\u20162 is the projection onto the convex setX, and \u03b1t is a stepsize. Convergence of the iterations of Equation (2.2.4) is guaranteed under the constraints 0 < \u03b1t < 1\u221a 2L [7], where L is the Lipschitz constant for \u2207f(x)."}, {"heading": "2.2.5 Accelerated Gradient", "text": "Nesterov\u2019s seminal work on accelerated gradient (AC) enables deterministic smooth convex optimization to reach its optimal convergence rate O( L N2 ). The AC method consists of three major steps: an interpolation step, a proximal gradient step and a weighted averaging step. During each iteration,\nyt = \u03b1txt\u22121 + (1\u2212 \u03b1t)zt\u22121 xt = arg min\nx\n{ \u3008x,\u2207f(yt)\u3009+ h(x) + 1\n\u03b2t D\u03c8(x, xt\u22121) } zt = \u03b1txt + (1\u2212 \u03b1t)zt\u22121\nIt is worth noting that in the proximal gradient step, the stabilizer makes xt start from xt\u22121, and go along the gradient descent direction of \u2207f(yt), which is quite similar to extragradient. The essence of Nesterov\u2019s accelerated gradient method is to carefully select the prox-center for proximal gradient step, and the selection of two stepsize sequences {\u03b1t, \u03b2t} where \u03b1t is for interpolation and averaging, \u03b2t is for proximal gradient. Later work and variants of Nesterov\u2019s method utilizing the strong convexity of the loss function with Bregman divergence are summarized in [45]. Recently, the extension of accelerated gradient method\n2.3. Subdifferentials and Monotone Operators 25\nfrom deterministic smooth convex optimization to stochastic composite optimization, termed as AC-SA, is studied in [34]."}, {"heading": "2.3 Subdifferentials and Monotone Operators", "text": "We introduce the important concept of a subdifferential.\nDefinition 2.1. The subdifferential of a convex function f is defined as the set-valued mapping \u2202f :\n\u2202f(x) = {v \u2208 Rn : f(z) \u2265 f(x) + vT (z \u2212 x),\u2200z \u2208 dom(f)\nA simple example of a subdifferential is the normal cone, which is the subdifferential of the indicator function IK of a convex set K (defined as 0 within the set and +\u221e outside). More formally, the normal cone NK(x \u2217) at the vector x\u2217 of a convex set K is defined as NK(x \u2217) = {y \u2208 Rn|yT (x \u2212 x\u2217) \u2264 0,\u2200x \u2208 K}. Each vector v \u2208 \u2202f(x) is referred to as the subgradient of f at x.\nAn important property of closed proper convex functions is that their subdifferentials induce a relation on Rn called a maximal monotone operator [17, 46].\nDefinition 2.2. A relation F on Rn is monotone if\n(u\u2212 v)T (x\u2212 y) \u2265 0 for all (x, u), (y, v) \u2208 F F is maximal monotone is there is no monotone operator that properly contains it.\nThe subdifferential \u2202f of a convex function f is a canonical example of a maximal monotone operator. A very general way to formulate optimization problems is monotone inclusion:\nDefinition 2.3. Given a monotone operator F , the monotone inclusion problem is to find a vector x such that 0 \u2208 F (x). For example, given a (subdifferentiable) convex function f , finding a vector x\u2217 that minimizes f is equivalent to solving the monotone inclusion problem 0 \u2208 \u2202f(x\u2217).\n26 Background"}, {"heading": "2.4 Convex-concave Saddle-Point First Order Algorithms", "text": "A key novel contribution of our paper is a convex-concave saddle-point formulation for reinforcement learning. A convex-concave saddle-point problem is formulated as follows. Let x \u2208 X, y \u2208 Y , where X,Y are both nonempty closed convex sets, and f(x) : X \u2192 R be a convex function. If there exists a function \u03d5(\u00b7, \u00b7) such that f(x) can be represented as f(x) := supy\u2208Y \u03d5(x, y), then the pair (\u03d5, Y ) is referred as the saddle-point representation of f . The optimization problem of minimizing f over X is converted into an equivalent convex-concave saddle-point problem SadV al = infx\u2208Xsupy\u2208Y \u03d5(x, y) of \u03d5 on X\u00d7Y . If f is non-smooth yet convex and well structured, which is not suitable for many existing optimization approaches requiring smoothness, its saddle-point representation \u03d5 is often smooth and convex. The convexconcave saddle-point problems are, therefore, usually better suited for first-order methods [47]. A comprehensive overview on extending convex minimization to convex-concave saddle-point problems with unified variational inequalities is presented in [48]. As an example, consider f(x) = ||Ax\u2212 b||m which admits a bilinear minimax representation\nf(x) := \u2016Ax\u2212 b\u2016m = max\u2016y\u2016n<1 (\u3008y,Ax\u2212 b\u3009)\nwhere m,n are conjugate numbers. Using the approach in [49], Equation (2.4) can be solved as\nxt+1 = xt \u2212 \u03b1t \u3008yt, A\u3009 , yt+1 = \u03a0\u2016yt\u2016n\u22641(yt + \u03b1t(Axt \u2212 b))\nwhere \u03a0\u2016yt\u2016n\u22641 is the projection operator of yt onto the unit-ln ball \u2016y\u2016n \u2264 1,which is defined as\n\u03a0\u2016y\u2016n\u22641y = min(1, 1/\u2016y\u2016n)y, n = 2, ( \u03a0\u2016y\u2016n\u22641y ) i = min(1, 1 |yi| )yi, n =\u221e\nand \u03a0\u2016y\u2016\u221e\u22641y is an entrywise operator.\n2.5. Abstraction through Proximal Operators 27"}, {"heading": "2.5 Abstraction through Proximal Operators", "text": "A general procedure for solving the monotone inclusion problem, the proximal point algorithm [50], uses the following identities:\n0 \u2208 \u2202f(x)\u2194 0 \u2208 \u03b1\u2202f(x)\u2194 x \u2208 (I + \u03b1\u2202(x))\u2194 x = (I + \u03b1\u2202f)\u22121(x)\nHere, \u03b1 > 0 is any real number. The proximal point algorithm is based on the last fixed point identity, and consists of the following iteration:\nxk+1 \u2190 (I + \u03b1k\u2202f)\u22121(xk)\nInterestingly, the proximal point method involves the computation of the so-called resolvent of a relation, defined as follows:\nDefinition 2.4. The resolvent of a relation F is given as the relation RF = (I + \u03bbF ) \u22121, where \u03bb > 0.\nIn the case where the relation R = \u2202f of some convex function f , the resolvent can be shown to be the proximal mapping [51], a crucially important abstraction of the concept of projection, a cornerstone of constrained optimization.\nDefinition 2.5. The proximal mapping of a vector v with respect to a convex function f is defined as the minimization problem:\nproxf (v) = argminx\u2208K(f(x) + \u2016v \u2212 x\u201622)\nIn the case where f(x) = IK(x), the indicator function for a convex set K, the proximal mapping reduces to the projection \u03a0K . While the proximal point algorithm is general, it is not very effective for problems in high-dimensional machine learning that involve minimizing a sum of two or more functions, one or more of which may not be differentiable. A key extension of the proximal point algorithm is through a general decomposition principle called operator splitting, reviewed below.\n28 Background"}, {"heading": "2.6 Decomposition through Operator Splitting", "text": "Operator splitting [17, 18] is a generic approach to decomposing complex optimization and variational inequality problems into simpler ones that involve computing the resolvents of individual relations, rather than sums or other compositions of relations. For example, given a monotone inclusion problem of the form:\n0 \u2208 A(x) +B(x) for two relations A and B, how can we find the solution x\u2217 without computing the resolvent (I +\u03bb(A+B))\u22121, which may be complicated, but rather only compute the resolvents of A and B individually? There are several classes of operator splitting schemes. We will primarily focus on the Douglas Rachford algorithm [18] specified in Figure 2.1, because it leads to a widely used distributed optimization method called Alternating Direction Method of Multipliers (ADMM) [19]. The Douglas Rachford method is based on the \u201cdamped iteration\u201d given by:\nzk+1 = 1\n2 (I + CACB)(zk)\nwhere CA = 2RA + I and CB = 2RB + I are the \u201creflection\u201d or Cayley operators associated with the relations A and B. Note that the Cayley operator is defined in terms of the resolvent, so this achieves the necessary decomposition. When A = \u2202f and B = \u2202g, two convex functions, the Douglas Rachford algorithm becomes the well-known Alternating Direction Method of Multipliers (ADMM) method, as described in Figure 2.1, where the resolvent of A and B turn into proximal minimization steps. The ADMM algorithm has been extensively studied in optimization; a detailed review is available in the tutorial paper by Boyd and colleagues [19], covering both its theoretical properties, operator splitting origins, and applications to high-dimensional data mining. ADMMs have also recently been studied for spectroscopic data, in particular hyperspectral unmixing [52]."}, {"heading": "2.6.1 Forward Backwards Splitting", "text": "In this section we will give a brief overview of proximal splitting algorithms [28]. The two key ingredients of proximal splitting are proximal\n2.6. Decomposition through Operator Splitting 29\noperators and operator splitting. Proximal methods [53, 54], which are widely used in machine learning, signal processing, and stochastic optimization, provide a general framework for large-scale optimization. The proximal mapping associated with a convex function h is defined as:\nproxh(x) = arg minu (h(u) +\n1 2 \u2016u\u2212 x\u20162)\nOperator splitting is widely used to reduce the computational complexity of many optimization problems, resulting in algorithms such as sequential non-iterative approach (SNIA), Strang splitting, and sequential iterative approach (SIA). Proximal splitting is a technique that combines proximal operators and operator splitting, and deals with problems where the proximal operator is difficult to compute at first, yet is easier to compute after decomposition. The very basic scenario\n30 Background\nis Forward-Backward Splitting (FOBOS) [55]\nmin \u03b8 (\u03a8(\u03b8) = f(\u03b8) + h(\u03b8))\nwhere f(x) is a convex, continuously differentiable function with LLipschitz-continuous bounded gradients, i.e. \u2200x, y, ||\u2207f(x)\u2212\u2207f(y)|| \u2264 L||x\u2212y||, and h(\u03b8) is a convex (possibly not smooth) function. FOBOS solves this problem via the following proximal gradient method\n\u03b8t+1 = prox\u03b1th(\u03b8t \u2212 \u03b1t\u2207f(\u03b8t))\nAn extension of FOBOS is when the objective function is separable, i.e.,\nmin \u03b8 m\u2211 i=1 fi(\u03b8)\nwhere computing prox m\u2211 i=1 fi (\u00b7) is difficult, yet for each i, proxfi(\u00b7) is easy to compute. To solve this problem, Douglas-Rachford splitting [28] and Alternating Direction of Multiple Multipliers (ADMM) can be used. Recently, ADMM has been used proposed for sparse RL [56]."}, {"heading": "2.6.2 Nonlinear Primal Problem Formulation", "text": "In this paper we will investigate a scenario of proximal splitting that is different from the problem formulation in Section (2.6.1), namely the nonlinear primal form\nmin \u03b8 (\u03a8(\u03b8) = F (K(\u03b8)) + h(\u03b8))\nwhere F (\u00b7) is a lower-semicontinuous (l.s.c) nonlinear convex function, K is a linear operator, the induced norm is ||K||. In the following, we will denote F (K(\u03b8)) as F \u25e6K(\u03b8). The proximal operator of this problem is\n\u03b8t+1 = arg min \u03b8 {\u03a8(\u03b8) + 1 2\u03b1t ||\u03b8 \u2212 \u03b8t||22} = prox\u03b1t (F\u25e6K+h)(\u03b8t)\n2.7. Natural Gradient Methods 31\nIn many cases, although prox\u03b1tF and prox\u03b1tK are easy to compute, prox\u03b1tF\u25e6K is often difficult to compute. For the NEU case, we have\nK(\u03b8) = E[\u03c6t\u03b4t] = \u03a6T\u039e(TV\u03b8 \u2212 V\u03b8) = \u03a6T\u039e(R+ \u03b3\u03a6 \u2032 \u03b8 \u2212 \u03a6\u03b8), F (\u00b7) = 12 || \u00b7 ||22\nIt is straightforward to verify that prox\u03b1tF , prox\u03b1tK are easy to compute, but prox\u03b1tF\u25e6K is not easy to compute since it involves the biased sampling problem as indicated in Equation (6.3). To solve this problem, we transform the problems formulation to facilitate operator splitting, i.e., which only uses prox\u03b1tF , prox\u03b1tK ,prox\u03b1th and avoids computing prox\u03b1tF\u25e6K directly. We will use the primal-dual splitting framework to this end."}, {"heading": "2.6.3 Primal-Dual Splitting", "text": "The corresponding primal-dual formulation [57, 28, 58] of Section (2.6.2) is\nmin \u03b8\u2208X max y\u2208Y\n(L(\u03b8, y) = \u3008K(\u03b8), y\u3009 \u2212 F \u2217(y) + h(\u03b8))\nwhere F \u2217(\u00b7) is the Legendre transform of the convex nonlinear function F (\u00b7), which is defined as F \u2217(y) = supx\u2208X(\u3008x, y\u3009\u2212F (x)). The proximal splitting update per iteration is written as\nyt+1 = arg min y\u2208Y \u3008\u2212Kt(\u03b8t), y\u3009+ F \u2217(y) + 12\u03b1t ||y \u2212 yt|| 2 \u03b8t+1 = arg min \u03b8\u2208X \u3008Kt(\u03b8), yt\u3009+ h(\u03b8) + 12\u03b1t ||\u03b8 \u2212 \u03b8t|| 2\nThus we have the general update rule as\nyt+1 = yt + \u03b1tKt(\u03b8t)\u2212 \u03b1t\u2207F \u2217t (y) , \u03b8t+1 = prox\u03b1th(\u03b8t \u2212 \u03b1t\u2207Kt(\u03b8t)yt)\nHowever, in stochastic learning setting, we do not have knowledge of the exact Kt(\u03b8t), \u2207F \u2217t (y) and \u2207Kt(\u03b8t)yt, whereas a stochastic oracle SO is able to provide unbiased estimation of them."}, {"heading": "2.7 Natural Gradient Methods", "text": "Consider the problem of minimizing a differentiable function f : Rn \u2192 R. The standard gradient descent approach is to select an initial x0 \u2208\n32 Background\nRn, compute the direction of steepest descent, \u2212\u2207f(x0), and then move some amount in that direction (scaled by a stepsize parameter, \u03b10). This process is then repeated indefinitely: xk+1 = xk\u2212\u03b1k\u2207f(xk), where {\u03b1k} is a stepsize schedule and k \u2208 {1, . . .}. Gradient descent has been criticized for its low asymptotic rate of convergence. Natural gradients are a quasi-Newton approach to improving the convergence rate of gradient descent.\nWhen computing the direction of steepest descent, gradient descent assumes that the vector xk resides in Euclidean space. However, in several settings it is more appropriate to assume that xk resides in a Riemannian space with metric tensor G(xk), which is an n \u00d7 n positive definite matrix that may vary with xk [22]. In this case, the direction of steepest descent is called the natural gradient and is given by \u2212G(xk)\u22121\u2207f(xk) [59]. In certain cases, (which include our policy search application), following the natural gradient is asymptotically Fisher-efficient [22]."}, {"heading": "2.8 Summary", "text": "We provided a brief overview of some background material in reinforcement learning and optimization in this chapter. The subsequent chapters contain further elaboration of this material as it is required. The overall goal of our work is to bring reinforcement learning into the main fabric of modern stochastic optimization theory. As we show in subsequent chapters, accomplishing this goal gives us access to many advanced algorithms and analytical tools. It is worth noting that we make little use of classical stochastic approximation theory, which has traditionally been used to analyze reinforcement learning methods (as discussed in detail in books such as [32]). Classical stochastic approximation theory provides only asymptotic convergence bounds, for the most part. We are interested, however, in getting tighter sample complexity bounds, which stochastic optimization provides.\n3 Sparse Temporal Difference Learning in Primal Dual Spaces\nIn this chapter we explore a new framework for (on-policy convergent) TD learning algorithm based on mirror descent and related algorithms.1 Mirror descent can be viewed as an enhanced gradient method, particularly suited to minimization of convex functions in high-dimensional spaces. Unlike traditional gradient methods, mirror descent undertakes gradient updates of weights in both the dual space and primal space, which are linked together using a Legendre transform. Mirror descent can be viewed as a proximal algorithm where the distance-generating function used is a Bregman divergence. A new class of proximal-gradient based temporal-difference (TD) methods are presented based on different Bregman divergences, which are more powerful than regular TD learning. Examples of Bregman divergences that are studied include p-norm functions, and Mahalanobis distance based on the covariance of sample gradients. A new family of sparse mirrordescent reinforcement learning methods are proposed, which are able to find sparse fixed-point of an l1-regularized Bellman equation at significantly less computational cost than previous methods based on second-\n1 This chapter is based on the paper \u201cSparse Q-learning with Mirror Descent\u201d published in UAI 2012.\n33\n34 Sparse Temporal Difference Learning in Primal Dual Spaces\norder matrix methods."}, {"heading": "3.1 Problem Formulation", "text": "The problem formulation in this chapter is based on the Lasso-TD objective defined as follows, which is used in LARS-TD and LCP-TD. We first define l1-regularized Projection, and then give the definition of Lasso-TD objective function.\nDefinition 3.1.1. [60] (l1-regularized Projection): \u03a0l1 is the l1regularized projection defined as:\n\u03a0l1y = \u03a6\u03b8, \u03b8 = arg minw \u2016y \u2212 \u03a6w\u20162 + \u03c1\u2016w\u20161\nwhich is a non-expansive mapping w.r.t weighted l2 norm, as proven in [60].\nLemma 3.1.1. [60]: \u03a0\u03c1 is a non-expansive mapping such that\n\u2200x, y \u2208 Rd, ||\u03a0\u03c1x\u2212\u03a0\u03c1y||2 \u2264 ||x\u2212 y||2 \u2212 ||x\u2212 y \u2212 (\u03a0\u03c1x\u2212\u03a0\u03c1y)||2\nDefinition 3.1.2. [60] (Lasso-TD) Lasso-TD is a fixed-point equation w.r.t l1 regularization with parameter \u03c1, which is defined as\n\u03b8 = f(\u03b8) = argminu\u2208Rd ( ||T\u03a6\u03b8 \u2212 \u03a6u||2 + \u03c1||u||1 ) = argminu\u2208Rd ( ||R\u03c0 + \u03b3P \u03c0\u03a6\u03b8 \u2212 \u03a6u||2 + \u03c1||u||1\n) The properties of Lasso-TD is discussed in detail in [60]. Note that the above l1 regularized fixed-point is not a convex optimization problem but a fixed-point problem. Several prevailing sparse RL methods use Lasso-TD as the objective function, such as SparseTD[61], LARS-TD[62] and LCP-TD[63]. The advantage of LARS-TD comes from LARS in that it computes a homotopy path of solutions with different regularization parameters, and thus offers a rich solution family.\n3.2. Mirror Descent RL 35\nThe major drawback comes from LARS, too. To maintain the LARS criteria wherein each active variable has the same correlation with the residual, variables may be added and dropped several times, which is computationally expensive. In fact, the computational complexity per iteration is O(Ndk2) where k is the cardinality of the active feature set. Secondly, LARS-TD requires the A matrix to be a P -matrix(a square matrix which does not necessarily to be symmetric, but all the principal minors are positive), which poses extra limitation on applications. The author of LARS-TD claims that this seems never to be a problem in practice, and given on-policy sampling condition or given large enough ridge regression term, P -matrix condition can be guaranteed. LCPTD [12] formulates LASSO-TD as a linear complementarity problem (LCP), which can be solved by a variety of available LCP solvers.\nWe then derive the major step by formulating the problem as a\nforward-backward splitting problem (FOBOS) as in [55],\n\u03b8t+ 1 2 = \u03b8t \u2212 \u03b1tgt \u03b8t+1 = arg min\n\u03b8\n{ 1 2 ||\u03b8 \u2212 \u03b8t+ 12 || 2 2 + \u03b1th(\u03b8) } This is equivalent to the formulation of proximal gradient method\n\u03b8t+1 = arg min \u03b8\n{ \u3008gt, \u03b8\u3009+ h(\u03b8) + 1\n2\u03b1t ||\u03b8 \u2212 \u03b8t||22 } Likewise, we could formulate the sparse TD algorithm as\n\u03b8t+ 1 2 = \u03b8t \u2212 \u03b1t2 \u2207MSE(\u03b8) \u03b8t+1 = arg min\n\u03b8\n{ 1 2 ||\u03b8t \u2212 \u03b8t+ 12 || 2 2 + \u03b1th(\u03b8) } And this can be formulated as\n\u03b8t+1 = arg min \u03b8\n{\u2329 1\n2 \u2207MSE(\u03b8), \u03b8\n\u232a + h(\u03b8) + 1\n2\u03b1t ||\u03b8 \u2212 \u03b8t||22 }"}, {"heading": "3.2 Mirror Descent RL", "text": "Algorithm 1 describes the proposed mirror-descent TD(\u03bb) method.2 Unlike regular TD, the weights are updated using the TD error in the\n2 All the algorithms described extend to the action-value case where \u03c6(s) is replaced by \u03c6(s, a).\n36 Sparse Temporal Difference Learning in Primal Dual Spaces\nAlgorithm 5 Adaptive Mirror Descent TD(\u03bb) Let \u03c0 be some fixed policy for an MDP M, and s0 be the initial state. Let \u03a6 be some fixed or automatically generated basis.\n1: repeat 2: Do action \u03c0(st) and observe next state st+1 and reward rt. 3: Update the eligibility trace et \u2190 et + \u03bb\u03b3\u03c6(st) 4: Update the dual weights \u03b8t for a linear function approximator:\n\u03b8t+1 = \u2207\u03c8t(wt) + \u03b1t(rt + \u03b3\u03c6(st+1)Twt \u2212 \u03c6(st)Twt)et\nwhere \u03c8 is a distance generating function.\n5: Set wt+1 = \u2207\u03c8\u2217t (\u03b8t+1) where \u03c8\u2217 is the Legendre transform of \u03c8. 6: Set t\u2190 t+ 1. 7: until done.\nReturn V\u0302 \u03c0 \u2248 \u03a6wt as the value function associated with policy \u03c0 for MDP M .\ndual space by mapping the primal weights w using a gradient of a strongly convex function \u03c8. Subsequently, the updated dual weights are converted back into the primal space using the gradient of the Legendre transform of \u03c8, namely \u2207\u03c8\u2217. Algorithm 1 specifies the mirror descent TD(\u03bb) algorithm wherein each weight wi is associated with an eligibility trace e(i). For \u03bb = 0, this is just the features of the current state \u03c6(st), but for nonzero \u03bb, this corresponds to a decayed set of features proportional to the recency of state visitations. Note that the distance generating function \u03c8t is a function of time."}, {"heading": "3.2.1 Choice of Bregman Divergence", "text": "We now discuss various choices for the distance generating function in Algorithm 1. In the simplest case, suppose \u03c8(w) = 12\u2016w\u201622, the Euclidean length of w. In this case, it is easy to see that mirror descent TD(\u03bb) corresponds to regular TD(\u03bb), since the gradients \u2207\u03c8 and \u2207\u03c8\u2217 correspond to the identity function. A much more interesting choice of \u03c8 is \u03c8(w) = 12\u2016w\u20162q , and its conjugate Legendre transform\n3.2. Mirror Descent RL 37\n\u03c8\u2217(w) = 12\u2016w\u20162p. Here, \u2016w\u2016q = (\u2211 j |wj |q ) 1 q , and p and q are conjugate numbers such that 1p + 1 q = 1. This \u03c8(w) leads to the p-norm link function \u03b8 = f(w) where f : Rd \u2192 Rd [16]:\nfj(w) = sign(wj)|wj |q\u22121 \u2016w\u2016q\u22122q , f\u22121j (\u03b8) = sign(\u03b8j)|\u03b8j |p\u22121 \u2016\u03b8\u2016p\u22122p\nThe p-norm function has been extensively studied in the literature on online learning [16], and it is well-known that for large p, the corresponding classification or regression method behaves like a multiplicative method (e.g., the p-norm regression method for large p behaves like an exponentiated gradient method (EG) [64, 65]).\nAnother distance generating function is the negative entropy function \u03c8(w) = \u2211\niwi logwi, which leads to the entropic mirror descent\nalgorithm [6]. Interestingly, this special case has been previously explored [66] as the exponentiated-gradient TD method, although the connection to mirror descent and Bregman divergences were not made in this previous study, and EG does not generate sparse solutions [37]. We discuss EG methods vs. p-norm methods in Section 3.6."}, {"heading": "3.2.2 Sparse Learning with Mirror Descent TD", "text": "Algorithm 2 describes a modification to obtain sparse value functions resulting in a sparse mirror-descent TD(\u03bb) algorithm. The main difference is that the dual weights \u03b8 are truncated according to Equation 1.1.3 to satisfy the l1 penalty on the weights. Here, \u03b2 is a sparsity parameter. An analogous approach was suggested in [37] for l1 penalized classification and regression."}, {"heading": "3.2.3 Composite Mirror Descent TD", "text": "Another possible mirror-descent TD algorithm uses as the distancegenerating function a Mahalanobis distance derived from the subgradients generated during actual trials. We base our derivation on the composite mirror-descent approach proposed in [67] for classification and regression. The composite mirror-descent solves the following op-\n38 Sparse Temporal Difference Learning in Primal Dual Spaces\nAlgorithm 6 Sparse Mirror Descent TD(\u03bb)\n1: repeat 2: Do action \u03c0(st) and observe next state st+1 and reward rt. 3: Update the eligibility trace et \u2190 et + \u03bb\u03b3\u03c6(st) 4: Update the dual weights \u03b8t:\n\u03b8\u0303t+1 = \u2207\u03c8t(wt) + \u03b1t ( rt + \u03b3\u03c6(st+1) Twt \u2212 \u03c6(st)Twt ) et\n(e.g., \u03c8(w) = 12\u2016w\u20162q is the p-norm link function). 5: Truncate weights:\n\u2200j, \u03b8t+1j = sign(\u03b8\u0303t+1j ) max(0, |\u03b8\u0303t+1j | \u2212 \u03b1t\u03b2)\n6: wt+1 = \u2207\u03c8\u2217t (\u03b8t+1) (e.g., \u03c8\u2217(\u03b8) = 12\u2016\u03b8\u20162p and p and q are dual norms such that 1p + 1 q = 1). 7: Set t\u2190 t+ 1. 8: until done.\nReturn V\u0302 \u03c0 \u2248 \u03a6wt as the l1 penalized sparse value function associated with policy \u03c0 for MDP M .\ntimization problem at each step:\nwt+1 = argminx\u2208X (\u03b1t\u3008x, \u2202ft\u3009+ \u03b1t\u00b5(x) +D\u03c8t(x,wt))\nHere, \u00b5 serves as a fixed regularization function, such as the l1 penalty, and \u03c8t is the time-dependent distance generating function as in mirror descent. We now describe a different Bregman divergence to be used as the distance generating function in this method. Given a positive definite matrix A, the Mahalanobis norm of a vector x is defined as\n\u2016x\u2016A = \u221a \u3008x,Ax\u3009. Let gt = \u2202f(st) be the subgradient of the function\nbeing minimized at time t, and Gt = \u2211 t gtg T t be the covariance matrix of outer products of the subgradients. It is computationally more\nefficient to use the diagonal matrix Ht = \u221a diag(Gt) instead of the full covariance matrix, which can be expensive to estimate. Algorithm 3 describes the adaptive subgradient mirror descent TD method.\n3.3. Convergence Analysis 39\nAlgorithm 7 Composite Mirror Descent TD(\u03bb)\n1: repeat 2: Do action \u03c0(st) and observe next state st+1 and reward rt. 3: Set TD error \u03b4t = rt + \u03b3\u03c6(st+1) Twt \u2212 \u03c6(st)Twt 4: Update the eligibility trace et \u2190 et + \u03bb\u03b3\u03c6(st) 5: Compute TD update \u03bet = \u03b4tet. 6: Update feature covariance\nGt = Gt\u22121 + \u03c6(st)\u03c6(st) T\n7: Compute Mahalanobis matrix Ht = \u221a diag(Gt). 8: Update the weights w:\nwt+1,i = sign(wt,i \u2212 \u03b1t\u03bet,i Ht,ii )(|wt,i \u2212 \u03b1t\u03bet,i Ht,ii | \u2212 \u03b1t\u03b2 Ht,ii )\n9: Set t\u2190 t+ 1. 10: until done.\nReturn V\u0302 \u03c0 \u2248 \u03a6wt as the l1 penalized sparse value function associated with policy \u03c0 for MDP M ."}, {"heading": "3.3 Convergence Analysis", "text": "Definition 2 [60]: \u03a0l1 is the l1-regularized projection defined as: \u03a0l1y = \u03a6\u03b1 such that \u03b1 = arg minw\u2016y \u2212 \u03a6w\u20162 +\u03b2\u2016w\u20161, which is a nonexpansive mapping w.r.t weighted l2 norm induced by the on-policy sample distribution setting, as proven in [60]. Let the approximation error f(y, \u03b2) = \u2016y \u2212\u03a0l1y\u20162. Definition 3 (Empirical l1-regularized projection): \u03a0\u0302l1 is the empirical l1-regularized projection with a specific l1 regularization solver, and satisfies the non-expansive mapping property. It can be shown using a direct derivation that \u03a0\u0302l1\u03a0T is a \u03b3-contraction mapping. Any unbiased l1 solver which generates intermediate sparse solution before convergence, e.g., SMIDAS solver after t-th iteration, comprises an empirical l1-regularized projection.\n40 Sparse Temporal Difference Learning in Primal Dual Spaces\nTheorem 1 The approximation error ||V \u2212 V\u0302 || of Algorithm 2 is bounded by (ignoring dependence on \u03c0 for simplicity):\n||V \u2212 V\u0302 || \u2264 11\u2212\u03b3\u00d7( \u2016V \u2212\u03a0V \u2016+ f(\u03a0V, \u03b2) + (M \u2212 1)P (0) + \u2016w\u2217\u201621 M\u03b1tN ) where V\u0302 is the approximated value function after N -th iteration, i.e., V\u0302 = \u03a6wN , M = 2\n2\u22124\u03b1t(p\u22121)e , \u03b1t is the stepsize, P (0) =\n1 N N\u2211 i=1 \u2016\u03a0V (si)\u201622, si is the state of i-th sample, e = d p 2 , d is the number of features, and finally, w\u2217 is l1-regularized projection of \u03a0V such that \u03a6w\u2217 = \u03a0l1\u03a0V . Proof: In the on-policy setting, the solution given by Algorithm 2 is the fixed point of V\u0302 = \u03a0\u0302l1\u03a0T V\u0302 and the error decomposition is illustrated in Figure 3.1. The error can be bounded by the triangle inequality\n||V \u2212 V\u0302 || = ||V \u2212\u03a0TV ||+ ||\u03a0TV \u2212 \u03a0\u0302l1\u03a0TV ||+ ||\u03a0\u0302l1\u03a0TV \u2212 V\u0302 ||\nSince \u03a0\u0302l1\u03a0T is a \u03b3-contraction mapping, and V\u0302 = \u03a0\u0302l1\u03a0T V\u0302 , we have\n||\u03a0\u0302l1\u03a0TV \u2212 V\u0302 || = ||\u03a0\u0302l1\u03a0TV \u2212 \u03a0\u0302l1\u03a0T V\u0302 || \u2264 \u03b3||V \u2212 V\u0302 ||\nSo we have\n(1\u2212 \u03b3)||V \u2212 V\u0302 || \u2264 ||V \u2212\u03a0TV ||+ ||\u03a0TV \u2212 \u03a0\u0302l1\u03a0TV ||\n\u2016V \u2212\u03a0TV \u2016 depends on the expressiveness of the basis \u03a6, where if V lies in span(\u03a6), this error term is zero. ||\u03a0TV \u2212 \u03a0l1\u03a0\u0302TV || is further\n3.4. Experimental Results: Discrete MDPs 41\nbounded by the triangle inequality\n||\u03a0TV \u2212 \u03a0\u0302l1\u03a0TV || \u2264 ||\u03a0TV \u2212\u03a0l1\u03a0TV ||+ ||\u03a0l1\u03a0TV \u2212 \u03a0\u0302l1\u03a0TV ||\nwhere \u2016\u03a0TV \u2212\u03a0l1\u03a0TV \u2016 is controlled by the sparsity parameter \u03b2, i.e., f(\u03a0TV, \u03b2) = ||\u03a0TV \u2212\u03a0l1\u03a0TV ||, where \u03b5 = ||\u03a0\u0302l1\u03a0TV \u2212\u03a0l1\u03a0TV || is the approximation error depending on the quality of the l1 solver employed. In Algorithm 2, the l1 solver is related to the SMIDAS l1 regularized mirror-descent method for regression and classification [37]. Note that for a squared loss function L(\u3008w, xi\u3009 , yi) = || \u3008w, xi\u3009 \u2212 yi||22, we have |L\u2032|2 \u2264 4L. Employing the result of Theorem 3 in [37], after the N -th iteration, the l1 approximation error is bounded by\n\u03b5 \u2264 (M \u2212 1)P (0) + ||w\u2217||21 M\n\u03b1tN ,M =\n2\n2\u2212 4\u03b1t(p\u2212 1)e By rearranging the terms and applying V = TV , Equation (3.3) can be deduced."}, {"heading": "3.4 Experimental Results: Discrete MDPs", "text": "Figure 3.2 shows that mirror-descent TD converges more quickly with far smaller Bellman errors than LARS-TD [68] on a discrete \u201ctworoom\u201d MDP [69]. The basis matrix \u03a6 was automatically generated as 50 proto-value functions by diagonalizing the graph Laplacian of the discrete state space connectivity graph[69]. The figure also shows that Algorithm 2 (sparse mirror-descent TD) scales more gracefully than LARS-TD. Note LARS-TD is unstable for \u03b3 = 0.9. It should be noted that the computation cost of LARS-TD is O(Ndm3), whereas that for Algorithm 2 is O(Nd), where N is the number of samples, d is the number of basis functions, and m is the number of active basis functions. If p is linear or sublinear w.r.t d, Algorithm 2 has a significant advantage over LARS-TD.\nFigure 3.3 shows the result of another experiment conducted to test the noise immunity of Algorithm 2 using a discrete 10\u00d7 10 grid world domain with the goal set at the upper left hand corner. For this problem, 50 proto-value basis functions were automatically generated, and 450 random Gaussian mean 0 noise features were added. The sparse\n42 Sparse Temporal Difference Learning in Primal Dual Spaces\nmirror descent TD algorithm was able to generate a very good approximation to the optimal value function despite the large number of irrelevant noisy features, and took a fraction of the time required by LARS-TD.\nFigure 3.4 compares the performance of mirror-descent Q-learning with a fixed p-norm link function vs. a decaying p-norm link function for a 10\u00d710 discrete grid world domain with the goal state in the upper left-hand corner. Initially, p = O(log d) where d is the number of features, and subsequently p is decayed to a minimum of p = 2. Varying p-norm interpolates between additive and multiplicative updates. Dif-\n3.4. Experimental Results: Discrete MDPs 43\nferent values of p yield an interpolation between the truncated gradient method [42] and SMIDAS [43].\nFigure 3.5 illustrates the performance of Algorithm 3 on the two-\nroom discrete grid world navigation task.\n44 Sparse Temporal Difference Learning in Primal Dual Spaces"}, {"heading": "3.5 Experimental Results: Continuous MDPs", "text": "Figure 3.6 compares the performance of Q-learning vs. mirror-descent Q-learning for the mountain car task, which converges more quickly to a better solution with much lower variance. Figure 3.7 shows that mirror-descent Q-learning with learned diffusion wavelet bases converges quickly on the 4-dimensional Acrobot task. We found in our experiments that LARS-TD did not converge within 20 episodes (its curve, not shown in Figure 3.6, would be flat on the vertical axis at 1000 steps). Finally, we tested the mirror-descent approach on a more\ncomplex 8-dimensional continuous MDP. The triple-link inverted pendulum [71] is a highly nonlinear time-variant under-actuated system,\n3.5. Experimental Results: Continuous MDPs 45\nwhich is a standard benchmark testbed in the control community. We base our simulation using the system parameters described in [71], except that the action space is discretized because the algorithms described here are restricted to policies with discrete actions. There are three actions, namely {0, 5Newton,\u22125Newton}. The state space is 8- dimensional, consisting of the angles made to the horizontal of the three links in the arm as well as their angular velocities, the position and velocity of the cart used to balance the pendulum. The goal is to learn a policy that can balance the system with the minimum number of episodes. A run is successful if it balances the inverted pendulum for the specified number of steps within 300 episodes, resulting in a reward of 0. Otherwise, this run is considered as a failure and yields a negative reward \u22121. The first action is chosen randomly to push the pendulum away from initial state. Two experiments were conducted on the triple-link pendulum domain with 20 runs for each experiment. As\nTable 1 shows, Mirror Descent Q-learning is able to learn the policy with fewer episodes and usually with reduced variance compared with regular Q-learning.\nThe experiment settings are Experiment 1: Zero initial state and the system receives a reward 1 if it is able to balance 10,000 steps. Experiment 2: Zero initial state and the system receives a reward 1 if it is able to balance 100,000 steps. Table 1 shows the comparison result between regular Q-learning and Mirror Descent Q-learning.\n46 Sparse Temporal Difference Learning in Primal Dual Spaces"}, {"heading": "3.6 Comparison of Link Functions", "text": "The two most widely used link functions in mirror descent are the p-norm link function [6] and the relative entropy function for exponentiated gradient (EG) [64]. Both of these link functions offer a multiplicative update rule compared with regular additive gradient methods. The differences between these two are discussed here. Firstly, the loss function for EG is the relative entropy whereas that of the p-norm link function is the square l2-norm function. Second and more importantly, EG does not produce sparse solutions since it must maintain the weights away from zero, or else its potential (the relative entropy) becomes unbounded at the boundary.\nAnother advantage of p-norm link functions over EG is that the p-norm link function offers a flexible interpolation between additive and multiplicative gradient updates. It has been shown that when the features are dense and the optimal coefficients \u03b8\u2217 are sparse, EG converges faster than the regular additive gradient methods [64]. However, according to our experience, a significant drawback of EG is the overflow of the coefficients due to the exponential operator. To prevent overflow, the most commonly used technique is rescaling: the weights are re-normalized to sum to a constant. However, it seems that this approach does not always work. It has been pointed out [66] that in the EG-Sarsa algorithm, rescaling can fail, and replacing eligible traces instead of regular additive eligible traces is used to prevent overflow. EG-Sarsa usually poses restrictions on the basis as well. Thanks to the flexible interpolation capability between multiplicative and additive gradient updates, the p-norm link function is more robust and applicable to various basis functions, such as polynomial, radial basis function (RBF), Fourier basis [70], proto-value functions (PVFs), etc.\n3.7. Summary 47"}, {"heading": "3.7 Summary", "text": "We proposed a novel framework for reinforcement learning using mirror-descent online convex optimization. Mirror Descent Q-learning demonstrates the following advantage over regular Q learning: faster convergence rate and reduced variance due to larger stepsizes with theoretical convergence guarantees [72]. Compared with existing sparse reinforcement learning algorithms such as LARS-TD, Algorithm 2 has lower sample complexity and lower computation cost, advantages accrued from the first-order mirror descent framework combined with proximal mapping [37]. There are many promising future research topics along this direction. We are currently exploring a mirror-descent fast-gradient RL method, which is both convergent off-policy and quicker than fast gradient TD methods such as GTD and TDC [2]. To scale to large MDPs, we are investigating hierarchical mirror-descent RL methods, in particular extending SMDP Q-learning. We are also undertaking a more detailed theoretical analysis of the mirror-descent RL framework, building on existing analysis of mirror-descent methods [67, 37]. Two types of theoretical investigations are being explored: regret bounds of mirror-descent TD methods, extending previous results [73] and convergence analysis combining robust stochastic approximation [72] and RL theory [32, 74].\n4 Regularized Off-Policy Temporal Difference Learning\nIn the last chapter we proposed an on-policy convergent sparse TD learning algorithm. Although TD converges when samples are drawn \u201con-policy\u201d by sampling from the Markov chain underlying a policy in a Markov decision process (MDP), it can be shown to be divergent when samples are drawn \u201coff-policy\u201d.\nIn this chapter, the off-policy TD learning problem is formulated from the stochastic optimization perspective. 1 A novel objective function is proposed based on the linear equation formulation of the TDC algorithm. The optimization problem underlying off-policy TD methods, such as TDC, is reformulated as a convex-concave saddle-point stochastic approximation problem, which is both convex and incrementally solvable. A detailed theoretical and experimental study of the RO-TD algorithm is presented.\n1 This chapter is based on the paper \u201dRegularized Off-Policy TD-Learning\u201d published in NIPS 2012.\n48\n4.1. Introduction 49"}, {"heading": "4.1 Introduction", "text": ""}, {"heading": "4.1.1 Off-Policy Reinforcement Learning", "text": "Off-policy learning refers to learning about one way of behaving, called the target policy, from sample sets that are generated by another policy of choosing actions, which is called the behavior policy, or exploratory policy. As pointed out in [75], the target policy is often a deterministic policy that approximates the optimal policy, and the behavior policy is often stochastic, exploring all possible actions in each state as part of finding the optimal policy. Learning the target policy from the samples generated by the behavior policy allows a greater variety of exploration strategies to be used. It also enables learning from training data generated by unrelated controllers, including manual human control, and from previously collected data. Another reason for interest in off-policy learning is that it enables learning about multiple target policies (e.g., optimal policies for multiple sub-goals) from a single exploratory policy generated by a single behavior policy, which triggered an interesting research area termed as \u201cparallel reinforcement learning\u201d. Besides, offpolicy methods are of wider applications since they are able to learn while executing an exploratory policy, learn from demonstrations, and learn multiple tasks in parallel [76]. Sutton et al. [26] introduced convergent off-policy temporal difference learning algorithms, such as TDC, whose computation time scales linearly with the number of samples and the number of features. Recently, a linear off-policy actor-critic algorithm based on the same framework was proposed in [76]."}, {"heading": "4.1.2 Convex-concave Saddle-point First-order Algorithms", "text": "The key novel contribution of this chapter is a convex-concave saddlepoint formulation for regularized off-policy TD learning. A convexconcave saddle-point problem is formulated as follows. Let x \u2208 X, y \u2208 Y , where X,Y are both nonempty bounded closed convex sets, and f(x) : X \u2192 R be a convex function. If there exists a function \u03d5(\u00b7, \u00b7) such that f(x) can be represented as f(x) := supy\u2208Y \u03d5(x, y), then the pair (\u03d5, Y ) is referred as the saddle-point representation of f . The optimization problem of minimizing f over X is converted into an equivalent\n50 Regularized Off-Policy Temporal Difference Learning\nconvex-concave saddle-point problem SadV al = infx\u2208Xsupy\u2208Y \u03d5(x, y) of \u03d5 on X \u00d7 Y . If f is non-smooth yet convex and well structured, which is not suitable for many existing optimization approaches requiring smoothness, its saddle-point representation \u03d5 is often smooth and convex. Thus, convex-concave saddle-point problems are, therefore, usually better suited for first-order methods [47]. A comprehensive overview on extending convex minimization to convex-concave saddlepoint problems with unified variational inequalities is presented in [48]. As an example, consider f(x) = ||Ax \u2212 b||m which admits a bilinear minimax representation\nf(x) := \u2016Ax\u2212 b\u2016m = max\u2016y\u2016n\u22641 yT (Ax\u2212 b)\nwhere m,n are conjugate numbers. Using the approach in [49], Equation (4.1.2) can be solved as\nxt+1 = xt \u2212 \u03b1tAT yt, yt+1 = \u03a0n(yt + \u03b1t(Axt \u2212 b))\nwhere \u03a0n is the projection operator of y onto the unit ln-ball \u2016y\u2016n \u2264 1,which is defined as\n\u03a0n(y) = min(1, 1/\u2016y\u2016n)y, n = 2, 3, \u00b7 \u00b7 \u00b7 ,\u03a0\u221e(yi) = min(1, 1/|yi|)yi\nand \u03a0\u221e is an entrywise operator."}, {"heading": "4.2 Problem Formulation", "text": ""}, {"heading": "4.2.1 Objective Function Formulation", "text": "Now let\u2019s review the concept of MSPBE. MSPBE is defined as\nMSPBE(\u03b8) = \u2016\u03a6\u03b8 \u2212\u03a0T (\u03a6\u03b8)\u20162\u039e = (\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8))T (\u03a6T\u039e\u03a6)\u22121\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8) = E[\u03b4t(\u03b8)\u03c6t]TE[\u03c6t\u03c6Tt ]\u22121E[\u03b4t(\u03b8)\u03c6t]\nTo avoid computing the inverse matrix (\u03a6T\u039e\u03a6)\u22121 and to avoid the double sampling problem [1] in (4.2.1), an auxiliary variable w is defined\nw = E[\u03c6t\u03c6Tt ]\u22121E[\u03b4t(\u03b8)\u03c6t] = (\u03a6T\u039e\u03a6)\u22121\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8)\n4.2. Problem Formulation 51\nThus we can have the following linear inverse problem\nE[\u03b4t(\u03b8)\u03c6t] = E[\u03c6t\u03c6Tt ]w = (\u03a6T\u039e\u03a6)w = \u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8)\nBy taking gradient w.r.t \u03b8 for optimum condition \u2207MSPBE(\u03b8) = 0 and utilizing Equation (4.2.1), we have\nE[\u03b4t(\u03b8)\u03c6t] = \u03b3E[\u03c6\u2032t\u03c6Tt ]w\nRearranging the two equality of Equation (4.2.1,4.2.1), we have the\nfollowing linear system equation[ \u03b7\u03a6T\u039e\u03a6 \u03b7\u03a6T\u039e(\u03a6\u2212 \u03b3\u03a6\u2032) \u03b3\u03a6 \u2032T \u039e\u03a6 \u03a6T\u039e(\u03a6\u2212 \u03b3\u03a6\u2032) ] [ w \u03b8 ] = [ \u03b7\u03a6T\u039eR \u03a6T\u039eR ] The stochastic gradient version of the above equation is as follows, where\nA = E[At], b = E[bt], x = [w; \u03b8]\nAt =\n[ \u03b7\u03c6t\u03c6t\nT \u03b7\u03c6t(\u03c6t \u2212 \u03b3\u03c6\u2032t)T \u03b3\u03c6\u2032t\u03c6t T \u03c6t(\u03c6t \u2212 \u03b3\u03c6\u2032t)T\n] , bt = [ \u03b7rt\u03c6t rt\u03c6t ] Following [26], the TDC algorithm solution follows from the linear\nequation Ax = b, where a single iteration gradient update would be\nxt+1 = xt \u2212 \u03b1t(Atxt \u2212 bt) where xt = [wt; \u03b8t]. The two time-scale gradient descent learning method TDC [26] is\n\u03b8t+1 = \u03b8t + \u03b1t\u03b4t\u03c6t \u2212 \u03b1t\u03b3\u03c6t\u2032(\u03c6Tt wt), wt+1 = wt + \u03b2t(\u03b4t \u2212 \u03c6Tt wt)\u03c6t\nwhere \u2212\u03b1t\u03b3\u03c6t\u2032(\u03c6Tt wt) is the term for correction of gradient descent direction, and \u03b2t = \u03b7\u03b1t, \u03b7 > 1.\nThere are some issues regarding the objective function, which arise from the online convex optimization and reinforcement learning perspectives, respectively. The first concern is that the objective function should be convex and stochastically solvable. Note that A,At are neither PSD nor symmetric, and it is not straightforward to formulate a\n52 Regularized Off-Policy Temporal Difference Learning\nconvex objective function based on them. The second concern is that since we do not have knowledge of A, the objective function should be separable so that it is stochastically solvable based on At, bt. The other concern regards the sampling condition in temporal difference learning: double-sampling. As pointed out in [1], double-sampling is a necessary condition to obtain an unbiased estimator if the objective function is the Bellman residual or its derivatives (such as projected Bellman residual), wherein the product of Bellman error or projected Bellman error metrics are involved. To overcome this sampling condition constraint, the product of TD errors should be avoided in the computation of gradients. Consequently, based on the linear equation\n4.2. Problem Formulation 53\nformulation in (4.2.1) and the requirement on the objective function discussed above, we propose the regularized loss function as\nL(x) = \u2016Ax\u2212 b\u2016m + h(x)\nHere we also enumerate some intuitive objective functions and give a brief analysis on the reasons why they are not suitable for regularized off-policy first-order TD learning. One intuitive idea is to add a sparsity penalty on MSPBE, i.e., L(\u03b8) = MSPBE(\u03b8)+\u03c1\u2016\u03b8\u20161. Because of the l1 penalty term, the solution to \u2207L = 0 does not have an analytical form and is thus difficult to compute. The second intuition is to use the online least squares formulation of the linear equation Ax = b. However, since A is not symmetric and positive semi-definite (PSD), A 1 2 does not exist and thus Ax = b cannot be reformulated as minx\u2208X ||A 1 2x\u2212A\u2212 12 b||22. Another possible idea is to attempt to find an objective function whose gradient is exactly Atxt \u2212 bt and thus the regularized gradient is prox\u03b1th(xt)(Atxt \u2212 bt). However, since At is not symmetric, this gradient does not explicitly correspond to any kind of optimization problem, not to mention a convex one2."}, {"heading": "4.2.2 Squared Loss Formulation", "text": "It is also worth noting that there exists another formulation of the loss function different from Equation (4.2.1) with the following convexconcave formulation as in [77, 47],\nmin x\n1 2 \u2016Ax\u2212 b\u201622 + \u03c1\u2016x\u20161 = max\u2016AT y\u2016\u221e\u22641 (bT y \u2212 \u03c1 2 yT y)\n= min x max \u2016u\u2016\u221e\u22641,y\n( xTu+ yT (Ax\u2212 b)\u2212 \u03c1\n2 yT y\n)\nHere we give the detailed deduction of formulation in Equation (4.1). First, using the dual norm representation, the standard LASSO problem formulation is reformulated as\n2 Note that the A matrix in GTD2\u2019s linear equation representation is symmetric, yet is not PSD, so it cannot be formulated as a convex problem.\n54 Regularized Off-Policy Temporal Difference Learning\nf(x) = 1\n2 \u2016Ax\u2212 b\u201622 + \u03c1\u2016x\u20161 = max\ny,\u2016AT y\u2016\u221e\u22641\n[ \u3008b/\u03c1, y\u3009 \u2212 1\n2 yT y ] Then3\n\u3008b, y\u3009 \u2212 12yT y = \u3008b, y\u3009 \u2212 12yT y + \u2329 x,AT y \u232a \u2212 \u3008y,Ax\u3009\n= \u3008y, b\u2212Ax\u3009 \u2212 12yT y + \u2329 x,AT y \u232a which can be solved iteratively without the proximal gradient step\nas follows, which serves as a counterpart of Equation (4.3),\nxt+1 = xt \u2212 \u03b1t\u03c1(ut +AtT yt) , yt+1 = yt + \u03b1t \u03c1 (Atxt \u2212 bt \u2212 \u03c1yt)\nut+ 1 2 = ut + \u03b1t \u03c1 xt , ut+1 = \u03a0\u221e(ut+ 1 2 )"}, {"heading": "4.3 Algorithm Design", "text": ""}, {"heading": "4.3.1 RO-TD Algorithm Design", "text": "In this section, the problem of (4.2.1) is formulated as a convex-concave saddle-point problem, and the RO-TD algorithm is proposed. Analogous to (4.1.2), the regularized loss function can be formulated as\n\u2016Ax\u2212 b\u2016m + h(x) = max\u2016y\u2016n\u22641 yT (Ax\u2212 b) + h(x)\nSimilar to (2.4), Equation (4.3.1) can be solved via an iteration procedure as follows, where xt = [wt; \u03b8t].\nxt+ 1 2 = xt \u2212 \u03b1tATt yt , yt+ 1 2 = yt + \u03b1t(Atxt \u2212 bt) xt+1 = prox\u03b1th(xt+ 1\n2 ) , yt+1 = \u03a0n(yt+ 1 2 )\n3 Let w = \u2212y, then we will have the same formulation as in Nemirovski\u2019s tutorial in COLT2012.\n\u03a6(x,w) = \u3008w,Ax\u2212 b\u3009 \u2212 1\n2 wTw \u2212\n\u2329 x,ATw \u232a\n4.3. Algorithm Design 55\nThe averaging step, which plays a crucial role in stochastic optimization convergence, generates the approximate saddle-points [47, 78]\nx\u0304t = (\u2211t\ni=0 \u03b1i )\u22121\u2211t i=0 \u03b1ixi, y\u0304t = (\u2211t i=0 \u03b1i )\u22121\u2211t i=0 \u03b1iyi\nDue to the computation of At in (4.3) at each iteration, the computation cost appears to be O(Nd2), where N, d are defined in Figure 4.1. However, the computation cost is actually O(Nd) with a linear algebraic trick by computing not At but y T t At, Atxt \u2212 bt. Denoting yt = [y1,t; y2,t], where y1,t; y2,t are column vectors of equal length, we have\nyTt At = [ \u03b7\u03c6Tt (y T 1,t\u03c6t) + \u03b3\u03c6 T t (y T 2,t\u03c6 \u2032 t) (\u03c6t \u2212 \u03b3\u03c6\u2032t)T (\u03b7yT1,t + yT2,t)\u03c6t ] Atxt \u2212 bt can be computed according to Equation (4.2.1) as follows:\nAtxt \u2212 bt = [ \u2212\u03b7(\u03b4t \u2212 \u03c6Tt wt)\u03c6t; \u03b3(\u03c6Tt wt)\u03c6t\u2032 \u2212 \u03b4t\u03c6t ] Both (4.3.1) and (4.3.1) are of linear computational complexity. Now we are ready to present the RO-TD algorithm:\nThere are some design details of the algorithm to be elaborated. First, the regularization term h(x) can be any kind of convex regularization, such as ridge regression or sparsity penalty \u03c1||x||1. In case of h(x) = \u03c1||x||1, prox\u03b1th(\u00b7) = S\u03b1t\u03c1(\u00b7). In real applications the sparsification requirement on \u03b8 and auxiliary variable w may be different, i.e., h(x) = \u03c11\u2016\u03b8\u20161 + \u03c12\u2016w\u20161, \u03c11 6= \u03c12, one can simply replace the uniform soft thresholding S\u03b1t\u03c1 by two separate soft thresholding operations S\u03b1t\u03c11 , S\u03b1t\u03c12 and thus the third equation in (4.3) is replaced by the following,\nxt+ 1 2\n= [ wt+ 1\n2 ; \u03b8t+ 1 2\n] , \u03b8t+1 = S\u03b1t\u03c11(\u03b8t+ 1\n2 ), wt+1 = S\u03b1t\u03c12(wt+ 1 2 )\nAnother concern is the choice of conjugate numbers (m,n). For ease of computing \u03a0n, we use (2, 2)(l2 fit), (+\u221e, 1)(uniform fit) or (1,+\u221e). m = n = 2 is used in the experiments below.\n56 Regularized Off-Policy Temporal Difference Learning\nAlgorithm 8 RO-TD Let \u03c0 be some fixed policy of an MDP M , and let the sample set S = {si, ri, si\u2032}Ni=1. Let \u03a6 be some fixed basis.\n(1) REPEAT (2) Compute \u03c6t, \u03c6t \u2032 and TD error \u03b4t = (rt + \u03b3\u03c6 \u2032T t \u03b8t)\u2212 \u03c6Tt \u03b8t (3) Compute yT t At, Atxt \u2212 bt in Equation (4.3.1) and (4.3.1). (4) Compute xt+1, yt+1 as in Equation (4.3) (5) Set t\u2190 t+ 1; (6) UNTIL t = N ; (7) Compute x\u0304N , y\u0304N as in Equation (4.3.1) with t = N ."}, {"heading": "4.3.2 RO-GQ(\u03bb) Design", "text": "GQ(\u03bb)[79] is a generalization of the TDC algorithm with eligibility traces and off-policy learning of temporally abstract predictions, where the gradient update changes from Equation (4.2.1) to\n\u03b8t+1 = \u03b8t +\u03b1t[\u03b4tet\u2212 \u03b3(1\u2212\u03bb)wtT et\u03c6\u0304t+1], wt+1 = wt + \u03b2t(\u03b4tet\u2212wTt \u03c6t\u03c6t)\nThe central element is to extend the MSPBE function to the case where it incorporates eligibility traces. The objective function and corresponding linear equation component At, bt can be written as follows:\nL(\u03b8) = ||\u03a6\u03b8 \u2212\u03a0T \u03c0\u03bb\u03a6\u03b8||2\u039e\nAt =\n[ \u03b7\u03c6t\u03c6t T \u03b7et(\u03c6t \u2212 \u03b3\u03c6\u0304t+1)T\n\u03b3(1\u2212 \u03bb)\u03c6\u0304t+1eTt et(\u03c6t \u2212 \u03b3\u03c6\u0304t+1) T\n] , bt = [ \u03b7rtet rtet ] Similar to Equation (4.3.1) and (4.3.1), the computation of yT\nt At, Atxt\u2212\nbt is\nyT t At = [ \u03b7\u03c6Tt (y T 1,t\u03c6t) + \u03b3(1\u2212 \u03bb)eTt (yT2,t\u03c6\u0304t+1) (\u03c6t \u2212 \u03b3\u03c6\u0304t+1)T (\u03b7yT1,t + yT2,t)et ] Atxt \u2212 bt = [ \u2212\u03b7(\u03b4tet \u2212 \u03c6Tt wt\u03c6t); \u03b3(1\u2212 \u03bb)(eTt wt)\u03c6\u0304t+1 \u2212 \u03b4tet\n] where eligibility traces et, and \u03c6\u0304t, T \u03c0\u03bb are defined in [79]. Algorithm 9, RO-GQ(\u03bb), extends the RO-TD algorithm to include eligibility traces.\n4.4. Theoretical Analysis 57\nAlgorithm 9 RO-GQ(\u03bb) Let \u03c0 be some fixed policy of an MDP M . Let \u03a6 be some fixed basis. Starting from s0.\n(1) REPEAT (2) Compute \u03c6t, \u03c6\u0304t+1 and TD error \u03b4t = (rt + \u03b3\u03c6\u0304 T t+1\u03b8t)\u2212 \u03c6Tt \u03b8t (3) Compute yT t At, Atxt \u2212 bt in Equation (4.4). (4) Compute xt+1, yt+1 as in Equation (4.3) (5) Choose action at, and get st+1 (6) Set t\u2190 t+ 1; (7) UNTIL st is an absorbing state; (8) Compute x\u0304t, y\u0304t as in Equation (4.3.1)"}, {"heading": "4.4 Theoretical Analysis", "text": "The theoretical analysis of RO-TD algorithm can be seen in the Appendix."}, {"heading": "4.5 Empirical Results", "text": "We now demonstrate the effectiveness of the RO-TD algorithm against other algorithms across a number of benchmark domains. LARS-TD [62], which is a popular second-order sparse reinforcement learning algorithm, is used as the baseline algorithm for feature selection and TDC is used as the off-policy convergent RL baseline algorithm, respectively."}, {"heading": "4.5.1 MSPBE Minimization and Off-Policy Convergence", "text": "This experiment aims to show the minimization of MSPBE and offpolicy convergence of the RO-TD algorithm. The 7 state star MDP is a well known counterexample where TD diverges monotonically and TDC converges. It consists of 7 states and the reward w.r.t any transition is zero. Because of this, the star MDP is unsuitable for LSTDbased algorithms, including LARS-TD since \u03a6TR = 0 always holds. The random-walk problem is a standard Markov chain with 5 states and two absorbing state at two ends. Three sets of different bases \u03a6\n58 Regularized Off-Policy Temporal Difference Learning\n4.5. Empirical Results 59\nare used in [26], which are tabular features, inverted features and dependent features respectively. An identical experiment setting to [26] is used for these two domains. The regularization term h(x) is set to 0 to make a fair comparison with TD and TDC. \u03b1 = 0.01, \u03b7 = 10 for TD, TDC and RO-TD. The comparison with TD, TDC and RO-TD is shown in the left sub-figure of Figure 4.2, where TDC and RO-TD have almost identical MSPBE over iterations. The middle sub-figure shows the value of yT t\n(Axt \u2212 b) and \u2016Axt \u2212 b\u20162, wherein \u2016Axt \u2212 b\u20162 is always greater than the value of yT\nt (Axt \u2212 b). Note that for this prob-\nlem, the Slater condition is satisfied so there is no duality gap between the two curves. As the result shows, TDC and RO-TD perform equally well, which illustrates the off-policy convergence of the RO-TD algorithm. The result of random-walk chain is averaged over 50 runs. The rightmost sub-figure of Figure 4.2 shows that RO-TD is able to reduce MSPBE over successive iterations w.r.t three different basis functions."}, {"heading": "4.5.2 Feature Selection", "text": "In this section, we use the mountain car example with a variety of bases to show the feature selection capability of RO-TD. The Mountain car is an optimal control problem with a continuous two-dimensional state space. The steep discontinuity in the value function makes learning difficult for bases with global support. To make a fair comparison, we use the same basis function setting as in [62], where two dimensional grids of 2, 4, 8, 16, 32 RBFs are used so that there are totally 1365 basis functions. For LARS-TD, 500 samples are used. For RO-TD and TDC, 3000 samples are used by executing 15 episodes with 200 steps for each episode, stepsize \u03b1t = 0.001, and \u03c11 = 0.01, \u03c12 = 0.2. We use the result of LARS-TD and l2 LSTD reported in [62]. As the result shows in Table 4.1, RO-TD is able to perform feature selection successfully, whereas TDC and TD failed. It is worth noting that comparing the performance of RO-TD and LARS-TD is not the major focus here, since LARS-TD is not convergent off-policy and RO-TD\u2019s performance can be further optimized using the mirror-descent approach with the Mirror-Prox algorithm [47] which incorporates mirror descent with an extragradient [8], as discussed below.\n60 Regularized Off-Policy Temporal Difference Learning"}, {"heading": "4.5.3 High-dimensional Under-actuated Systems", "text": "The triple-link inverted pendulum [71] is a highly nonlinear underactuated system with 8-dimensional state space and discrete action space. The state space consists of the angles and angular velocity of each arm as well as the position and velocity of the car. The discrete action space is {0, 5Newton,\u22125Newton}. The goal is to learn a policy that can balance the arms for Nx steps within some minimum number of learning episodes. The allowed maximum number of episodes is 300. The pendulum initiates from zero equilibrium state and the first action is randomly chosen to push the pendulum away from initial state. We test the performance of RO-GQ(\u03bb), GQ(\u03bb) and LARS-TD. Two experiments are conducted with Nx = 10, 000 and 100, 000, respectively. Fourier basis [80] with order 2 is used, resulting in 6561 basis functions. Table 4.2 shows the results of this experiment, where RO-GQ(\u03bb) performs better than other approaches, especially in Experiment 2, which is a harder task. LARS-TD failed in this domain, which is mainly not due to LARS-TD itself but the quality of samples collected via random walk.\nTo sum up, RO-GQ(\u03bb) tends to outperform GQ(\u03bb) in all aspects, and is able to outperform LARS-TD based policy iteration in high di-\n4.6. Summary 61\nmensional domains, as well as in selected smaller MDPs where LARSTD diverges (e.g., the star MDP). It is worth noting that the computation cost of LARS-TD is O(Ndk2), where that for RO-TD is O(Nd). If k is linear or sublinear w.r.t d, RO-TD has a significant advantage over LARS-TD. However, compared with LARS-TD, RO-TD requires fine tuning the parameters of \u03b1t, \u03c11, \u03c12 and is usually not as sample efficient as LARS-TD. We also find that tuning the sparsity parameter \u03c12 generates an interpolation between GQ(\u03bb) and Q-learning, where a large \u03c12 helps eliminate the correction term of TDC update and make the update direction more similar to the TD update."}, {"heading": "4.6 Summary", "text": "In this chapter we present a novel unified framework for designing regularized off-policy convergent RL algorithms combining a convexconcave saddle-point problem formulation for RL with stochastic firstorder methods. A detailed experimental analysis reveals that the proposed RO-TD algorithm is both off-policy convergent and robust to noisy features.\n5 Safe Reinforcement Learning using Projected Natural Actor Critic\nNatural actor-critics form a popular class of policy search algorithms for finding locally optimal policies for Markov decision processes. In this paper we address a drawback of natural actor-critics that limits their real-world applicability\u2014their lack of safety guarantees. We present a principled algorithm for performing natural gradient descent over a constrained domain 1. In the context of reinforcement learning, this allows for natural actor-critic algorithms that are guaranteed to remain within a known safe region of policy space. While deriving our class of constrained natural actor-critic algorithms, which we call Projected Natural Actor-Critics (PNACs), we also elucidate the relationship between natural gradient descent and mirror descent."}, {"heading": "5.1 Introduction", "text": "Natural actor-critics form a class of policy search algorithms for finding locally optimal policies for Markov decision processes (MDPs) by approximating and ascending the natural gradient [59] of an objective\n1 This paper is a revised version of the paper \u201cProjected Natural Actor-Critic\u201d that was published in NIPS 2013.\n62\n5.1. Introduction 63\nfunction. Despite the numerous successes of, and the continually growing interest in, natural actor-critic algorithms, they have not achieved widespread use for real-world applications. A lack of safety guarantees is a common reason for avoiding the use of natural actor-critic algorithms, particularly for biomedical applications. Since natural actor-critics are unconstrained optimization algorithms, there are no guarantees that they will avoid regions of policy space that are known to be dangerous.\nFor example, proportional-integral-derivative controllers (PID controllers) are the most widely used control algorithms in industry, and have been studied in depth [81]. Techniques exist for determining the set of stable gains (policy parameters) when a model of the system is available [82]. Policy search can be used to find the optimal gains within this set (for some definition of optimality). A desirable property of a policy search algorithm in this context would be a guarantee that it will remain within the predicted region of stable gains during its search.\nConsider a second example: functional electrical stimulation (FES) control of a human arm. By selectively stimulating muscles using subcutaneous probes, researchers have made significant strides toward returning motor control to people suffering from paralysis induced by spinal cord injury [83]. There has been a recent push to develop controllers that specify how much and when to stimulate each muscle in a human arm to move it from its current position to a desired position [84]. This closed-loop control problem is particularly challenging because each person\u2019s arm has different dynamics due to differences in, for example, length, mass, strength, clothing, and amounts of muscle atrophy, spasticity, and fatigue. Moreover, these differences are challenging to model. Hence, a proportional-derivative (PD) controller, tuned to a simulation of an ideal human arm, required manual tuning to obtain desirable performance on a human subject with biceps spasticity [85].\nResearchers have shown that policy search algorithms are a viable approach to creating controllers that can automatically adapt to an individual\u2019s arm by training on a few hundred two-second reaching movements [86]. However, safety concerns have been raised in regard to both this specific application and other biomedical applications of policy search algorithms. Specifically, the existing state-of-the-art gradient-\n64 Safe Reinforcement Learning using Projected Natural Actor Critic\nbased algorithms, including the current natural actor-critic algorithms, are unconstrained and could potentially select dangerous policies. For example, it is known that certain muscle stimulations could cause the dislocation of a subject\u2019s arm. Although we lack an accurate model of each individual\u2019s arm, we can generate conservative safety constraints on the space of policies. Once again, a desirable property of a policy search algorithm would be a guarantee that it will remain within a specified region of policy space (known-safe policies).\nIn this paper we present a class of natural actor-critic algorithms that perform constrained optimization\u2014given a known safe region of policy space, they search for a locally optimal policy while always remaining within the specified region. We call our class of algorithms Projected Natural Actor-Critics (PNACs) since, whenever they generate a new policy, they project the policy back to the set of safe policies. The interesting question is how the projection can be done in a principled manner. We show that natural gradient descent (ascent), which is an unconstrained optimization algorithm, is a special case of mirror descent (ascent), which is a constrained optimization algorithm. In order to create a projected natural gradient algorithm, we add constraints in the mirror descent algorithm that is equivalent to natural gradient descent. We apply this projected natural gradient algorithm to policy search to create the PNAC algorithms, which we validate empirically."}, {"heading": "5.2 Related Work", "text": "Researchers have addressed safety concerns like these before [87]. Bendrahim and Franklin [88] showed how a walking biped robot can switch to a stabilizing controller whenever the robot leaves a stable region of state space. Similar state-avoidant approaches to safety have been proposed by several others [89, 90, 91]. These approaches do not account for situations where, over an unavoidable region of state space, the actions themselves are dangerous. Kuindersma et al. [92] developed a method for performing risk-sensitive policy search, which models the variance of the objective function for each policy and permits runtime adjustments of risk sensitivity. However, their approach does not guarantee that an unsafe region of state space or policy space will be avoided.\n5.3. Equivalence of Natural Gradient Descent and Mirror Descent 65\nBhatnagar et al. [93] presented projected natural actor-critic algorithms for the average reward setting. As in our projected natural actor-critic algorithms, they proposed computing the update to the policy parameters and then projecting back to the set of allowed policy parameters. However, they did not specify how the projection could be done in a principled manner. We show in Section 5.5 that the Euclidean projection can be arbitrarily bad, and argue that the projection that we propose is particularly compatible with natural actor-critics (natural gradient descent).\nDuchi et al. [94] presented mirror descent using the Mahalanobis norm for the proximal function, which is very similar to the proximal function that we show to cause mirror descent to be equivalent to natural gradient descent. However, their proximal function is not identical to ours and they did not discuss any possible relationship between mirror descent and natural gradient descent."}, {"heading": "5.3 Equivalence of Natural Gradient Descent and Mirror Descent", "text": "We begin by showing an important relationship between natural gradient methods and mirror descent.\nTheorem 5.3.1. The natural gradient descent update at step k with metric tensor Gk , G(xk):\nxk+1 = xk \u2212 \u03b1kG\u22121k \u2207f(xk), (5.1)\nis equivalent to the mirror descent update at step k, with \u03c8k(x) = (1/2)x\u1d40Gkx.\nProof. First, notice that \u2207\u03c8k(x) = Gkx. Next, we derive a closed-form for \u03c8\u2217k:\n\u03c8\u2217k(y) = max x\u2208Rn\n{ x\u1d40y \u2212 1\n2 x\u1d40Gkx\n} . (5.2)\nSince the function being maximized on the right hand side is strictly concave, the x that maximizes it is its critical point. Solving for this\n66 Safe Reinforcement Learning using Projected Natural Actor Critic\ncritical point, we get x = G\u22121k y. Substituting this into (5.2), we find that \u03c8\u2217k(y) = ( 1/2)y\u1d40G\u22121k y. Hence, \u2207\u03c8\u2217k(y) = G\u22121k y. Using the definitions of \u2207\u03c8k(x) and \u2207\u03c8\u2217k(y), we find that the mirror descent update is\nxk+1 =G \u22121 k (Gkxk \u2212 \u03b1k\u2207f(xk)) = xk \u2212 \u03b1kG\u22121k \u2207f(xk),\nwhich is identical to (5.1). Although researchers often use \u03c8k that are norms like the p-norm and Mahalanobis norm, notice that the \u03c8k that results in natural gradient descent is not a norm. Also, since Gk depends on k, \u03c8k is an adaptive proximal function [94]."}, {"heading": "5.4 Projected Natural Gradients", "text": "When x is constrained to some set, X, \u03c8k in mirror descent is augmented with the indicator function IX , where IX(x) = 0 if x \u2208 X, and +\u221e otherwise. The \u03c8k that was shown to generate an update equivalent to the natural gradient descent update, with the added constraint that x \u2208 X, is \u03c8k(x) = (1/2)x\u1d40Gkx + IX(x). Hereafter, any references to \u03c8k refer to this augmented version.\nFor this proximal function, the subdifferential of \u03c8k(x) is \u2207\u03c8k(x) = Gk(x) + N\u0302X(x) = (Gk + N\u0302X)(x), where N\u0302X(x) , \u2202IX(x) and, in the middle term, Gk and N\u0302X are relations and + denotes Minkowski addition.2 N\u0302X(x) is the normal cone of X at x if x \u2208 X and \u2205 otherwise [95].\n\u2207\u03c8\u2217k(y) = (Gk + N\u0302X)\u22121(y). (5.3)\nLet \u03a0GkX (y), be the set of x \u2208 X that are closest to y, where the length of a vector, z, is (1/2)z\u1d40Gkz. More formally,\n\u03a0GkX (y) , arg minx\u2208X 1 2 (y \u2212 x)\u1d40Gk(y \u2212 x). (5.4)\n2 Later, we abuse notation and switch freely between treating Gk as a matrix and a relation. When it is a matrix, Gkx denotes matrix-vector multiplication that produces a vector. When it is a relation, Gk(x) produces the singleton {Gkx}.\n5.5. Compatibility of Projection 67\nLemma 5.4.1. \u03a0GkX (y) = (Gk + N\u0302X) \u22121(Gky).\nProof. We write (5.4) without the explicit constraint that x \u2208 X by appending the indicator function:\n\u03a0GkX (y) = arg minx\u2208Rn hy(x),\nwhere hy(x) = (1/2)(y\u2212x)\u1d40Gk(y\u2212x)+IX(x). Since hy is strictly convex over X and +\u221e elsewhere, its critical point is its global minimizer. The critical point satisfies\n0 \u2208 \u2207hy(x) = \u2212Gk(y) +Gk(x) + N\u0302X(x).\nThe globally minimizing x therefore satisfies Gky \u2208 Gk(x) + N\u0302X(x) = (Gk + N\u0302X)(x). Solving for x, we find that x = (Gk + N\u0302X)\n\u22121(Gky). Combining Lemma 5.4.1 with (5.3), we find that \u2207\u03c8\u2217(y) = \u03a0GkX (G \u22121 k y). Hence, mirror descent with the proximal function that produces natural gradient descent, augmented to include the constraint that x \u2208 X, is:\nxk+1 =\u03a0 Gk X ( G\u22121k ( (Gk + N\u0302X)(xk)\u2212 \u03b1k\u2207f(xk) )) =\u03a0GkX ( (I +G\u22121k N\u0302X)(xk)\u2212 \u03b1kG\u22121k \u2207f(xk) ) ,\nwhere I denotes the identity relation. Since xk \u2208 X, we know that 0 \u2208 N\u0302X(xk), and hence the update can be written as\nxk+1 = \u03a0 Gk X ( xk \u2212 \u03b1kG\u22121k \u2207f(xk) ) , (5.5)\nwhich we call projected natural gradient (PNG)."}, {"heading": "5.5 Compatibility of Projection", "text": "The standard projected subgradient (PSG) descent method follows the negative gradient (as opposed to the negative natural gradient) and projects back to X using the Euclidean norm. If f and X are convex and the stepsize is decayed appropriately, it is guaranteed to converge to a global minimum, x\u2217 \u2208 X. Any such x\u2217 is a fixed point. This means\n68 Safe Reinforcement Learning using Projected Natural Actor Critic\nthat a small step in the negative direction of any subdifferential of f at x\u2217 will project back to x\u2217.\nOur choice of projection, \u03a0GkX , results in PNG having the same fixed points (see Lemma 5.5.1). This means that, when the algorithm is at x\u2217 and a small step is taken down the natural gradient to x\u2032, \u03a0GkX will project x\u2032 back to x\u2217. We therefore say that \u03a0GkX is compatible with the natural gradient. For comparison, the Euclidean projection of x\u2032 will not necessarily return x\u2032 to x\u2217.\nLemma 5.5.1. The sets of fixed points for PSG and PNG are equivalent.\nProof. A necessary and sufficient condition for x to be a fixed point of PSG is that \u2212\u2207f(x) \u2208 N\u0302X(x) [96]. A necessary and sufficient condition for x to be a fixed point of PNG is\nx =\u03a0GkX ( x\u2212 \u03b1kG\u22121k \u2207f(x) ) = (Gk + N\u0302X) \u22121 ( Gk ( x\u2212 \u03b1kG\u22121k \u2207f(x) ) ) =(Gk + N\u0302X)\n\u22121 (Gkx\u2212 \u03b1k\u2207f(x)) \u21d4Gkx\u2212 \u03b1k\u2207f(x) \u2208 Gk(x) + N\u0302X(x) \u21d4\u2212\u2207f(x) \u2208 N\u0302X(x).\nTo emphasize the importance of using a compatible projection, consider the following simple example. Minimize the function f(x) = x\u1d40Ax+ b\u1d40x, where A = diag(1, 0.01) and b = [\u22120.2,\u22120.1]\u1d40, subject to the constraints \u2016x\u20161 \u2264 1 and x \u2265 0. We implemented three algorithms, and ran each for 1000 iterations using a fixed stepsize:\n(1) PSG - projected subgradient descent using the Euclidean\nprojection. (2) PNG - projected natural gradient descent using \u03a0GkX . (3) PNG-Euclid - projected natural gradient descent using the\nEuclidean projection.\nThe results are shown in Figure 1. Notice that PNG and PSG converge to the optimal solution, x\u2217. From this point, they both step in different directions, but project back to x\u2217. However, PNG-Euclid converges to\n5.6. Natural Actor-Critic Algorithms 69\nFig. 5.1: The thick diagonal line shows one constraint and dotted lines show projections. Solid arrows show the directions of the natural gradient and gradient at the optimal solution, x\u2217. The dashed blue arrows show PNG-Euclid\u2019s projections, and emphasize the the projections cause PNGEuclid to move away from the optimal solution.\na suboptimal solution (outside the domain of the figure). If X were a line segment between the point that PNG-Euclid and PNG converge to, then PNG-Euclid would converge to the pessimal solution within X, while PSG and PNG would converge to the optimal solution within X. Also, notice that the natural gradient corrects for the curvature of the function and heads directly towards the global unconstrained minimum. Since the natural methods in this example use metric tensor G = A, which is the Hessian of f , they are essentially an incremental form of Newton\u2019s method. In practice, the Hessian is usually not known, and an estimate thereof is used."}, {"heading": "5.6 Natural Actor-Critic Algorithms", "text": "An MDP is a tuple M = (S,A,P,R, d0, \u03b3), where S is a set of states, A is a set of actions, P(s\u2032|s, a) gives the probability density of the system entering state s\u2032 when action a is taken in state s, R(s, a) is the expected reward, r, when action a is taken in state s, d0 is the initial state distribution, and \u03b3 \u2208 [0, 1) is a reward discount parameter. A parameterized policy, \u03c0, is a conditional probability density function\u2014 \u03c0(a|s, \u03b8) is the probability density of action a in state s given a vector of policy parameters, \u03b8 \u2208 Rn.\n70 Safe Reinforcement Learning using Projected Natural Actor Critic\nLet J(\u03b8) = E [\u2211\u221e\nt=0 \u03b3 trt|\u03b8\n] be the discounted-reward objective or the\naverage reward objective function with J(\u03b8) = limn\u2192\u221e 1 nE [ \u2211n t=0 rt|\u03b8]. Given an MDP, M , and a parameterized policy, \u03c0, the goal is to find policy parameters that maximize one of these objectives. When the action set is continuous, the search for globally optimal policy parameters becomes intractable, so policy search algorithms typically search for locally optimal policy parameters.\nNatural actor-critics, first proposed by Kakade [97], are algorithms that estimate and ascend the natural gradient of J(\u03b8), using the average Fisher information matrix as the metric tensor:\nGk = G(\u03b8k) = Es\u223cd\u03c0 ,a\u223c\u03c0\n[( \u2202\n\u2202\u03b8k log \u03c0(a|s, \u03b8k)\n)( \u2202\n\u2202\u03b8k log \u03c0(a|s, \u03b8k)\n)\u1d40] ,\nwhere d\u03c0 is a policy and objective function-dependent distribution over the state set [98].\nThere are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93]. All of them form an estimate, typically denoted wk, of the natural gradient of J(\u03b8k). That is, wk \u2248 G(\u03b8k)\u22121\u2207J(\u03b8k). They then perform the policy parameter update, \u03b8k+1 = \u03b8k + \u03b1kwk."}, {"heading": "5.7 Projected Natural Actor-Critics", "text": "If we are given a closed convex set, \u0398 \u2286 Rn, of admissible policy parameters (e.g., the stable region of gains for a PID controller), we may wish to ensure that the policy parameters remain within \u0398. The natural actor-critic algorithms described in the previous section do not provide such a guarantee. However, their policy parameter update equations, which are natural gradient ascent updates, can easily be modified to the projected natural gradient ascent update in (5.5) by projecting the parameters back onto \u0398 using \u03a0 G(\u03b8k) \u0398 :\n\u03b8k+1 = \u03a0 G(\u03b8k) \u0398 (\u03b8k + \u03b1kwk) .\n5.7. Projected Natural Actor-Critics 71\nMany of the existing natural policy gradient algorithms, including NAC-LSTD, eNAC, NAC-Sarsa, and INAC, follow biased estimates of the natural policy gradient [103]. For our experiments, we must use an unbiased algorithm since the projection that we propose is compatible with the natural gradient, but not necessarily biased estimates thereof.\nNAC-Sarsa and INAC are equivalent biased discounted-reward natural actor-critic algorithms with per-time-step time complexity linear in the number of features. The former was derived by replacing the LSTD-Q(\u03bb) component of NAC-LSTD with Sarsa(\u03bb), while the latter is the discounted-reward version of NGAC. Both are similar to NTD, which is a biased average-reward algorithm. The unbiased discounted - reward form of NAC-Sarsa was recently derived [103]. References to NAC-Sarsa hereafter refer to this unbiased variant. In our case studies we use the projected natural actor-critic using Sarsa(\u03bb) (PNAC-Sarsa), the projected version of the unbiased NAC-Sarsa algorithm.\nNotice that the projection, \u03a0 G(\u03b8k) \u0398 , as defined in (5.4), is not merely the Euclidean projection back onto \u0398. For example, if \u0398 is the set of \u03b8 that satisfy A\u03b8 \u2264 b, for some fixed matrix A and vector b, then the projection, \u03a0\nG(\u03b8k) \u0398 , of y onto \u0398 is a quadratic program,\nminimize f(\u03b8) =\u2212 y\u1d40G(\u03b8k)\u03b8 + 1\n2 \u03b8\u1d40G(\u03b8k)\u03b8, s.t. A\u03b8 \u2264 b.\nIn order to perform this projection, we require an estimate of the average Fisher information matrix, G(\u03b8k). If the natural actor-critic algorithm does not already include this (like NAC-LSTD and NACSarsa do not), then an estimate can be generated by selecting G0 = \u03b2I, where \u03b2 is a positive scalar and I is the identity matrix, and then updating the estimate with Gt+1 = (1\u2212 \u00b5t)Gt + \u00b5t ( \u2202\n\u2202\u03b8k log \u03c0(at|st, \u03b8k)\n)( \u2202\n\u2202\u03b8k log \u03c0(at|st, \u03b8k)\n)\u1d40 ,\nwhere {\u00b5t} is a stepsize schedule [93]. Notice that we use t and k subscripts since many time steps of the MDP may pass between updates to the policy parameters.\n72 Safe Reinforcement Learning using Projected Natural Actor Critic"}, {"heading": "5.8 Case Study: Functional Electrical Stimulation", "text": "In this case study, we searched for proportional-derivative (PD) gains to control a simulated human arm undergoing FES. We used the Dynamic Arm Simulator 1 (DAS1) [104], a detailed biomechanical simulation of a human arm undergoing functional electrical stimulation. In a previous study, a controller created using DAS1 performed well on an actual human subject undergoing FES, although it required some additional tuning in order to cope with biceps spasticity [85]. This suggests that it is a reasonably accurate model of an ideal arm.\nThe DAS1 model, depicted in Figure 2a, has state st =\n(\u03c61, \u03c62, \u03c6\u03071, \u03c6\u03072, \u03c6 target 1 , \u03c6 target 2 ), where \u03c6 target 1 and \u03c6 target 2 are the desired joint angles, and the desired joint angle velocities are zero. The goal is to, during a two-second episode, move the arm from its random initial state to a randomly chosen stationary target. The arm is controlled by providing a stimulation in the interval [0, 1] to each of six muscles. The reward function used was similar to that of Jagodnik and van den Bogert [85], which punishes joint angle error and high muscle stimulation. We searched for locally optimal PD gains using PNAC-Sarsa where the policy was a PD controller with Gaussian noise added for exploration.\nAlthough DAS1 does not model shoulder dislocation, we added safety constraints by limiting the l1-norm of certain pairs of gains. The constraints were selected to limit the forces applied to the humerus. These constraints can be expressed in the form A\u03b8 \u2264 b, where A is a matrix, b is a vector, and \u03b8 are the PD gains (policy parameters). We compared the performance of three algorithms:\n(1) NAC: NAC-Sarsa with no constraints on \u03b8. (2) PNAC: PNAC-Sarsa using the compatible projection,\n\u03a0 G(\u03b8k) \u0398 .\n(3) PNAC-E: PNAC-Sarsa using the Euclidean projection.\nSince we are not promoting the use of one natural actor-critic over another, we did not focus on finely tuning the natural actor-critic nor comparing the learning speeds of different natural actor-critics. Rather, we show the importance of the proper projection by allowing PNACSarsa to run for a million episodes (far longer than required for con-\n5.9. Case Study: uBot Balancing 73\nvergence), after which we plot the mean sum of rewards during the last quarter million episodes. Each algorithm was run ten times, and the results averaged and plotted in Figure 2b. Notice that PNAC performs worse than the unconstrained NAC. This happens because NAC leaves the safe region of policy space during its search, and converges to a dangerous policy\u2014one that reaches the goal quickly and with low total muscle force, but which can cause large, short, spikes in muscle forces surrounding the shoulder, which violates our safety constraints. We suspect that PNAC converges to a near-optimal policy within the region of policy space that we have designated as safe. PNAC-E converges to a policy that is worse than that found by PNAC because it uses an incompatible projection."}, {"heading": "5.9 Case Study: uBot Balancing", "text": "In the previous case study, the optimal policy lay outside the designated safe region of policy space (this is common when a single failure is so costly that adding a penalty to the reward function for failure is impractical, since a single failure is unacceptable). We present a second case study in which the optimal policy lies within the designated safe region of policy space, but where an unconstrained search algorithm may enter the unsafe region during its search of policy space (at which point large negative rewards return it to the safe region).\nThe uBot-5, shown in Figure 5.2, is an 11-DoF mobile manipulator developed at the University of Massachusetts Amherst [20, 21]. During experiments, it often uses its arms to interact with the world. Here, we consider the problem faced by the controller tasked with keeping the robot balanced during such experiments. To allow for results that are easy to visualize in 2D, we use a PD controller that observes only the current body angle, its time derivative, and the target angle (always vertical). This results in the PD controller having only two gains (tunable policy parameters). We use a crude simulation of the uBot-5 with random upper-body movements, and search for the PD gains that minimize a weighted combination of the energy used and the mean angle error (distance from vertical).\nWe constructed a set of conservative estimates of the region of stable\n74 Safe Reinforcement Learning using Projected Natural Actor Critic\n(Figure 2a) DAS1, the two-joint, sixmuscle biomechanical model used. Antagonistic muscle pairs are as follows, listed as (flexor, extensor): monoarticular shoulder muscles (a: anterior deltoid, b: posterior deltoid); monoarticular elbow muscles (c: brachialis, d: triceps brachii (short head)); biarticular muscles (e: biceps brachii, f: triceps brachii (long head)).\nNAC PNAC PNAC\u2010E\n\u201015\nrn Re tu r\n\u201016 M ea n\u00a0\n1\nM\n\u2010 7\n(Figure 2b) Mean return during the last 250,000 episodes of training using thee algorithms. Standard deviation error bars from the 10 trials are provided. The NAC bar is red to emphasize that the final policy found by NAC resides in the dangerous region of policy space.\ngains, with which the uBot-5 should never fall, and used PNAC-Sarsa and NAC-Sarsa to search for the optimal gains. Each training episode lasted 20 seconds, but was terminated early (with a large penalty) if the uBot-5 fell over. Figure 5.2 (middle) shows performance over 100 training episodes. Using NAC-Sarsa, the PD weights often left the conservative estimate of the safe region, which resulted in the uBot-5\n5.10. Summary 75\nfalling over. Figure 5.2 (right) shows one trial where the uBot-5 fell over four times (circled in red). The resulting large punishments cause NAC-Sarsa to quickly return to the safe region of policy space. Using PNAC-Sarsa, the simulated uBot-5 never fell. Both algorithms converge to gains that reside within the safe region of policy space. We selected this example because it shows how, even if the optimal solution resides within the safe region of policy space (unlike the in the previous case study), unconstrained RL algorithms may traverse unsafe regions of policy space during their search."}, {"heading": "5.10 Summary", "text": "We presented a class of algorithms, which we call projected natural actor-critics (PNACs). PNACs are the simple modification of existing natural actor-critic algorithms to include a projection of newly computed policy parameters back onto an allowed set of policy parameters (e.g., those of policies that are known to be safe). We argued that a principled projection is the one that results from viewing natural gradient descent, which is an unconstrained algorithm, as a special case of\n76 Safe Reinforcement Learning using Projected Natural Actor Critic\nmirror descent, which is a constrained algorithm.\nWe show that the resulting projection is compatible with the natural gradient and gave a simple empirical example that shows why a compatible projection is important. This example also shows how an incompatible projection can result in natural gradient descent converging to a pessimal solution in situations where a compatible projection results in convergence to an optimal solution. We then applied a PNAC algorithm to a realistic constrained control problem with six-dimensional continuous states and actions. Our results support our claim that the use of an incompatible projection can result in convergence to inferior policies. Finally, we applied PNAC to a simulated robot and showed its substantial benefits over unconstrained natural actor-critic algorithms.\n6 True Stochastic Gradient Temporal Difference Learning Algorithms\nWe now turn to the solution of a longstanding puzzle: how to design a \u201ctrue\u201d gradient method for reinforcement learning? We address longstanding questions in reinforcement learning: (1) Are there any firstorder reinforcement learning algorithms that can be viewed as \u201ctrue\u201d stochastic gradient methods? If there are, what are their objective functions and what are their convergence rates? (2) What is the general framework for avoiding biased sampling (instead of double-sampling, which is a stringent sampling requirement) in reinforcement learning? To this end, we introduce a novel primal-dual splitting framework for reinforcement learning, which shows that the GTD family of algorithms are true stochastic algorithms with respect to the primal-dual formulation of the objective functions such as NEU and MSPBE, which facilitates their convergence rate analysis and regularization. We also propose operator splitting as a unified framework to avoid bias sampling in reinforcement learning. We present an illustrative empirical study on simple canonical problems validating the effectiveness of the proposed algorithms compared with previous approaches.\n77\n78 True Stochastic Gradient Temporal Difference Learning Algorithms"}, {"heading": "6.1 Introduction", "text": "First-order temporal difference (TD) learning is a widely used class of techniques in reinforcement learning. Although least-squares based temporal difference approaches, such as LSTD [23], LSPE [24] and LSPI [25] perform well with moderate size problems, first-order temporal difference learning algorithms scale more gracefully to high dimensional problems. The initial class of TD methods was known to converge only when samples are drawn \u201con-policy\u201d. This motivated the development of the gradient TD (GTD) family of methods [26]. A novel saddle-point framework for sparse regularized GTD was proposed recently [14]. However, there have been several questions regarding the current off-policy TD algorithms. (1) The first is the convergence rate of these algorithms. Although these algorithms are motivated from the gradient of an objective function such as MSPBE and NEU, they are not true stochastic gradient methods with respect to these objective functions, as pointed out in [27], which make the convergence rate and error bound analysis difficult, although asymptotic analysis has been carried out using the ODE approach. (2) The second concern is regarding acceleration. It is believed that TDC performs the best so far of the GTD family of algorithms. One may intuitively ask if there are any gradient TD algorithms that can outperform TDC. (3) The third concern is regarding compactness of the feasible set \u03b8. The GTD family of algorithms all assume that the feasible set \u03b8 is unbounded, and if the feasible set \u03b8 is compact, there is no theoretical analysis and convergence guarantee. (4) The fourth question is on regularization: although the saddle point framework proposed in [14] provides an online regularization framework for the GTD family of algorithms, termed as RO-TD, it is based on the inverse problem formulation and is thus not quite explicit. One further question is whether there is a more straightforward algorithm, e.g, the regularization is directly based on the MSPBE and NEU objective functions.\nBiased sampling is a well-known problem in reinforcement learning. Biased sampling is caused by the stochasticity of the policy wherein there are multiple possible successor states from the current state where the agent is. If it is a deterministic policy, then there will be no biased\n6.2. Background 79\nsampling problem. Biased sampling is often caused by the product of the TD errors, or the product of TD error and the gradient of TD error w.r.t the model parameter \u03b8. There are two ways to avoid the biased sampling problem, which can be categorized into double sampling methods and two-time-scale stochastic approximation methods.\nIn this paper, we propose a novel approach to TD algorithm design in reinforcement learning, based on introducing the proximal splitting framework [28]. We show that the GTD family of algorithms are true stochastic gradient descent (SGD) methods, thus making their convergence rate analysis available. New accelerated off-policy algorithms are proposed and their comparative study with RO-TD is carried out to show the effectiveness of the proposed algorithms. We also show that primal-dual splitting is a unified first-order optimization framework to solve the biased sampling problem.\nHere is a roadmap to the rest of the chapter. Section 2 reviews reinforcement learning and the basics of proximal splitting formulations and algorithms. Section 3 introduces a novel problem formulation which we investigate in this paper. Section 4 proposes a series of new algorithms, demonstrates the connection with the GTD algorithm family, and also presents accelerated algorithms. Section 5 presents theoretical analysis of the algorithms. Finally, empirical results are presented in Section 6 which validate the effectiveness of the proposed algorithmic framework. Abbreviated technical proofs of the main theoretical results are provided in a supplementary appendix."}, {"heading": "6.2 Background", "text": ""}, {"heading": "6.2.1 Markov Decision Process and Reinforcement Learning", "text": "In linear value function approximation, a value function is assumed to lie in the linear span of a basis function matrix \u03a6 of dimension |S| \u00d7 d, where d is the number of linear independent features. Hence, V \u2248 V\u03b8 = \u03a6\u03b8. For the t-th sample, \u03c6t (the t-th row of \u03a6), \u03c6\u2032t (the t-th row of \u03a6\u2032) are the feature vectors corresponding to st, s \u2032 t, respectively. \u03b8t is the weight vector for t-th sample in first-order TD learning methods, and \u03b4t = (rt+\u03b3\u03c6 \u2032T t \u03b8t)\u2212\u03c6Tt \u03b8t is the temporal difference error. TD learning uses the following update rule \u03b8t+1 = \u03b8t + \u03b1t\u03b4t\u03c6t, where\n80 True Stochastic Gradient Temporal Difference Learning Algorithms\n\u03b1t is the stepsize. However, TD is only guaranteed to converge in the on-policy setting, although in many off-policy situations, it still has satisfactory performance [105]. To this end, Sutton et al. proposed a family of off-policy convergent algorithms including GTD, GTD2 and TD with gradient correction (TDC). GTD is a two-time-scale stochastic approximation approach which aims to minimize the norm of the expected TD update (NEU), which is defined as\nNEU(\u03b8) = E[\u03b4t(\u03b8)\u03c6t]TE[\u03b4t(\u03b8)\u03c6t].\nTDC [26] aims to minimize the mean-square projected Bellman error (MSPBE) with a similar two-time-scale technique, which is defined as MSPBE(\u03b8) =\n\u2016\u03a6\u03b8 \u2212\u03a0T (\u03a6\u03b8)\u20162\u039e = (\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8))T (\u03a6T\u039e\u03a6)\u22121\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8),\nwhere \u039e is a diagonal matrix whose entries \u03be(s) are given by a positive probability distribution over states."}, {"heading": "6.3 Problem Formulation", "text": "Biased sampling is a well-known problem in reinforcement learning. Biased sampling is caused by E[\u03c6\u2032Tt \u03c6 \u2032 t] or E[\u03c6 \u2032 t\u03c6 \u2032T t ], where \u03c6 \u2032 t is the feature vector for state s \u2032 t in sample (st, at, rt, s \u2032 t). Due to the stochastic nature of the policy, there may be many s\u2032t w.r.t the same st, thus E[\u03c6 \u2032T t \u03c6 \u2032 t] or E[\u03c6\u2032t\u03c6 \u2032T t ] cannot be consistently estimated via a single sample. This problem hinders the objective functions to be solved via stochastic gradient descent (SGD) algorithms. As pointed out in [27], although many algorithms are motivated by well-defined convex objective functions such as MSPBE and NEU, due to the biased sampling problem, the unbiased stochastic gradient is impossible to obtain, and thus the algorithms are not true SGD methods w.r.t. these objective functions. The biased sampling is often caused by the product of the TD errors, or the product of TD error and the derivative of TD error w.r.t. the parameter \u03b8. There are two ways to avoid the biased sampling problem, which can be categorized into double sampling methods and stochastic approximation methods. Double sampling, which samples both s\u2032 and\n6.3. Problem Formulation 81\ns\u2032\u2032 and thus requires computing \u03c6\u2032 and \u03c6\u2032\u2032, is possible in batch reinforcement learning, but is usually impractical in online reinforcement learning. The other approach is stochastic approximation, which introduces a new variable to estimate the part containing \u03c6 \u2032 t, thus avoiding the product of \u03c6 \u2032 t and \u03c6 \u2032\u2032 t . Consider, for example, the NEU objective function in Section (6.2.1). Taking the gradient w.r.t. \u03b8, we have\n\u22121 2 NEU(\u03b8) = E[(\u03c6t \u2212 \u03b3\u03c6\u2032t)\u03c6Tt ]E[\u03b4t(\u03b8)\u03c6t]\nIf the gradient can be written as a single expectation value, then it is straightforward to use a stochastic gradient method, however, here we have a product of two expectations, and due to the correlation between (\u03c6t\u2212 \u03b3\u03c6\u2032t)\u03c6Tt and \u03b4t(\u03b8)\u03c6t, the sampled product is not an unbiased estimate of the gradient. In other words, E[(\u03c6t\u2212\u03b3\u03c6\u2032t)\u03c6Tt ] and E[\u03b4t(\u03b8)\u03c6t] can be directly sampled, yet E[(\u03c6t \u2212 \u03b3\u03c6\u2032t)\u03c6Tt ]E[\u03b4t(\u03b8)\u03c6t] can not be directly sampled. To tackle this, the GTD algorithm uses the two-time-scale stochastic approximation method by introducing an auxiliary variable wt, and thus the method is not a true stochastic gradient method w.r.t. NEU(\u03b8) any more. This auxiliary variable technique is also used in [56].\nThe other problem for first-order reinforcement learning algorithms is that it is difficult to define the objective functions, which is also caused by the biased sampling problem. As pointed out in [27], although the GTD family of algorithms are derived from the gradient w.r.t. the objective functions such as MSPBE and NEU, because of the biasedsampling problem, these algorithms cannot be formulated directly as SGD methods w.r.t. these objective functions.\nIn sum, due to biased sampling, the RL objective functions cannot be solved via a stochastic gradient method, and it is also difficult to find objective functions of existing first-order reinforcement learning algorithms. Thus, there remains a large gap between first-order reinforcement learning algorithms and stochastic optimization, which we now show how to bridge.\n82 True Stochastic Gradient Temporal Difference Learning Algorithms"}, {"heading": "6.4 Algorithm Design", "text": "In what follows, we build on the operator splitting methods introduced in Section 2.6.3, which should be reviewed before reading the section below."}, {"heading": "6.4.1 NEU Objective Function", "text": "The primal-dual formulation of the NEU defined in Section (6.2.1) is as follows:\nmin \u03b8\u2208X\n( 1\n2 NEU(\u03b8) + h(\u03b8)\n) = min\n\u03b8\u2208X max y\n( \u3008\u03a6T\u039e(R+ \u03b3\u03a6\u2032\u03b8 \u2212 \u03a6\u03b8), y\u3009 \u2212 1\n2 ||y||22 + h(\u03b8) ) We have K(\u03b8) = \u03a6T\u039e(R + \u03b3\u03a6\n\u2032 \u03b8 \u2212 \u03a6\u03b8) , and F (\u00b7) = 12 || \u00b7 ||22 , thus the\nLegendre transform is F \u2217(\u00b7) = F (\u00b7) = 12 || \u00b7 ||22. Thus the update rule is\nyt+1 = yt + \u03b1t(\u03b4t\u03c6t \u2212 yt), \u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6\u2032t)(yTt \u03c6t) ) Note that if h(\u03b8) = 0 andX = Rd, then we will have the GTD algorithm proposed in [106]."}, {"heading": "6.4.2 MSPBE Objective Function", "text": "Based on the definition of MSPBE in Section (6.2.1), we can reformulate MSPBE as\nMSPBE(\u03b8) = ||\u03a6T\u039e(TV\u03b8 \u2212 V\u03b8)||2(\u03a6T\u039e\u03a6)\u22121\nThe gradient of MSPBE is correspondingly computed as\n\u22121 2 MSPBE(\u03b8) = E[(\u03c6t \u2212 \u03b3\u03c6 \u2032 t)\u03c6 T t ]E[\u03c6t\u03c6Tt ] \u22121E[\u03b4t(\u03b8)\u03c6t]\nAs opposed to computing the NEU gradient, computing Equation (6.4.2) involves computing the inverse matrix E[\u03c6t\u03c6Tt ] \u22121, which imposes extra difficulty. To this end, we propose another primal-dual splitting formulation with weighted Euclidean norm as follows,\nmin x\u2208X\n1 2 ||x||2M\u22121 = minx\u2208X maxw \u3008x,w\u3009 \u2212 1 2 ||w||2M\n6.4. Algorithm Design 83\nwhere M = \u03a6T\u039e\u03a6, and the dual variable is denoted as wt to differentiate it from yt used for the NEU objective function. Then we have\nmin \u03b8\u2208X\n1 2 MSPBE(\u03b8)+h(\u03b8) = min \u03b8\u2208X max w \u3008\u03a6T\u039e(R+ \u03b3\u03a6\u2032\u03b8 \u2212 \u03a6\u03b8), w\u3009\u22121 2 ||w||2M+h(\u03b8)\nNote that the nonlinear convex F (\u00b7) = 12 ||\u00b7||2M\u22121 , and thus the Legendre transform is F \u2217(\u00b7) = 12 || \u00b7 ||2M . We can see that by using the primal-dual splitting formulation, computing the inverse matrix M\u22121 is avoided. Thus the update rule is as follows:\nwt+1 = wt + \u03b1t(\u03b4t \u2212 \u03c6Tt wt)\u03c6t, \u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6\u2032t)(wTt \u03c6t) ) Note that if h(\u03b8) = 0 and X = Rd, then we will have the GTD2 algorithm proposed in [26]. It is also worth noting that the TDC algorithm seems not to have an explicit proximal splitting representation, since it incorporates wt(\u03b8) = E[\u03c6t\u03c6Tt ] \u22121E[\u03b4t(\u03b8)\u03c6t] into the update of \u03b8t, a quasistationary condition which is commonly used in two-time-scale stochastic approximation approaches. An intuitive answer to the advantage of TDC over GTD2 is that the TDC update of \u03b8t can be considered as incorporating the prior knowledge into the update rule: for a stationary \u03b8t, if the optimal wt(\u03b8t) (termed as w \u2217 t (\u03b8t)) has a closed-form solution or is easy to compute, then incorporating this w\u2217t (\u03b8t) into the update rule tends to accelerate the algorithm\u2019s convergence performance. For the GTD2 update in Equation (6.4.2), note that there is a sum of two terms where wt appears: which are (\u03c6t\u2212\u03b3\u03c6\u2032t)(wTt \u03c6t) = \u03c6t(wTt \u03c6t)\u2212\u03b3\u03c6\u2032t(wTt \u03c6t). Replacing wt in the first term with w \u2217 t (\u03b8) = E[\u03c6t\u03c6Tt ]\n\u22121E[\u03b4t(\u03b8)\u03c6t], we have the update rule as follows\nwt+1 = wt + \u03b1t(\u03b4t \u2212 \u03c6Tt wt)\u03c6t , \u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6\u2032t)(\u03c6Tt wt) ) Note that if h(\u03b8) = 0 and X = Rd, then we will have TDC algorithm proposed in [26]. Note that this technique does not have the same convergence guarantee as the original objective function. For example, if we use a similar trick on the GTD update with the optimal yt(\u03b8t) (termed as y\u2217t (\u03b8t)) where y \u2217 t (\u03b8) = E[\u03b4t(\u03b8)\u03c6t], then we can have\n\u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t\u03b4t(\u03c6t \u2212 \u03b3\u03c6 \u2032 t) )\n84 True Stochastic Gradient Temporal Difference Learning Algorithms\nwhich is the update rule of residual gradient [107], and is proven not to converge to NEU any more.1"}, {"heading": "6.5 Accelerated Gradient Temporal Difference Learning Algorithms", "text": "In this section we will discuss the acceleration of GTD2 and TDC. The acceleration of GTD is not discussed due to space consideration, which is similar to GTD2. A comprehensive overview of the convergence rate of different approaches to stochastic saddle-point problems is given in [108]. In this section we present accelerated algorithms based on the Stochastic Mirror-Prox (SMP) Algorithm [47, 109]. Algorithm 11, termed as GTD2-MP, is accelerated GTD2 with extragradient. Algorithm 12, termed as TDC-MP, is accelerated TDC with extragradient.\nAlgorithm 10 Algorithm Template Let \u03c0 be some fixed policy of an MDP M , \u03a6 be some fixed basis.\n1: repeat 2: Compute \u03c6t, \u03c6t \u2032 and TD error \u03b4t = rt + \u03b3\u03c6t\n\u2032T \u03b8t \u2212 \u03c6Tt \u03b8t 3: Compute \u03b8t+1, wt+1 according to each algorithm update rule 4: until t = N ;\n5: Compute primal average \u03b8\u0304N = 1 N N\u2211 i=1 \u03b8i, w\u0304N = 1 N N\u2211 i=1 wi"}, {"heading": "6.6 Theoretical Analysis", "text": "In this section, we discuss the convergence rate and error bound of GTD, GTD2 and GTD2-MP."}, {"heading": "6.6.1 Convergence Rate", "text": "Proposition 1 The convergence rates of the GTD/GTD2 algorithms with primal average are O(LF\u2217+LK+\u03c3\u221a N ), where LK = ||\u03a6T\u039e(\u03a6 \u2212\n1 It converges to mean-square TD error (MSTDE), as proven in [75].\n6.6. Theoretical Analysis 85\nAlgorithm 11 GTD2-MP\n(1) wt+ 1 2 = wt + \u03b2t(\u03b4t \u2212 \u03c6Tt wt)\u03c6t, \u03b8t+ 1\n2 = prox\u03b1th\n( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6t\u2032)(\u03c6Tt wt) ) (2) \u03b4t+ 1\n2 = rt + \u03b3\u03c6t \u2032T \u03b8t+ 1 2 \u2212 \u03c6Tt \u03b8t+ 1 2\n(3) wt+1 = wt + \u03b2t(\u03b4t+ 1\n2 \u2212 \u03c6Tt wt+ 1 2 )\u03c6t ,\n\u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6t\u2032)(\u03c6Tt wt+ 1 2 ) )\nAlgorithm 12 TDC-MP\n(1) wt+ 1 2 = wt + \u03b2t(\u03b4t \u2212 \u03c6Tt wt)\u03c6t, \u03b8t+ 1\n2 = prox\u03b1th\n( \u03b8t + \u03b1t\u03b4t\u03c6t \u2212 \u03b1t\u03b3\u03c6t\u2032(\u03c6Tt wt) ) (2) \u03b4t+ 1\n2 = rt + \u03b3\u03c6t \u2032T \u03b8t+ 1 2 \u2212 \u03c6Tt \u03b8t+ 1 2\n(3) wt+1 = wt + \u03b2t(\u03b4t+ 1\n2 \u2212 \u03c6Tt wt+ 1 2 )\u03c6t ,\n\u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t\u03b4t+ 1 2 \u03c6t \u2212 \u03b1t\u03b3\u03c6t\u2032(\u03c6Tt wt+ 1 2 ) )\n\u03b3\u03a6 \u2032T )||2, for GTD, LF \u2217 = 1 and for GTD2, LF \u2217 = ||\u03a6T\u039e\u03a6||2, \u03c3 is defined in the Appendix due to space limitations.\nNow we consider the convergence rate of GTD2-MP. Proposition 2 The convergence rate of the GTD2-MP algorithm\nis O(LF\u2217+LKN + \u03c3\u221a N ).\nSee supplementary materials for an abbreviated proof. Remark: The above propositions imply that when the noise level is low, the GTD2-MP algorithm is able to converge at the rate of O( 1N ), whereas the convergence rate of GTD2 is O( 1\u221a N ). However, when the noise level is high, both algorithms\u2019 convergence rates reduce to O( \u03c3\u221a N )."}, {"heading": "6.6.2 Value Approximation Error Bound", "text": "Proposition 3: For GTD/GTD2, the prediction error of ||V \u2212 V\u03b8|| is bounded by ||V \u2212 V\u03b8||\u221e \u2264 L\u039e\u03c6 1\u2212\u03b3 \u00b7 O ( LF\u2217+LK+\u03c3\u221a\nN\n) ; For GTD2-MP, it\n86 True Stochastic Gradient Temporal Difference Learning Algorithms\nis bounded by ||V \u2212 V\u03b8||\u221e \u2264 L\u039e\u03c6 1\u2212\u03b3 \u00b7 O\n( LF\u2217+LK\nN + \u03c3\u221a N ) , where L\u039e\u03c6 =\nmaxs||(\u03a6T\u039e\u03a6)\u22121\u03c6(s)||1. Proof : see Appendix."}, {"heading": "6.6.3 Related Work", "text": "Here we will discuss previous related work. To the best of our knowledge, the closest related work is the RO-TD algorithm, which first introduced the convex-concave saddle-point framework to regularize the TDC family of algorithms. 2 The major difference is that RO-TD is motivated by the linear inverse problem formulation of TDC algorithm and uses its dual norm representation as the objective function, which does not explore the auxiliary variable wt. In contrast, by introducing the operator splitting framework, we demonstrate that the GTD family of algorithms can be nicely explained as a \u201ctrue\u201d SGD approach, where the auxiliary variable wt has a nice explanation.\nAnother interesting question is whether ADMM is suitable for the operator splitting algorithm here. Let\u2019s take NEU for example. The ADMM formulation is as follows, where we assume K(\u03b8) = K\u03b8 for simplicity, and other scenarios can be derived similarly,\nmin \u03b8,z (F (z) + h(\u03b8)) s.t.z = K\u03b8\nThe update rule is as follows, where \u03b1t is the stepsize\n\u03b8t+1 = arg min \u03b8\n( h(\u03b8) + \u3008yt,K\u03b8 \u2212 zt\u3009+ 12 ||K\u03b8 \u2212 zt||2 ) zt+1 = arg min\nz\n( F (z) + \u3008yt,K\u03b8t+1 \u2212 z\u3009+ 12 ||K\u03b8t+1 \u2212 z||2 ) yt+1 = yt + \u03b1t(K\u03b8t+1 \u2212 zt+1)\nAt first glance the operator of F (\u00b7) and K\u03b8 seem to be split, however, if we compute the closed-form update rule of \u03b8t, we can see that the update of \u03b8t includes (K TK)\u22121, which involves both biased-sampling and computing the inverse matrix, thus regular ADMM does not seem to be practical for this first-order reinforcement learning setting. However, using the pre-conditioning technique introduced in [110], ADMM\n2 Although only regularized TDC was proposed in [14], the algorithm can be easily extended to regularized GTD and GTD2.\n6.7. Experimental Study 87\ncan be reduced to the primal-dual splitting method as pointed out in [58]."}, {"heading": "6.7 Experimental Study", "text": ""}, {"heading": "6.7.1 Off-Policy Convergence: Baird Example", "text": "The Baird example is a well-known example where TD diverges and TDC converges. The stepsizes are set to be constants where \u03b2t = \u00b5\u03b1t as shown in Figure 6.1. From Figure 6.1, we can see that GTD2-MP and TDC-MP have a significant advantage over the GTD2 and TDC algorithms wherein both the MSPBE and the variance are substantially reduced."}, {"heading": "6.7.2 Regularization Solution Path: Two-State Example", "text": "Now we consider the two-state MDP in [111]. The transition matrix and reward vector are [0, 1; 0, 1] and R = [0,\u22121]T , \u03b3 = 0.9, and a one-feature basis \u03a6 = [1, 2]T . The objective function are \u03b8 = arg min \u03b8 ( 1 2L(\u03b8) + \u03c1||\u03b8||1 ) , where L(\u03b8) is NEU(\u03b8) and MSPBE(\u03b8). The objective functions are termed as l1-NEU and l1-MSPBE for short. In Figure 6.2, both l1-NEU and l1-MSPBE have well-defined solution\n88 True Stochastic Gradient Temporal Difference Learning Algorithms\npaths w.r.t \u03c1, whereas Lasso-TD may have multiple solutions if the P -matrix condition is not satisfied [62].\n6.7.3 On-Policy Performance: 400-State Random MDP\nIn this experiment we compare the on-policy performance of the four algorithms. We use the random generated MDP with 400 states and 10 actions in [112]. Each state is represented by a feature vector with 201 features, where 200 features are generated by sampling from a uniform distribution the 201-th feature is a constant. The stepsizes are set to be constants where \u03b2t = \u00b5\u03b1t as shown in Figure 6.3. The parameters of each algorithm are chosen via comparative studies similar to [112]. The result is shown in Figure 6.3. The results for each algorithm are averaged on 100 runs, and the parameters of each algorithm are chosen via experiments. TDC shows high variance and chattering effect of MSPBE curve on this domain. Compared with GTD2, GTD2-M1P is able to reduce the MSPBE significantly. Compared with TDC, TDC-MP not only reduces the MSPBE, but also the variance and the \u201dchattering\u201d effect."}, {"heading": "6.8 Summary", "text": "This chapter shows that the GTD/GTD2 algorithms are true stochastic gradient methods w.r.t. the primal-dual formulation of their corresponding objective functions, which enables their convergence rate analysis and regularization. Second, it proposes operator splitting as a\n6.8. Summary 89\nbroad framework to solve the biased-sampling problem in reinforcement learning. Based on the unified primal-dual splitting framework, it also proposes accelerated algorithms with both rigorous theoretical analysis and illustrates their improved performance w.r.t. previous methods. Future research is ongoing to explore other operator splitting techniques beyond primal-dual splitting as well as incorporating random projections [113], and investigating kernelized algorithms [114, 115]. Finally, exploring the convergence rate of the TDC algorithm is also important and interesting.\n7 Variational Inequalities: The Emerging Frontier of Machine Learning\nThis paper describes a new framework for reinforcement learning based on primal dual spaces connected by a Legendre transform. The ensuing theory yields surprising and beautiful solutions to several important questions that have remained unresolved: (i) how to design reliable, convergent, and stable reinforcement learning algorithms (ii) how to guarantee that reinforcement learning satisfies pre-specified \u201csafety\u201d guarantees, and remains in a stable region of the parameter space (iv) how to design \u201coff-policy\u201d TD-learning algorithms in a reliable and stable manner, and finally, (iii) how to integrate the study of reinforcement learning into the rich theory of stochastic optimization. In this paper, we gave detailed answers to all these questions using the powerful framework of proximal operators. The single most important idea that emerges is the use of primal dual spaces connected through the use of a Legendre transform. This allows temporal-difference updates to occur in dual spaces, allowing a variety of important technical advantages. The Legendre transform, as we show, elegantly generalizes past algorithms for solving reinforcement learning problems, such as natural gradient methods, which we show relate closely to the previously unconnected framework of mirror descent methods. Equally importantly, proximal\n90\n7.1. Variational Inequalities 91\noperator theory enables the systematic development of operator splitting methods that show how to safely and reliably decompose complex products of gradients that occur in recent variants of gradient-based temporal-difference learning. This key technical contribution makes it possible to finally show to design \u201ctrue\u201d stochastic gradient methods for reinforcement learning. Finally, Legendre transforms enable a variety of other benefits, including modeling sparsity and domain geometry. Our work builds extensively on recent work on the convergence of saddlepoint algorithms, and on the theory of monotone operators in Hilbert spaces, both in optimization and for variational inequalities. The latter represents possibly the most exciting future research direction, and we give a more detailed description of this ongoing research thrust."}, {"heading": "7.1 Variational Inequalities", "text": "Our discussion above has repeatedly revolved around the fringes of variational inequality theory. Methods like extragradient [8] and the mirror-prox algorithm were originally proposed to solve variational inequalities and related saddle point problems. We are currently engaged in redeveloping the proposed ideas more fully within the fabric of variational inequality (VI). Accordingly, we briefly describe the framework of VIs, and give the reader a brief tour of this fascinating extension of the basic underlying framework of optimization. We lack the space to do a thorough review. That is the topic of another monograph to be published at a later date, and several papers on this topic are already under way.\nAt the dawn of a new millennium, the Internet dominates our economic, intellectual and social lives. The concept of equilibrium plays a key role in understanding not only the Internet, but also other networked systems, such as human migration [116], evolutionary dynamics and the spread of infectious diseases [117], and social networks [118]. Equilibria are also a central idea in game theory [119, 120], economics [121], operations research [29], and many related areas. We are currently exploring two powerful mathematical tools for the study of equilibria \u2013 variational inequalities (VIs) and projected dynamical systems (PDS) [12, 122] \u2013 in developing a new machine learning framework for solving\n92 Variational Inequalities: The Emerging Frontier of Machine Learning\nequilibrium problems in a rich and diverse range of practical applications. As Figure 7.1 illustrates, finite-dimensional VIs provide a mathematical framework that unifies many disparate equilibrium problems of significant importance, including (convex) optimization, equilibrium problems in economics, game theory and networks, linear and nonlinear complementarity problems, and solutions of systems of nonlinear equations.\nVariational inequalities (VIs), in the infinite-dimensional setting, were originally proposed by Hartman and Stampacchia [10] in the mid1960s in the context of solving partial differential equations in mechanics. Finite-dimensional VIs rose in popularity in the 1980s partly as a result of work by Dafermos [11]. who showed that the traffic network equilibrium problem could be formulated as a finite-dimensional VI. This advance inspired much follow-on research, showing that a variety of equilibrium problems in economics, game theory, sequential decisionmaking etc. could also be formulated as finite-dimensional VIs \u2013 the\n7.1. Variational Inequalities 93\nbooks by Nagurney [12] and Facchinei and Pang [13] provide a detailed introduction to the theory and applications of finite-dimensional VIs. Projected dynamical systems (PDS) [122] are a class of ordinary differential equations (ODEs) with a discontinuous right-hand side. Associated with every finite-dimensional VI is a PDS, whose stationary points are the solutions of the VI. While VIs provide a static analysis of equilibria, PDS enable a microscopic examination of the dynamic processes that lead to or away from stable equilibria. . There has been longstanding interest in AI in the development of gradient-based learning algorithms for finding Nash equilibria in multiplayer games, e.g. [123, 119, 124]. A gradient method for finding Nash equilibria can be formalized by a set of ordinary differential equations, whose phase space portrait solution reveals the dynamical process of convergence to an equilibrium point, or lack thereof. A key complication in this type of analysis is that the classical dynamical systems approach does not allow incorporating constraints on values of variables, which are omnipresent in equilibria problems, not only in games, but also in many other applications in economics, network flow, traffic modeling etc. In contrast, the right-hand side of a PDS is a discontinuous projection operator that allows enabling constraints to be modeled.\nOne of the original algorithms for solving finite-dimensional VIs is the extragradient method proposed by Korpelevich [125]. It has been applied to structured prediction models in machine learning by Taskar et al. [126]. Bruckner et al. [127] use a modified extragradient method for solving the spam filtering problem modeled as a prediction game. We are developing a new family of extragradient-like methods based on well-known numerical methods for solving ordinary differential equations, specifically the Runge Kutta method [128]. In optimization, the extragradient algorithm was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129, 130]. We have extended the mirror-prox method by combining it with Runge-Kutta methods for solving high-dimensional VI problems over the simplex and other spaces. We show the enhanced performance of Runge-Kutta extragradient methods on a range of benchmark variational inequalities drawn\n94 Variational Inequalities: The Emerging Frontier of Machine Learning\nfrom standard problems in the optimization literature."}, {"heading": "7.1.1 Definition", "text": "The formal definition of a VI as follows:1\nDefinition 7.1. The finite-dimensional variational inequality problem VI(F,K) involves finding a vector x\u2217 \u2208 K \u2282 Rn such that\n\u3008F (x\u2217), x\u2212 x\u2217\u3009 \u2265 0, \u2200x \u2208 K where F : K \u2192 Rn is a given continuous function and K is a given\nclosed convex set, and \u3008., .\u3009 is the standard inner product in Rn.\nFigure 7.2 provides a geometric interpretation of a variational inequality. 2 The following general result characterizes when solutions to VIs exist:\n1 Variational problems can be defined more abstractly in Hilbert spaces. We confine our\ndiscussion to n-dimensional Euclidean spaces. 2 In Figure 7.2, the normal cone C(x\u2217) at the vector x\u2217 of a convex set K is defined as C(x\u2217) = {y \u2208 Rn|\u3008y, x\u2212 x\u2217\u3009 \u2264 0,\u2200x \u2208 K}.\n7.1. Variational Inequalities 95\nTheorem 7.1. Suppose K is compact, and that F : K \u2192 Rn is continuous. Then, there exists a solution to VI(F,K).\nAs Figure 7.2 shows, x\u2217 is a solution to V I(F,K) if and only if the angle between the vectors F (x\u2217) and x \u2212 x\u2217, for any vector x \u2208 K, is less than or equal to 900. To build up some intuition, the reduction of a few well-known problems to a VI is now provided.\nTheorem 7.2. Let x\u2217 be a solution to the optimization problem of minimizing a continuously differentiable function f(x), subject to x \u2208 K, where K is a closed and convex set. Then, x\u2217 is a solution to V I(\u2207f,K), such that \u3008\u2207f(x\u2217), x\u2212 x\u2217\u3009 \u2265 0, \u2200x \u2208 K.\nProof: Define \u03c6(t) = f(x\u2217 + t(x\u2212 x\u2217)). Since \u03c6(t) is minimized at t = 0, it follows that 0 \u2264 \u03c6\u2032(0) = \u3008\u2207f(x\u2217), x \u2212 x\u2217\u3009 \u2265 0, \u2200x \u2208 K, that is x\u2217 solves the VI.\nTheorem 7.3. If f(x) is a convex function, and x\u2217 is the solution of V I(\u2207f,K), then x\u2217 minimizes f .\nProof: Since f is convex, it follows that any tangent lies below the function, that is f(x) \u2265 f(x\u2217) + \u3008\u2207f(x\u2217), x\u2212 x\u2217\u3009, \u2200x \u2208 K. But, since x\u2217 solves the VI, it follows that f(x\u2217) is a lower bound on the value of f(x) everywhere, or that x\u2217 minimizes f .\nA rich class of problems called complementarity problems (CPs) also can be reduced to solving a VI. When the feasible set K is a cone, meaning that if x \u2208 K, then \u03b1x \u2208 K,\u03b1 \u2265 0, then the VI becomes a CP.\nDefinition 7.2. Given a cone K \u2282 Rn, and a mapping F : K \u2192 Rn, the complementarity problem CP(F,K) is to find an x \u2208 K such that F (x) \u2208 K\u2217, the dual cone to K, and \u3008x, F (x)\u3009 \u2265 0. 3\n3 Given a cone K, the dual cone K\u2217 is defined as K\u2217 = {y \u2208 Rn|\u3008y, x\u3009 \u2265 0, \u2200x \u2208 K}.\n96 Variational Inequalities: The Emerging Frontier of Machine Learning\nA number of special cases of CPs are important. The nonlinear complementarity problem (NCP) is to find x\u2217 \u2208 Rn+ (the non-negative orthant) such that F (x\u2217) \u2265 0 and \u3008F (x\u2217), x\u2217\u3009 = 0. The solution to an NCP and the corresponding V I(F,Rn+) are the same, showing that NCPs reduce to VIs. In an NCP, whenever the mapping function F is affine, that is F (x) = Mx + b, where M is an n \u00d7 n matrix, then the corresponding NCP is called a linear complementarity problem (LCP) [131]. Recent work on learning sparse models using L1 regularization has exploited the fact that the standard LASSO objective [132] of L1 penalized regression can be reduced to solving an LCP [133]. This reduction to LCP has been used in recent work on sparse value function approximation as well in a method called LCP-TD [134]. A final crucial property of VIs is that they can be formulated as finding fixed points.\nTheorem 7.4. The vector x\u2217 is the solution of VI(F,K) if and only if, for any \u03b3 > 0, x\u2217 is also a fixed point of the map x\u2217 = \u03a0K(x \u2217\u2212\u03b3F (x\u2217)), where \u03a0K is the projector onto convex set K.\nIn terms of the geometric picture of a VI illustrated in Figure 7.2. this property means that the solution of a VI occurs at a vector x\u2217 where the vector field F (x\u2217) induced by F on K is normal to the boundary of K and directed inwards, so that the projection of x\u2217 \u2212 \u03b3F (x\u2217) is the vector x\u2217 itself. This property forms the basis for the projection class of methods that solve for the fixed point."}, {"heading": "7.1.2 Equilibrium Problems in Game Theory", "text": "The VI framework provides a mathematically elegant approach to model equilibrium problems in game theory [119, 120]. A Nash game consists of m players, where player i chooses a strategy xi belonging to a closed convex set Xi \u2282 Rn. After executing the joint action, each player is penalized (or rewarded) by the amount Fi(x1, . . . , xm), where Fi : Rni \u2192 R is a continuously differentiable function. A set of strategies x\u2217 = (x\u22171, . . . , x \u2217 m) \u2208 \u220fM i=1Xi is said to be in equilibrium if no player can reduce the incurred penalty (or increase the incurred reward) by unilaterally deviating from the chosen strategy. If each Fi is convex\n7.2. Algorithms for Variational Inequalities 97\non the set Xi, then the set of strategies x \u2217 is in equilibrium if and only if \u3008(xi \u2212 x\u2217i ),\u2207iFi(x\u2217i )\u3009 \u2265 0. In other words, x\u2217 needs to be a solution of the VI \u3008(x \u2212 x\u2217), f(x\u2217)\u3009 \u2265 0, where f(x) = (\u2207F1(x), . . . ,\u2207Fm(x)). Nash games are closely related to saddle point problems [129, 130, 135]. where we are given a function F : X \u00d7 Y \u2192 R, and the objective is to find a solution (x\u2217, y\u2217) \u2208 X \u00d7 Y such that\nF (x\u2217, y) \u2264 F (x\u2217, y\u2217) \u2264 F (x, y\u2217), \u2200x \u2208 X, \u2200y \u2208 Y\nHere, F is convex in x for each fixed y, and concave in y for each fixed x. Many equilibria problems in economics can be modeled using VIs [12]."}, {"heading": "7.2 Algorithms for Variational Inequalities", "text": "We briefly describe two algorithms for solving variational inequalities below: the projection method and the extragradient method. We conclude with a brief discussion of how these relate to reinforcement learning."}, {"heading": "7.2.1 Projection-Based Algorithms for VIs", "text": "The basic projection-based method (Algorithm 1) for solving VIs is based on Theorem 7.4 introduced earlier.\nAlgorithm 13 The Basic Projection Algorithm for solving VIs. INPUT: Given VI(F,K), and a symmetric positive definite matrix D.\n1: Set k = 0 and xk \u2208 K. 2: repeat 3: Set xk+1 \u2190 \u03a0K,D(xk \u2212D\u22121F (xk)). 4: Set k \u2190 k + 1. 5: until xk = \u03a0K,D(xk \u2212D\u22121F (xk)). 6: Return xk\nHere, \u03a0K,D is the projector onto convex set K with respect to the natural norm induced by D, where \u2016x\u20162D = \u3008x,Dx\u3009. It can be shown that the basic projection algorithm solves any V I(F,K) for which the\n98 Variational Inequalities: The Emerging Frontier of Machine Learning\nmapping F is strongly monotone 4 and Lipschitz.5A simple strategy is to set D = \u03b1I, where \u03b1 > L 2\n2\u00b5 , and L is the Lipschitz smooth-\nness constant, and \u00b5 is the strong monotonicity constant. The basic projection-based algorithm has two critical limitations: it requires that the mapping F be strongly monotone. If, for example, F is the gradient map of a continuously differentiable function, strong monotonicity implies the function must be strongly convex. Second, setting the parameter \u03b1 requires knowing the Lipschitz smoothness L and the strong monotonicity parameter \u00b5. The extragradient method of Korpolevich [125] addresses some of these concerns, and is defined as Algorithm 2 below.\nAlgorithm 14 The Extragradient Algorithm for solving VIs. INPUT: Given VI(F,K), and a scalar \u03b1.\n1: Set k = 0 and xk \u2208 K. 2: repeat 3: Set yk \u2190 \u03a0K(xk \u2212 \u03b1F (xk)). 4: Set xk+1 \u2190 \u03a0K(xk \u2212 \u03b1F (yk)). 5: Set k \u2190 k + 1. 6: until xk = \u03a0K(xk \u2212 \u03b1F (xk)). 7: Return xk\nFigure 7.3 shows a simple example where Algorithm 1 fails to converge, but Algorithm 2 does. If the initial point x0 is chosen to be on the boundary of X, using Algorithm 1, it stays on it and fails to converge to the solution of this VI (which is at the origin). If x0 is chosen to be in the interior of K, Algorithm 1 will move towards the boundary. In contrast, using Algorithm 2, the solution can be found for any starting point. The extragradient algoriithm derives its name from the property that it requires an \u201cextra gradient\u201d step (step 4 in Algorithm 2), unlike the basic projection algorithm given earlier as Algorithm 1. The principal advantage of the extragradient method is that it can be shown to converge under a considerably weaker condition on the mapping F ,\n4 A mapping F is strongly monotone if \u3008F (x)\u2212F (y), x\u2212 y\u3009 \u2265 \u00b5\u2016x\u2212 y\u201622, \u00b5 > 0, \u2200x, y \u2208 K. 5 A mapping F is Lipschitz if \u2016F (x)\u2212 F (y)\u20162 \u2264 L\u2016x\u2212 y\u20162,\u2200x, y \u2208 K.\n7.2. Algorithms for Variational Inequalities 99\nwhich now has to be merely monotonic: \u3008F (x)\u2212 F (y), x\u2212 y\u3009 \u2265 0. The earlier Lipschitz condition is still necessary for convergence.\nThe extragradient algorithm has been the topic of much attention in optimization since it was proposed, e.g., see [137, 138, 139, 140, 141, 142]. Khobotov [138] proved that the extragradient method converges under the weaker requirement of pseudo-monotone mappings, 6 when the learning rate is automatically adjusted based on a local measure of the Lipschitz constant. Iusem [137] proposed a variant whereby the current iterate was projected onto a hyperplane separating the current iterate from the final solution, and subsequently projected from the hyperplane onto the feasible set. Solodov and Svaiter [142] proposed another hyperplane method, whereby the current iterate is projected onto the intersection of the hyperplane and the feasible set. Finally, the extragradient method was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129].\n6 A mapping F is pseudo-monotone if \u3008F (y), x\u2212 y\u3009 \u2265 0\u21d2 \u3008F (x), x\u2212 y\u3009 \u2265 0, \u2200x, y \u2208 K.\n100 Variational Inequalities: The Emerging Frontier of Machine Learning"}, {"heading": "7.2.2 Variational Inequaities and Reinforcement Learning", "text": "Variational inequalities also provide a useful framework for reinforcement learning [32, 1]. In this case, it can be shown that the mapping F for the VI defined by reinforcement learning is affine and represents a (linear) complementarity problem. For this case, a number of special properties can be exploited in designing a faster more scalable class of algorithms. Recall from Theorem 7.4 that each VI(F,K) corresponds to solving a particular fixed point problem x\u2217 = \u03a0K(x \u2217\u2212 \u03b3F (x\u2217)), which led to the projection algorithm (Algorithm 1). Generalizing this, consider solving for the fixed point of a projected equation x\u2217 = \u03a0S\u0302T (x \u2217) [143, 144] for a functional mapping T : Rn \u2192 Rn, where \u03a0S\u0302 is the projector onto a low-dimensional convex subspace S\u0302 w.r.t. some positive definite matrix \u039e, so that\nS\u0302 = {\u03a6r|r \u2208 R\u0302}, R\u0302 = {r|\u03a6r \u2208 S\u0302} \u21d2 \u03a6r\u2217 = \u03a0S\u0302T (\u03a6r\u2217)\nHere. \u03a6 is an n \u00d7 s matrix where s n, and the goal is to make the computation depend on s, not n. Note that x\u2217 = \u03a0S\u0302T (x \u2217) if and only if \u3008(x\u2217 \u2212 T (x\u2217),\u039e(x\u2212 x\u2217)\u3009 \u2265 0. \u2200x \u2208 S\u0302 Following [143], note that this is a variational inequality of the form \u3008F (x\u2217), (x\u2212x\u2217)\u3009 \u2265 0 if we identify F (x) = \u039e(x\u2212T (x)), and in the lowerdimensional space, \u3008F (\u03a6r\u2217),\u03a6(r\u2212 r\u2217)\u3009, \u2200r \u2208 R\u0302. Hence, the projection algorithm takes on the form:\nxk+1 = \u03a0S\u0302(xk \u2212 \u03b3D\u22121\u3008\u03a6, F (\u03a6xk))\u3009\nIt is shown in [143] that if T is a contraction mapping, then F (x) = \u039e(x \u2212 T (x)) is strongly monotone. Hence, the above projection algorithm will converge to the solution x\u2217 of the VI for any given starting point x0 \u2208 S\u0302. Now, the only problem is how to ensure the computation depends only on the size of the projected lower-dimensional space (i.e., s, not n). To achieve this, let us assume that the mapping T (x) = Ax+b is affine, and that the constraint region R\u0302 is polyhedral. In this case, we can use the following identities:\n\u3008\u03a6, F (\u03a6, x)\u3009 = \u03a6T\u039eF (\u03a6x) = Cr \u2212 d, C = \u03a6T\u039e(I \u2212A)\u03a6, d = \u03a6T\u039eb\n7.2. Algorithms for Variational Inequalities 101\nand the projection algorithm for this affine case can be written as:\nxk+1 = \u03a0S\u0302(xk \u2212 \u03b3D\u22121(Cr \u2212 d))\nOne way to solve this iteratively is to compute a progressively more accurate approximation Ck \u2192 C and dk \u2192 d by sampling from the rows and columns of the matrix A and vector b, as follows:\nCk = 1\nk + 1 k\u2211 t=0 \u03c6(it)(\u03c6(it)\u2212 aitjt pitjt \u03c6(jt)) T , dk = 1 k + 1 k\u2211 t=0 \u03c6(it)bit\nwhere the row sampling generates the indices (i0, i1, . . .) and the column sampling generates the transitions ((i0, j0), (i1, j1), . . . , ) in such a way that the relative frequency of row index i matches the diagonal element \u03bei of the positive definite matrix \u039e. Given Ck and dk, the solution can be found by x\u2217 \u2248 C\u22121k dk, or by using an incremental method. Computation now only depends on the dimension s of the lower-dimensional space, not on the original high-dimensional space. Gordon [144] proposes an alternative approach separating the projection of the current iterate on the low-dimensional subspace spanned by \u03a6 from its projection onto the feasible set. Both of these approaches [143, 144] have been only studied with the simple projection method (Algorithm 1), and can be generalized to a more powerful class of VI methods that we are currently developing."}, {"heading": "Acknowledgements", "text": "We like to acknowledge the useful feedback of past and present members of the Autonomous Learning Laboratory at the University of Massachusetts, Amherst. Principal funding for this research was provided by the National Science Foundation under the grant NSF IIS-1216467. Past work by the first author has been funded by NSF grants IIS0534999 and IIS-0803288.\n8"}, {"heading": "Appendix: Technical Proofs", "text": ""}, {"heading": "8.1 Convergence Analysis of Saddle Point Temporal Difference Learning", "text": "Proof of Proposition 1\nWe give a descriptive proof here. We first present the monotone operator corresponding to the bilinear saddle-point problem and then extend it to stochastic approximation case with certain restrictive assumptions, and use the result in [47].\nThe monotone operator \u03a6(x, y) with saddle-point problem\nSadV al = infx\u2208Xsupy\u2208Y \u03c6(x, y) is a point-to-set operator\n\u03a6(x, y) = {\u2202x\u03c6(x, y)} \u00d7 {\u2212\u2202y\u03c6(x, y)}\nWhere \u2202x\u03c6(x, y) is the subgradient of \u03c6(x, \u00b7) over x and \u2202y\u03c6(x, y) is the subgradient of \u03c6(\u00b7, y) over y. For the bilinear problem in Equation (4.1.2), the corresponding \u03a6(x, y) is\n\u03a6(x, y) = (AT y, b\u2212Ax)\nNow we verify that the problem (4.2.1) can be reduced to a standard bilinear minimax problem. To prove this we only need to prove X in\n102\n8.2. Convergence Analysis of True Gradient Temporal Difference Learning 103\nour RL problem is indeed a closed compact convex set. This is easy to verify as we can simply define X = {x|\u2016x\u20162 \u2264 R} where R is large enough. In fact, the sparse regularization h(x) = \u03c1||x||1 helps xt stay within this l2 ball. Now we extend to the stochastic approximation case wherein the objective function f(x) is given by the stochastic oracle, and in our case, it is Ax\u2212 b, where A, b are defined in Equation (4.2.1), with Assumption 3 and further assuming that the noise \u03b5t for t-th sample is i.i.d noise, then with the result in [109], we can prove that the RO-TD algorithm converges to the global minimizer of\nx\u2217 = arg min x\u2208X \u2016Ax\u2212 b\u2016m + \u03c1\u2016x\u20161\nThen we prove the error level of approximate saddle-point x\u0304t, y\u0304t defined in (4.3.1) is \u03b1tL 2. With the subgradient boundedness assumption and using the result in Proposition 1 in [78], this can be proved."}, {"heading": "8.2 Convergence Analysis of True Gradient Temporal Difference Learning", "text": "We first present the assumptions for the MDP and basis functions, which are similar to [26, 14].\nAssumption 1 (MDP): The underlying Markov Reward Process (MRP) M = (S, P,R, \u03b3) is finite and mixing, with stationary distribution \u03c0. The training sequence (st, at, s \u2032 t) is an i.i.d sequence.\nAssumption 2 (Basis Function): The inverses E[\u03c6t\u03c6Tt ]\u22121 and [\u03c6t(\u03c6t \u2212 \u03b3\u03c6t \u2032T )]\u22121 exist. This implies that \u03a6 is a full column rank matrix. Also, assume the features (\u03c6t, \u03c6 \u2032 t) have uniformly bounded second moments, and \u2016\u03c6t\u2016\u221e < +\u221e, \u2016\u03c6\u2032t\u2016\u221e < +\u221e. Next we present the assumptions for the stochastic saddle point problem formulation, which are similar to [108, 109].\nAssumption 3 (Compactness): Assume for the primal-dual loss\nfunction,\nmin \u03b8\u2208X max y\u2208Y\n(L(\u03b8, y) = \u3008K(\u03b8), y\u3009 \u2212 F \u2217(y) + h(\u03b8)) ,\nthe sets X,Y are closed compact sets.\nAssumption 4 (F \u2217(\u00b7)): We assume that F \u2217(\u00b7) is a smooth convex function with Lipschitz continuous gradient, i.e., \u2203LF \u2217 such that \u2200x, y \u2208\n104 Appendix: Technical Proofs\nX\nF \u2217(y)\u2212 F \u2217(x)\u2212 \u3008\u2207F \u2217(x), y \u2212 x\u3009 \u2264 LF \u2217 2 ||y \u2212 x||2\nAssumption 5 (K(\u03b8)): K(\u03b8) is a linear mapping which can be extended to Lipschitz continuous vector-valued mapping defined on a closed convex cone CK . Assuming K(\u03b8) to be CK-convex, i.e., \u2200\u03b8, \u03b8\u2032 \u2208 X,\u03bb \u2208 [0, 1],\nK(\u03bb\u03b8 + (1\u2212 \u03bb)\u03b8\u2032)\u2264CK\u03bbK(\u03b8) + (1\u2212 \u03bb)K(\u03b8\u2032),\nwhere a\u2264CK b means that b\u2212 a \u2208 CK . Assumption 6 (Stochastic Gradient): In the stochastic saddle point problem, we assume that there exists a stochastic oracle SO that is able to provide unbiased estimation with bounded variance such that\nE[F\u2217(yt)] = \u2207F \u2217(yt) E[||F\u2217(yt)\u2212\u2207F \u2217(yt)||2] \u2264 \u03c32F \u2217 E[K\u03b8(\u03b8t)] = K(\u03b8t) E[||K\u03b8(\u03b8t)\u2212K(\u03b8t)||2] \u2264 \u03c32K,\u03b8\nE[Ky(\u03b8t)T yt] = \u2207K(\u03b8t)T yt E[||Ky(\u03b8t)T yt \u2212\u2207K(\u03b8t)T yt||2] \u2264 \u03c32K,y\nwhere \u03c3F \u2217 , \u03c3K,\u03b8 and \u03c3K,y are non-negative constants. We further\ndefine\n\u03c3 = \u221a \u03c32F \u2217 + \u03c3 2 K,\u03b8 + \u03c3K,y"}, {"heading": "8.2.1 Convergence Rate", "text": "Here we discuss the convergence rate of the proposed algorithms. First let us review the nonlinear primal form\nmin \u03b8\u2208X (\u03a8(\u03b8) = F (K(\u03b8)) + h(\u03b8))\nThe corresponding primal-dual formulation [57, 28, 58] of Equation (8.2.1) is Equation (2.6.3). Thus we have the general update rule as\nyt+1 = yt + \u03b1tK\u03b8(\u03b8t)\u2212 \u03b1tF\u2217(yt), \u03b8t+1 = prox\u03b1th(\u03b8t \u2212 \u03b1tKy(\u03b8t)T yt)\n8.2. Convergence Analysis of True Gradient Temporal Difference Learning 105\nLemma 1 (Optimal Convergence Rate): The optimal conver-\ngence rate of 2.6.3 is O(LF\u2217 N2 + LKN + \u03c3\u221a N ).\nProof: Equation (8.2.1) can be easily converted to the following\nprimal-dual formulation\nmin y\u2208Y max \u03b8\u2208X\n(\u3008\u2212K(\u03b8), y\u3009+ F \u2217(y)\u2212 h(\u03b8))\nUsing the bounds proved in [145, 109, 108], the optimal convergence rate of stochastic saddle-point problem is O(LF\u2217 N2 + LKN + \u03c3\u221a N ).\nThe GTD/GTD2 algorithms can be considered as using Polyak\u2019s algorithm without the primal average step. Hence, by adding the primal average step, GTD/GTD2 algorithms will become standard Polyak\u2019s algorithms [146], and thus the convergence rates are O(LF\u2217+LK+\u03c3\u221a N ) according to [49]. So we have the following propositions.\nProposition 1 The convergence rates of GTD/GTD2 algorithms\nwith primal average are O(LF\u2217+LK+\u03c3\u221a N ), where LK = ||\u03a6T\u039e(\u03a6 \u2212 \u03b3\u03a6 \u2032T )||2, for GTD, LF \u2217 = 1 and for GTD2, LF \u2217 = ||M ||2. Now we consider the acceleration using the SMP algorithm, which incorporates the extragradient term. According to [109] which extends the SMP algorithm to solving saddle-point problems and variational inequality problems, the convergence rate is accelerated to O(LF\u2217+LKN + \u03c3\u221a N ). Consequently,\nProposition 2 The convergence rate of the GTD2-MP algorithm\nis O(LF\u2217+LKN + \u03c3\u221a N )."}, {"heading": "8.2.2 Value Approximation Error Bound", "text": "One key question is how to give the error bound of ||V \u2212V\u03b8|| given that of ||K(\u03b8)||. Here we use the result in [111], which is similar to the one in [147].\nLemma 2 [111]: For any V\u03b8 = \u03a6\u03b8, the following component-wise\nequality holds\nV \u2212 V\u03b8 = (I \u2212 \u03b3\u03a0\u039eP )\u22121 (( V \u2212\u03a0\u039eV ) + \u03a6(\u03a6T\u039e\u03a6)\u22121K(\u03b8) ) Proof :\n106 Appendix: Technical Proofs\nUse the equality V = TV and V\u03b8 = \u03a0 \u039eV\u03b8, where the first equality is the Bellman equation, and the second is that V\u03b8 lies within the spanning space of \u03a6.\nwe have\nV \u2212\u03a0\u039eV = V \u2212\u03a0\u039eTV + (V\u03b8 \u2212\u03a0\u039eTV\u03b8)\u2212 (V\u03b8 \u2212\u03a0\u039eTV\u03b8) = (I \u2212 \u03b3\u03a0\u039eP )(V \u2212 V\u03b8) + \u03a0\u039e(V\u03b8 \u2212 TV\u03b8)\nAfter rearranging the equation, we have Equation (8.2.2) and find that\n\u03a0\u039e(V\u03b8 \u2212 TV\u03b8) = \u2212\u03a6(\u03a6T\u039e\u03a6)\u22121K(\u03b8) Proposition 3: For GTD/GTD2, the prediction error of ||V \u2212 V\u03b8||\nis bounded by ||V \u2212 V\u03b8||\u221e \u2264 L\u039e\u03c6 1\u2212\u03b3 \u00b7 O\n( LF\u2217+LK+\u03c3\u221a\nN\n) ; For GTD2-MP,\nit is bounded by ||V \u2212 V\u03b8||\u221e \u2264 L\u039e\u03c6 1\u2212\u03b3 \u00b7 O\n( LF\u2217+LK\nN + \u03c3\u221a N ) , where L\u039e\u03c6 =\nmaxs||(\u03a6T\u039e\u03a6)\u22121\u03c6(s)||1. Proof:\nFrom Lemma 2, we have ||V \u2212 V\u03b8||\u221e \u2264 ||(I \u2212 \u03b3\u03a0\u039eP )\u22121||\u221e \u00b7 ( ||V \u2212\u03a0\u039eV ||\u221e + L\u039e\u03c6 ||K(\u03b8)||\u221e ) Using the results in Proposition 1 and Proposition 2, we have for GTD and GTD2,\n||V\u2212V\u03b8||\u221e \u2264 ||(I \u2212 \u03b3\u03a0\u039eP )\u22121||\u221e\u00b7 ( ||V \u2212\u03a0\u039eV ||\u221e + L\u039e\u03c6 \u00b7O ( LF \u2217 + LK + \u03c3\u221a\nN(1\u2212 \u03b3) )) For GTD2-MP,\n||V\u2212V\u03b8||\u221e \u2264 ||(I \u2212 \u03b3\u03a0\u039eP )\u22121||\u221e\u00b7 ( ||V \u2212\u03a0\u039eV ||\u221e + L\u039e\u03c6 \u00b7O(\nLF \u2217 + LK N + \u03c3\u221a N ) ) If we further assume a rich expressive hypothesis space H, i.e., \u03a0\u039eP = P,\u03a0\u039eR = R, ||V \u2212 \u03a0\u039eV ||\u221e = 0, ||(I \u2212 \u03b3\u03a0\u039eP )\u22121||\u221e = 11\u2212\u03b3 , then for GTD and GTD2, we have\n||V \u2212 V\u03b8||\u221e \u2264 L\u039e\u03c6 1\u2212 \u03b3 \u00b7O ( LF \u2217 + LK + \u03c3\u221a\nN ) For GTD2-MP, we have\n||V \u2212 V\u03b8||\u221e \u2264 L\u039e\u03c6 1\u2212 \u03b3 \u00b7O ( LF \u2217 + LK N + \u03c3\u221a N )"}], "references": [{"title": "Reinforcement Learning: An Introduction", "author": ["R. Sutton", "A.G. Barto"], "venue": "MIT Press,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1998}, {"title": "Fast gradient-descent methods for temporal-difference learning with linear function approximation", "author": ["Richard S. Sutton", "Hamid Reza Maei", "Doina Precup", "Shalabh Bhatnagar", "David Silver", "Csaba Szepesvri", "Eric Wiewiora"], "venue": "Proceedings of the 26th International Conference on Machine Learning,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Convex Optimization", "author": ["S. Boyd", "L. Vandenberghe"], "venue": "Cambridge University Press,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2004}, {"title": "The relaxation method of finding the common point of convex sets and its application to the solution of problems in convex programming", "author": ["L. Bregman"], "venue": "USSR Computational Mathematics and Mathematical Physics, 7:200\u2013217,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1967}, {"title": "Problem Complexity and Method Efficiency in Optimization", "author": ["A. Nemirovksi", "D. Yudin"], "venue": "John Wiley Press,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1983}, {"title": "Mirror descent and nonlinear projected subgradient methods for convex optimization", "author": ["A. Beck", "M. Teboulle"], "venue": "Operations Research Letters, Jan", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "Prox-method with rate of convergence O(1/t) for variational inequalities with Lipschitz continuous monotone operators and smooth convex-concave saddle point problems", "author": ["A. Nemirovski"], "venue": "SIAM Journal on Optimization, 15(1):229\u2013251,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2005}, {"title": "Korpelevich. The extragradient method for finding saddle points and other problems", "author": ["M. G"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1976}, {"title": "On some nonlinear elliptic differential functional equations", "author": ["P. Hartman", "G. Stampacchia"], "venue": "Acta Mathematica, 115:271\u2013310,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1966}, {"title": "Traffic equilibria and variational inequalities", "author": ["S. Dafermos"], "venue": "Transportation Science, 14:42\u201354,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1980}, {"title": "Network Economics: A Variational Inequality Approach", "author": ["A. Nagurney"], "venue": "Kluwer Academic Press,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1999}, {"title": "Finite-Dimensional Variational Inequalities and Complimentarity Problems", "author": ["F. Facchinei", "Pang J"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2003}, {"title": "Regularized off-policy TDlearning", "author": ["B. Liu", "S. Mahadevan", "J. Liu"], "venue": "Advances in Neural Information Processing Systems 25, pages 845\u2013853,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "The ordered subsets mirror descent optimization method with applications to tomography", "author": ["A. Ben-Tal", "T. Margalit", "A. Nemirovski"], "venue": "SIAM Journal of Optimization, Jan", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2001}, {"title": "The robustness of the p-norm algorithms", "author": ["Claudio Gentile"], "venue": "ISSN 0885-6125. doi: 10. 1023/A:1026319107706. URL http://dl.acm.org/citation. cfm?id=948445.948447", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2003}, {"title": "Proximal splitting methods in signal processing", "author": ["P. Combetes", "J.C. Pesquel"], "venue": "Fixed-Point Algorithms for Inverse Problems in Science and Engineering. Springer,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2011}, {"title": "On the numerical solution of heat conduction problems in two and three space variables", "author": ["J. Douglas", "H. Rachford"], "venue": "Transactions of the American Mathematical Society, 82:421\u2013439,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1956}, {"title": "Convergence Analysis of True Gradient Temporal Difference Learning 109 tributed optimization and statistical learning via the alternating direction method of multipliers", "author": ["S. Boyd", "N. Parikh", "E. Chu", "B. Peleato", "J. Eckstein. Dis"], "venue": "Foundations and Trends in Machine Learning,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2010}, {"title": "Whole-Body Strategies for Mobility and Manipulation", "author": ["P. Deegan"], "venue": "PhD thesis, University of Massachusetts Amherst,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2010}, {"title": "Dexterous mobility with the uBot-5 mobile manipulator", "author": ["S.R. Kuindersma", "E. Hannigan", "D. Ruiken", "R.A. Grupen"], "venue": "Proceedings of the 14th International Conference on Advanced Robotics,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2009}, {"title": "Why natural gradient", "author": ["S. Amari", "S. Douglas"], "venue": "In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech, and Signal Processing,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1998}, {"title": "Linear least-squares algorithms for temporal difference learning", "author": ["S. Bradtke", "A. Barto"], "venue": "Machine Learning, 22:33\u201357,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1996}, {"title": "Least-squares policy evaluation algorithms with linear function approximation", "author": ["A. Nedic", "D. Bertsekas"], "venue": "Discrete Event Systems Journal, 13,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2003}, {"title": "Least-squares policy iteration", "author": ["M. Lagoudakis", "R. Parr"], "venue": "Journal of Machine Learning Research, 4:1107\u20131149,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2003}, {"title": "Fast gradient-descent methods for temporal-difference learning with linear function approximation", "author": ["R.S. Sutton", "H.R. Maei", "D. Precup", "S. Bhatnagar", "D. Silver", "C. Szepesv\u00e1ri", "E. Wiewiora"], "venue": "International Conference on Machine Learning, pages 993\u20131000,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2009}, {"title": "Algorithms for reinforcement learning", "author": ["C. Szepesv\u00e1ri"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, 4(1): 1\u2013103,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2010}, {"title": "Proximal splitting methods in signal processing", "author": ["P. L Combettes", "J. C Pesquet"], "venue": "Fixed-point algorithms for inverse problems in science and engineering, pages 185\u2013212.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2011}, {"title": "Markov Decision Processes", "author": ["M.L. Puterman"], "venue": "Wiley Interscience, New York, USA,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1994}, {"title": "Learning to predict by the methods of temporal differences", "author": ["R.S. Sutton"], "venue": "Machine Learning, 3:9\u201344,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1988}, {"title": "Learning from Delayed Rewards", "author": ["C. Watkins"], "venue": "PhD thesis, King\u2019s  110 Appendix: Technical Proofs College, Cambridge, England,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1989}, {"title": "Neuro-Dynamic Programming", "author": ["D. Bertsekas", "J. Tsitsiklis"], "venue": "Athena Scientific, Belmont, Massachusetts,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1996}, {"title": "Learning representation and control in Markov Decision Processes: new frontiers", "author": ["S. Mahadevan"], "venue": "Foundations and Trends in Machine Learning, 1(4):403\u2013565,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2009}, {"title": "An optimal method for stochastic composite optimization", "author": ["G. Lan"], "venue": "Mathematical Programming, 133(1-2):365\u2013397,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2012}, {"title": "Mirror descent and nonlinear projected subgradient methods for convex optimization", "author": ["A. Beck", "M. Teboulle"], "venue": "Operations Research Letters, 31:167\u2013175,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2003}, {"title": "The robustness of the p-norm algorithms", "author": ["C. Gentile"], "venue": "Machine Learning, 53(3):265\u2013299,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2003}, {"title": "Stochastic methods for l1 regularized loss minimization", "author": ["S. Shalev-Shwartz", "A. Tewari"], "venue": "Journal of Machine Learning Research, pages 1865\u20131892, June", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2011}, {"title": "Dual averaging methods for regularized stochastic learning and online optimization", "author": ["L. Xiao"], "venue": "The Journal of Machine Learning Research, 11:2543\u20132596,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2010}, {"title": "Composite objective mirror descent", "author": ["J. Duchi", "S. Shalev-Shwartz", "Y. Singer", "A. Tewari"], "venue": "COLT, pages 14\u201326,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2010}, {"title": "A voted regularized dual averaging method for large-scale discriminative training in natural language processing", "author": ["J. Gao", "T. Xu", "L. Xiao", "X. He"], "venue": "Technical report, Microsoft Research,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2013}, {"title": "Follow-the-regularized-leader and mirror descent: Equivalence theorems and l1 regularization", "author": ["H.B. McMahan"], "venue": "International Conference on Artificial Intelligence and Statistics, pages 525\u2013533,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2011}, {"title": "Sparse online learning via truncated gradient", "author": ["J. Langford", "L. Li", "T. Zhang"], "venue": "The Journal of Machine Learning Research, 10:777\u2013801,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2009}, {"title": "Stochastic methods for l1 regularized loss minimization", "author": ["S. Shalev-Shwartz", "A. Tewari"], "venue": "Proceedings of the 26th Annual International Conference on Machine Learning, pages 929\u2013936,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2009}, {"title": "Manifold identification in dual averaging 8.2. Convergence Analysis of True Gradient Temporal Difference Learning 111 for regularized stochastic online learning", "author": ["S. Lee", "S.J. Wright"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2012}, {"title": "On accelerated proximal gradient methods for convexconcave optimization", "author": ["P. Tseng"], "venue": "submitted to SIAM Journal on Optimization,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2008}, {"title": "Convex Analysis", "author": ["R Rockafellar"], "venue": "Princeton University Press,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 1970}, {"title": "Optimization for Machine Learning, chapter First-Order Methods for Nonsmooth Convex Large- Scale Optimization", "author": ["A. Juditsky", "A. Nemirovski"], "venue": "MIT Press,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2011}, {"title": "Non-Euclidean restricted memory level method for large-scale convex optimization", "author": ["A. Ben-Tal", "A. Nemirovski"], "venue": "Mathematical Programming, 102(3):407\u2013456,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2005}, {"title": "Robust stochastic approximation approach to stochastic programming", "author": ["A. Nemirovski", "A. Juditsky", "G. Lan", "A. Shapiro"], "venue": "SIAM Journal on Optimization, 19:1574\u20131609,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2009}, {"title": "Monotone operators and the proximal point algorithm", "author": ["R. Rockafellar"], "venue": "SIAM Journal of Optimization, 14(5):877\u2013898,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 1976}, {"title": "Functions convexes duales et points proximaux dans un espace hilbertien", "author": ["J. Moreau"], "venue": "Reports of the Paris Academy of Sciences, Series A, 255:2897\u20132899,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 1962}, {"title": "Monotone operators and the proximal point algorithm", "author": ["R. T Rockafellar"], "venue": "SIAM Journal on Control and Optimization, 14(5): 877\u2013898,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 1976}, {"title": "Proximal algorithms", "author": ["N. Parikh", "S. Boyd"], "venue": "Foundations and Trends in optimization, 1(3):123\u2013231,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2013}, {"title": "Efficient learning using forward-backward splitting", "author": ["J. Duchi", "Y. Singer"], "venue": "Proceedings of Advances in Neural Information Processing Systems", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2009}, {"title": "Sparse Reinforcement Learning via Convex Optimization", "author": ["Z. Qin", "W. Li"], "venue": "Proceedings of the 31st International Conference on Machine Learning,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2014}, {"title": "Convex analysis and mono-  112 Appendix: Technical Proofs tone operator theory in Hilbert spaces", "author": ["H. H Bauschke", "P. L Combettes"], "venue": "Springer,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2011}, {"title": "A first-order primal-dual algorithm for convex problems with applications to imaging", "author": ["A. Chambolle", "T. Pock"], "venue": "Journal of Mathematical Imaging and Vision, 40(1):120\u2013145,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2011}, {"title": "Natural gradient works efficiently in learning", "author": ["S. Amari"], "venue": "Neural Computation, 10:251\u2013276,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 1998}, {"title": "Finite- Sample Analysis of Lasso-TD", "author": ["M. Ghavamzadeh", "A. Lazaric", "R. Munos", "M. Hoffman"], "venue": "Proceedings of the 28th International Conference on Machine Learning,", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2011}, {"title": "Representation policy iteration", "author": ["S. Mahadevan"], "venue": "Proceedings of the 21th Annual Conference on Uncertainty in Artificial Intelligence (UAI-05), pages 372\u201337. AUAI Press,", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2005}, {"title": "Regularization and feature selection in least-squares temporal difference learning", "author": ["J.Z. Kolter", "A.Y. Ng"], "venue": "Proceedings of the 26th annual international conference on machine learning, pages 521\u2013528,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2009}, {"title": "Linear complementarity for regularized policy evaluation and improvement", "author": ["J. Johns", "C. Painter-Wakefield", "R. Parr"], "venue": "Proceedings of the International Conference on Neural Information Processing Systems,", "citeRegEx": "63", "shortCiteRegEx": null, "year": 2010}, {"title": "Exponentiated gradient versus gradient descent for linear predictors", "author": ["J. Kivinen", "M.K. Warmuth"], "venue": "Information and Computation, 132,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 1995}, {"title": "Learning quickly when irrelevant attributes abound: A new linear-threshold algorithm", "author": ["N. Littlestone"], "venue": "Machine Learning, pages 285\u2013318,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 1988}, {"title": "Exponentiated gradient methods for reinforcement learning", "author": ["D. Precup", "R.S. Sutton"], "venue": "ICML, pages 272\u2013277,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 1997}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["J. Duchi", "E. Hazan", "Y. Singer"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2011}, {"title": "Regularization and feature selection in least-squares temporal difference learning", "author": ["J. Zico Kolter", "Andrew Y. Ng"], "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,", "citeRegEx": "68", "shortCiteRegEx": "68", "year": 2009}, {"title": "Proto-Value Functions: A Laplacian framework for learning representation and control in Markov Decision Processes", "author": ["S. Mahadevan", "M. Maggioni"], "venue": "Journal of Machine Learning Research, 8: 2169\u20132231,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2007}, {"title": "Value function approximation in reinforcement learning using the fourier basis", "author": ["G. Konidaris", "S. Osentoski", "PS Thomas"], "venue": "Computer Science Department Faculty Publication Series, page 101,", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2008}, {"title": "Online learning control by association and reinforcement", "author": ["J. Si", "Y. Wang"], "venue": "IEEE Transactions on Neural Networks, 12:264\u2013 276,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2001}, {"title": "Robust stochastic approximation approach to stochastic programming", "author": ["A Nemirovski", "A Juditsky", "G Lan", "A. Shapiro"], "venue": "SIAM Journal on Optimization, 14(4):1574\u20131609,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 2009}, {"title": "On the worst-case analysis of temporal-difference learning algorithms", "author": ["Robert Schapire", "Manfred K. Warmuth"], "venue": "In Machine Learning,", "citeRegEx": "73", "shortCiteRegEx": "73", "year": 1994}, {"title": "Stochastic Approximation: A Dynamical Systems Viewpoint", "author": ["V. Borkar"], "venue": "Cambridge University Press,", "citeRegEx": "74", "shortCiteRegEx": null, "year": 2008}, {"title": "Gradient temporal-difference learning algorithms", "author": ["H.R. Maei"], "venue": "PhD thesis, University of Alberta,", "citeRegEx": "75", "shortCiteRegEx": null, "year": 2011}, {"title": "Linear off-policy actorcritic", "author": ["T. Degris", "M. White", "R.S. Sutton"], "venue": "International Conference on Machine Learning,", "citeRegEx": "76", "shortCiteRegEx": null, "year": 2012}, {"title": "Gradient methods for minimizing composite objective function", "author": ["Y. Nesterov"], "venue": "www.optimization-online.org,", "citeRegEx": "77", "shortCiteRegEx": null, "year": 2007}, {"title": "Subgradient methods for saddle-point problems", "author": ["A. Nedic", "A. Ozdaglar"], "venue": "Journal of optimization theory and applications, 142 (1):205\u2013228,", "citeRegEx": "78", "shortCiteRegEx": null, "year": 2009}, {"title": "GQ (\u03bb): A general gradient algorithm for temporal-difference prediction learning with eligibility traces", "author": ["H.R. Maei", "R.S. Sutton"], "venue": "Proceedings of the Third Conference on Artificial General Intelligence, pages 91\u201396,", "citeRegEx": "79", "shortCiteRegEx": null, "year": 2010}, {"title": "Value function approximation in reinforcement learning using the fourier basis", "author": ["G. Konidaris", "S. Osentoski", "P.S. Thomas"], "venue": "Proceedings of the Twenty-Fifth Conference on Artificial In-  114 Appendix: Technical Proofs telligence,", "citeRegEx": "80", "shortCiteRegEx": null, "year": 2011}, {"title": "PID Controllers: Theory, Design, and Tuning", "author": ["K.J. \u00c5str\u00f6m", "T. H\u00e4gglund"], "venue": "ISA: The Instrumentation, Systems, and Automation Society,", "citeRegEx": "81", "shortCiteRegEx": null, "year": 1995}, {"title": "Fast calculation of stabilizing PID controllers", "author": ["M.T. S\u00f6ylemez", "N. Munro", "H. Baki"], "venue": "Automatica, 39(1):121\u2013126,", "citeRegEx": "82", "shortCiteRegEx": null, "year": 2003}, {"title": "A real-time 3-D musculoskeletal model for dynamic simulation of arm movements", "author": ["E.K. Chadwick", "D. Blana", "A.J. van den Bogert", "R.F. Kirsch"], "venue": "In IEEE Transactions on Biomedical Engineering,", "citeRegEx": "84", "shortCiteRegEx": "84", "year": 2009}, {"title": "A proportional derivative FES controller for planar arm movement", "author": ["K. Jagodnik", "A. van den Bogert"], "venue": "In 12th Annual Conference International FES Society,", "citeRegEx": "85", "shortCiteRegEx": "85", "year": 2007}, {"title": "Application of the actor-critic architecture to functional electrical stimulation control of a human arm", "author": ["P.S. Thomas", "M.S. Branicky", "A.J. van den Bogert", "K.M. Jagodnik"], "venue": "In Proceedings of the Twenty-First Innovative Applications of Artificial Intelligence,", "citeRegEx": "86", "shortCiteRegEx": "86", "year": 2009}, {"title": "Lyapunov design for safe reinforcement learning", "author": ["T.J. Perkins", "A.G. Barto"], "venue": "Journal of Machine Learning Research, 3: 803\u2013832,", "citeRegEx": "87", "shortCiteRegEx": null, "year": 2003}, {"title": "Biped dynamic walking using reinforcement learning", "author": ["H. Bendrahim", "J.A. Franklin"], "venue": "Robotics and Autonomous Systems, 22: 283\u2013302,", "citeRegEx": "88", "shortCiteRegEx": null, "year": 1997}, {"title": "Control of markov chains with safety bounds", "author": ["A. Arapostathis", "R. Kumar", "S.P. Hsu"], "venue": "IEEE Transactions on Automation Science and Engineering, volume 2, pages 333\u2013343, October", "citeRegEx": "89", "shortCiteRegEx": null, "year": 2005}, {"title": "Control design for Markov chains under safety constraints: A convex approach", "author": ["E. Arvelo", "N.C. Martins"], "venue": "CoRR, abs/1209.2883,", "citeRegEx": "90", "shortCiteRegEx": null, "year": 2012}, {"title": "Risk-sensitive reinforcement learning applied to control under constraints", "author": ["P. Geibel", "F. Wysotzki"], "venue": "Journal of Artificial Intelligence Research 24, pages 81\u2013108,", "citeRegEx": "91", "shortCiteRegEx": null, "year": 2005}, {"title": "Variational bayesian 8.2. Convergence Analysis of True Gradient Temporal Difference Learning 115 optimization for runtime risk-sensitive control", "author": ["S. Kuindersma", "R. Grupen", "A.G. Barto"], "venue": "In Robotics: Science and Systems VIII,", "citeRegEx": "92", "shortCiteRegEx": "92", "year": 2012}, {"title": "Natural actor-critic algorithms", "author": ["S. Bhatnagar", "R.S. Sutton", "M. Ghavamzadeh", "M. Lee"], "venue": "Automatica, 45(11):2471\u20132482,", "citeRegEx": "93", "shortCiteRegEx": null, "year": 2009}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["J. Duchi", "E. Hazan", "Y. Singer"], "venue": "Technical Report UCB/EECS-2010-24, Electrical Engineering and Computer Sciences, University of California at Berkeley, March", "citeRegEx": "94", "shortCiteRegEx": null, "year": 2010}, {"title": "Convex Analysis", "author": ["R. Tyrell Rockafellar"], "venue": "Princeton University Press, Princeton, New Jersey,", "citeRegEx": "95", "shortCiteRegEx": null, "year": 1970}, {"title": "Numerical Optimization", "author": ["J. Nocedal", "S. Wright"], "venue": "Springer, second edition,", "citeRegEx": "96", "shortCiteRegEx": null, "year": 2006}, {"title": "A natural policy gradient", "author": ["S. Kakade"], "venue": "Advances in Neural Information Processing Systems, volume 14, pages 1531\u20131538,", "citeRegEx": "97", "shortCiteRegEx": null, "year": 2002}, {"title": "Policy gradient methods for reinforcement learning with function approximation", "author": ["R.S. Sutton", "D. McAllester", "S. Singh", "Y. Mansour"], "venue": "Advances in Neural Information Processing Systems 12, pages 1057\u20131063,", "citeRegEx": "98", "shortCiteRegEx": null, "year": 2000}, {"title": "Utilizing the natural gradient in temporal difference reinforcement learning with eligibility traces", "author": ["T. Morimura", "E. Uchibe", "K. Doya"], "venue": "International Symposium on Information Geometry and its Application,", "citeRegEx": "99", "shortCiteRegEx": null, "year": 2005}, {"title": "Natural actor-critic", "author": ["J. Peters", "S. Schaal"], "venue": "Neurocomputing, 71:1180\u20131190,", "citeRegEx": "100", "shortCiteRegEx": null, "year": 2008}, {"title": "Motor primitive discovery", "author": ["P.S. Thomas", "A.G. Barto"], "venue": "Procedings of the IEEE Conference on Development and Learning and EPigenetic Robotics,", "citeRegEx": "101", "shortCiteRegEx": null, "year": 2012}, {"title": "Model-free reinforcement learning with continuous action in practice", "author": ["T. Degris", "P.M. Pilarski", "R.S. Sutton"], "venue": "Proceedings of the 2012 American Control Conference,", "citeRegEx": "102", "shortCiteRegEx": null, "year": 2012}, {"title": "Bias in natural actor-critic algorithms", "author": ["P.S. Thomas"], "venue": "Technical Report UM-CS-2012-018, Department of Computer Science, University of Massachusetts at Amherst,", "citeRegEx": "103", "shortCiteRegEx": null, "year": 2012}, {"title": "Combined feedforward and feedback control of a redundant, nonlinear, dynamic musculoskeletal system", "author": ["D. Blana", "R.F. Kirsch", "E.K. Chadwick"], "venue": "Medical and Biological Engineering and 116 Appendix: Technical Proofs Computing, 47:533\u2013542,", "citeRegEx": "104", "shortCiteRegEx": null, "year": 2009}, {"title": "The Fixed Points of Off-Policy TD", "author": ["J. Zico Kolter"], "venue": "Advances in Neural Information Processing Systems 24, pages 2169\u20132177,", "citeRegEx": "105", "shortCiteRegEx": null, "year": 2011}, {"title": "A convergent o(n) algorithm for off-policy temporal-difference learning with linear function approximation", "author": ["R.S. Sutton", "C. Szepesvari", "H.R. Maei"], "venue": "Neural Information Processing Systems, pages 1609\u20131616,", "citeRegEx": "106", "shortCiteRegEx": null, "year": 2008}, {"title": "Residual algorithms: Reinforcement learning with function approximation", "author": ["L.C. Baird"], "venue": "International Conference on Machine Learning, pages 30\u201337,", "citeRegEx": "107", "shortCiteRegEx": null, "year": 1995}, {"title": "Optimal primal-dual methods for a class of saddle point problems", "author": ["Y. Chen", "G. Lan", "Y. Ouyang"], "venue": "arXiv preprint arXiv:1309.5548,", "citeRegEx": "108", "shortCiteRegEx": null, "year": 2013}, {"title": "Solving variational inequalities with stochastic mirror-prox algorithm", "author": ["A. Juditsky", "A.S. Nemirovskii", "C. Tauvel"], "venue": "Arxiv preprint arXiv:0809.0815,", "citeRegEx": "109", "shortCiteRegEx": null, "year": 2008}, {"title": "A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science", "author": ["E. Esser", "X. Zhang", "T. F Chan"], "venue": "SIAM Journal on Imaging Sciences, 3(4): 1015\u20131046,", "citeRegEx": "110", "shortCiteRegEx": null, "year": 2010}, {"title": "A Dantzig Selector Approach to Temporal Difference Learning", "author": ["M. Geist", "B. Scherrer", "A. Lazaric", "M. Ghavamzadeh"], "venue": "International Conference on Machine Learning,", "citeRegEx": "111", "shortCiteRegEx": null, "year": 2012}, {"title": "Policy evaluation with temporal differences: A survey and comparison", "author": ["C. Dann", "G. Neumann", "J. Peters"], "venue": "Journal of Machine Learning Research, 15:809\u2013883,", "citeRegEx": "112", "shortCiteRegEx": null, "year": 2014}, {"title": "LSTD with Random Projections", "author": ["M. Ghavamzadeh", "A. Lazaric", "O.A. Maillard", "R. Munos"], "venue": "Proceedings of the International Conference on Neural Information Processing Systems,", "citeRegEx": "113", "shortCiteRegEx": null, "year": 2010}, {"title": "Practical kernel-based reinforcement learning", "author": ["A. MS Barreto", "D. Precup", "J. Pineau"], "venue": null, "citeRegEx": "114", "shortCiteRegEx": "114", "year": 2013}, {"title": "Kernelized value function approximation for reinforcement learning", "author": ["G. Taylor", "R. Parr"], "venue": "Proceedings of the 26th Annual International Conference on Machine Learning, pages 1017\u20131024. 8.2. Convergence Analysis of True Gradient Temporal Difference Learning 117 ACM,", "citeRegEx": "115", "shortCiteRegEx": null, "year": 2009}, {"title": "Migration equilibrium and variational inequalities", "author": ["A. Nagurney"], "venue": "Economics Letters, 31:109\u2013112,", "citeRegEx": "116", "shortCiteRegEx": null, "year": 1989}, {"title": "Evolutionary Dynamics: Exploring the Equations of Life", "author": ["M. Novak"], "venue": "Harvard Belknap Press,", "citeRegEx": "117", "shortCiteRegEx": null, "year": 2006}, {"title": "Networks, Crowds, and Markets: Reasoning About a Highly Connected World", "author": ["D. Easley", "J. Kleinberg"], "venue": "Cambridge University Press,", "citeRegEx": "118", "shortCiteRegEx": null, "year": 2010}, {"title": "The Theory of Learning in Games", "author": ["D. Fudenberg", "D. Levine"], "venue": "MIT Press,", "citeRegEx": "119", "shortCiteRegEx": null, "year": 1999}, {"title": "Algorithmic Game Theory", "author": ["N. Nisan", "T. Roughgarden", "E. Tardos", "V. Vazirani"], "venue": "Cambridge University Press,", "citeRegEx": "120", "shortCiteRegEx": null, "year": 2007}, {"title": "Economics", "author": ["P. Samuelson", "W. Nordhaus"], "venue": "McGraw Hill Press,", "citeRegEx": "121", "shortCiteRegEx": null, "year": 2009}, {"title": "Projected Dynamical Systems and Variational Inequalities with Applications", "author": ["A. Nagurney", "D. Zhang"], "venue": "Kluwer Academic Press,", "citeRegEx": "122", "shortCiteRegEx": null, "year": 1996}, {"title": "Multiagent learning with a variable learning rate", "author": ["M. Bowling", "M. Veloso"], "venue": "Artificial Intelligence, 136:215\u2013250,", "citeRegEx": "123", "shortCiteRegEx": null, "year": 2002}, {"title": "Nash convergence of gradient dynamics in general-sum games", "author": ["S. Singh", "M. Kearns", "Y. Mansour"], "venue": "Proceedings of the Uncertainty in AI conference,", "citeRegEx": "124", "shortCiteRegEx": null, "year": 2000}, {"title": "The extragradient method for finding saddle points and other problems", "author": ["G. Korpelevich"], "venue": "Matekon, 13:35\u201349,", "citeRegEx": "125", "shortCiteRegEx": null, "year": 1977}, {"title": "Structured prediction, dual extragradient and bregman projections", "author": ["B. Taskar", "S. Lacoste-Julien", "Michael Jordan"], "venue": "Matekon, 7:627\u20131653,", "citeRegEx": "126", "shortCiteRegEx": "126", "year": 2008}, {"title": "Static prediction games for adversarial learning problems", "author": ["M. Bruckner", "C. Kanzow", "T. Scheffer"], "venue": "Journal of Machine Learning Research, 13:2617\u20132654,", "citeRegEx": "127", "shortCiteRegEx": null, "year": 2012}, {"title": "Numerical Recipes in C", "author": ["W. Press", "S. Tuekolsky", "W. Vettering", "B. Flannery"], "venue": "Cambridge University Press,", "citeRegEx": "128", "shortCiteRegEx": null, "year": 1992}, {"title": "First order methods for nonsmooth convex large-scale optimization, i: General purpose methods", "author": ["A. Juditsky", "A. Nemirovski"], "venue": "Optimization in Machine Learning. MIT Press,", "citeRegEx": "129", "shortCiteRegEx": null, "year": 2011}, {"title": "First order methods for non- 118 Appendix: Technical Proofs smooth convex large-scale optimization, ii: Utilizing problem structure", "author": ["A. Juditsky", "A. Nemirovski"], "venue": "Optimization in Machine Learning. MIT Press,", "citeRegEx": "130", "shortCiteRegEx": null, "year": 2011}, {"title": "Linear Complementarity, Linear and Nonlinear Programming", "author": ["K. Murty"], "venue": "Heldermann Verlag,", "citeRegEx": "131", "shortCiteRegEx": null, "year": 1988}, {"title": "Regression shrinkage and selection via the lasso", "author": ["R. Tibshirani"], "venue": "Journal of the Royal Statistical Society. Series B, Jan", "citeRegEx": "132", "shortCiteRegEx": null, "year": 1996}, {"title": "Fast active-set-type algorithms for L1regularized linear regression", "author": ["J. Kim", "H. Park"], "venue": "Proceedings of the Conference on AI and Statistics, pages 397\u2013404,", "citeRegEx": "133", "shortCiteRegEx": null, "year": 2010}, {"title": "Linear complementarity for regularized policy evaluation and improvement", "author": ["J. Johns", "C. Painter-Wakefield", "R. Parr"], "venue": "Proceedings of Advances in Neural Information Processing Systems, 23,", "citeRegEx": "134", "shortCiteRegEx": null, "year": 2010}, {"title": "Regularized off-policy TDlearning", "author": ["B. Liu", "S. Mahadevan", "J. Liu"], "venue": "Proceedings of the International Conference on Neural Information Processing Systems (NIPS),", "citeRegEx": "135", "shortCiteRegEx": null, "year": 2012}, {"title": "Parallel and Distributed Computation: Numerical Methods", "author": ["D. Bertsekas", "J. Tsitsiklis"], "venue": "Athena Scientific,", "citeRegEx": "136", "shortCiteRegEx": null, "year": 1997}, {"title": "A variant of Korpelevich\u2019s method for variational inequalities with a new search strategy", "author": ["A. Iusem", "B. Svaiter"], "venue": "Optimization, 42:309\u2013321,", "citeRegEx": "137", "shortCiteRegEx": null, "year": 1997}, {"title": "Modification of the extragradient method for solving variational inequalities of certain optimization problems", "author": ["E. Khobotov"], "venue": "USSR Computational Mathematics and Mathematical Physics, 27:120\u2013127,", "citeRegEx": "138", "shortCiteRegEx": null, "year": 1987}, {"title": "Application of Khobotov\u2019s algorithm to variational inequalities and network equilibrium problems", "author": ["P. Marcotte"], "venue": "INFORM, 29,", "citeRegEx": "139", "shortCiteRegEx": null, "year": 1991}, {"title": "A new hybrid extragradient method for generalized mixed equilibrium problems, fixed point problems, and variational inequality problems", "author": ["J. Peng", "J. Yao"], "venue": "Taiwanese Journal of Mathematics, 12:1401\u20131432,", "citeRegEx": "140", "shortCiteRegEx": null, "year": 2008}, {"title": "Dual extrapolation and its application to solving variational inequalities and related problems", "author": ["Y. Nesterov"], "venue": "Mathematical Programming Series B., 109:319\u2013344,", "citeRegEx": "141", "shortCiteRegEx": null, "year": 2007}, {"title": "A new projection method for variational inequality problems", "author": ["M. Solodov", "B. Svaiter"], "venue": "SIAM Journal of Control and Optimization, 37(3):756\u2013776,", "citeRegEx": "142", "shortCiteRegEx": null, "year": 1999}, {"title": "Projected equations, variational inequalities, and temporal difference methods", "author": ["D. Bertsekas"], "venue": "Technical Report LIDS-P-2808, MIT, March", "citeRegEx": "143", "shortCiteRegEx": null, "year": 2009}, {"title": "Galerkin methods for complementarity problems and variational inequalities", "author": ["G. Gordon"], "venue": "Arxiv, June", "citeRegEx": "144", "shortCiteRegEx": null, "year": 2013}, {"title": "Introductory lectures on convex optimization: A basic course, volume", "author": ["Y. Nesterov"], "venue": null, "citeRegEx": "145", "shortCiteRegEx": "145", "year": 2004}, {"title": "Acceleration of stochastic approximation by averaging", "author": ["B. T Polyak", "A. B Juditsky"], "venue": "SIAM Journal on Control and Optimization, 30(4):838\u2013855,", "citeRegEx": "146", "shortCiteRegEx": null, "year": 1992}, {"title": "New error bounds for approximations from projected linear equations", "author": ["H. Yu", "D.P. Bertsekas"], "venue": "Technical Report C-2008-43, Dept. Computer Science, Univ. of Helsinki,", "citeRegEx": "147", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": "In this chapter, we lay out the elements of our novel framework for reinforcement learning [1], based on doing temporal difference learning not in the primal space, but in a dual space defined by a so-called mirror map.", "startOffset": 91, "endOffset": 94}, {"referenceID": 1, "context": "examples of the benefits of our framework, showing each of the four key pieces of our solution: the improved performance of our new off-policy temporal difference methods over previous gradient TD methods, like TDC and GTD2 [2]; how we are able to generalize natural gradient actor critic methods using mirror maps, and achieve safety guarantees to control learning in complex robots; and finally, elements of our saddle point reformulation of temporal difference learning.", "startOffset": 224, "endOffset": 227}, {"referenceID": 2, "context": "endre\u201d transform [3].", "startOffset": 17, "endOffset": 20}, {"referenceID": 3, "context": "We use Bregman divergences [4] to ensure that safety constraints are adhered to, where the projection is defined as:", "startOffset": 27, "endOffset": 30}, {"referenceID": 4, "context": "The framework of mirror descent [5, 6] plays a central role in our framework, which includes not just the original mirror descent method, but also the mirror-prox method [7], which generalizes the extragradient method to non-Euclidean geometries [8].", "startOffset": 32, "endOffset": 38}, {"referenceID": 5, "context": "The framework of mirror descent [5, 6] plays a central role in our framework, which includes not just the original mirror descent method, but also the mirror-prox method [7], which generalizes the extragradient method to non-Euclidean geometries [8].", "startOffset": 32, "endOffset": 38}, {"referenceID": 6, "context": "The framework of mirror descent [5, 6] plays a central role in our framework, which includes not just the original mirror descent method, but also the mirror-prox method [7], which generalizes the extragradient method to non-Euclidean geometries [8].", "startOffset": 170, "endOffset": 173}, {"referenceID": 7, "context": "The framework of mirror descent [5, 6] plays a central role in our framework, which includes not just the original mirror descent method, but also the mirror-prox method [7], which generalizes the extragradient method to non-Euclidean geometries [8].", "startOffset": 246, "endOffset": 249}, {"referenceID": 8, "context": "Variational inequalities, in the infinite-dimensional setting, were originally proposed by Hartman and Stampacchia [10] in the mid-1960s in the", "startOffset": 115, "endOffset": 119}, {"referenceID": 9, "context": "Finitedimensional VIs rose in popularity in the 1980s partly as a result of work by Dafermos [11], who showed that the traffic network equilibrium problem could be formulated as a finite-dimensional VI.", "startOffset": 93, "endOffset": 97}, {"referenceID": 10, "context": "could also be formulated as finite-dimensional VIs \u2013 the books by Nagurney [12] and Facchinei and Pang [13] provide a detailed introduction to the theory and applications of finite-dimensional VIs.", "startOffset": 75, "endOffset": 79}, {"referenceID": 11, "context": "could also be formulated as finite-dimensional VIs \u2013 the books by Nagurney [12] and Facchinei and Pang [13] provide a detailed introduction to the theory and applications of finite-dimensional VIs.", "startOffset": 103, "endOffset": 107}, {"referenceID": 1, "context": "We will see later how this property of extragradient makes its appearance in accelerating gradient temporal difference learning algorithms, such as TDC [2].", "startOffset": 152, "endOffset": 155}, {"referenceID": 6, "context": "The mirror-prox algorithm (MP) [7] is a first-order approach that is able to solve saddle-point problems at a convergence rate of O(1/t).", "startOffset": 31, "endOffset": 34}, {"referenceID": 12, "context": "The MP method plays a key role in our framework as our approach extensively uses the saddle point reformulation of reinforcement learning developed by us [14].", "startOffset": 154, "endOffset": 158}, {"referenceID": 4, "context": "With this introduction, we can now introduce the main concept of mirror descent, which was originally proposed by Nemirovksi and Yudin [5].", "startOffset": 135, "endOffset": 138}, {"referenceID": 5, "context": "We follow the treatment in [6] in presenting the mirror descent algorithm as a nonlinear proximal method based on a distance generator function that is a Bregman divergence [4].", "startOffset": 27, "endOffset": 30}, {"referenceID": 3, "context": "We follow the treatment in [6] in presenting the mirror descent algorithm as a nonlinear proximal method based on a distance generator function that is a Bregman divergence [4].", "startOffset": 173, "endOffset": 176}, {"referenceID": 13, "context": "It is shown in [15] that the mirror descent procedure specified in Equation 1.", "startOffset": 15, "endOffset": 19}, {"referenceID": 14, "context": "3 with the Bregman divergence defined by the p-norm function [16] can outperform regular projected subgradient method by a factor n logn where n is the dimensionality of the space.", "startOffset": 61, "endOffset": 65}, {"referenceID": 15, "context": "In our framework, a key insight used to derive a true stochastic gradient method for reinforcement learning is based on the powerful concept of operator splitting [17, 18].", "startOffset": 163, "endOffset": 171}, {"referenceID": 16, "context": "In our framework, a key insight used to derive a true stochastic gradient method for reinforcement learning is based on the powerful concept of operator splitting [17, 18].", "startOffset": 163, "endOffset": 171}, {"referenceID": 3, "context": "This problem originally motivated the development of Bregman divergences [4].", "startOffset": 73, "endOffset": 76}, {"referenceID": 13, "context": "The convex feasibility problem is an example of many real-world problems, such as 3D voxel reconstruction in brain imaging [15], a high-dimensional problem that mirror descent was originally developed for.", "startOffset": 123, "endOffset": 127}, {"referenceID": 16, "context": "Many different operator splitting strategies have been developed, such as Douglas Rachford splitting [18], which is a generalization of widely used distributed optimization methods like Alternating Direction Method of Multipliers [19].", "startOffset": 101, "endOffset": 105}, {"referenceID": 17, "context": "Many different operator splitting strategies have been developed, such as Douglas Rachford splitting [18], which is a generalization of widely used distributed optimization methods like Alternating Direction Method of Multipliers [19].", "startOffset": 230, "endOffset": 234}, {"referenceID": 20, "context": "Our proposed framework solves this problem by establishing a key technical result, stated below, between mirror descent and the well-known, but previously unrelated, class of algorithms called natural gradient [22].", "startOffset": 210, "endOffset": 214}, {"referenceID": 18, "context": "5: The uBot-5 is a 11 degree of freedom mobile manipulator developed at the Laboratory of Perceptual Robotics (LPR) at the University of Massachusetts, Amherst [20, 21].", "startOffset": 160, "endOffset": 168}, {"referenceID": 19, "context": "5: The uBot-5 is a 11 degree of freedom mobile manipulator developed at the Laboratory of Perceptual Robotics (LPR) at the University of Massachusetts, Amherst [20, 21].", "startOffset": 160, "endOffset": 168}, {"referenceID": 20, "context": "How can we design a \u201csafe\u201d reinforcement learning algorithm which is guaranteed to ensure that policy learning will not violate pre-defined constraints such that such robots will operate in dangerous regions of the control parameter space? Our framework provides a key solution, based on showing an equivalence between mirror descent and a previously well-studied but unrelated algorithm called natural gradient [22].", "startOffset": 412, "endOffset": 416}, {"referenceID": 21, "context": "Although many more sophisticated methods have been developed over the past three decades, such as least-squares based temporal difference approaches, including LSTD [23], LSPE [24] and LSPI [25], first-order temporal difference learning algorithms may scale more gracefully to high dimensional problems.", "startOffset": 165, "endOffset": 169}, {"referenceID": 22, "context": "Although many more sophisticated methods have been developed over the past three decades, such as least-squares based temporal difference approaches, including LSTD [23], LSPE [24] and LSPI [25], first-order temporal difference learning algorithms may scale more gracefully to high dimensional problems.", "startOffset": 176, "endOffset": 180}, {"referenceID": 23, "context": "Although many more sophisticated methods have been developed over the past three decades, such as least-squares based temporal difference approaches, including LSTD [23], LSPE [24] and LSPI [25], first-order temporal difference learning algorithms may scale more gracefully to high dimensional problems.", "startOffset": 190, "endOffset": 194}, {"referenceID": 24, "context": "This motivated the development of the gradient TD (GTD) family of methods [26].", "startOffset": 74, "endOffset": 78}, {"referenceID": 12, "context": "A crucial step in the development of our framework was the development of a novel saddle-point framework for sparse regularized GTD [14].", "startOffset": 132, "endOffset": 136}, {"referenceID": 24, "context": "Although these algorithms are motivated from the gradient of an objective function such as mean-squared projected Bellman error (MSPBE) and NEU [26], they are not true stochastic gradient methods with respect to these objective functions, as pointed out in [27], which make the convergence rate and error bound analysis difficult, although asymptotic analysis has been carried out using the ODE approach.", "startOffset": 144, "endOffset": 148}, {"referenceID": 25, "context": "Although these algorithms are motivated from the gradient of an objective function such as mean-squared projected Bellman error (MSPBE) and NEU [26], they are not true stochastic gradient methods with respect to these objective functions, as pointed out in [27], which make the convergence rate and error bound analysis difficult, although asymptotic analysis has been carried out using the ODE approach.", "startOffset": 257, "endOffset": 261}, {"referenceID": 12, "context": "(4) The fourth question is on regularization: although the saddle point framework proposed in [14] provides an online regularization framework for the GTD family of algorithms, termed as RO-TD, it is based on the inverse problem formulation and is thus not quite explicit.", "startOffset": 94, "endOffset": 98}, {"referenceID": 26, "context": "In this paper, we propose a novel approach to TD algorithm design in reinforcement learning, based on introducing the proximal splitting framework [28].", "startOffset": 147, "endOffset": 151}, {"referenceID": 0, "context": "7 illustrates a sample result, showing how the mirror descent variant of temporal difference learning results in faster convergence, and much lower variance (not shown) on the classic mountain car task [1].", "startOffset": 202, "endOffset": 205}, {"referenceID": 27, "context": "The learning environment for decision-making is generally modeled by the well-known Markov Decision Process[29] M = (S,A, P,R, \u03b3), which is derived from a Markov chain.", "startOffset": 107, "endOffset": 111}, {"referenceID": 27, "context": "(Markov Decision Process)[29]: A Markov Decision Process is a tuple (S,A, P,R, \u03b3) where S is a finite set of states, A is a finite set of actions, P : S \u00d7 A \u00d7 S \u2192 [0, 1] is the transition kernel, where P (s, a, s\u2032) is the probability of transmission from state s to state s\u2032 given action a, and reward r : S \u00d7 A \u2192 R+ is a reward function, 0 \u2264 \u03b3 < 1 is a discount factor.", "startOffset": 25, "endOffset": 29}, {"referenceID": 0, "context": "(Markov Decision Process)[29]: A Markov Decision Process is a tuple (S,A, P,R, \u03b3) where S is a finite set of states, A is a finite set of actions, P : S \u00d7 A \u00d7 S \u2192 [0, 1] is the transition kernel, where P (s, a, s\u2032) is the probability of transmission from state s to state s\u2032 given action a, and reward r : S \u00d7 A \u2192 R+ is a reward function, 0 \u2264 \u03b3 < 1 is a discount factor.", "startOffset": 163, "endOffset": 169}, {"referenceID": 0, "context": "A stochastic policy \u03c0 : S \u00d7A\u2192 [0, 1].", "startOffset": 30, "endOffset": 36}, {"referenceID": 28, "context": "The most popular and widely used RL method is temporal difference (TD) learning [30].", "startOffset": 80, "endOffset": 84}, {"referenceID": 29, "context": "The (optimal) action value formulation is convenient because it can be approximately solved by a temporal-difference (TD) learning technique called Q-learning [31].", "startOffset": 159, "endOffset": 163}, {"referenceID": 30, "context": "TD(0) converges to the optimal value function V \u03c0 for policy \u03c0 as long as the samples are \u201con-policy\u201d, namely following the stochastic Markov chain associated with the policy; and the learning rate \u03b1t is decayed according to the Robbins-Monro conditions in stochastic approximation theory: \u2211 t \u03b1t = \u221e, \u2211 t \u03b1 2 t < \u221e [32].", "startOffset": 316, "endOffset": 320}, {"referenceID": 31, "context": ") or automatically generated basis functions [33].", "startOffset": 45, "endOffset": 49}, {"referenceID": 32, "context": "Here we define the problem of Stochastic Composite Optimization (SCO)[34]:", "startOffset": 69, "endOffset": 73}, {"referenceID": 33, "context": "(Distance-generating Function)[35]: A distancegenerating function \u03c8(x) is defined as a continuously differentiable \u03bcstrongly convex function.", "startOffset": 30, "endOffset": 34}, {"referenceID": 33, "context": "(Bregman Divergence)[35]: Given distancegenerating function \u03c8, the Bregman divergence induced by \u03c8 is defined as:", "startOffset": 20, "endOffset": 24}, {"referenceID": 34, "context": "1 p + 1 q = 1 [36].", "startOffset": 14, "endOffset": 18}, {"referenceID": 33, "context": "The mirror descent [35] algorithm is a generalization of classic gradient descent, which has led to developments of new more powerful machine learning methods for classification and regression.", "startOffset": 19, "endOffset": 23}, {"referenceID": 35, "context": "Mirror descent has become the cornerstone of many online l1 regularization approaches such as in [37], [38] and [39].", "startOffset": 97, "endOffset": 101}, {"referenceID": 36, "context": "Mirror descent has become the cornerstone of many online l1 regularization approaches such as in [37], [38] and [39].", "startOffset": 103, "endOffset": 107}, {"referenceID": 37, "context": "Mirror descent has become the cornerstone of many online l1 regularization approaches such as in [37], [38] and [39].", "startOffset": 112, "endOffset": 116}, {"referenceID": 36, "context": "Regularized dual averaging (RDA) [38] is a variant of Dual averaging (DA) with \u201csimple\u201d regularizers, such as l1 regularization.", "startOffset": 33, "endOffset": 37}, {"referenceID": 38, "context": "The DA method approximates this lower bound model with an approximate (possibly not supporting) lower bound hyperplane with the averaging of all the past gradients [40].", "startOffset": 164, "endOffset": 168}, {"referenceID": 39, "context": "RDA with local stabilizer can be seen in [41].", "startOffset": 41, "endOffset": 45}, {"referenceID": 40, "context": "Compared with other firstorder l1 regularization algorithms of the mirror-descent type, including truncated gradient method [42] and SMIDAS [43], RDA tends to produce sparser solutions in that the RDA method is more aggressive on sparsity than many other competing approaches.", "startOffset": 124, "endOffset": 128}, {"referenceID": 41, "context": "Compared with other firstorder l1 regularization algorithms of the mirror-descent type, including truncated gradient method [42] and SMIDAS [43], RDA tends to produce sparser solutions in that the RDA method is more aggressive on sparsity than many other competing approaches.", "startOffset": 140, "endOffset": 144}, {"referenceID": 42, "context": "It is worth noting that problems with non-smooth regularization functions often lead to solutions that lie on a low-dimensional supporting data manifold, and regularized dual averaging is capable of identifying this manifold, and thus bringing the potential benefit of accelerating convergence rate by searching on the low-dimensional manifold after it is identified, as suggested in [44].", "startOffset": 384, "endOffset": 388}, {"referenceID": 7, "context": "The extragradient method was first proposed by Korpelevich[8] as a relaxation of ordinary gradient descent to solve variational inequality (VI) problems.", "startOffset": 58, "endOffset": 61}, {"referenceID": 6, "context": "4) is guaranteed under the constraints 0 < \u03b1t < 1 \u221a 2L [7], where L is the Lipschitz constant for \u2207f(x).", "startOffset": 55, "endOffset": 58}, {"referenceID": 43, "context": "Later work and variants of Nesterov\u2019s method utilizing the strong convexity of the loss function with Bregman divergence are summarized in [45].", "startOffset": 139, "endOffset": 143}, {"referenceID": 32, "context": "from deterministic smooth convex optimization to stochastic composite optimization, termed as AC-SA, is studied in [34].", "startOffset": 115, "endOffset": 119}, {"referenceID": 15, "context": "An important property of closed proper convex functions is that their subdifferentials induce a relation on Rn called a maximal monotone operator [17, 46].", "startOffset": 146, "endOffset": 154}, {"referenceID": 44, "context": "An important property of closed proper convex functions is that their subdifferentials induce a relation on Rn called a maximal monotone operator [17, 46].", "startOffset": 146, "endOffset": 154}, {"referenceID": 45, "context": "The convexconcave saddle-point problems are, therefore, usually better suited for first-order methods [47].", "startOffset": 102, "endOffset": 106}, {"referenceID": 46, "context": "A comprehensive overview on extending convex minimization to convex-concave saddle-point problems with unified variational inequalities is presented in [48].", "startOffset": 152, "endOffset": 156}, {"referenceID": 47, "context": "Using the approach in [49], Equation (2.", "startOffset": 22, "endOffset": 26}, {"referenceID": 48, "context": "A general procedure for solving the monotone inclusion problem, the proximal point algorithm [50], uses the following identities:", "startOffset": 93, "endOffset": 97}, {"referenceID": 49, "context": "In the case where the relation R = \u2202f of some convex function f , the resolvent can be shown to be the proximal mapping [51], a crucially important abstraction of the concept of projection, a cornerstone of constrained optimization.", "startOffset": 120, "endOffset": 124}, {"referenceID": 15, "context": "Operator splitting [17, 18] is a generic approach to decomposing complex optimization and variational inequality problems into simpler ones that involve computing the resolvents of individual relations, rather than sums or other compositions of relations.", "startOffset": 19, "endOffset": 27}, {"referenceID": 16, "context": "Operator splitting [17, 18] is a generic approach to decomposing complex optimization and variational inequality problems into simpler ones that involve computing the resolvents of individual relations, rather than sums or other compositions of relations.", "startOffset": 19, "endOffset": 27}, {"referenceID": 16, "context": "We will primarily focus on the Douglas Rachford algorithm [18] specified in Figure 2.", "startOffset": 58, "endOffset": 62}, {"referenceID": 17, "context": "1, because it leads to a widely used distributed optimization method called Alternating Direction Method of Multipliers (ADMM) [19].", "startOffset": 127, "endOffset": 131}, {"referenceID": 17, "context": "The ADMM algorithm has been extensively studied in optimization; a detailed review is available in the tutorial paper by Boyd and colleagues [19], covering both its theoretical properties, operator splitting origins, and applications to high-dimensional data mining.", "startOffset": 141, "endOffset": 145}, {"referenceID": 26, "context": "In this section we will give a brief overview of proximal splitting algorithms [28].", "startOffset": 79, "endOffset": 83}, {"referenceID": 50, "context": "Proximal methods [53, 54], which are widely used in machine learning, signal processing, and stochastic optimization, provide a general framework for large-scale optimization.", "startOffset": 17, "endOffset": 25}, {"referenceID": 51, "context": "Proximal methods [53, 54], which are widely used in machine learning, signal processing, and stochastic optimization, provide a general framework for large-scale optimization.", "startOffset": 17, "endOffset": 25}, {"referenceID": 52, "context": "is Forward-Backward Splitting (FOBOS) [55]", "startOffset": 38, "endOffset": 42}, {"referenceID": 26, "context": "To solve this problem, Douglas-Rachford splitting [28] and Alternating Direction of Multiple Multipliers (ADMM) can be used.", "startOffset": 50, "endOffset": 54}, {"referenceID": 53, "context": "Recently, ADMM has been used proposed for sparse RL [56].", "startOffset": 52, "endOffset": 56}, {"referenceID": 54, "context": "The corresponding primal-dual formulation [57, 28, 58] of Section (2.", "startOffset": 42, "endOffset": 54}, {"referenceID": 26, "context": "The corresponding primal-dual formulation [57, 28, 58] of Section (2.", "startOffset": 42, "endOffset": 54}, {"referenceID": 55, "context": "The corresponding primal-dual formulation [57, 28, 58] of Section (2.", "startOffset": 42, "endOffset": 54}, {"referenceID": 20, "context": "However, in several settings it is more appropriate to assume that xk resides in a Riemannian space with metric tensor G(xk), which is an n \u00d7 n positive definite matrix that may vary with xk [22].", "startOffset": 191, "endOffset": 195}, {"referenceID": 56, "context": "In this case, the direction of steepest descent is called the natural gradient and is given by \u2212G(xk)\u2207f(xk) [59].", "startOffset": 108, "endOffset": 112}, {"referenceID": 20, "context": "In certain cases, (which include our policy search application), following the natural gradient is asymptotically Fisher-efficient [22].", "startOffset": 131, "endOffset": 135}, {"referenceID": 30, "context": "It is worth noting that we make little use of classical stochastic approximation theory, which has traditionally been used to analyze reinforcement learning methods (as discussed in detail in books such as [32]).", "startOffset": 206, "endOffset": 210}, {"referenceID": 57, "context": "[60] (l1-regularized Projection): \u03a0l1 is the l1regularized projection defined as:", "startOffset": 0, "endOffset": 4}, {"referenceID": 57, "context": "t weighted l2 norm, as proven in [60].", "startOffset": 33, "endOffset": 37}, {"referenceID": 57, "context": "[60]: \u03a0\u03c1 is a non-expansive mapping such that \u2200x, y \u2208 R, ||\u03a0\u03c1x\u2212\u03a0\u03c1y|| \u2264 ||x\u2212 y|| \u2212 ||x\u2212 y \u2212 (\u03a0\u03c1x\u2212\u03a0\u03c1y)||", "startOffset": 0, "endOffset": 4}, {"referenceID": 57, "context": "[60] (Lasso-TD) Lasso-TD is a fixed-point equation w.", "startOffset": 0, "endOffset": 4}, {"referenceID": 57, "context": "The properties of Lasso-TD is discussed in detail in [60].", "startOffset": 53, "endOffset": 57}, {"referenceID": 58, "context": "Several prevailing sparse RL methods use Lasso-TD as the objective function, such as SparseTD[61], LARS-TD[62] and LCP-TD[63].", "startOffset": 93, "endOffset": 97}, {"referenceID": 59, "context": "Several prevailing sparse RL methods use Lasso-TD as the objective function, such as SparseTD[61], LARS-TD[62] and LCP-TD[63].", "startOffset": 106, "endOffset": 110}, {"referenceID": 60, "context": "Several prevailing sparse RL methods use Lasso-TD as the objective function, such as SparseTD[61], LARS-TD[62] and LCP-TD[63].", "startOffset": 121, "endOffset": 125}, {"referenceID": 10, "context": "LCPTD [12] formulates LASSO-TD as a linear complementarity problem (LCP), which can be solved by a variety of available LCP solvers.", "startOffset": 6, "endOffset": 10}, {"referenceID": 52, "context": "We then derive the major step by formulating the problem as a forward-backward splitting problem (FOBOS) as in [55],", "startOffset": 111, "endOffset": 115}, {"referenceID": 14, "context": "This \u03c8(w) leads to the p-norm link function \u03b8 = f(w) where f : Rd \u2192 Rd [16]:", "startOffset": 71, "endOffset": 75}, {"referenceID": 14, "context": "The p-norm function has been extensively studied in the literature on online learning [16], and it is well-known that for large p, the corresponding classification or regression method behaves like a multiplicative method (e.", "startOffset": 86, "endOffset": 90}, {"referenceID": 61, "context": ", the p-norm regression method for large p behaves like an exponentiated gradient method (EG) [64, 65]).", "startOffset": 94, "endOffset": 102}, {"referenceID": 62, "context": ", the p-norm regression method for large p behaves like an exponentiated gradient method (EG) [64, 65]).", "startOffset": 94, "endOffset": 102}, {"referenceID": 5, "context": "Another distance generating function is the negative entropy function \u03c8(w) = \u2211 iwi logwi, which leads to the entropic mirror descent algorithm [6].", "startOffset": 143, "endOffset": 146}, {"referenceID": 63, "context": "Interestingly, this special case has been previously explored [66] as the exponentiated-gradient TD method, although the connection to mirror descent and Bregman divergences were not made in this previous study, and EG does not generate sparse solutions [37].", "startOffset": 62, "endOffset": 66}, {"referenceID": 35, "context": "Interestingly, this special case has been previously explored [66] as the exponentiated-gradient TD method, although the connection to mirror descent and Bregman divergences were not made in this previous study, and EG does not generate sparse solutions [37].", "startOffset": 254, "endOffset": 258}, {"referenceID": 35, "context": "An analogous approach was suggested in [37] for l1 penalized classification and regression.", "startOffset": 39, "endOffset": 43}, {"referenceID": 64, "context": "We base our derivation on the composite mirror-descent approach proposed in [67] for classification and regression.", "startOffset": 76, "endOffset": 80}, {"referenceID": 57, "context": "Definition 2 [60]: \u03a0l1 is the l1-regularized projection defined as: \u03a0l1y = \u03a6\u03b1 such that \u03b1 = arg minw\u2016y \u2212 \u03a6w\u2016 +\u03b2\u2016w\u20161, which is a nonexpansive mapping w.", "startOffset": 13, "endOffset": 17}, {"referenceID": 57, "context": "t weighted l2 norm induced by the on-policy sample distribution setting, as proven in [60].", "startOffset": 86, "endOffset": 90}, {"referenceID": 35, "context": "In Algorithm 2, the l1 solver is related to the SMIDAS l1 regularized mirror-descent method for regression and classification [37].", "startOffset": 126, "endOffset": 130}, {"referenceID": 35, "context": "Employing the result of Theorem 3 in [37], after the N -th iteration, the l1 approximation error is bounded by", "startOffset": 37, "endOffset": 41}, {"referenceID": 65, "context": "2 shows that mirror-descent TD converges more quickly with far smaller Bellman errors than LARS-TD [68] on a discrete \u201ctworoom\u201d MDP [69].", "startOffset": 99, "endOffset": 103}, {"referenceID": 66, "context": "2 shows that mirror-descent TD converges more quickly with far smaller Bellman errors than LARS-TD [68] on a discrete \u201ctworoom\u201d MDP [69].", "startOffset": 132, "endOffset": 136}, {"referenceID": 66, "context": "The basis matrix \u03a6 was automatically generated as 50 proto-value functions by diagonalizing the graph Laplacian of the discrete state space connectivity graph[69].", "startOffset": 158, "endOffset": 162}, {"referenceID": 40, "context": "ferent values of p yield an interpolation between the truncated gradient method [42] and SMIDAS [43].", "startOffset": 80, "endOffset": 84}, {"referenceID": 41, "context": "ferent values of p yield an interpolation between the truncated gradient method [42] and SMIDAS [43].", "startOffset": 96, "endOffset": 100}, {"referenceID": 67, "context": "6: Top: Q-learning; Bottom: mirror-descent Q-learning with pnorm link function, both with 25 fixed Fourier bases [70] for the mountain car task.", "startOffset": 113, "endOffset": 117}, {"referenceID": 68, "context": "The triple-link inverted pendulum [71] is a highly nonlinear time-variant under-actuated system,", "startOffset": 34, "endOffset": 38}, {"referenceID": 68, "context": "We base our simulation using the system parameters described in [71], except that the action space is discretized because the algorithms described here are restricted to policies with discrete actions.", "startOffset": 64, "endOffset": 68}, {"referenceID": 5, "context": "The two most widely used link functions in mirror descent are the p-norm link function [6] and the relative entropy function for exponentiated gradient (EG) [64].", "startOffset": 87, "endOffset": 90}, {"referenceID": 61, "context": "The two most widely used link functions in mirror descent are the p-norm link function [6] and the relative entropy function for exponentiated gradient (EG) [64].", "startOffset": 157, "endOffset": 161}, {"referenceID": 61, "context": "It has been shown that when the features are dense and the optimal coefficients \u03b8\u2217 are sparse, EG converges faster than the regular additive gradient methods [64].", "startOffset": 158, "endOffset": 162}, {"referenceID": 63, "context": "It has been pointed out [66] that in the EG-Sarsa algorithm, rescaling can fail, and replacing eligible traces instead of regular additive eligible traces is used to prevent overflow.", "startOffset": 24, "endOffset": 28}, {"referenceID": 67, "context": "Thanks to the flexible interpolation capability between multiplicative and additive gradient updates, the p-norm link function is more robust and applicable to various basis functions, such as polynomial, radial basis function (RBF), Fourier basis [70], proto-value functions (PVFs), etc.", "startOffset": 248, "endOffset": 252}, {"referenceID": 69, "context": "Mirror Descent Q-learning demonstrates the following advantage over regular Q learning: faster convergence rate and reduced variance due to larger stepsizes with theoretical convergence guarantees [72].", "startOffset": 197, "endOffset": 201}, {"referenceID": 35, "context": "Compared with existing sparse reinforcement learning algorithms such as LARS-TD, Algorithm 2 has lower sample complexity and lower computation cost, advantages accrued from the first-order mirror descent framework combined with proximal mapping [37].", "startOffset": 245, "endOffset": 249}, {"referenceID": 1, "context": "We are currently exploring a mirror-descent fast-gradient RL method, which is both convergent off-policy and quicker than fast gradient TD methods such as GTD and TDC [2].", "startOffset": 167, "endOffset": 170}, {"referenceID": 64, "context": "We are also undertaking a more detailed theoretical analysis of the mirror-descent RL framework, building on existing analysis of mirror-descent methods [67, 37].", "startOffset": 153, "endOffset": 161}, {"referenceID": 35, "context": "We are also undertaking a more detailed theoretical analysis of the mirror-descent RL framework, building on existing analysis of mirror-descent methods [67, 37].", "startOffset": 153, "endOffset": 161}, {"referenceID": 70, "context": "Two types of theoretical investigations are being explored: regret bounds of mirror-descent TD methods, extending previous results [73] and convergence analysis combining robust stochastic approximation [72] and RL theory [32, 74].", "startOffset": 131, "endOffset": 135}, {"referenceID": 69, "context": "Two types of theoretical investigations are being explored: regret bounds of mirror-descent TD methods, extending previous results [73] and convergence analysis combining robust stochastic approximation [72] and RL theory [32, 74].", "startOffset": 203, "endOffset": 207}, {"referenceID": 30, "context": "Two types of theoretical investigations are being explored: regret bounds of mirror-descent TD methods, extending previous results [73] and convergence analysis combining robust stochastic approximation [72] and RL theory [32, 74].", "startOffset": 222, "endOffset": 230}, {"referenceID": 71, "context": "Two types of theoretical investigations are being explored: regret bounds of mirror-descent TD methods, extending previous results [73] and convergence analysis combining robust stochastic approximation [72] and RL theory [32, 74].", "startOffset": 222, "endOffset": 230}, {"referenceID": 72, "context": "As pointed out in [75], the target policy is often a deterministic policy that approximates the optimal policy, and the behavior policy is often stochastic, exploring all possible actions in each state as part of finding the optimal policy.", "startOffset": 18, "endOffset": 22}, {"referenceID": 73, "context": "Besides, offpolicy methods are of wider applications since they are able to learn while executing an exploratory policy, learn from demonstrations, and learn multiple tasks in parallel [76].", "startOffset": 185, "endOffset": 189}, {"referenceID": 24, "context": "[26] introduced convergent off-policy temporal difference learning algorithms, such as TDC, whose computation time scales linearly with the number of samples and the number of features.", "startOffset": 0, "endOffset": 4}, {"referenceID": 73, "context": "Recently, a linear off-policy actor-critic algorithm based on the same framework was proposed in [76].", "startOffset": 97, "endOffset": 101}, {"referenceID": 45, "context": "Thus, convex-concave saddle-point problems are, therefore, usually better suited for first-order methods [47].", "startOffset": 105, "endOffset": 109}, {"referenceID": 46, "context": "A comprehensive overview on extending convex minimization to convex-concave saddlepoint problems with unified variational inequalities is presented in [48].", "startOffset": 151, "endOffset": 155}, {"referenceID": 47, "context": "Using the approach in [49], Equation (4.", "startOffset": 22, "endOffset": 26}, {"referenceID": 0, "context": "MSPBE(\u03b8) = \u2016\u03a6\u03b8 \u2212\u03a0T (\u03a6\u03b8)\u20162\u039e = (\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8))T (\u03a6T\u039e\u03a6)\u22121\u03a6T\u039e(T\u03a6\u03b8 \u2212 \u03a6\u03b8) = E[\u03b4t(\u03b8)\u03c6t]E[\u03c6t\u03c6t ]E[\u03b4t(\u03b8)\u03c6t] To avoid computing the inverse matrix (\u03a6T\u039e\u03a6)\u22121 and to avoid the double sampling problem [1] in (4.", "startOffset": 187, "endOffset": 190}, {"referenceID": 24, "context": "Following [26], the TDC algorithm solution follows from the linear equation Ax = b, where a single iteration gradient update would be", "startOffset": 10, "endOffset": 14}, {"referenceID": 24, "context": "The two time-scale gradient descent learning method TDC [26] is", "startOffset": 56, "endOffset": 60}, {"referenceID": 0, "context": "As pointed out in [1], double-sampling is a necessary condition to obtain an unbiased estimator if the objective function is the Bellman residual or its derivatives (such as projected Bellman residual), wherein the product of Bellman error or projected Bellman error metrics are involved.", "startOffset": 18, "endOffset": 21}, {"referenceID": 74, "context": "1) with the following convexconcave formulation as in [77, 47],", "startOffset": 54, "endOffset": 62}, {"referenceID": 45, "context": "1) with the following convexconcave formulation as in [77, 47],", "startOffset": 54, "endOffset": 62}, {"referenceID": 45, "context": "The averaging step, which plays a crucial role in stochastic optimization convergence, generates the approximate saddle-points [47, 78]", "startOffset": 127, "endOffset": 135}, {"referenceID": 75, "context": "The averaging step, which plays a crucial role in stochastic optimization convergence, generates the approximate saddle-points [47, 78]", "startOffset": 127, "endOffset": 135}, {"referenceID": 76, "context": "GQ(\u03bb)[79] is a generalization of the TDC algorithm with eligibility traces and off-policy learning of temporally abstract predictions, where the gradient update changes from Equation (4.", "startOffset": 5, "endOffset": 9}, {"referenceID": 76, "context": "where eligibility traces et, and \u03c6\u0304t, T \u03c0\u03bb are defined in [79].", "startOffset": 58, "endOffset": 62}, {"referenceID": 59, "context": "LARS-TD [62], which is a popular second-order sparse reinforcement learning algorithm, is used as the baseline algorithm for feature selection and TDC is used as the off-policy convergent RL baseline algorithm, respectively.", "startOffset": 8, "endOffset": 12}, {"referenceID": 24, "context": "are used in [26], which are tabular features, inverted features and dependent features respectively.", "startOffset": 12, "endOffset": 16}, {"referenceID": 24, "context": "An identical experiment setting to [26] is used for these two domains.", "startOffset": 35, "endOffset": 39}, {"referenceID": 59, "context": "To make a fair comparison, we use the same basis function setting as in [62], where two dimensional grids of 2, 4, 8, 16, 32 RBFs are used so that there are totally 1365 basis functions.", "startOffset": 72, "endOffset": 76}, {"referenceID": 59, "context": "We use the result of LARS-TD and l2 LSTD reported in [62].", "startOffset": 53, "endOffset": 57}, {"referenceID": 45, "context": "It is worth noting that comparing the performance of RO-TD and LARS-TD is not the major focus here, since LARS-TD is not convergent off-policy and RO-TD\u2019s performance can be further optimized using the mirror-descent approach with the Mirror-Prox algorithm [47] which incorporates mirror descent with an extragradient [8], as discussed below.", "startOffset": 257, "endOffset": 261}, {"referenceID": 7, "context": "It is worth noting that comparing the performance of RO-TD and LARS-TD is not the major focus here, since LARS-TD is not convergent off-policy and RO-TD\u2019s performance can be further optimized using the mirror-descent approach with the Mirror-Prox algorithm [47] which incorporates mirror descent with an extragradient [8], as discussed below.", "startOffset": 318, "endOffset": 321}, {"referenceID": 68, "context": "The triple-link inverted pendulum [71] is a highly nonlinear underactuated system with 8-dimensional state space and discrete action space.", "startOffset": 34, "endOffset": 38}, {"referenceID": 77, "context": "Fourier basis [80] with order 2 is used, resulting in 6561 basis functions.", "startOffset": 14, "endOffset": 18}, {"referenceID": 56, "context": "Natural actor-critics form a class of policy search algorithms for finding locally optimal policies for Markov decision processes (MDPs) by approximating and ascending the natural gradient [59] of an objective", "startOffset": 189, "endOffset": 193}, {"referenceID": 78, "context": "For example, proportional-integral-derivative controllers (PID controllers) are the most widely used control algorithms in industry, and have been studied in depth [81].", "startOffset": 164, "endOffset": 168}, {"referenceID": 79, "context": "Techniques exist for determining the set of stable gains (policy parameters) when a model of the system is available [82].", "startOffset": 117, "endOffset": 121}, {"referenceID": 80, "context": "There has been a recent push to develop controllers that specify how much and when to stimulate each muscle in a human arm to move it from its current position to a desired position [84].", "startOffset": 182, "endOffset": 186}, {"referenceID": 81, "context": "Hence, a proportional-derivative (PD) controller, tuned to a simulation of an ideal human arm, required manual tuning to obtain desirable performance on a human subject with biceps spasticity [85].", "startOffset": 192, "endOffset": 196}, {"referenceID": 82, "context": "Researchers have shown that policy search algorithms are a viable approach to creating controllers that can automatically adapt to an individual\u2019s arm by training on a few hundred two-second reaching movements [86].", "startOffset": 210, "endOffset": 214}, {"referenceID": 83, "context": "Researchers have addressed safety concerns like these before [87].", "startOffset": 61, "endOffset": 65}, {"referenceID": 84, "context": "Bendrahim and Franklin [88] showed how a walking biped robot can switch to a stabilizing controller whenever the robot leaves a stable region of state space.", "startOffset": 23, "endOffset": 27}, {"referenceID": 85, "context": "Similar state-avoidant approaches to safety have been proposed by several others [89, 90, 91].", "startOffset": 81, "endOffset": 93}, {"referenceID": 86, "context": "Similar state-avoidant approaches to safety have been proposed by several others [89, 90, 91].", "startOffset": 81, "endOffset": 93}, {"referenceID": 87, "context": "Similar state-avoidant approaches to safety have been proposed by several others [89, 90, 91].", "startOffset": 81, "endOffset": 93}, {"referenceID": 88, "context": "[92] developed a method for performing risk-sensitive policy search, which models the variance of the objective function for each policy and permits runtime adjustments of risk sensitivity.", "startOffset": 0, "endOffset": 4}, {"referenceID": 89, "context": "[93] presented projected natural actor-critic algorithms for the average reward setting.", "startOffset": 0, "endOffset": 4}, {"referenceID": 90, "context": "[94] presented mirror descent using the Mahalanobis norm for the proximal function, which is very similar to the proximal function that we show to cause mirror descent to be equivalent to natural gradient descent.", "startOffset": 0, "endOffset": 4}, {"referenceID": 90, "context": "Also, since Gk depends on k, \u03c8k is an adaptive proximal function [94].", "startOffset": 65, "endOffset": 69}, {"referenceID": 91, "context": "2 N\u0302X(x) is the normal cone of X at x if x \u2208 X and \u2205 otherwise [95].", "startOffset": 63, "endOffset": 67}, {"referenceID": 92, "context": "A necessary and sufficient condition for x to be a fixed point of PSG is that \u2212\u2207f(x) \u2208 N\u0302X(x) [96].", "startOffset": 94, "endOffset": 98}, {"referenceID": 93, "context": "Natural actor-critics, first proposed by Kakade [97], are algorithms that estimate and ascend the natural gradient of J(\u03b8), using the average Fisher information matrix as the metric tensor:", "startOffset": 48, "endOffset": 52}, {"referenceID": 94, "context": "where d\u03c0 is a policy and objective function-dependent distribution over the state set [98].", "startOffset": 86, "endOffset": 90}, {"referenceID": 95, "context": "There are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93].", "startOffset": 123, "endOffset": 127}, {"referenceID": 96, "context": "There are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93].", "startOffset": 177, "endOffset": 182}, {"referenceID": 96, "context": "There are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93].", "startOffset": 221, "endOffset": 226}, {"referenceID": 97, "context": "There are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93].", "startOffset": 276, "endOffset": 281}, {"referenceID": 98, "context": "There are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93].", "startOffset": 323, "endOffset": 328}, {"referenceID": 89, "context": "There are many natural actor-critics, including Natural policy gradient utilizing the Temporal Differences (NTD) algorithm [99], Natural Actor-Critic using LSTD-Q(\u03bb) (NAC-LSTD) [100], Episodic Natural Actor-Critic (eNAC) [100], Natural Actor-Critic using Sarsa(\u03bb) (NAC-Sarsa) [101], Incremental Natural Actor-Critic (INAC) [102], and Natural-Gradient Actor-Critic with Advantage Parameters (NGAC) [93].", "startOffset": 397, "endOffset": 401}, {"referenceID": 99, "context": "Many of the existing natural policy gradient algorithms, including NAC-LSTD, eNAC, NAC-Sarsa, and INAC, follow biased estimates of the natural policy gradient [103].", "startOffset": 159, "endOffset": 164}, {"referenceID": 99, "context": "The unbiased discounted reward form of NAC-Sarsa was recently derived [103].", "startOffset": 70, "endOffset": 75}, {"referenceID": 89, "context": "where {\u03bct} is a stepsize schedule [93].", "startOffset": 34, "endOffset": 38}, {"referenceID": 100, "context": "We used the Dynamic Arm Simulator 1 (DAS1) [104], a detailed biomechanical simulation of a human arm undergoing functional electrical stimulation.", "startOffset": 43, "endOffset": 48}, {"referenceID": 81, "context": "In a previous study, a controller created using DAS1 performed well on an actual human subject undergoing FES, although it required some additional tuning in order to cope with biceps spasticity [85].", "startOffset": 195, "endOffset": 199}, {"referenceID": 0, "context": "The arm is controlled by providing a stimulation in the interval [0, 1] to each of six muscles.", "startOffset": 65, "endOffset": 71}, {"referenceID": 81, "context": "The reward function used was similar to that of Jagodnik and van den Bogert [85], which punishes joint angle error and high muscle stimulation.", "startOffset": 76, "endOffset": 80}, {"referenceID": 18, "context": "2, is an 11-DoF mobile manipulator developed at the University of Massachusetts Amherst [20, 21].", "startOffset": 88, "endOffset": 96}, {"referenceID": 19, "context": "2, is an 11-DoF mobile manipulator developed at the University of Massachusetts Amherst [20, 21].", "startOffset": 88, "endOffset": 96}, {"referenceID": 21, "context": "Although least-squares based temporal difference approaches, such as LSTD [23], LSPE [24] and LSPI [25] perform well with moderate size problems, first-order temporal difference learning algorithms scale more gracefully to high dimensional problems.", "startOffset": 74, "endOffset": 78}, {"referenceID": 22, "context": "Although least-squares based temporal difference approaches, such as LSTD [23], LSPE [24] and LSPI [25] perform well with moderate size problems, first-order temporal difference learning algorithms scale more gracefully to high dimensional problems.", "startOffset": 85, "endOffset": 89}, {"referenceID": 23, "context": "Although least-squares based temporal difference approaches, such as LSTD [23], LSPE [24] and LSPI [25] perform well with moderate size problems, first-order temporal difference learning algorithms scale more gracefully to high dimensional problems.", "startOffset": 99, "endOffset": 103}, {"referenceID": 24, "context": "This motivated the development of the gradient TD (GTD) family of methods [26].", "startOffset": 74, "endOffset": 78}, {"referenceID": 12, "context": "A novel saddle-point framework for sparse regularized GTD was proposed recently [14].", "startOffset": 80, "endOffset": 84}, {"referenceID": 25, "context": "Although these algorithms are motivated from the gradient of an objective function such as MSPBE and NEU, they are not true stochastic gradient methods with respect to these objective functions, as pointed out in [27], which make the convergence rate and error bound analysis difficult, although asymptotic analysis has been carried out using the ODE approach.", "startOffset": 213, "endOffset": 217}, {"referenceID": 12, "context": "(4) The fourth question is on regularization: although the saddle point framework proposed in [14] provides an online regularization framework for the GTD family of algorithms, termed as RO-TD, it is based on the inverse problem formulation and is thus not quite explicit.", "startOffset": 94, "endOffset": 98}, {"referenceID": 26, "context": "In this paper, we propose a novel approach to TD algorithm design in reinforcement learning, based on introducing the proximal splitting framework [28].", "startOffset": 147, "endOffset": 151}, {"referenceID": 101, "context": "However, TD is only guaranteed to converge in the on-policy setting, although in many off-policy situations, it still has satisfactory performance [105].", "startOffset": 147, "endOffset": 152}, {"referenceID": 24, "context": "TDC [26] aims to minimize the mean-square projected Bellman error (MSPBE) with a similar two-time-scale technique, which is defined as MSPBE(\u03b8) =", "startOffset": 4, "endOffset": 8}, {"referenceID": 25, "context": "As pointed out in [27], although many algorithms are motivated by well-defined convex objective functions such as MSPBE and NEU, due to the biased sampling problem, the unbiased stochastic gradient is impossible to obtain, and thus the algorithms are not true SGD methods w.", "startOffset": 18, "endOffset": 22}, {"referenceID": 53, "context": "This auxiliary variable technique is also used in [56].", "startOffset": 50, "endOffset": 54}, {"referenceID": 25, "context": "As pointed out in [27], although the GTD family of algorithms are derived from the gradient w.", "startOffset": 18, "endOffset": 22}, {"referenceID": 102, "context": "Note that if h(\u03b8) = 0 andX = Rd, then we will have the GTD algorithm proposed in [106].", "startOffset": 81, "endOffset": 86}, {"referenceID": 24, "context": "Note that if h(\u03b8) = 0 and X = Rd, then we will have the GTD2 algorithm proposed in [26].", "startOffset": 83, "endOffset": 87}, {"referenceID": 24, "context": "Note that if h(\u03b8) = 0 and X = Rd, then we will have TDC algorithm proposed in [26].", "startOffset": 78, "endOffset": 82}, {"referenceID": 103, "context": "which is the update rule of residual gradient [107], and is proven not to converge to NEU any more.", "startOffset": 46, "endOffset": 51}, {"referenceID": 104, "context": "A comprehensive overview of the convergence rate of different approaches to stochastic saddle-point problems is given in [108].", "startOffset": 121, "endOffset": 126}, {"referenceID": 45, "context": "In this section we present accelerated algorithms based on the Stochastic Mirror-Prox (SMP) Algorithm [47, 109].", "startOffset": 102, "endOffset": 111}, {"referenceID": 105, "context": "In this section we present accelerated algorithms based on the Stochastic Mirror-Prox (SMP) Algorithm [47, 109].", "startOffset": 102, "endOffset": 111}, {"referenceID": 72, "context": "1 It converges to mean-square TD error (MSTDE), as proven in [75].", "startOffset": 61, "endOffset": 65}, {"referenceID": 106, "context": "However, using the pre-conditioning technique introduced in [110], ADMM", "startOffset": 60, "endOffset": 65}, {"referenceID": 12, "context": "2 Although only regularized TDC was proposed in [14], the algorithm can be easily extended to regularized GTD and GTD2.", "startOffset": 48, "endOffset": 52}, {"referenceID": 55, "context": "can be reduced to the primal-dual splitting method as pointed out in [58].", "startOffset": 69, "endOffset": 73}, {"referenceID": 107, "context": "Now we consider the two-state MDP in [111].", "startOffset": 37, "endOffset": 42}, {"referenceID": 0, "context": "9, and a one-feature basis \u03a6 = [1, 2]T .", "startOffset": 31, "endOffset": 37}, {"referenceID": 1, "context": "9, and a one-feature basis \u03a6 = [1, 2]T .", "startOffset": 31, "endOffset": 37}, {"referenceID": 59, "context": "t \u03c1, whereas Lasso-TD may have multiple solutions if the P -matrix condition is not satisfied [62].", "startOffset": 94, "endOffset": 98}, {"referenceID": 108, "context": "We use the random generated MDP with 400 states and 10 actions in [112].", "startOffset": 66, "endOffset": 71}, {"referenceID": 108, "context": "The parameters of each algorithm are chosen via comparative studies similar to [112].", "startOffset": 79, "endOffset": 84}, {"referenceID": 109, "context": "Future research is ongoing to explore other operator splitting techniques beyond primal-dual splitting as well as incorporating random projections [113], and investigating kernelized algorithms [114, 115].", "startOffset": 147, "endOffset": 152}, {"referenceID": 110, "context": "Future research is ongoing to explore other operator splitting techniques beyond primal-dual splitting as well as incorporating random projections [113], and investigating kernelized algorithms [114, 115].", "startOffset": 194, "endOffset": 204}, {"referenceID": 111, "context": "Future research is ongoing to explore other operator splitting techniques beyond primal-dual splitting as well as incorporating random projections [113], and investigating kernelized algorithms [114, 115].", "startOffset": 194, "endOffset": 204}, {"referenceID": 7, "context": "Methods like extragradient [8] and the mirror-prox algorithm were originally proposed to solve variational inequalities and related saddle point problems.", "startOffset": 27, "endOffset": 30}, {"referenceID": 112, "context": "The concept of equilibrium plays a key role in understanding not only the Internet, but also other networked systems, such as human migration [116], evolutionary dynamics and the spread of infectious diseases [117], and social networks [118].", "startOffset": 142, "endOffset": 147}, {"referenceID": 113, "context": "The concept of equilibrium plays a key role in understanding not only the Internet, but also other networked systems, such as human migration [116], evolutionary dynamics and the spread of infectious diseases [117], and social networks [118].", "startOffset": 209, "endOffset": 214}, {"referenceID": 114, "context": "The concept of equilibrium plays a key role in understanding not only the Internet, but also other networked systems, such as human migration [116], evolutionary dynamics and the spread of infectious diseases [117], and social networks [118].", "startOffset": 236, "endOffset": 241}, {"referenceID": 115, "context": "Equilibria are also a central idea in game theory [119, 120], economics [121], operations research [29], and many related areas.", "startOffset": 50, "endOffset": 60}, {"referenceID": 116, "context": "Equilibria are also a central idea in game theory [119, 120], economics [121], operations research [29], and many related areas.", "startOffset": 50, "endOffset": 60}, {"referenceID": 117, "context": "Equilibria are also a central idea in game theory [119, 120], economics [121], operations research [29], and many related areas.", "startOffset": 72, "endOffset": 77}, {"referenceID": 27, "context": "Equilibria are also a central idea in game theory [119, 120], economics [121], operations research [29], and many related areas.", "startOffset": 99, "endOffset": 103}, {"referenceID": 10, "context": "We are currently exploring two powerful mathematical tools for the study of equilibria \u2013 variational inequalities (VIs) and projected dynamical systems (PDS) [12, 122] \u2013 in developing a new machine learning framework for solving", "startOffset": 158, "endOffset": 167}, {"referenceID": 118, "context": "We are currently exploring two powerful mathematical tools for the study of equilibria \u2013 variational inequalities (VIs) and projected dynamical systems (PDS) [12, 122] \u2013 in developing a new machine learning framework for solving", "startOffset": 158, "endOffset": 167}, {"referenceID": 8, "context": "Variational inequalities (VIs), in the infinite-dimensional setting, were originally proposed by Hartman and Stampacchia [10] in the mid1960s in the context of solving partial differential equations in mechanics.", "startOffset": 121, "endOffset": 125}, {"referenceID": 9, "context": "Finite-dimensional VIs rose in popularity in the 1980s partly as a result of work by Dafermos [11].", "startOffset": 94, "endOffset": 98}, {"referenceID": 10, "context": "books by Nagurney [12] and Facchinei and Pang [13] provide a detailed introduction to the theory and applications of finite-dimensional VIs.", "startOffset": 18, "endOffset": 22}, {"referenceID": 11, "context": "books by Nagurney [12] and Facchinei and Pang [13] provide a detailed introduction to the theory and applications of finite-dimensional VIs.", "startOffset": 46, "endOffset": 50}, {"referenceID": 118, "context": "Projected dynamical systems (PDS) [122] are a class of ordinary differential equations (ODEs) with a discontinuous right-hand side.", "startOffset": 34, "endOffset": 39}, {"referenceID": 119, "context": "[123, 119, 124].", "startOffset": 0, "endOffset": 15}, {"referenceID": 115, "context": "[123, 119, 124].", "startOffset": 0, "endOffset": 15}, {"referenceID": 120, "context": "[123, 119, 124].", "startOffset": 0, "endOffset": 15}, {"referenceID": 121, "context": "One of the original algorithms for solving finite-dimensional VIs is the extragradient method proposed by Korpelevich [125].", "startOffset": 118, "endOffset": 123}, {"referenceID": 122, "context": "[126].", "startOffset": 0, "endOffset": 5}, {"referenceID": 123, "context": "[127] use a modified extragradient method for solving the spam filtering problem modeled as a prediction game.", "startOffset": 0, "endOffset": 5}, {"referenceID": 124, "context": "We are developing a new family of extragradient-like methods based on well-known numerical methods for solving ordinary differential equations, specifically the Runge Kutta method [128].", "startOffset": 180, "endOffset": 185}, {"referenceID": 4, "context": "In optimization, the extragradient algorithm was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129, 130].", "startOffset": 134, "endOffset": 137}, {"referenceID": 125, "context": "In optimization, the extragradient algorithm was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129, 130].", "startOffset": 191, "endOffset": 201}, {"referenceID": 126, "context": "In optimization, the extragradient algorithm was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129, 130].", "startOffset": 191, "endOffset": 201}, {"referenceID": 127, "context": "In an NCP, whenever the mapping function F is affine, that is F (x) = Mx + b, where M is an n \u00d7 n matrix, then the corresponding NCP is called a linear complementarity problem (LCP) [131].", "startOffset": 182, "endOffset": 187}, {"referenceID": 128, "context": "Recent work on learning sparse models using L1 regularization has exploited the fact that the standard LASSO objective [132] of L1 penalized regression can be reduced to solving an LCP [133].", "startOffset": 119, "endOffset": 124}, {"referenceID": 129, "context": "Recent work on learning sparse models using L1 regularization has exploited the fact that the standard LASSO objective [132] of L1 penalized regression can be reduced to solving an LCP [133].", "startOffset": 185, "endOffset": 190}, {"referenceID": 130, "context": "This reduction to LCP has been used in recent work on sparse value function approximation as well in a method called LCP-TD [134].", "startOffset": 124, "endOffset": 129}, {"referenceID": 115, "context": "The VI framework provides a mathematically elegant approach to model equilibrium problems in game theory [119, 120].", "startOffset": 105, "endOffset": 115}, {"referenceID": 116, "context": "The VI framework provides a mathematically elegant approach to model equilibrium problems in game theory [119, 120].", "startOffset": 105, "endOffset": 115}, {"referenceID": 125, "context": "Nash games are closely related to saddle point problems [129, 130, 135].", "startOffset": 56, "endOffset": 71}, {"referenceID": 126, "context": "Nash games are closely related to saddle point problems [129, 130, 135].", "startOffset": 56, "endOffset": 71}, {"referenceID": 131, "context": "Nash games are closely related to saddle point problems [129, 130, 135].", "startOffset": 56, "endOffset": 71}, {"referenceID": 10, "context": "Many equilibria problems in economics can be modeled using VIs [12].", "startOffset": 63, "endOffset": 67}, {"referenceID": 121, "context": "The extragradient method of Korpolevich [125] addresses some of these concerns, and is defined as Algorithm 2 below.", "startOffset": 40, "endOffset": 45}, {"referenceID": 132, "context": "3: Left: This figure illustrates a VI where the basic projection algorithm (Algorithm 1) fails, but the extragradient algorithm (Algorithm 2) succeeds [136].", "startOffset": 151, "endOffset": 156}, {"referenceID": 133, "context": ", see [137, 138, 139, 140, 141, 142].", "startOffset": 6, "endOffset": 36}, {"referenceID": 134, "context": ", see [137, 138, 139, 140, 141, 142].", "startOffset": 6, "endOffset": 36}, {"referenceID": 135, "context": ", see [137, 138, 139, 140, 141, 142].", "startOffset": 6, "endOffset": 36}, {"referenceID": 136, "context": ", see [137, 138, 139, 140, 141, 142].", "startOffset": 6, "endOffset": 36}, {"referenceID": 137, "context": ", see [137, 138, 139, 140, 141, 142].", "startOffset": 6, "endOffset": 36}, {"referenceID": 138, "context": ", see [137, 138, 139, 140, 141, 142].", "startOffset": 6, "endOffset": 36}, {"referenceID": 134, "context": "Khobotov [138] proved that the extragradient method converges under the weaker requirement of pseudo-monotone mappings, 6 when the learning rate is automatically adjusted based on a local measure of the Lipschitz constant.", "startOffset": 9, "endOffset": 14}, {"referenceID": 133, "context": "Iusem [137] proposed a variant whereby the current iterate was projected onto a hyperplane separating the current iterate from the final solution, and subsequently projected from the hyperplane onto the feasible set.", "startOffset": 6, "endOffset": 11}, {"referenceID": 138, "context": "Solodov and Svaiter [142] proposed another hyperplane method, whereby the current iterate is projected onto the intersection of the hyperplane and the feasible set.", "startOffset": 20, "endOffset": 25}, {"referenceID": 4, "context": "Finally, the extragradient method was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129].", "startOffset": 123, "endOffset": 126}, {"referenceID": 125, "context": "Finally, the extragradient method was generalized to the non-Euclidean case by combining it with the mirror-descent method [5], resulting in the so-called \u201cmirrror-prox\u201d algorithm [129].", "startOffset": 180, "endOffset": 185}, {"referenceID": 30, "context": "Variational inequalities also provide a useful framework for reinforcement learning [32, 1].", "startOffset": 84, "endOffset": 91}, {"referenceID": 0, "context": "Variational inequalities also provide a useful framework for reinforcement learning [32, 1].", "startOffset": 84, "endOffset": 91}, {"referenceID": 139, "context": "Generalizing this, consider solving for the fixed point of a projected equation x\u2217 = \u03a0\u015cT (x \u2217) [143, 144] for a functional mapping T : Rn \u2192 Rn, where \u03a0\u015c is the projector onto a low-dimensional convex subspace \u015c w.", "startOffset": 95, "endOffset": 105}, {"referenceID": 140, "context": "Generalizing this, consider solving for the fixed point of a projected equation x\u2217 = \u03a0\u015cT (x \u2217) [143, 144] for a functional mapping T : Rn \u2192 Rn, where \u03a0\u015c is the projector onto a low-dimensional convex subspace \u015c w.", "startOffset": 95, "endOffset": 105}, {"referenceID": 139, "context": "Following [143], note that this is a variational inequality of the form \u3008F (x\u2217), (x\u2212x\u2217)\u3009 \u2265 0 if we identify F (x) = \u039e(x\u2212T (x)), and in the lowerdimensional space, \u3008F (\u03a6r\u2217),\u03a6(r\u2212 r\u2217)\u3009, \u2200r \u2208 R\u0302.", "startOffset": 10, "endOffset": 15}, {"referenceID": 139, "context": "It is shown in [143] that if T is a contraction mapping, then F (x) = \u039e(x \u2212 T (x)) is strongly monotone.", "startOffset": 15, "endOffset": 20}, {"referenceID": 140, "context": "Gordon [144] proposes an alternative approach separating the projection of the current iterate on the low-dimensional subspace spanned by \u03a6 from its projection onto the feasible set.", "startOffset": 7, "endOffset": 12}, {"referenceID": 139, "context": "Both of these approaches [143, 144] have been only studied with the simple projection method (Algorithm 1), and can be generalized to a more powerful class of VI methods that we are currently developing.", "startOffset": 25, "endOffset": 35}, {"referenceID": 140, "context": "Both of these approaches [143, 144] have been only studied with the simple projection method (Algorithm 1), and can be generalized to a more powerful class of VI methods that we are currently developing.", "startOffset": 25, "endOffset": 35}, {"referenceID": 45, "context": "We first present the monotone operator corresponding to the bilinear saddle-point problem and then extend it to stochastic approximation case with certain restrictive assumptions, and use the result in [47].", "startOffset": 202, "endOffset": 206}, {"referenceID": 105, "context": "d noise, then with the result in [109], we can prove that the RO-TD algorithm converges to the global minimizer of", "startOffset": 33, "endOffset": 38}, {"referenceID": 75, "context": "With the subgradient boundedness assumption and using the result in Proposition 1 in [78], this can be proved.", "startOffset": 85, "endOffset": 89}, {"referenceID": 24, "context": "We first present the assumptions for the MDP and basis functions, which are similar to [26, 14].", "startOffset": 87, "endOffset": 95}, {"referenceID": 12, "context": "We first present the assumptions for the MDP and basis functions, which are similar to [26, 14].", "startOffset": 87, "endOffset": 95}, {"referenceID": 104, "context": "Next we present the assumptions for the stochastic saddle point problem formulation, which are similar to [108, 109].", "startOffset": 106, "endOffset": 116}, {"referenceID": 105, "context": "Next we present the assumptions for the stochastic saddle point problem formulation, which are similar to [108, 109].", "startOffset": 106, "endOffset": 116}, {"referenceID": 0, "context": ", \u2200\u03b8, \u03b8\u2032 \u2208 X,\u03bb \u2208 [0, 1], K(\u03bb\u03b8 + (1\u2212 \u03bb)\u03b8)\u2264CK\u03bbK(\u03b8) + (1\u2212 \u03bb)K(\u03b8\u2032),", "startOffset": 17, "endOffset": 23}, {"referenceID": 54, "context": "The corresponding primal-dual formulation [57, 28, 58] of Equation (8.", "startOffset": 42, "endOffset": 54}, {"referenceID": 26, "context": "The corresponding primal-dual formulation [57, 28, 58] of Equation (8.", "startOffset": 42, "endOffset": 54}, {"referenceID": 55, "context": "The corresponding primal-dual formulation [57, 28, 58] of Equation (8.", "startOffset": 42, "endOffset": 54}, {"referenceID": 141, "context": "Using the bounds proved in [145, 109, 108], the optimal convergence rate of stochastic saddle-point problem is O(F N2 + LK N + \u03c3 \u221a N ).", "startOffset": 27, "endOffset": 42}, {"referenceID": 105, "context": "Using the bounds proved in [145, 109, 108], the optimal convergence rate of stochastic saddle-point problem is O(F N2 + LK N + \u03c3 \u221a N ).", "startOffset": 27, "endOffset": 42}, {"referenceID": 104, "context": "Using the bounds proved in [145, 109, 108], the optimal convergence rate of stochastic saddle-point problem is O(F N2 + LK N + \u03c3 \u221a N ).", "startOffset": 27, "endOffset": 42}, {"referenceID": 142, "context": "Hence, by adding the primal average step, GTD/GTD2 algorithms will become standard Polyak\u2019s algorithms [146], and thus the convergence rates are O(FK \u221a N ) ac-", "startOffset": 103, "endOffset": 108}, {"referenceID": 47, "context": "cording to [49].", "startOffset": 11, "endOffset": 15}, {"referenceID": 105, "context": "According to [109] which extends the SMP algorithm to solving saddle-point problems and variational inequality problems, the convergence rate is accelerated to O(FK N + \u03c3 \u221a N ).", "startOffset": 13, "endOffset": 18}, {"referenceID": 107, "context": "Here we use the result in [111], which is similar to the one in [147].", "startOffset": 26, "endOffset": 31}, {"referenceID": 143, "context": "Here we use the result in [111], which is similar to the one in [147].", "startOffset": 64, "endOffset": 69}, {"referenceID": 107, "context": "Lemma 2 [111]: For any V\u03b8 = \u03a6\u03b8, the following component-wise equality holds V \u2212 V\u03b8 = (I \u2212 \u03b3\u03a0P )\u22121 (( V \u2212\u03a0V ) + \u03a6(\u03a6T\u039e\u03a6)\u22121K(\u03b8) )", "startOffset": 8, "endOffset": 13}], "year": 2014, "abstractText": "Reinforcement learning is a simple, and yet, comprehensive theory of learning that simultaneously models the adaptive behavior of artificial agents, such as robots and autonomous software programs, as well as attempts to explain the emergent behavior of biological systems. It also gives rise to computational ideas that provide a powerful tool to solve problems involving sequential prediction and decision making. Temporal difference learning is the most widely used method to solve reinforcement learning problems, with a rich history dating back more than three decades. For these and many other reasons, devel1 This article is currently not under review for the journal Foundations and Trends in ML, but will be submitted for formal peer review at some point in the future, once the draft reaches a stable \u201cequilibrium\u201d state. ar X iv :1 40 5. 67 57 v1 [ cs .L G ] 2 6 M ay 2 01 4 oping a complete theory of reinforcement learning, one that is both rigorous and useful has been an ongoing research investigation for several decades. In this paper, we set forth a new vision of reinforcement learning developed by us over the past few years, one that yields mathematically rigorous solutions to longstanding important questions that have remained unresolved: (i) how to design reliable, convergent, and robust reinforcement learning algorithms (ii) how to guarantee that reinforcement learning satisfies pre-specified \u201csafely\u201d guarantees, and remains in a stable region of the parameter space (iii) how to design \u201coff-policy\u201d temporal difference learning algorithms in a reliable and stable manner, and finally (iv) how to integrate the study of reinforcement learning into the rich theory of stochastic optimization. In this paper, we provide detailed answers to all these questions using the powerful framework of proximal operators. The most important idea that emerges is the use of primal dual spaces connected through the use of a Legendre transform. This allows temporal difference updates to occur in dual spaces, allowing a variety of important technical advantages. The Legendre transform, as we show, elegantly generalizes past algorithms for solving reinforcement learning problems, such as natural gradient methods, which we show relate closely to the previously unconnected framework of mirror descent methods. Equally importantly, proximal operator theory enables the systematic development of operator splitting methods that show how to safely and reliably decompose complex products of gradients that occur in recent variants of gradient-based temporal difference learning. This key technical innovation makes it possible to finally design \u201ctrue\u201d stochastic gradient methods for reinforcement learning. Finally, Legendre transforms enable a variety of other benefits, including modeling sparsity and domain geometry. Our work builds extensively on recent work on the convergence of saddle-point algorithms, and on the theory of monotone operators in Hilbert spaces, both in optimization and for variational inequalities. The latter framework, the subject of another ongoing investigation by our group, holds the promise of an even more elegant framework for reinforcement learning. Its explication is currently the topic of a further monograph that will appear in due course. Dedicated to Andrew Barto and Richard Sutton for inspiring a generation of researchers to the study of reinforcement learning. Algorithm 1 TD (1984) (1) \u03b4t = rt + \u03b3\u03c6 \u2032 t T \u03b8t \u2212 \u03c6t \u03b8t (2) \u03b8t+1 = \u03b8t + \u03b2t\u03b4t Algorithm 2 GTD2-MP (2014) (1) wt+ 1 2 = wt + \u03b2t(\u03b4t \u2212 \u03c6t wt)\u03c6t, \u03b8t+ 1 2 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6t)(\u03c6t wt) ) (2) \u03b4t+ 1 2 = rt + \u03b3\u03c6 \u2032 t T \u03b8t+ 1 2 \u2212 \u03c6t \u03b8t+ 1 2 (3) wt+1 = wt + \u03b2t(\u03b4t+ 1 2 \u2212 \u03c6t wt+ 1 2 )\u03c6t , \u03b8t+1 = prox\u03b1th ( \u03b8t + \u03b1t(\u03c6t \u2212 \u03b3\u03c6t)(\u03c6t wt+ 1 2 ) )", "creator": "LaTeX with hyperref package"}}}