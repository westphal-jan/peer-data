{"id": "1405.7253", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-May-2014", "title": "Conformant Planning as a Case Study of Incremental QBF Solving", "abstract": "We consider creation with disagreement once the initial community because a whether medical related modest achievable Boolean ferrari (QBF) disputes. We posted only scientific this in d\u00e9p\u00f4t will incrementally memorize little planning instance before perfect sequence of QBFs. To accomplish its correspond of incrementally constructed QBFs, we use putting general - purpose expansions QBF satisfiability DepQBF. Since two gain QBFs has among prohibitions besides polynomials was used, our approach studiously redundancy instead saw form encoding similar making both the solving partial. Experimental tournament show if incremental QBF negotiation outperforms encourage - calculations QBF conflict. Our today even several first characterization study included incremental QBF solving in entire aspect in conduct. Based on supposed appeal study, all any that incremental QBF mechanism also now itself lack will improve QBF - based subroutines it other application extracellular.", "histories": [["v1", "Wed, 28 May 2014 14:23:50 GMT  (64kb,D)", "https://arxiv.org/abs/1405.7253v1", null], ["v2", "Wed, 8 Oct 2014 12:04:01 GMT  (60kb,D)", "http://arxiv.org/abs/1405.7253v2", "revision (camera-ready, to appear in the proceedings of AISC 2014, volume 8884 of LNAI, Springer)"], ["v3", "Mon, 4 Apr 2016 11:06:57 GMT  (60kb,D)", "http://arxiv.org/abs/1405.7253v3", "added reference to extended journal article; revision (camera-ready, to appear in the proceedings of AISC 2014, volume 8884 of LNAI, Springer)"]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["uwe egly", "martin kronegger", "florian lonsing", "andreas pfandler"], "accepted": false, "id": "1405.7253"}, "pdf": {"name": "1405.7253.pdf", "metadata": {"source": "CRF", "title": "Conformant Planning as a Case Study of Incremental QBF Solving", "authors": ["Uwe Egly", "Martin Kronegger", "Florian Lonsing", "Andreas Pfandler"], "emails": ["firstname.lastname@tuwien.ac.at"], "sections": [{"heading": "1 Introduction", "text": "Many workflows in formal verification and model checking rely on certain logics as languages to model verification conditions or properties of the systems under consideration. Examples are propositional logic (SAT), quantified Boolean formulas (QBFs), and decidable fragments of first order logic in terms of satisfiability modulo theories (SMT). A tight integration of decision procedures to solve formulas in these logics is crucial for the overall performance of the workflows in practice.\nIn the context of SAT, incremental solving [1,10,22,30] has become a state of the art approach. Given a sequence of related propositional formulas S = \u3008\u03c60, \u03c61, . . . , \u03c6n\u3009 an incremental SAT solver reuses information that was gathered when solving \u03c6i in order to solve the next formula \u03c6i+1. Since incremental solving avoids some redundancy in the process of solving the sequence S, it is desirable to integrate incremental solvers in practical workflows. In contrast, in non-incremental solving the solver does not keep any information from previously solved formulas and always starts from scratch.\nQBFs allow for explicit universal (\u2200) and existential (\u2203) quantification over Boolean variables. The problem of checking the satisfiability of QBFs is PSPACE-complete. We consider QBFs as a natural modelling language for planning problems with uncertainty in the initial state. In conformant planning we are given a set of state variables over a\n? Supported by the Austrian Science Fund (FWF) under grants S11409-N23 and P25518-N23 and the German Research Foundation (DFG) under grant ER 738/2-1. This article appeared in the proceedings of Artificial Intelligence and Symbolic Computation (AISC) [11]. An extended version appeared in Annals of Mathematics and Artificial Intelligence [12].\nar X\niv :1\n40 5.\n72 53\nv3 [\ncs .L\nO ]\n4 A\npr 2\nspecified domain, a set of actions with preconditions and effects, an initial state where some values of the variables may be unknown, and a specification of the goal. The task is to find a sequence of actions, i.e., a plan, that leads from the initial state to a state where the goal is satisfied. Many natural problems, such as repair and therapy planning [35], can be formulated as conformant planning problems. When restricted to plans of length polynomial in the input size this form of planning is \u03a32P-complete [3], whereas classical planning is NP-complete.\nTherefore, using a transformation to QBFs in the case of conformant planning is a very natural approach. Rintanen [33] presented such transformations. Recently, Kronegger et al. [20] showed that transforming the planning instance into a sequence of QBFs can be competitive. In this approach, they generated a QBF for every plan length under consideration and invoked an external QBF solver on each generated QBF. However, the major drawback is that the QBF solver cannot reuse information from previous runs and thus has to relearn all necessary information in order to solve the QBF. In this work we overcome this problem by tightly integrating a general-purpose incremental QBF solver in an incremental workflow to solve planning problems. To obtain a better picture of the performance gain through the incremental approach, we perform a case study where we compare incremental and non-incremental QBF solving on benchmarks for conformant planning.\nThe main contributions of this work are as follows. \u2013 Planning tool. We present a planning tool based on the transformation of planning\ninstances with unknown variables in the initial state to QBFs. This tool implements an incremental and exact approach, i.e., it is guaranteed to find a plan whenever a plan exists and \u2013 if successful \u2013 it returns a plan of minimal length. Furthermore, our tool allows for the use of arbitrary (incremental) QBF solvers. \u2013 Experimental evaluation. We evaluate the performance of the incremental and the non-incremental approach to planning with incomplete information in the initial state. Thereby, we rely on incremental and non-incremental variants of the QBF solver DepQBF [25,26].3 Incremental QBF solving outperforms non-incremental QBF solving in our planning tool. Our results are a case study of incremental QBF solving and motivate its use in other application domains. In addition, we also compare our results to heuristic approaches."}, {"heading": "2 Incremental QBF Solving", "text": "We focus on QBFs \u03c8 = Q\u0302.\u03c6 in prenex conjunctive normal form (PCNF). All quantifiers occur in the prefix Q\u0302 = Q1B1 . . . QnBn and the CNF part \u03c6 is a quantifier-free propositional formula in CNF. The prefix consists of pairwise disjoint sets Bi of quantified Boolean variables, where Qi \u2208 {\u2200,\u2203}, and gives rise to a linear ordering of the variables: we define x < y if x \u2208 Bi, y \u2208 Bj and i < j.\nThe semantics of QBFs is defined recursively based on the quantifier types and the prefix ordering of the variables. The QBF consisting only of the truth constant true (>) or false (\u22a5) is satisfiable or unsatisfiable, respectively. The QBF \u03c8 = \u2200x. \u03c8\u2032 with\n3 DepQBF is free software: http://lonsing.github.io/depqbf/\nthe universal quantification \u2200x at the leftmost position in the prefix is satisfiable if \u03c8[x := \u22a5] and \u03c8[x := >] are satisfiable, where the formula \u03c8[x := \u22a5] (\u03c8[x := >]) results from \u03c8 by replacing the free variable x by\u22a5 (>). The QBF \u03c8 = \u2203x. \u03c8\u2032 with the existential quantification \u2203x is satisfiable if \u03c8[x := \u22a5] or \u03c8[x := >] are satisfiable.\nSearch-based QBF solving [8] is a generalization of the DPLL algorithm [9] for SAT. Modern search-based QBF solvers implement a QBF-specific variant of conflictdriven clause learning (CDCL) for SAT, called QCDCL [13,23,27,36]. In QCDCL the variables are successively assigned until an (un)satisfiable subcase is encountered. The subcase is analyzed and new learned constraints (clauses or cubes) are inferred by Qresolution [19,27]. The purpose of the learned constraints is to prune the search space and to speed up proof search. Assignments are retracted by backtracking and the next subcase is determined until the formula is solved.\nLet \u3008\u03c80, \u03c81, . . . , \u03c8n\u3009 be a sequence of QBFs. In incremental QBF solving based on QCDCL, we must keep track which of the constraints that were learned on a solved QBF \u03c8i can be reused for solving the QBFs \u03c8j with i < j. An approach to incremental QBF solving was first presented in the context of bounded model checking [29]. We rely on the general-purpose incremental QBF solver DepQBF [25,26].\nTo illustrate the potential of incremental QBF solving, we present a case study of QBF-based conformant planning in the following sections. To this end we discuss conformant planning and two types of benchmarks used in the experimental analysis."}, {"heading": "3 Conformant Planning and Benchmark Domains", "text": "A conformant planning problem consists of a set of state variables over a specified domain, a set of actions with preconditions and effects, an initial state where some values of the variables may be unknown, and a specification of the goal. The task is to find a sequence of actions, i.e., a plan, that leads from the initial state to a state where the goal is satisfied. The plan has to reach the goal for all possible values of unknown variables, i.e., it has to be fail-safe. This problem can nicely be encoded into QBFs, e.g., by building upon the encodings by Rintanen [33]. Conformant planning naturally arises, e.g., in repair and therapy planning [35], where a plan needs to succeed even if some obstacles arise.\nThe length of a plan is the number of actions in the plan. As one is usually looking for short plans, the following strategy is used. Starting at a lower bound k on the minimal plan length, we iteratively increment the plan length k until a plan is found or a limit on the plan length is reached. This strategy is readily supported by an incremental QBF solver because a large number of clauses remains untouched when moving from length k to k + 1 and always leads to optimal plans with respect to the plan length.\nThe two benchmark types we consider in our case study are called \u201cDungeon\u201d. These benchmarks are inspired by adventure computer-games and were first presented at the QBF workshop 2013 [20]. In this setting a player wants to defeat monsters living in a dungeon. Each monster requires a certain configuration of items to be defeated. In the beginning, the player picks at most one item from each pool of items. In addition, the player can exchange several items for one more powerful item if she holds all necessary \u201cingredients\u201d. Eventually, the player enters the dungeon. When entering the dungeon,\nthe player is forced to pick additional items. The dilemma is that the player does not know which items she will get, i.e., the additional items are represented by variables with unknown values in the initial state. It might also happen that the new items turn out to be obstructive given the previously chosen item configuration. The goal is to pick items such that irrespective of the additional items she defeats at least one monster.\nWe consider two variants of the Dungeon benchmark. In variant v0 the player is only allowed to enter the dungeon once, thus has to pick the items and build more powerful items in advance. In contrast, in variant v1 the player might attempt fighting the monsters several times and pick/build further items in between if she was unsuccessful.\nDespite the simple concept, these benchmarks are well suited for our case study. First, they capture the full hardness of \u03a32P-complete problems. Second, it is natural to reinterpret the game setting as a configuration or maintenance problem."}, {"heading": "4 QBF Planning Tool", "text": "We briefly describe our planning tool that takes planning instances as input and encodes them as a sequence of QBFs. This tool generates a plan of minimal length for a given conformant planning instance with uncertainty in the initial state.\nFigure 1 illustrates the architecture of our planning tool which was used for the experiments. The tool takes a planning instances given in PDDL format as input. After parsing the input, the grounder analyzes the given planning instance and calculates a lower bound ` on the plan length. Starting with a plan length of k = `, the grounder then grounds only relevant parts of the instance, i.e., the grounder systematically eliminates variables from the PDDL instance. In a next step, the QBF encoder takes the ground representation as input and transforms it into a QBF that is satisfiable if and only if the planning problem has a plan of length k. The encoding which is used for this transformation to QBFs builds upon the \u2203\u2200\u2203-encoding described in the work of Rintanen [33]. We decided to employ the \u2203\u2200\u2203-encoding rather than a \u2203\u2200-encoding as this gives a more natural encoding and simplifies the PCNF transformation. Since in this work we focus on a comparison of the incremental and non-incremental approach, we do not go into the details of the encoding. After the transformation into a QBF, the QBF encoder then invokes a QBF solver on the generated QBF. If the generated QBF is satisfiable, our system extracts the optimal plan from the assignment of the leftmost \u2203-block. If the QBF is unsatisfiable, the plan length k is incremented, additional relevant parts of the problem may need grounding, and the subsequent QBF is passed to the solver. Below, we give an overview of the features and optimizations of our planning tool.\nSince grounding the planning instance can cause an exponential blow-up in the size of the input, we have implemented a dynamic grounding algorithm. This algorithm uses\nideas from the concept of the planning graph [6] to only ground actions that are relevant for a certain plan length. With this optimization, we are able to make the grounding process feasible. Although the planning tool provides several methods to compute lower bounds on the plan length, in our experiments we always started with plan length 0 to allow for a better comparison of the incremental and non-incremental approach.\nOur incremental QBF solver DepQBF is written in C whereas the planning tool is written in Java. To integrate DepQBF in our tool and to employ its features for incremental solving, we implemented a Java interface for DepQBF, called DepQBF4J.4 This way, DepQBF can be integrated into arbitrary Java applications and its API functions can then be called via the Java Native Interface (JNI).\nIn our planning tool, the use of DepQBF\u2019s API is crucial for incremental solving because we have to avoid writing the generated QBFs to a file. Instead, we add and modify the QBFs to be solved directly via the API of DepQBF. The API provides push and pop functions to add and remove frames, i.e., sets of clauses, in a stack-based manner. The CNF part of a QBF is represented as a sequence of frames.\nGiven a planning instance, the workflow starts with plan length k = 0. The QBF \u03c8k for plan length k can be encoded naturally in an incremental fashion by maintaining two frames f0 and f1 of clauses: clauses which encode the goal state are added to f1. All other clauses are added to f0. Frame f0 is added to DepQBF before frame f1. If \u03c8k is unsatisfiable, then f1 is deleted by a pop operation, i.e., the clauses encoding the goal state of plan length k are removed. The plan length is increased by one and additional clauses encoding the possible state transitions from plan length k to k + 1 are added to f0. The clauses encoding the goal state for plan length k + 1 are added to a new f1. Note that in the workflow clauses are added to f0 but this frame is never deleted.\nThe workflow terminates if (1) the QBF \u03c8k is satisfiable, indicating that the instance has a plan with optimal length k, or (2) \u03c8k is unsatisfiable and k + 1 exceeds a userdefined upper bound, indicating that the instance does not have a plan of length k or smaller, or (3) the time or memory limits are exceeded. In the cases (1) and (2), we consider the planning instance as solved. For the experimental evaluation, we imposed an upper bound of 200 on the plan length.\nThe Dungeon benchmark captures the full hardness of problems on the second level of the polynomial hierarchy. Therefore, as shown in the following section, already instances with moderate plan lengths might be hard for QBF solvers as well as for planning-specific solvers [20]. We considered an upper bound of 200 of the plan length to be sufficient to show the difference between the incremental and non-incremental QBF-based approach. The hardness is due to the highly combinatorial nature of the Dungeon instances, which also applies to configuration and maintenance problems. Further, configuration and maintenance problems can be encoded easily into conformant planning as the Dungeon benchmark is essentially a configuration problem.\nOur planning tool can also be combined with any non-incremental QBF solver to determine a plan of minimal length in a non-incremental fashion. This is done by writing the QBFs which correspond to the plan lengths k = 0, 1, . . . under consideration to separate files and solving them with a standalone QBF solver [20].\n4 DepQBF4J is part of the release of DepQBF version 3.03 or later."}, {"heading": "5 Experimental Evaluation", "text": "We evaluate the incremental workflow described in the previous section using planning instances from the Dungeon benchmark. The purpose of our experimental analysis is to compare incremental and non-incremental QBF solving in the context of conformant planning. Thereby, we provide the first empirical study of incremental QBF solving in the planning domain. In addition to [28,29], our results independently motivate the use of incremental QBF solving in other application domains.\nFrom the Dungeon benchmark described in Section 3, we selected 144 planning instances from each variant v0 and v1, resulting in 288 planning instances. Given a planning instance, we allowed 900 seconds wall clock time and 7 GB of memory for the entire workflow, which includes grounding, QBF encoding and QBF solving. All experiments reported were run on AMD Opteron 6238, 2.6 GHz, 64-bit Linux.\nWe first compare the performance of incremental and non-incremental QBF solving in the planning workflow. To this end, we used incremental and non-incremental variants of our QBF solver DepQBF, referred to as incDepQBF and DepQBF, respectively. For non-incremental solving, we called the standalone solver DepQBF by system calls from our planning tool. Thereby, we generated the QBF encoding of a particular planning instance and wrote it to a file on the hard disk. DepQBF then reads the QBF from the file. For incremental solving, we called incDepQBF through its API via the DepQBF4J interface. This way, the QBF encoding is directly added to incDepQBF by its API within the planning tool (as outlined in the previous section), and no files are written. The solvers incDepQBF and DepQBF have the same codebase. Therefore, differences in their performance are due to whether incremental solving is applied or not.\nThe statistics in Tables 1 to 3 and Figure 3 illustrate that incremental QBF solving by incDepQBF outperforms non-incremental solving by DepQBF in the workflow in terms of solved instances, uniquely solved instances (Table 2), run time and in the number of\nbacktracks and assignments spent in QBF solving. With incDepQBF and DepQBF, 166 instances were solved by both. For three of these 166 instances, no plan exists.\nThe different calling principles of incDepQBF (by the API) and DepQBF (by system calls) may have some influence on the overall run time of the workflow, depending on the underlying hardware and operating system. In general, the use of the API avoids I/O overhead in terms of hard disk accesses and thus might save run time. Due to the timeout of 900 seconds and the relatively small number of QBF solver calls in the workflow (at most 201, for plan length 0 up to the upper bound of 200), we expect that the influence of the calling principle on the overall time statistics in Tables 1 and 2 and Figure 3 is only marginal. Moreover, considering backtracks and assignments as shown in Table 3 as an independent measure of the performance of the workflow, incremental solving by incDepQBF clearly outperforms non-incremental solving by DepQBF.\nFigure 2 shows how the number of backtracks evolves if the plan length is increased. On the selected instances which have a plan with optimal length k, we observed peaks in the number of backtracks by incDepQBF and DepQBF on those QBFs which correspond to the plan length k \u2212 1. Thus empirically the final unsatisfiable QBF for plan length k \u2212 1 is harder to solve than the QBF for the optimal plan length k or shorter plan lengths. Figure 2 (right) shows notable exceptions. For k = 6, the number of backtracks by DepQBF increases in contrast to incDepQBF. For k = 5 and k = 7, incDepQBF spent more backtracks than DepQBF. We attribute this difference to the heuristics in (inc)DepQBF. The same QBFs must be solved by incDepQBF and DepQBF in one run of the workflow. However, the heuristics in incDepQBF might be negatively influenced by previously solved QBFs. We made similar observations on instances not solved with either incDepQBF or DepQBF where DepQBF reached a longer plan length than incDepQBF within the time limit.\nIncremental solving performs particularly well on instances for which no plan exists. Considering the ten instances uniquely solved with incDepQBF (Table 2), on aver-\nage it took less than 0.5 seconds to encode and solve one of the 201 unsatisfiable QBFs (i.e., from plan length zero to the upper bound of 200) in the planning workflow. Considering the 13 instances solved using incDepQBF which do not have a plan (Table 1), on average the workflow took 73.80 seconds and incDepQBF spent 35,729 assignments and 135 backtracks. In contrast to that, the workflow using DepQBF took 270.92 seconds on average to solve the five instances which do not have a plan (Table 1), and DepQBF spent 421,619 assignments and 99 backtracks."}, {"heading": "5.1 Preprocessing", "text": "The implementation of (inc)DepQBF does not include preprocessing [5,14]. In general, preprocessing might be very beneficial for the performance of QBF-based workflows. The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].\nIn order to evaluate the potential impact of preprocessing in our workflow, we carried out the following experiment. We ran the workflow using DepQBF on all 288 planning instances with a time limit of 900 seconds and collected all QBFs that were generated this way. Like for the results in Table 1, we ran DepQBF and incDepQBF on these QBFs within our workflow. Additionally, we ran the QBF solver Nenofex [24] because it performed well on QBFs generated from the Dungeon benchmark.5 Nenofex successively eliminates variables in a QBF by expansion at the cost of a possibly exponential blow up of the formula size. Figure 4 shows the run times of DepQBF, incDepQBF, Nenofex and DepQBF-pre, which combines DepQBF with the preprocessor Bloqqer [5]. We accumulated the solving times spent on QBFs that were generated from a particular planning instance. The plot shows these accumulated times for each planning instance. Run times smaller than the time out of 900 seconds do not necessarily indicate that the planning instance was solved because we considered only a subset\n5 Results of Nenofex in the QBF Gallery 2013: http://www.kr.tuwien.ac.at/ events/qbfgallery2013/sc_apps/conf_planning_dungeon.html\nof the QBFs corresponding to the planning instance. The performance of DepQBF-pre and Nenofex shown in Figure 4 illustrates the benefits of preprocessing in the planning workflow. Among other techniques, Bloqqer applies expansion, the core technique used in Nenofex, in a way that restricts the blow up of the formula size [4,7].\nGiven the results shown in Figure 4, preprocessing might considerably improve the performance of incremental QBF solving in our workflow. To this end, it is necessary to combine QBF preprocessing and solving in an incremental way."}, {"heading": "5.2 Comparison to Heuristic Approaches", "text": "Although our focus is on a comparison of non-incremental and incremental QBF solving, we report on additional experiments with the heuristic planning tools ConformantFF [17] and T0 [32]. In contrast to our implemented QBF-based approach to conformant planning, heuristic tools do not guarantee to find a plan with the optimal (i.e., shortest) length. In practical settings, plans with optimal length are desirable. Moreover, the QBF-based approach allows to verify the non-existence of a plan with respect to an upper bound on the plan length. Due to these differences, a comparison based on the run times and numbers of solved instances only is not appropriate.\nRelated to Table 1, ConformantFF solved 169 planning instances, where it found a plan for 144 instances and concluded that no plan exists (with a length shorter than our considered upper bound of 200) for 25 instances. Considering the 124 instances where both incDepQBF and ConformantFF found a plan, for 42 instances the optimal plan found by incDepQBF was strictly shorter than the plan found by ConformantFF. On the\n124 instances, the average (median) length of the plan found by incDepQBF was 2.06 (1), compared to an average (median) length of 3.45 (1) by ConformantFF.\nDue to technical problems, we were not able to run the experiments with T06 on the same system as the experiments with (inc)DepQBF and ConformantFF. Hence the results by T0 reported in the following are actually incomparable to Table 1. However, we include them here to allow for a basic comparison of the plan lengths.\nUsing the same time and memory limits as for incDepQBF and ConformantFF, T0 solved 206 planning instances, where it found a plan for 203 instances and concluded that no plan exists (with a length shorter than the upper bound of 200) for three instances. Given the 156 instances where both incDepQBF and T0 found a plan, for 56 instances the optimal plan found by incDepQBF was strictly shorter than the plan found by T0. On the 156 instances, the average (median) length of the plan found by incDepQBF was 2.25 (1), compared to an average (median) length of 3.08 (2) by T0.\nFrom the 13 instances solved by incDepQBF for which no plan exists (Table 1), none was solved using T0 and 12 were solved using ConformantFF.\nOur experiments confirm that the QBF-based approach to conformant planning finds optimal plans in contrast to the plans found by the heuristic approaches implemented in ConformantFF and T0. Moreover, (inc)DepQBF and other search-based QBF solvers rely on Q-resolution [19] as the underlying proof system. Given a Q-resolution proof \u03a0 of the unsatisfiability of a QBF \u03c8, it is possible to extract from \u03a0 a countermodel [2] or strategy [15] of \u03c8 in terms of a set of Herbrand functions. Intuitively, an Herbrand function fy(xy1 , . . . , xyn) represents the values that a universal variable fy must take to falsify \u03c8 with respect to the values of all existential variables xy1 , . . . , xyn with xyi < y in the prefix ordering. Given a conformant planning problem P , Qresolution proofs and Herbrand function countermodels allow to independently explain and verify [31] the non-existence of a plan (of a particular length) for P by verifying the unsatisfiability of the QBF encoding of P . This is an appealing property of the QBFbased approach. In practical applications, it may be interesting to have an explanation of the non-existence of a plan in addition to the mere answer that no plan exists.\nThe exact QBF-based approach for conformant planning can be combined with heuristic approaches in a portfolio-style system, for example. Thereby, the two approaches are applied in parallel and independently from each other. This way, modern multi-core hardware can naturally be exploited."}, {"heading": "6 Conclusion", "text": "We presented a case study of incremental QBF solving based on a workflow to incrementally encode planning problems into sequences of QBFs. Thereby, we focused on a general-purpose QBF solver. The incremental approach avoids some redundancy. First, parts of the QBF encodings of shorter plan lengths can be reused in the encodings of longer plan lengths. Second, the incremental QBF solver benefits from information that was learned from previously solved QBFs. Compared to heuristic approaches, the QBFbased approach has the advantage that it always finds the shortest plan and it allows to verify the non-existence of a plan by Q-resolution proofs.\n6 Experiments with T0 were run on AMD Opteron 6176 SE, 2.3 GHz, 64-bit Linux\nUsing variants of the solver DepQBF, incremental QBF solving outperforms nonincremental QBF solving in the planning workflow in terms of solved instances and statistics like the number of backtracks, assignments, and run time. The results of our experimental study independently motivate the use of incremental QBF solving in applications other than planning. We implemented the Java interface DepQBF4J to integrate the solver DepQBF in our planning tool. This interface is extensible and can be combined with arbitrary Java applications.\nThe experiments revealed that keeping learned information in incremental QBF solving might be harmful if the heuristics of the solver are negatively influenced. Our observations merit a closer look on these heuristics when used in incremental solving. In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows."}], "references": [{"title": "Improving Glucose for Incremental SAT Solving with Assumptions: Application to MUS Extraction", "author": ["G. Audemard", "J.M. Lagniez", "L. Simon"], "venue": "J\u00e4rvisalo, M., Van Gelder, A. (eds.) SAT. LNCS, vol. 7962, pp. 309\u2013317. Springer", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2013}, {"title": "Unified QBF certification and its applications", "author": ["V. Balabanov", "J.H.R. Jiang"], "venue": "Formal Methods in System Design 41(1), 45\u201365", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Computational Complexity of Planning and Approximate Planning in the Presence of Incompleteness", "author": ["C. Baral", "V. Kreinovich", "R. Trejo"], "venue": "Artificial Intelligence 122(1-2), 241\u2013267", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2000}, {"title": "Resolve and Expand", "author": ["A. Biere"], "venue": "Hoos, H.H., Mitchell, D.G. (eds.) SAT (Selected Papers). LNCS, vol. 3542, pp. 59\u201370. Springer", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2004}, {"title": "Blocked Clause Elimination for QBF", "author": ["A. Biere", "F. Lonsing", "M. Seidl"], "venue": "Bj\u00f8rner, N., Sofronie-Stokkermans, V. (eds.) CADE. LNCS, vol. 6803, pp. 101\u2013115. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Fast Planning Through Planning Graph Analysis", "author": ["A. Blum", "M.L. Furst"], "venue": "Artificial Intelligence 90(1-2), 281\u2013300", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1997}, {"title": "Bounded Universal Expansion for Preprocessing QBF", "author": ["U. Bubeck", "H. Kleine B\u00fcning"], "venue": "Marques-Silva, J., Sakallah, K.A. (eds.) SAT. LNCS, vol. 4501, pp. 244\u2013257. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "An Algorithm to Evaluate Quantified Boolean Formulae and Its Experimental Evaluation", "author": ["M. Cadoli", "M. Schaerf", "A. Giovanardi", "M. Giovanardi"], "venue": "Journal of Automated Reasoning 28(2), 101\u2013142", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2002}, {"title": "A Machine Program for Theorem-proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM 5(7), 394\u2013397", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1962}, {"title": "Temporal Induction by Incremental SAT Solving", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "Electronic Notes in Theoretical Computer Science 89(4), 543\u2013560", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "Conformant Planning as a Case Study of Incremental QBF Solving", "author": ["U. Egly", "M. Kronegger", "F. Lonsing", "A. Pfandler"], "venue": "Aranda-Corral, G.A., Calmet, J., Mart\u0131\u0301n-Mateos, F.J. (eds.) AISC. LNCS, vol. 8884, pp. 120\u2013131. Springer", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Conformant planning as a case study of incremental QBF solving", "author": ["U. Egly", "M. Kronegger", "F. Lonsing", "A. Pfandler"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2016}, {"title": "Clause/Term Resolution and Learning in the Evaluation of Quantified Boolean Formulas", "author": ["E. Giunchiglia", "M. Narizzano", "A. Tacchella"], "venue": "Journal of Artificial Intelligence Research 26, 371\u2013416", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2006}, {"title": "sQueezeBF: An Effective Preprocessor for QBFs Based on Equivalence Reasoning", "author": ["E. Giunchiglia", "P. Marin", "M. Narizzano"], "venue": "Strichman, O., Szeider, S. (eds.) SAT. LNCS, vol. 6175, pp. 85\u201398. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2010}, {"title": "A Uniform Approach for Generating Proofs and Strategies for Both True and False QBF Formulas", "author": ["A. Goultiaeva", "A. Van Gelder", "F. Bacchus"], "venue": "Walsh, T. (ed.) IJCAI. pp. 546\u2013553. AAAI Press", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "A Unified Proof System for QBF Preprocessing", "author": ["M. Heule", "M. Seidl", "A. Biere"], "venue": "Demri, S., Kapur, D., Weidenbach, C. (eds.) IJCAR. LNCS, vol. 8562, pp. 91\u2013106. Springer", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2014}, {"title": "Conformant planning via heuristic forward search: A new approach", "author": ["J. Hoffmann", "R.I. Brafman"], "venue": "Artificial Intelligence 170(6-7), 507\u2013541", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "On QBF Proofs and Preprocessing", "author": ["M. Janota", "R. Grigore", "J. Marques-Silva"], "venue": "McMillan, K.L., Middeldorp, A., Voronkov, A. (eds.) LPAR-19. LNCS, vol. 8312, pp. 473\u2013489. Springer", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2013}, {"title": "Resolution for Quantified Boolean Formulas", "author": ["H. Kleine B\u00fcning", "M. Karpinski", "A. Fl\u00f6gel"], "venue": "Information and Computation 117(1), 12\u201318", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1995}, {"title": "Conformant planning as a benchmark for QBFsolvers", "author": ["M. Kronegger", "A. Pfandler", "R. Pichler"], "venue": "Report Int. Workshop on Quantified Boolean Formulas", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2013}, {"title": "Incremental Preprocessing Methods for Use in BMC", "author": ["S. Kupferschmid", "M.D.T. Lewis", "T. Schubert", "B. Becker"], "venue": "Formal Methods in System Design 39(2), 185\u2013204", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Factoring Out Assumptions to Speed Up MUS Extraction", "author": ["J.M. Lagniez", "A. Biere"], "venue": "J\u00e4rvisalo, M., Van Gelder, A. (eds.) SAT. LNCS, vol. 7962, pp. 276\u2013292. Springer", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "Lemma and Model Caching in Decision Procedures for Quantified Boolean Formulas", "author": ["R. Letz"], "venue": "Egly, U., Ferm\u00fcller, C.G. (eds.) TABLEAUX. LNCS, vol. 2381, pp. 160\u2013175. Springer", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2002}, {"title": "Nenofex: Expanding NNF for QBF Solving", "author": ["F. Lonsing", "A. Biere"], "venue": "Kleine B\u00fcning, H., Zhao, X. (eds.) SAT. LNCS, vol. 4996, pp. 196\u2013210. Springer", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "Incremental QBF Solving", "author": ["F. Lonsing", "U. Egly"], "venue": "O\u2019Sullivan, B. (ed.) CP. LNCS, vol. 8656, pp. 514\u2013530. Springer", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2014}, {"title": "Incremental QBF Solving by DepQBF", "author": ["F. Lonsing", "U. Egly"], "venue": "Hong, H., Yap, C. (eds.) ICMS. LNCS, vol. 8592, pp. 307\u2013314. Springer", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2014}, {"title": "Efficient Clause Learning for Quantified Boolean Formulas via QBF Pseudo Unit Propagation", "author": ["F. Lonsing", "U. Egly", "A. Van Gelder"], "venue": "J\u00e4rvisalo, M., Van Gelder, A. (eds.) SAT. LNCS, vol. 7962, pp. 100\u2013115. Springer", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2013}, {"title": "Incremental QBF Preprocessing for Partial Design Verification - (Poster Presentation)", "author": ["P. Marin", "C. Miller", "B. Becker"], "venue": "Cimatti, A., Sebastiani, R. (eds.) SAT. LNCS, vol. 7317, pp. 473\u2013474. Springer", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2012}, {"title": "Verification of Partial Designs using Incremental QBF Solving", "author": ["P. Marin", "C. Miller", "M.D.T. Lewis", "B. Becker"], "venue": "Rosenstiel, W., Thiele, L. (eds.) DATE. pp. 623\u2013628. IEEE", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2012}, {"title": "Ultimately Incremental SAT", "author": ["A. Nadel", "V. Ryvchin", "O. Strichman"], "venue": "Sinz, C., Egly, U. (eds.) SAT. LNCS, vol. 8561, pp. 206\u2013218. Springer", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2014}, {"title": "Resolution-Based Certificate Extraction for QBF - (Tool Presentation)", "author": ["A. Niemetz", "M. Preiner", "F. Lonsing", "M. Seidl", "A. Biere"], "venue": "Cimatti, A., Sebastiani, R. (eds.) SAT. LNCS, vol. 7317, pp. 430\u2013435. Springer", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2012}, {"title": "Compiling Uncertainty Away in Conformant Planning Problems with Bounded Width", "author": ["H. Palacios", "H. Geffner"], "venue": "Journal of Artificial Intelligence Research 35, 623\u2013675", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2009}, {"title": "Asymptotically Optimal Encodings of Conformant Planning in QBF", "author": ["J. Rintanen"], "venue": "Holte, R.C., Howe, A.E. (eds.) AAAI. pp. 1045\u20131050. AAAI Press", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2007}, {"title": "Partial witnesses from preprocessed quantified Boolean formulas", "author": ["M. Seidl", "R. K\u00f6nighofer"], "venue": "DATE. pp. 1\u20136. IEEE", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2014}, {"title": "Conformant Graphplan", "author": ["D.E. Smith", "D.S. Weld"], "venue": "Mostow, J., Rich, C. (eds.) AAAI/IAAI. pp. 889\u2013896. AAAI Press / The MIT Press", "citeRegEx": "35", "shortCiteRegEx": null, "year": 1998}, {"title": "Towards a Symmetric Treatment of Satisfaction and Conflicts in Quantified Boolean Formula Evaluation", "author": ["L. Zhang", "S. Malik"], "venue": "Hentenryck, P.V. (ed.) CP. LNCS, vol. 2470, pp. 200\u2013 215. Springer", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2002}], "referenceMentions": [{"referenceID": 0, "context": "In the context of SAT, incremental solving [1,10,22,30] has become a state of the art approach.", "startOffset": 43, "endOffset": 55}, {"referenceID": 9, "context": "In the context of SAT, incremental solving [1,10,22,30] has become a state of the art approach.", "startOffset": 43, "endOffset": 55}, {"referenceID": 21, "context": "In the context of SAT, incremental solving [1,10,22,30] has become a state of the art approach.", "startOffset": 43, "endOffset": 55}, {"referenceID": 29, "context": "In the context of SAT, incremental solving [1,10,22,30] has become a state of the art approach.", "startOffset": 43, "endOffset": 55}, {"referenceID": 10, "context": "This article appeared in the proceedings of Artificial Intelligence and Symbolic Computation (AISC) [11].", "startOffset": 100, "endOffset": 104}, {"referenceID": 11, "context": "An extended version appeared in Annals of Mathematics and Artificial Intelligence [12].", "startOffset": 82, "endOffset": 86}, {"referenceID": 34, "context": "Many natural problems, such as repair and therapy planning [35], can be formulated as conformant planning problems.", "startOffset": 59, "endOffset": 63}, {"referenceID": 2, "context": "When restricted to plans of length polynomial in the input size this form of planning is \u03a32P-complete [3], whereas classical planning is NP-complete.", "startOffset": 102, "endOffset": 105}, {"referenceID": 32, "context": "Rintanen [33] presented such transformations.", "startOffset": 9, "endOffset": 13}, {"referenceID": 19, "context": "[20] showed that transforming the planning instance into a sequence of QBFs can be competitive.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "Thereby, we rely on incremental and non-incremental variants of the QBF solver DepQBF [25,26].", "startOffset": 86, "endOffset": 93}, {"referenceID": 25, "context": "Thereby, we rely on incremental and non-incremental variants of the QBF solver DepQBF [25,26].", "startOffset": 86, "endOffset": 93}, {"referenceID": 7, "context": "Search-based QBF solving [8] is a generalization of the DPLL algorithm [9] for SAT.", "startOffset": 25, "endOffset": 28}, {"referenceID": 8, "context": "Search-based QBF solving [8] is a generalization of the DPLL algorithm [9] for SAT.", "startOffset": 71, "endOffset": 74}, {"referenceID": 12, "context": "Modern search-based QBF solvers implement a QBF-specific variant of conflictdriven clause learning (CDCL) for SAT, called QCDCL [13,23,27,36].", "startOffset": 128, "endOffset": 141}, {"referenceID": 22, "context": "Modern search-based QBF solvers implement a QBF-specific variant of conflictdriven clause learning (CDCL) for SAT, called QCDCL [13,23,27,36].", "startOffset": 128, "endOffset": 141}, {"referenceID": 26, "context": "Modern search-based QBF solvers implement a QBF-specific variant of conflictdriven clause learning (CDCL) for SAT, called QCDCL [13,23,27,36].", "startOffset": 128, "endOffset": 141}, {"referenceID": 35, "context": "Modern search-based QBF solvers implement a QBF-specific variant of conflictdriven clause learning (CDCL) for SAT, called QCDCL [13,23,27,36].", "startOffset": 128, "endOffset": 141}, {"referenceID": 18, "context": "The subcase is analyzed and new learned constraints (clauses or cubes) are inferred by Qresolution [19,27].", "startOffset": 99, "endOffset": 106}, {"referenceID": 26, "context": "The subcase is analyzed and new learned constraints (clauses or cubes) are inferred by Qresolution [19,27].", "startOffset": 99, "endOffset": 106}, {"referenceID": 28, "context": "An approach to incremental QBF solving was first presented in the context of bounded model checking [29].", "startOffset": 100, "endOffset": 104}, {"referenceID": 24, "context": "We rely on the general-purpose incremental QBF solver DepQBF [25,26].", "startOffset": 61, "endOffset": 68}, {"referenceID": 25, "context": "We rely on the general-purpose incremental QBF solver DepQBF [25,26].", "startOffset": 61, "endOffset": 68}, {"referenceID": 32, "context": ", by building upon the encodings by Rintanen [33].", "startOffset": 45, "endOffset": 49}, {"referenceID": 34, "context": ", in repair and therapy planning [35], where a plan needs to succeed even if some obstacles arise.", "startOffset": 33, "endOffset": 37}, {"referenceID": 19, "context": "These benchmarks are inspired by adventure computer-games and were first presented at the QBF workshop 2013 [20].", "startOffset": 108, "endOffset": 112}, {"referenceID": 32, "context": "The encoding which is used for this transformation to QBFs builds upon the \u2203\u2200\u2203-encoding described in the work of Rintanen [33].", "startOffset": 122, "endOffset": 126}, {"referenceID": 5, "context": "ideas from the concept of the planning graph [6] to only ground actions that are relevant for a certain plan length.", "startOffset": 45, "endOffset": 48}, {"referenceID": 19, "context": "Therefore, as shown in the following section, already instances with moderate plan lengths might be hard for QBF solvers as well as for planning-specific solvers [20].", "startOffset": 162, "endOffset": 166}, {"referenceID": 19, "context": "under consideration to separate files and solving them with a standalone QBF solver [20].", "startOffset": 84, "endOffset": 88}, {"referenceID": 27, "context": "In addition to [28,29], our results independently motivate the use of incremental QBF solving in other application domains.", "startOffset": 15, "endOffset": 22}, {"referenceID": 28, "context": "In addition to [28,29], our results independently motivate the use of incremental QBF solving in other application domains.", "startOffset": 15, "endOffset": 22}, {"referenceID": 4, "context": "The implementation of (inc)DepQBF does not include preprocessing [5,14].", "startOffset": 65, "endOffset": 71}, {"referenceID": 13, "context": "The implementation of (inc)DepQBF does not include preprocessing [5,14].", "startOffset": 65, "endOffset": 71}, {"referenceID": 20, "context": "The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].", "startOffset": 102, "endOffset": 109}, {"referenceID": 29, "context": "The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].", "startOffset": 102, "endOffset": 109}, {"referenceID": 15, "context": "The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].", "startOffset": 118, "endOffset": 131}, {"referenceID": 17, "context": "The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].", "startOffset": 118, "endOffset": 131}, {"referenceID": 27, "context": "The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].", "startOffset": 118, "endOffset": 131}, {"referenceID": 33, "context": "The efficient combination of preprocessing and incremental solving is part of ongoing research in SAT [21,30] and QBF [16,18,28,34].", "startOffset": 118, "endOffset": 131}, {"referenceID": 23, "context": "Additionally, we ran the QBF solver Nenofex [24] because it performed well on QBFs generated from the Dungeon benchmark.", "startOffset": 44, "endOffset": 48}, {"referenceID": 4, "context": "Figure 4 shows the run times of DepQBF, incDepQBF, Nenofex and DepQBF-pre, which combines DepQBF with the preprocessor Bloqqer [5].", "startOffset": 127, "endOffset": 130}, {"referenceID": 3, "context": "Among other techniques, Bloqqer applies expansion, the core technique used in Nenofex, in a way that restricts the blow up of the formula size [4,7].", "startOffset": 143, "endOffset": 148}, {"referenceID": 6, "context": "Among other techniques, Bloqqer applies expansion, the core technique used in Nenofex, in a way that restricts the blow up of the formula size [4,7].", "startOffset": 143, "endOffset": 148}, {"referenceID": 16, "context": "Although our focus is on a comparison of non-incremental and incremental QBF solving, we report on additional experiments with the heuristic planning tools ConformantFF [17] and T0 [32].", "startOffset": 169, "endOffset": 173}, {"referenceID": 31, "context": "Although our focus is on a comparison of non-incremental and incremental QBF solving, we report on additional experiments with the heuristic planning tools ConformantFF [17] and T0 [32].", "startOffset": 181, "endOffset": 185}, {"referenceID": 18, "context": "Moreover, (inc)DepQBF and other search-based QBF solvers rely on Q-resolution [19] as the underlying proof system.", "startOffset": 78, "endOffset": 82}, {"referenceID": 1, "context": "Given a Q-resolution proof \u03a0 of the unsatisfiability of a QBF \u03c8, it is possible to extract from \u03a0 a countermodel [2] or strategy [15] of \u03c8 in terms of a set of Herbrand functions.", "startOffset": 113, "endOffset": 116}, {"referenceID": 14, "context": "Given a Q-resolution proof \u03a0 of the unsatisfiability of a QBF \u03c8, it is possible to extract from \u03a0 a countermodel [2] or strategy [15] of \u03c8 in terms of a set of Herbrand functions.", "startOffset": 129, "endOffset": 133}, {"referenceID": 30, "context": "Given a conformant planning problem P , Qresolution proofs and Herbrand function countermodels allow to independently explain and verify [31] the non-existence of a plan (of a particular length) for P by verifying the unsatisfiability of the QBF encoding of P .", "startOffset": 137, "endOffset": 141}, {"referenceID": 15, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}, {"referenceID": 17, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}, {"referenceID": 20, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}, {"referenceID": 27, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}, {"referenceID": 28, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}, {"referenceID": 29, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}, {"referenceID": 33, "context": "In general, the combination of preprocessing and incremental solving [16,18,21,28,29,30,34] could improve the performance of QBF-based workflows.", "startOffset": 69, "endOffset": 91}], "year": 2016, "abstractText": "We consider planning with uncertainty in the initial state as a case study of incremental quantified Boolean formula (QBF) solving. We report on experiments with a workflow to incrementally encode a planning instance into a sequence of QBFs. To solve this sequence of successively constructed QBFs, we use our general-purpose incremental QBF solver DepQBF. Since the generated QBFs have many clauses and variables in common, our approach avoids redundancy both in the encoding phase and in the solving phase. Experimental results show that incremental QBF solving outperforms non-incremental QBF solving. Our results are the first empirical study of incremental QBF solving in the context of planning and motivate its use in other application domains.", "creator": "LaTeX with hyperref package"}}}