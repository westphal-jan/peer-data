{"id": "1405.7714", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-May-2014", "title": "The Computational Impact of Partial Votes on Strategic Voting", "abstract": "In appear real world elections, agents often not allow to individual are campaigning. We specialists including of main particularly common requires addition able submit change tougher however might with including partial votes. These methods modify consecutive rules (n't the Borda count ), elimination incorporating any (like five discretized vote) in rules provided immediately brought competition covariance (like Copeland) first. We argue that with of play-off brilliant counted rule like single transferable congressional, limitation voting definitely not possibility before any moved scope contesting. reasons. However, with fourth rules often policies based on after tournament graph, modifications voting can current same helpful leaving strategic balloting is possibility. As perfect arise, the computational complexity called computing only objective conservatives not could. For there, with Borda probably, there processes whose computing came tactical reject can slight much stays the usually example on indeed we eighth modification votes.", "histories": [["v1", "Wed, 28 May 2014 12:13:52 GMT  (34kb)", "http://arxiv.org/abs/1405.7714v1", "To appear in Proceedings of ECAI 2014"]], "COMMENTS": "To appear in Proceedings of ECAI 2014", "reviews": [], "SUBJECTS": "cs.GT cs.AI", "authors": ["nina narodytska", "toby walsh"], "accepted": false, "id": "1405.7714"}, "pdf": {"name": "1405.7714.pdf", "metadata": {"source": "CRF", "title": "The Computational Impact of Partial Votes on Strategic Voting", "authors": ["Nina Narodytska", "Toby Walsh"], "emails": ["nan@cs.toronto.edu", "toby.walsh@nicta.com.au."], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n77 14\nv1 [\ncs .G\nT ]\n2 8\nM ay\n2 01\n4"}, {"heading": "1 INTRODUCTION", "text": "Voting is a simple but general mechanism to aggregate the preferences of multiple agents. Much work in social choice supposes voters declare a complete ordering over all candidates. In practice, however, voting systems often permit voters to declare an ordering over a subset of the candidates. For example, in single transferable vote elections for the Maltese parliament, for the Legislative Assembly of the Australian Capital Territory, and for the President of Ireland, voters rank as many or as few candidates as they wish. When all candidates in a partial vote have been eliminated, this vote is ignored. As a second example, in elections for the Free Software Foundation Europe, voters can again rank as many or as few candidates as they wish. Unranked candidates are considered as equal last when constructing the tournament graph used to compute the Schulze winner. As a third example, the Irish Green Party uses the modified Borda count to elect its chair. Voters can again rank as many or as few candidates as they wish. If a voter ranks just k candidates, then their ith choice is given k \u2212 i+ 1 points. The candidate with the most total points wins.\nPartial voting can have a significant effect on elections [1]. For example, one reason given for the French Academy to drop the Borda count was \u201cvoters had found how to manipulate the Borda rule . . . by truncating their lists\u201d (page 40 of [2]). As a second example, in elections for the Tasmanian Parliament, voters are forced to rank a minimum number of candidates to prevent certain types of strategic voting (for example, when three candidates are running, voters must\n1 University of Toronto, Canada, and UNSW, Sydney, Australia, email: ninan@cs.toronto.edu 2 NICTA and UNSW, Sydney, Australia, email: toby.walsh@nicta.com.au. NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council. The author is also supported by AOARD Grant FA2386-12-1-4056.\nrank at least two candidates, whilst when four or more candidates are running, at least three candidates must be ranked).\nIn this paper, we show that partial voting has a significant impact on computational issues surrounding strategic voting. Partial voting has a similar but not completely identical impact on related problems like computing possible and necessary winners, and campaign management with truncated ballots [3]. For example, manipulating with partial votes is different to the possible winners problem with top truncated ballots [3] since manipulating votes must be complete in the latter problem. On the other hand, manipulating with partial votes is equivalent to the extension bribery problem with zero-costs. One important lesson from this research is that it would be worthwhile to re-visit much previous work in computational social choice which assumes complete votes [4, 5]."}, {"heading": "2 BACKGROUND", "text": "A complete vote is a linear order over the m candidates. We consider partial votes that are a linear order over a strict subset of the m candidates (sometimes called \u201ctop truncated\u201d votes). An interesting extension of this work would be to other forms of partial vote (e.g. when voters only order a subset of the candidate pairs). A voting rule is a function that maps a tuple of votes to the unique winning alternative. We consider several common voting rules defined on complete votes:\nScoring rules: (s1, . . . , sm) is a vector of scores, the ith candidate in a total order scores si, and the winner is the candidate with highest total score. The plurality rule has the vector (1, 0, . . . , 0), whilst the Borda count has the vector (m\u2212 1, m\u2212 2, . . . , 0). Single transferable vote (STV): This proceeds in rounds. Unless one candidate has a majority of first place votes, we eliminate the candidate with the least number of first place votes. Ballots with the eliminated candidate in first place are re-assigned to the second place candidate. We then repeat until a candidate has a majority. Copeland: The candidate with the highest Copeland score wins. The Copeland score of candidate i is \u2211 i6=j(N(i, j) > n 2 ) \u2212\n(N(i, j) < n 2 ) where N(i, j) is the number of voters preferring i to j and n is the number of voters. The Copeland winner is the candidate that wins the most pairwise elections. Formally this is Copeland0.5 but for brevity, we simply write Copeland.\nWe discuss in the next section how these rules can be modified to work with partial votes. All these rules can be easily modified to work with weighted votes. A vote of integer weight w can be viewed as w agents who vote identically. To ensure the winner is unique, we will sometimes need to break ties. A typical assumption made in the literature (and in this paper) is that ties are broken in favour of the\nmanipulator. In real world elections, ties are often broken at random (e.g. by tossing a coin or choosing a random vote). In this case, our results can be seen as deciding if we can give our preferred candidate a non-zero chance of winning.\nWe will consider one agent or a coalition of agents trying to manipulate the result of the election. Manipulation is where these agents vote differently to their true preferences in order to change the outcome whilst the other voters vote truthfully. As in earlier work (e.g. [6, 7]), we consider two cases where computational complexity may provide a shield against manipulation: unweighted votes, a small number of manipulators and an unbounded number of candidates; or weighted votes, a small number of candidates and a coalition of manipulators of unbounded size. We assume that the manipulators have complete knowledge of the other votes. Even though this can be unrealistic in practice, there are several reasons why this case is interesting. First, any computational hardness results for complete information directly imply hardness when there is uncertainty in the votes. Second, results about the hardness of manipulation by a coalition with weighted votes and complete information imply hardness of manipulation by an individual agent with unweighted votes and incomplete information [7]. Third, by assuming complete information, we factor out any complexity coming from the uncertainty model and focus instead on computing just the manipulation."}, {"heading": "3 PARTIAL VOTES", "text": "In practice, voters appear to take advantage of partial voting. As we already noted, it was observed that members of French Academy cast truncated votes in an attempt to manipulate the Borda count. As a second example, in the 1992 General Election for Dublin North, 12 candidates ran, but the 43941 voters ranked only a median of 4 candidates, and a mean of 4.98 candidates, with a standard deviation of 2.88 candidates. In fact, only 8.3% of voters cast a complete vote. Similarly, in the 1992 General Election for Dublin West, 9 candidates ran, but the 29988 voters again ranked only a median of 4 candidates, and a mean of 4.42 candidates, with a standard deviation of 2.33 candidates. In this case, 12.7% of the voters cast a complete vote.\nWe consider a partial vote that ranks just k out of the m candidates. There are a number of different ways that voting rules can be modified to deal with partial votes. We consider three voting rules (Borda count, STV and Copeland) which illustrate the most common ways to treat partial votes. These rules allow us to cover the spectrum of possible impacts that partial voting has on manipulation. With scoring rules like the Borda count, we can adjust the scoring vector to deal with a partial vote (e.g. by shifting it down as in the modified Borda count). With elimination style rules like STV, we can simply ignore votes once all their candidates are eliminated. Finally, with rules based on the tournament graph like Copeland, we can simply treat unranked candidates in a partial vote as tied in last place. We will look at each method for dealing with partial votes in turn."}, {"heading": "4 SCORING RULES", "text": "The first method we study to deal with a partial vote is to shift the scoring vector and score unranked candidates appropriately. Three possible schemes can be found in the literature for dealing with when voters rank just k out of the m candidates (k < m):\nRound up: A candidate ranked in ith place (i \u2264 k) gets a score of si, unranked candidates get a score of 0. For example, a partial vote that only ranks a single candidate gives that candidate a score of s1, and 0 to every other candidate. We denote this Borda\u2191.\nRound down: A candidate ranked in ith place (i \u2264 k) gets a score of sm\u2212(k\u2212i)\u22121, whilst unranked candidates get a score of sm. The modified Borda count is an instance of such rounding down. For example, with the modified Borda count, a partial vote that only ranks a single candidate gives that candidate a score of sm\u2212(1\u22121)\u22121 = sm\u22121 = 1, and 0 to every other candidate. As a second example, a partial vote that ranks two candidates, gives the first ranked candidate a score of sm\u2212(2\u22121)\u22121 = sm\u22122 = 2, a score of sm\u2212(2\u22122)\u22121 = sm\u22121 = 1 to the second ranked candidate and 0 to every one else. If k = m we use Borda count to compute scores. Average score: A candidate ranked in ith place (i \u2264 k) gets a score\nof si, and unranked candidates get \u2211 m\u2265j>k sj\n(m\u2212k) , the average re-\nmaining score. For example, a partial vote that only ranks one out of four possible candidates gives that candidate a score of s1, and s2+s3+s4\n3 , the average of the remaining scores to the other three\ncandidates. We denote this Bordaav .\nWe will show that which of these three schemes we choose to deal with partial votes can have a strong impact on the computational complexity of computing a manipulation."}, {"heading": "4.1 Borda and unweighted votes", "text": "Partial voting increases the situations where an election using the Borda count can be manipulated. For example, suppose we have three candidates (a, b and p) and a manipulator who wants p to win. One vote has been cast for each of a > b > p and b > a > p. With complete votes, a manipulator cannot make p win. The manipulator must cast a vote that gives at least one point to a or b thereby defeating p. However, with Borda\u2191, the manipulator can cast a vote for just p who wins by tie-breaking. Partial voting can also change the computational complexity of computing a manipulation. With complete votes, computing if two voters can manipulate the Borda count is NP-hard [8, 9]. On the other hand, with partial voting and rounding up, computing such a manipulation takes polynomial time.\nProposition 1 Computing if a coalition of manipulators can manipulate Borda\u2191 with unweighted and partial votes takes polynomial time.\nProof: The manipulators simply vote for the candidate who they wish to win and no one else. This is the best possible vote.\nIf we treat partial votes by rounding down or averaging the remaining scores, computing a manipulation remains intractable.\nProposition 2 Computing if two voters can manipulate the modified Borda count or Bordaav with unweighted and partial votes is NPhard.\nProof: We use the same reduction as in [8]. To ensure that the preferred (first) candidate with an initial score of C wins and that the n + 2th (of n + 3) candidate with an initial score of 2(n + 2) + C does not, the two manipulators must cast a complete vote for all n+3 candidates with their preferred candidate in the first place, and the n + 2th candidate in the last place for Bordaav . If we use the modified Borda count, manipulators can also cast partial votes of length n+2 with their preferred candidate in the first place and the n+2th candidate not ranked. This also achieves the manipulators\u2019 goal of reducing the gap between the preferred candidate and the n + 2th candidate to 0. Hence, partial voting does not increase the ability of the manipulators to manipulate the problem instances used in the reduction."}, {"heading": "4.2 Borda and weighted votes", "text": "We now turn to weighted votes. With complete votes, computing a coalition manipulation of the Borda count with just 3 candidates is NP-hard [7]. With partial votes and rounding up, computing such a manipulation now takes polynomial time.\nProposition 3 Computing a coalition manipulation of Borda\u2191 with weighted and partial votes takes polynomial time.\nProof: The coalition simply votes for their most preferred candidate and no one else.\nOn the other hand, if we treat partial votes by rounding down or averaging the remaining scores, computing a coalition manipulation remains computationally intractable.\nProposition 4 Computing a coalition manipulation of the modified Borda count with weighted and partial votes and 3 candidates is NPhard.\nProof: Reduction from the number partitioning problem. We have a bag of integers, ki summing to 2K and wish to decide if we can divide them into two partitions, each with sum K. We consider an election over three candidates, a, b and p in which the manipulating coalition wish p to win. We have partial votes of weight 3K for a and for b. Hence, the score of a is 3K and the score of b is 3K.\nThe voters in the coalition each have weight ki. We identify voters in the coalition by the corresponding integer ki. Suppose a partition exists. Let those manipulators in one partition vote p > a > b and the others vote p > b > a. Now, a, b and p all have scores of 4K so p wins by tie breaking. Conversely, suppose p wins. We can suppose no manipulator votes for just a or just b (as this is counter-productive). Suppose the manipulators have votes of weight x for p > a > b, y for p > b > a and z for just p. Aside: a vote for p > a is the same as one for p > a > b as only p gets two points and a gets one point in these votes, similarly a vote for p > b is the same as one for p > b > a. Now x+ y + z = 2K. Since p wins, p beats a. That is, 2(x+ y) + z \u2265 3K + x. This simplifies to (x+ y + z) + y \u2265 3K. Substituting x + y + z = 2K gives y \u2265 K. Similarly, p beats b. That is 2(x + y) + z \u2265 3K + y. Again this gives x \u2265 K. But z = 2K \u2212 x\u2212 y. Hence, z \u2264 0. Thus, x = y = K and z = 0. That is, we have a perfect partition. Note that the proof in [10] showing that coalition manipulation of the Borda count with weighted and complete votes is NP-hard does not work for the modified Borda count. In this reduction, the final scores (of 24K and 24K \u2212 3) are not close enough to preclude a manipulation using both complete and partial votes even when there is no perfect partition.\nFor Bordaav , computing a coalition manipulation with partial votes is also NP-hard. We have a relatively simple proof for 4 candidates based on a reduction from number partitioning similar to that for the modified Borda count. For 3 candidates, our proof is much more complex and requires reduction from a very specialized subset sum problem which we prove is itself NP-hard.\nProposition 5 Computing a coalition manipulation of Bordaav with weighted and partial votes and 3 candidates is NP-hard.\nProof: The proof uses a reduction from a specialized subset sum problem with repetition. Given a bag of positive integers S, such that S can be partitioned into pairs of identical numbers, and a target sum t, we consider deciding if there is a subset S\u2032 of S whose sum is t. To show that this subset sum problem is NP-hard, we modify the reduction of 3SAT to subset sum in [20]. Consider a CNF formula with n\nvariables and m clauses. For each literal xi and x\u0304i we introduce two equal numbers, yi, y\u2032i, yi = y \u2032 i, and zi, z \u2032 i, zi = z \u2032 i, i = 1, . . . , n, respectively. For each clause Cj we introduce two equal numbers, gj and g\u2032j , j = 1, . . . , m. By construction, it follows that numbers in S can be partitioned into pairs of identical numbers. Each number yi, y\u2032i, zi, z \u2032 i, gj and g \u2032 j is a decimal number with n + m digits. We call the first n digits variable-digits and the last m digits clausedigits. Consider the yi number, i = 1, . . . , n. The ith digit in yi is one. If Cj contains xi then the (n + j)th digit is 1. The remaining digits are zeros. The y\u2032i number is identical to yi, i = 1, . . . , n. Similarly, we define numbers zi(z\u2032i), i = 1, . . . , n. The ith digit in zi is one. If Cj contains x\u0304i then the (n + j)th digit is 1. The remaining digits are zeros. Consider numbers gj(g\u2032j), i = 1, . . . ,m. The (n+ j)th digit is 1. The remaining digits are zeros. Finally, we introduce the target number t. The first n digits equal one and the last m digits equal 3.\nAssignment encoding. As first n variable-digits of t are ones, only one of the numbers yi, y\u2032i, zi, z \u2032 i can be selected to S\n\u2032. Hence, selection of yi or y\u2032i to S\n\u2032 encodes that xi = 1, and a selection of zi or z\u2032i to S\u2032 encodes that xi = 0.\nChecking an assignment. Last m clause-digits of t equal 3. Consider a clause Cj = (xi, x\u0304s, xk). If none of the variables yi, y \u2032 i, zs, z \u2032 s, yk and y \u2032 k is selected to the set S\n\u2032 then the maximum value in the (n + j)th digit is two. Hence, one of these variables must be selected. The reverse direction is trivial. Hence, this subset sum problem with repetition is NP-hard.\nWe use this problem to show NP-hardness of coalition manipulation of Bordaav with 3 candidates. Given a set of positive integers S = {s1, s\u20321 . . . , s \u2032 n, sn}, such that all elements of S can be partitioned into pairs of identical numbers, {si, s\u2032i}, i = 1, . . . , n, and a target sum t1, we consider if there is a subset of S, S\u2032, whose sum is t1. We assume that t =\n\u2211 si\u2208S (si + s \u2032 i). We denote\nt2 = t \u2212 t1. We have an election over three candidates (a, b and p) in which the manipulating coalition wish p to win. We have one complete vote of weight t1 for a > b > p and one complete vote of weight t2 b > a > p. The total scores from non-manipulators are score(a) = 2t1 + t2 = t1 + t, score(b) = 2t2 + t1 = t2 + t and score(p) = 0. The voters in the coalition each have weight (si+s\u2032i). Suppose a subset sum S\u2032 exists. Consider three cases. If si and s\u2032i are in S\u2032 then the ith manipulator votes p > b > a. If si and s\u2032i are not in S\u2032 then the ith manipulator votes p > a > b. If si is in and s\u2032i is not in S\n\u2032 then the ith manipulator votes p. Hence, a and b get si = s \u2032 i points each. The case when si is not in and s \u2032 i is in S\n\u2032 is similar. As S\u2032 exists, the score of b from manipulators is exactly the sum of numbers in S\u2032 which is equal to t1. The preferred candidate p gets 2t points which is the sum of all elements in S multiplied by 2. Finally, a gets t2 points which is the sum of all elements in S \\ S\u2032. Hence, the total scores are score(a) = t1 + t + t2 = 2t, score(b) = t2 + t + t1 = 2t and score(p) = 2t. The preferred candidate p wins by the tie-breaking rule.\nConversely, suppose p wins. We show that p wins iff p is ranked first in all manipulators votes. Suppose p\u2019s score is 2t\u2212 \u01eb, \u01eb > 0, so that it is not ranked first in all manipulator votes. Hence, a and b have to share t+ \u01eb points between them as we have 3t points to distribute. Let a get q1 and b get q2 points out of t+ \u01eb points, q1 + q2 = t+ \u01eb. For p to be a co-winner the following must hold: t+ t1+q1 \u2264 2t\u2212\u01eb and t + t2 + q2 \u2264 2t \u2212 \u01eb. If we sum up these two inequalities we get 2t + (t1 + t2) + (q1 + q2) = 4t \u2212 \u01eb \u2264 4t \u2212 2\u01eb. This leads to a contradiction. Therefore, p is ranked first in all manipulators votes. In this case, there are exactly t points that the manipulators have to distribute between a and b. Let a get q1 and b get q2 points out of\nt points, q1 + q2 = t. We also know that t + t1 + q1 \u2264 2t and t + t2 + q2 \u2264 2t. Hence, q1 \u2264 t \u2212 t1 = t2 and q2 \u2264 t \u2212 t2 = t1. As q1 + q2 = t, q1 = t2 and q2 = t1. In a successful manipulation there are three types of votes: p > a > b, p > b > a and p. If the ith manipulator votes p > b > a then b gets si + s\u2032i points and we say that si and s\u2032i belong to S\n\u2032. If the ith manipulator votes p then b gets si points and we say that si belongs to S\u2032. If the ith manipulator votes p > a > b then b gets 0 points. As b1 gets exactly t1 then the sum of the numbers in S\u2032 is exactly t1.\nFor other scoring rules besides the Borda count, it appears likely that similar results can be given for the impact of partial voting on weighted and unweighted manipulation."}, {"heading": "5 SINGLE TRANSFERABLE VOTE", "text": "We now consider the second type of method for dealing with partial votes. For elimination style rules like STV, a method analogous to rounding up for scoring rules is used in many real world settings. We simply ignore a partial vote once all the candidates in the vote have been eliminated. Unlike with the Borda count, partial voting in STV elections does not permit more manipulations to take place.\nProposition 6 Under STV, if a coalition of agents can cast partial votes to ensure a given candidate wins then they can also cast complete votes for the same outcome.\nProof: Suppose the agents can cast partial votes to ensure a given candidate p wins. We can complete each of their votes without changing the outcome of the election. We simply add p to the end of the partial vote (if it does not already include p). Then we add the remaining candidates in any order. Such a completion does not change the result. If the partial vote included p, then the completion will never be considered. If the partial vote didn\u2019t include p, then we have merely added another vote for p from the point that all the candidates in the partial vote have been eliminated. This only helps p to win.\nSince partial voting does not change which elections can be manipulated, it follows immediately that the computational complexity of computing a manipulation of STV remains unchanged when we permit partial voting. In particular, with weighted votes, computing a coalition manipulation of STV with 3 candidates and complete votes is NP-hard [7]. The problem remains computationally intractable when the manipulating coalition can cast partial votes. Similarly, with unweighted votes, it is NP-hard for a single agent to compute a strategic manipulating vote of STV [6]. The problem again remains computationally intractable with partial voting. It would be interesting to identify other voting rules where partial voting has no impact on manipulation. Not all elimination style rules are unchanged by partial voting. For instance, it is easy to see that Borda style elimination rules like Nanson and Baldwin are impacted by partial voting."}, {"heading": "6 TOURNAMENT GRAPH RULES", "text": "We now consider the third method for dealing with partial votes. For voting rules based on the tournament graph like Copeland, a method for dealing with partial votes analogous to rounding up for scoring rules is used in several real world settings. More particularly, we consider unranked candidates to be tied in last place. Such partial voting increases the situations where manipulation is possible. Suppose we have 4 candidates: a, b, c and p. One vote each has been cast for a > b > c > p, b > c > a > p, and p > c > a > b. We have one manipulator who wants p to win. If the manipulator casts\na partial vote that just ranks p in first place then every candidate has a Copeland score of 0, and p wins by tie breaking. Hence, there is a successful manipulation with partial voting. On the other hand, suppose the manipulator must cast a complete vote. Now a, b and c are symmetric. They each tie with p (supposing p is ranked in first place by the manipulator), and in the fixed votes, each beats one candidate and is beaten by one other candidate. Without loss of generality, we can suppose therefore that the manipulator casts the complete vote p > a > b > c. In this case, a wins with a Copeland score of 1. Hence, with complete voting, manipulation is not possible."}, {"heading": "6.1 Copeland and unweighted votes", "text": "With complete votes, a simple greedy method will compute a strategic vote for a single agent to manipulate the result of Copeland\u2019s method in polynomial time when this is possible [11]. We can adapt this method to construct a strategic partial vote. Our adaptation adds an additional stopping condition which exits the procedure early with a successful partial vote. We suppose, as before, that we break ties in favour of the manipulator. It is, however, easy to relax this assumption. The initial step of the greedy manipulation procedure is to rank the preferred candidate p in first place. We then repeat the following steps. If the Copeland score of p is greater than or equal to the current Copeland scores of all the other candidates, we stop as we have a (possibly partial) vote with the desired outcome. Alternatively, we still need to reduce the Copeland scores of one or more \u201cdangerous\u201d candidates by voting for a \u201charmless\u201d candidate. To do this, we determine if there is a candidate who can be placed in the next position in the partial vote without giving this candidate a Copeland score exceeding that of p. We add this candidate to the partial vote and repeat. If there is no such candidate, then we terminate as p cannot win.\nProposition 7 For Copeland\u2019s method, there is a greedy manipulation procedure which finds a strategic partial vote in polynomial time that makes a given candidate win whenever this is possible.\nProof: Suppose the procedure fails but there exists a partial vote \u03a0 that makes the given candidate p win. Consider the highest candidate c not appearing in the partial vote constructed by the greedy manipulation procedure before it failed. If we add c to this partially constructed vote then c has a lower Copeland score than if we added the vote \u03a0. Hence, there was a candidate who could be harmlessly placed in the next position in the vote. The greedy manipulation procedure should not therefore have terminated unsuccessfully."}, {"heading": "6.2 Copeland and weighted votes", "text": "With complete votes, it is NP-hard to compute a weighted coalition manipulation of Copeland\u2019s method. As we argued earlier, partial voting increases our ability to manipulate such elections. However, it remains computationally intractable to compute such a manipulation.\nProposition 8 Computing a coalition manipulation of Copeland\u2019s method with weighted and partial votes and 4 candidates is NP-hard.\nProof: Reduction from number partitioning. We are given a bag of integers ki with sum 2K and wish to determine if there is a partition into two bags each of sum K. There are 4 candidates, a, b, c and p where p is the candidate that the manipulating coalition prefers to win. We suppose there are K fixed identical votes for a > b > c > p and K for a > c > b > p. The manipulating coalition has a voter of weight ki for each integer in the bag being partitioned. Suppose there\nis a perfect partition, and the voters corresponding to one partition vote p > b > c > a and in the other vote p > c > b > a. Then all candidates have a Copeland score of 0, and p wins by the tie-breaking rule. On the other hand, suppose that the manipulating coalition can vote so that p wins. Without loss of generality, we can suppose that they all rank p first. This is the best possible outcome for p, giving p a Copeland score of 0. The manipulating coalition cannot therefore cast votes that result in a, b or c having a Copeland score greater than 0. Now, without the votes of the manipulating coalition, a has a Copeland score of 3. The manipulating coalition must all prefer b and c to a to reduce this score. Hence every member of the manipulating coalition must rank b and c. Finally, b and c are tied before the manipulating coalition votes. If b is preferred to c overall then b has a Copeland score of 1. Similarly, if c is preferred to b overall then c has a Copeland score of 1. Hence, b and c must tie. This is only possible if the manipulating coalition cast votes of weight K for b > c and of weight K for c > a. Thus, the manipulating coalition must cast complete votes of weight K for p > b > c > a and of weight K for p > c > b > a.\nNote that we cannot use the reduction used in proving the NPhardness of coalition manipulation of Copeland\u2019s method with complete votes and 4 candidates [7]. By casting a partial vote for just p and leaving all other candidates unranked, the manipulating coalition can make the preferred candidate p win in this reduction even if there is not a perfect partition. This proof also requires that we break ties against the manipulating coalition whilst our proof makes the (more common?) assumption that we break ties in favor of the manipulating coalition. With just 3 candidates and tie breaking in favour of the manipulators, coalition manipulation of Copeland\u2019s method with weighted and complete votes is NP-hard (Theorem 4.1 in [12]). Unfortunately, the reduction used in this proof fails for partial votes. We conjecture that the problem of computing a manipulation of Copeland\u2019s method is NP-hard with partial votes and 3 candidates. However, any proof looks as involved as that required for Bordaav .\nOur results for Borda, STV and Copeland voting rules with complete and partial votes are summarised in Table 1."}, {"heading": "7 INTRODUCING INTRACTABILITY", "text": "We have seen that partial voting has a range of effects on the computational complexity of computing a manipulation.\n1. Partial voting does not change when strategic voting is possible, and thus there is no change also in the computational cost of computing a strategic vote (e.g. STV). 2. Partial voting permits more strategic voting but there is no change in the worst case complexity of computing a strategic vote (e.g. the modified Borda count). 3. Partial voting permits more strategic voting and the worst case complexity of computing a strategic vote decreases (e.g. Borda\u2191)\nWe now demonstrate the fourth and final possibility: partial voting permits more strategic voting and the worst case complexity of computing a strategic vote increases. This occurs when a strategic but complete vote takes polynomial time to compute whilst a strategic but partial vote is NP-hard to compute. In fact, our proof that demonstrates there exists a subclass of elections where computing a manipulation with complete votes takes polynomial time (because it is never possible), but with partial votes and two manipulators it is NPhard.\nProposition 9 There exists a variant of Borda voting, and a class of elections where it takes polynomial time for two agents to compute their strategic vote when they must cast complete votes but it is NPhard with partial votes.\nProof: We consider the scoring rule in which a candidate ranked in ith position gets a score of m\u2212 i+2 where m is the total number of candidates. Hence the last ranked candidate in a complete vote gets a score of 2. With partial votes, we suppose scores are rounded down. That is, if only k candidates are ranked, then the ith ranked candidates gets a score of k \u2212 i+ 2, and unranked candidates get a score of 0. We adapt the reduction used in [8]. We add one \u201cdangerous\u201d candidates (to give n + 4 candidates in total). This candidate gets a score from the fixed votes of C + 2(n + 4). All other candidates get the same score as in the reduction in [8]. Now, if either of the manipulating agents casts a complete vote, the dangerous candidate increases their score so is sure to win. In fact, the only way for the dangerous candidate not to win is for both manipulating agents to cast a partial vote ranking all but the dangerous candidate. With such a vote, the dangerous candidate will draw with the other leading scorers. The proof then follows the same argument as in [8]."}, {"heading": "8 PARTIAL VOTING IN PRACTICE", "text": "We analysed of the partiality of voting in real world data sets. We analysed the following data sets from PrefLib [21]: Irish Election, Debian Project, Electoral Reform Society (ERS), Glasgow City Council, F1 and Skiing and Sushi. In many elections, more than half of the votes contain less than half of the candidates. Therefore, manipulators have to deal with partial votes. For each set, we picked several instances and generated 100 elections with t randomly picked votes from the set of votes in the benchmark, where t \u2208 {32, 64}. On top of this, we vary the length of manipulators\u2019 votes. For each problem instance, we computed the optimal manipulation with a timeout of 1000 sec. Table 2 summarizes our results.\nWe partition instances into two groups. The first group contains instances with up to 20 candidates. The second group contains instances with more than 54 candidates. Based on the size of the candidate list, we varied the length of the manipulators\u2019 votes differently in these groups. In the first group the lengths of manipulators\u2019 votes are 3, 6 or 9 and, in the second group, they are 15, 30 or 45. Then we computed the average time and the average number of manipulators in the optimal manipulation over solved instances with partial or full votes. It can be seen from the table that there is little correlation between complexity in practice of finding optimal manipulation with partial and full votes for Borda\u2191. On the other hand, for the modified Borda count, finding an optimal manipulation with full votes is slightly more expensive. The number of manipulators decreases as the length of the manipulators\u2019 votes increases for Borda\u2191. In contrast, it stays within a 15% corridor in many benchmarks with the modified Borda count."}, {"heading": "9 CONCLUSIONS", "text": "In many elections, voters can cast partial votes. We have studied three of the most common methods used to modify voting rules to deal with such partial votes. These methods modify scoring rules, elimination rules and rules based on the tournament graph respectively. We argued that partial voting may not change the situations where strategic voting is possible (e.g. with STV). However, with the Borda count and Copeland\u2019s method, partial voting increases the situations where strategic voting is possible. As a consequence, the computational complexity of computing a manipulation can change. For example, with the Borda count, the complexity can decrease or stay the same depending on how we score partial votes. We were even able to demonstrate a situation where the computational complexity of computing a manipulation increases when we permit partial voting.\nOur results are worst-case and may not reflect the difficulty of manipulation in practice. A number of recent theoretical and empirical results suggest that manipulation can often be computationally easy on average (e.g. [13] - [19]). Our NP-hardness results should therefore be seen as just one of the first steps in understanding the impact of partial voting on the computational complexity of computing a manipulation. There are many other interesting directions to follow. For example, do results like these suggest which is the best way to deal with partial voting? Might we increase our bias for STV over the Borda count based on its resistance to manipulation by partial voting. As a second example, how does partial voting impact on computational issues surrounding related problems like possible and necessary winners, control and bribery?"}], "references": [{"title": "The original Borda count and partial voting", "author": ["P. Emerson"], "venue": "Social Choice and Welfare", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2013}, {"title": "Campaigns for lazy voters: truncated ballots", "author": ["D. Baumeister", "P. Faliszewski", "J. Lang", "J. Rothe"], "venue": "In: International Conference on Autonomous Agents and Multiagent Systems (AAMAS", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "AI\u2019s war on manipulation: Are we winning", "author": ["P. Faliszewski", "A. Procaccia"], "venue": "AI Magazine", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2010}, {"title": "Using complexity to protect elections", "author": ["P. Faliszewski", "E. Hemaspaandra", "L. Hemaspaandra"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2010}, {"title": "Single transferable vote resists strategic voting", "author": ["J. Bartholdi", "J. Orlin"], "venue": "Social Choice and Welfare", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1991}, {"title": "When are elections with few candidates hard to manipulate", "author": ["V. Conitzer", "T. Sandholm", "J. Lang"], "venue": "JACM", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "Complexity of and algorithms for Borda manipulation", "author": ["J. Davies", "G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "Proceedings of 25th AAAI Conference on Artificial Intelligence (AAAI", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Unweighted coalitional manipulation under the Borda rule is NP-Hard", "author": ["N. Betzler", "R. Niedermeier", "G. Woeginger"], "venue": "Proceedings of 22nd IJCAI,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Complexity of manipulating elections with few candidates", "author": ["V. Conitzer", "T. Sandholm"], "venue": "Proceedings of 18th National Conference on Artificial Intelligence,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2002}, {"title": "The computational difficulty of manipulating an election", "author": ["J. Bartholdi", "C. Tovey", "M. Trick"], "venue": "Social Choice and Welfare", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1989}, {"title": "Copeland voting: ties matter", "author": ["P. Faliszewski", "E. Hemaspaandra", "H. Schnoor"], "venue": "Joint Conference on Autonomous Agents and Multiagent Systems", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "Nonexistence of voting rules that are usually hard to manipulate", "author": ["V. Conitzer", "T. Sandholm"], "venue": "Proceedings of 21st National Conference on Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2006}, {"title": "Junta distributions and the averagecase complexity of manipulating elections", "author": ["A.D. Procaccia", "J.S. Rosenschein"], "venue": "JAIR", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2007}, {"title": "Generalized scoring rules and the frequency of coalitional manipulability", "author": ["L. Xia", "V. Conitzer"], "venue": "EC \u201908: Proceedings of 9th ACM Conference on Electronic Commerce,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Elections can be manipulated often", "author": ["E. Friedgut", "G. Kalai", "N. Nisan"], "venue": "Proceedings 49th FOCS, IEEE Computer Society", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2008}, {"title": "Where are the really hard manipulation problems? The phase transition in manipulating the veto rule", "author": ["T. Walsh"], "venue": "Proceedings of 21st International Joint Conference on Artificial Intelligence", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "An empirical study of the manipulability of single transferable voting", "author": ["T. Walsh"], "venue": "Proceedings of 19th European Conference on Artificial Intelligence (ECAI-2010). IOS Press", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2010}, {"title": "Where are the hard manipulation problems", "author": ["T. Walsh"], "venue": "JAIR", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2011}, {"title": "Computational models (2009) Spring 2009, Lecture 14, http://www.cs.tau.ac.il/ bchor/CM09/Computer14.pdf", "author": ["B. Chor"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2009}, {"title": "PrefLib: A Library of Preference Data", "author": ["N. Mattei", "T. Walsh"], "venue": "Proceedings of 3rd International Conference on Algorithmic Decision Theory (ADT", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2013}, {"title": "Algorithms for the coalitional manipulation problem", "author": ["M. Zuckerman", "A. Procaccia", "J. Rosenschein"], "venue": "Artificial Intelligence", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "Partial voting can have a significant effect on elections [1].", "startOffset": 58, "endOffset": 61}, {"referenceID": 1, "context": "lems like computing possible and necessary winners, and campaign management with truncated ballots [3].", "startOffset": 99, "endOffset": 102}, {"referenceID": 1, "context": "top truncated ballots [3] since manipulating votes must be complete in the latter problem.", "startOffset": 22, "endOffset": 25}, {"referenceID": 2, "context": "One important lesson from this research is that it would be worthwhile to re-visit much previous work in computational social choice which assumes complete votes [4, 5].", "startOffset": 162, "endOffset": 168}, {"referenceID": 3, "context": "One important lesson from this research is that it would be worthwhile to re-visit much previous work in computational social choice which assumes complete votes [4, 5].", "startOffset": 162, "endOffset": 168}, {"referenceID": 4, "context": "[6, 7]), we consider two cases where computational complexity may provide a shield against manipulation: unweighted votes, a small number of manipulators and an unbounded number of candidates; or weighted votes, a small number of candidates and a coalition of manipulators of unbounded size.", "startOffset": 0, "endOffset": 6}, {"referenceID": 5, "context": "[6, 7]), we consider two cases where computational complexity may provide a shield against manipulation: unweighted votes, a small number of manipulators and an unbounded number of candidates; or weighted votes, a small number of candidates and a coalition of manipulators of unbounded size.", "startOffset": 0, "endOffset": 6}, {"referenceID": 5, "context": "of manipulation by an individual agent with unweighted votes and incomplete information [7].", "startOffset": 88, "endOffset": 91}, {"referenceID": 6, "context": "With complete votes, computing if two voters can manipulate the Borda count is NP-hard [8, 9].", "startOffset": 87, "endOffset": 93}, {"referenceID": 7, "context": "With complete votes, computing if two voters can manipulate the Borda count is NP-hard [8, 9].", "startOffset": 87, "endOffset": 93}, {"referenceID": 6, "context": "Proof: We use the same reduction as in [8].", "startOffset": 39, "endOffset": 42}, {"referenceID": 5, "context": "coalition manipulation of the Borda count with just 3 candidates is NP-hard [7].", "startOffset": 76, "endOffset": 79}, {"referenceID": 8, "context": "Note that the proof in [10] showing that coalition manipulation of the Borda count with weighted and complete votes is NP-hard does not work for the modified Borda count.", "startOffset": 23, "endOffset": 27}, {"referenceID": 18, "context": "show that this subset sum problem is NP-hard, we modify the reduction of 3SAT to subset sum in [20].", "startOffset": 95, "endOffset": 99}, {"referenceID": 5, "context": "In particular, with weighted votes, computing a coalition manipulation of STV with 3 candidates and complete votes is NP-hard [7].", "startOffset": 126, "endOffset": 129}, {"referenceID": 4, "context": "Similarly, with unweighted votes, it is NP-hard for a single agent to compute a strategic manipulating vote of STV [6].", "startOffset": 115, "endOffset": 118}, {"referenceID": 9, "context": "gic vote for a single agent to manipulate the result of Copeland\u2019s method in polynomial time when this is possible [11].", "startOffset": 115, "endOffset": 119}, {"referenceID": 5, "context": "Note that we cannot use the reduction used in proving the NPhardness of coalition manipulation of Copeland\u2019s method with complete votes and 4 candidates [7].", "startOffset": 153, "endOffset": 156}, {"referenceID": 10, "context": "1 in [12]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 6, "context": "We adapt the reduction used in [8].", "startOffset": 31, "endOffset": 34}, {"referenceID": 6, "context": "All other candidates get the same score as in the reduction in [8].", "startOffset": 63, "endOffset": 66}, {"referenceID": 6, "context": "The proof then follows the same argument as in [8].", "startOffset": 47, "endOffset": 50}, {"referenceID": 19, "context": "We analysed the following data sets from PrefLib [21]: Irish Election, Debian Project, Electoral Reform Society (ERS), Glasgow City Council, F1 and Skiing and Sushi.", "startOffset": 49, "endOffset": 53}, {"referenceID": 11, "context": "[13] - [19]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[13] - [19]).", "startOffset": 7, "endOffset": 11}], "year": 2014, "abstractText": "In many real world elections, agents are not required to rank all candidates. We study three of the most common methods used to modify voting rules to deal with such partial votes. These methods modify scoring rules (like the Borda count), elimination style rules (like single transferable vote) and rules based on the tournament graph (like Copeland) respectively. We argue that with an elimination style voting rule like single transferable vote, partial voting does not change the situations where strategic voting is possible. However, with scoring rules and rules based on the tournament graph, partial voting can increase the situations where strategic voting is possible. As a consequence, the computational complexity of computing a strategic vote can change. For example, with Borda count, the complexity of computing a strategic vote can decrease or stay the same depending on how we score partial votes.", "creator": "LaTeX with hyperref package"}}}