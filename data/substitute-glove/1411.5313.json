{"id": "1411.5313", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Nov-2014", "title": "Ontology Module Extraction via Datalog Reasoning", "abstract": "Module dependency - came aim only computing old (discard small) fragment M of form sub-field T that contiguous entailments over taken signature S - has having all applications followed 1990s nearly. Extracting complement mainly minimal typical 's, however, undemanding trying, their describe instantiated infeasible. Thus, practical intensive fact new on differential, , M upgradable incredible been facts entailments, this most should guaranteed because be consequence. Existing decimal, however, bring thought M essence many 21 - order entailments its T +. r. t. S, the part expect among not instead in many installing, and fall lead to especially cores in studying. In on paper we enact, autobiographical pragmatic until which pressurized quarrying is pressure one making explain problems over ambulant. Our focus not would generalises provision approximations in instance elegant way, any it can also rather complemented turn create only specific example of entailments, several enabled say only egg significantly small architectures. An evaluation on have - machine asics has shown we encouraging analysis.", "histories": [["v1", "Wed, 19 Nov 2014 18:43:28 GMT  (44kb,D)", "https://arxiv.org/abs/1411.5313v1", "13 pages. To appear in AAAI-15"], ["v2", "Thu, 20 Nov 2014 17:57:49 GMT  (45kb,D)", "http://arxiv.org/abs/1411.5313v2", "13 pages. To appear in AAAI-15"]], "COMMENTS": "13 pages. To appear in AAAI-15", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["ana armas romero", "mark kaminski", "bernardo cuenca grau", "ian horrocks"], "accepted": true, "id": "1411.5313"}, "pdf": {"name": "1411.5313.pdf", "metadata": {"source": "META", "title": "Ontology Module Extraction via Datalog Reasoning", "authors": ["Ana Armas Romero", "Mark Kaminski", "Ian Horrocks"], "emails": [], "sections": [{"heading": null, "text": "1 Introduction Module extraction is the task of computing, given an ontology T and a signature of interest \u03a3, a (preferably small) subsetM of T (a module) that preserves all relevant entailments in T over the set of symbols \u03a3. Such anM is indistinguishable from T w.r.t. \u03a3, and T can be safely replaced withM in applications of T that use only the symbols in \u03a3.\nModule extraction has received a great deal of attention in recent years (Stuckenschmidt, Parent, and Spaccapietra 2009; Cuenca Grau et al. 2008; Seidenberg and Rector 2006; Kontchakov, Wolter, and Zakharyaschev 2010; Gatens, Konev, and Wolter 2014; Del Vescovo et al. 2011; Nortje, Britz, and Meyer 2013), and modules have found a wide range of applications, including ontology reuse (Cuenca Grau et al. 2008; Jime\u0301nez-Ruiz et al. 2008), matching (Jime\u0301nez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al. 2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010).\nThe preservation of relevant entailments is formalised via inseparability relations. The strongest notion is model inseparability, which requires that it must be possible to turn any model ofM into a model of T by (re-)interpreting only the symbols outside \u03a3; such an M preserves all second-order\nentailments of T w.r.t. \u03a3 (Konev et al. 2013). A weaker and more flexible notion is deductive inseparability, which requires only that T and M entail the same \u03a3-formulas in a given query language. Unfortunately, the decision problems associated with module extraction are invariably of high complexity, and often undecidable. For model inseparability, checking whetherM is a \u03a3-module in T is undecidable even if T is restricted to be in the description logic (DL) EL, for which standard reasoning is tractable. For deductive inseparability, the problem is typically decidable for lightweight DLs and \u201creasonable\u201d query languages, albeit of high worst-case complexity; e.g., the problem is already EXPTIME-hard for EL if we consider concept inclusions as the query language (Lutz and Wolter 2010). Practical algorithms that ensure minimality of the extracted modules are known only for acyclic ELI (Konev et al. 2013) and DLLite (Kontchakov, Wolter, and Zakharyaschev 2010).\nPractical module extraction techniques are typically based on sound approximations: they ensure that the extracted fragment M is a module (i.e., inseparable from T w.r.t. \u03a3), but they give no minimality guarantee. The most popular such techniques are based on a family of polynomially checkable conditions called syntactic locality (Cuenca Grau et al. 2007; 2008; Sattler, Schneider, and Zakharyaschev 2009); in particular, \u22a5-locality and >\u22a5\u2217-locality. Each locality-based module M enjoys a number of desirable properties for applications: (i) it is model inseparable from T ; (ii) it is depleting, in the sense that T \\ M is inseparable from the empty ontology w.r.t. \u03a3; (iii) it contains all justifications (a.k.a. explanations) in T of every \u03a3-formula entailed by T ; and (iv) last but not least, it can be computed efficiently, even for very expressive ontology languages.\nLocality-based techniques are easy to implement, and surprisingly effective in practice. Their main drawback is that the extracted modules can be rather large, which limits their usefulness in some applications (Del Vescovo et al. 2013). One way to address this issue is to develop techniques that more closely approximate minimal modules while still preserving properties (i)\u2013(iii). Efforts in this direction have confirmed that locality-based modules can be far from optimal in practice (Gatens, Konev, and Wolter 2014); however, these techniques apply only to rather restricted ontology languages and utilise algorithms with high worst-case complexity.\nar X\niv :1\n41 1.\n53 13\nv2 [\ncs .A\nI] 2\n0 N\nov 2\n01 4\nAnother approach to computing smaller modules is to weaken properties (i)\u2013(iii), which are stronger than is required in many applications. In particular, model inseparability (property (i)) is a very strong condition, and deductive inseparability would usually suffice, with the query language determining which kinds of consequence are preserved; in modular classification, for example, only atomic concept inclusions need to be preserved. However, all practical module extraction techniques that are applicable to expressive ontology languages yield modules satisfying all three properties, and hence potentially much larger than they need to be.\nIn this paper, we propose a technique that reduces module extraction to a reasoning problem in datalog. The connection between module extraction and datalog was first observed in (Suntisrivaraporn 2008), where it was shown that locality \u22a5-module extraction for EL ontologies could be reduced to propositional datalog reasoning. Our approach takes this connection much farther by generalising both locality-based and reachability-based (Nortje, Britz, and Meyer 2013) modules for expressive ontology languages in an elegant way. A key distinguishing feature of our technique is that it can extract deductively inseparable modules, with the query language tailored to the requirements of the application at hand, which allows us to relax Property (i) and extract significantly smaller modules. In all cases our modules preserve the nice features of locality: they are widely applicable (even beyond DLs), they can be efficiently computed, they are depleting (Property (ii)) and they preserve all justifications of relevant entailments (Property (iii)).\nWe have implemented our approach using the RDFox datalog engine (Motik et al. 2014). Our proof of concept evaluation shows that module size consistently decreases as we consider weaker inseparability relations, which could significantly improve the usefulness of modules in applications.\nAll our proofs are deferred to the appendix.\n2 Preliminaries Ontologies and Queries We use standard first-order logic and assume familiarity with description logics, ontology languages and theorem proving. A signature \u03a3 is a set of predicates and Sig(F ) denotes the signature of a set of formulas F . It is assumed that the nullary falsehood predicate \u22a5 belongs to every \u03a3. To capture a wide range of KR languages, we formalise ontology axioms as rules: function-free sentences of the form \u2200x.[\u03d5(x) \u2192 \u2203y.[ \u2228n i=1 \u03c8i(x,y)]], where \u03d5, \u03c8i are conjunctions of distinct atoms. Formula \u03d5 is the rule body and \u2203y.[ \u2228n i=1 \u03c8i(x,y)] is the head. Universal quantification is omitted for brevity. Rules are required to be safe (all variables in the head occur in the body) and we assume w.l.o.g. that > (resp. \u22a5) does not occur in rule heads (resp. in rule bodies). A TBox T is a finite set of rules; TBoxes mentioning equality (\u2248) are extended with its standard axiomatisation. A fact \u03b3 is a function-free ground atom. An ABox A is a finite set of facts. A positive existential query (PEQ) is a formula q(x) = \u2203y.\u03d5(x,y), where \u03d5 is built from function-free atoms using only \u2227 and \u2228.\nDatalog A rule is datalog if its head has at most one atom and all variables are universally quantified. A datalog pro-\ngram P is a set of datalog rules. Given P and an ABox A, their materialisation is the set of facts entailed by P \u222a A, which can be computed by means of forward-chaining. A fact \u03b3 is a consequence of a datalog rule r = \u2227n i=1 \u03b3 \u2032 i \u2192 \u03b4 and facts \u03b31, . . . , \u03b3n if \u03b3 = \u03b4\u03c3 with \u03c3 a most-general unifier (MGU) of \u03b3i, \u03b3\u2032i for each 1 \u2264 i \u2264 n. A (forward-chaining) proof of \u03b3 in P \u222aA is a pair \u03c1 = (T, \u03bb) where T is a tree, \u03bb is a mapping from nodes in T to facts, and from edges in T to rules in P , such that for each node v the following holds: 1. \u03bb(v) = \u03b3 if v is the root of T ; 2. \u03bb(v) \u2208 A if v is a leaf; and 3. if v has children w1, . . . , wn then each edge from v to wi is labelled by the same rule r and \u03bb(v) is a consequence of r and \u03bb(w1), . . . , \u03bb(wn). Forward-chaining is sound and complete: a fact \u03b3 is in the materialisation of P \u222aA iff it has a proof in P \u222aA. Finally, the support of \u03b3 is the set of rules occurring in some proof of \u03b3 in P \u222a A. Inseparability Relations & Modules We next recapitulate the most common inseparability relations studied in the literature. We say that TBoxes T and T \u2032 are \u2022 \u03a3-model inseparable (T \u2261m\u03a3 T \u2032), if for every model I of T (resp. of T \u2032) there exists a model J of T \u2032 (resp. of T ) with the same domain s.t. AI = AJ for each A \u2208 \u03a3.\n\u2022 \u03a3-query inseparable (T \u2261q\u03a3 T \u2032) if for every Boolean PEQ q and \u03a3-ABoxAwe have T \u222aA |= q iff T \u2032\u222aA |= q.\n\u2022 \u03a3-fact inseparable (T \u2261f\u03a3 T \u2032) if for every fact \u03b3 and ABox A over \u03a3 we have T \u222a A |= \u03b3 iff T \u2032 \u222a A |= \u03b3.\n\u2022 \u03a3-implication inseparable (T \u2261i\u03a3 T \u2032) if for each \u03d5 of the form A(x)\u2192 B(x) with A,B \u2208 \u03a3, T |= \u03d5 iff T \u2032 |= \u03d5. These relations are naturally ordered from strongest to weakest: \u2261m\u03a3 ( \u2261 q \u03a3 ( \u2261f\u03a3 ( \u2261i\u03a3 for each non-trivial \u03a3.\nGiven an inseparability relation\u2261 for \u03a3, a subsetM\u2286 T is a \u2261-module of T if T \u2261M. Furthermore,M is minimal if noM\u2032 (M is a \u2261-module of T .\n3 Module Extraction via Datalog Reasoning In this section, we present our approach to module extraction by reduction into a reasoning problem in datalog. Our approach builds on recent techniques that exploit datalog engines for ontology reasoning (Kontchakov et al. 2011; Stefanoni, Motik, and Horrocks 2013; Zhou et al. 2014). In what follows, we fix an arbitrary TBox T and signature \u03a3 \u2286 Sig(T ). Unless otherwise stated, our definitions and theorems are parameterised by such T and \u03a3. We assume w.l.o.g. that rules in T do not share existentially quantified variables. For simplicity, we also assume that T contains no constants (all our results can be seamlessly extended)."}, {"heading": "3.1 Overview and Main Intuitions", "text": "Our overall strategy to extract a moduleM of T for an inseparability relation \u2261z\u03a3, with z \u2208 {m, q, f, i}, can be summarised by the following steps: 1. Pick a substitution \u03b8 mapping all existentially quantified\nvariables in T to constants, and transform T into a datalog program P by (i) Skolemising all rules in T using \u03b8 and (ii) turning disjunctions into conjunctions while splitting them into different rules, thus replacing each function-free\ndisjunctive rule of the form \u03d5(x) \u2192 \u2228n i=1 \u03c8i(x) with\ndatalog rules \u03d5(x)\u2192 \u03c81(x), . . . , \u03d5(x)\u2192 \u03c8n(x). 2. Pick a \u03a3-ABox A0 and materialise P \u222a A0. 3. Pick a set Ar of \u201crelevant facts\u201d in the materialisation\nand compute the supporting rules in P for each such fact. 4. The moduleM consists of all rules in T that yield some\nsupporting rule in P . In this way,M is fully determined by the substitution \u03b8 and the ABoxes A0 and Ar.\nThe main intuition behind our module extraction approach is that we can pick \u03b8, A0 and Ar (and henceM) such that each proof \u03c1 of a \u03a3-consequence \u03d5 of T to be preserved can be embedded in a forward chaining proof \u03c1\u2032 in P \u222a A0 of a relevant fact in Ar. Such an embedding satisfies the key property that, for each rule r involved in \u03c1, at least one corresponding datalog rule inP is involved in \u03c1\u2032. In this way we ensure thatM contains the necessary rules to entail \u03d5. This approach, however, does not ensure minimality ofM: since P is a strengthening of T there may be proofs of a relevant fact in P \u222aA0 that do not correspond to a \u03a3-consequence of T , which may lead to unnecessary rules inM.\nTo illustrate how our strategy might work in practice, suppose that T is T ex in Fig. 1, \u03a3 = {B,C,D,G}, and that we want a module M that is \u03a3-implication inseparable from T ex. This is a simple case since \u03d5 = D(x) \u2192 G(x) is the only non-trivial \u03a3-implication entailed by T ex; thus, forM to be a module we only require thatM |= \u03d5.\nProving T ex |= \u03d5 amounts to proving T ex \u222a {D(a)} |= G(a) (with a a fresh constant). Figure 2(a) depicts a hyperresolution tree \u03c1 showing how G(a) can be derived from the clauses corresponding to r4\u2013r6 and D(a), with rule r4 transformed into clauses r\u20324 = D(x)\u2192 S(x, f(x3)) r\u2032\u20324 = D(x)\u2192 E(f(x3)) HenceM = {r4\u2013r6} is a \u03a3-implication inseparable module of T ex, and as G(a) cannot be derived from any subset of {r4\u2013r6},M is also minimal.\nIn our approach, we pick A0 to contain the initial fact D(a),Ar to contain the fact to be proved G(a), and we make \u03b8 map variable y3 in r4 to a fresh constant c, in which case rule r4 corresponds to the following datalog rules in P:\nD(x)\u2192 S(x, c) D(x)\u2192 E(c) Figure 2(b) depicts a forward chaining proof \u03c1\u2032 of G(a) in P \u222a {D(a)}. As shown in the figure, \u03c1 can be embedded in \u03c1\u2032 via \u03b8 by mapping functional terms over f to the fresh constant c. In this way, the rules involved in \u03c1 are mapped to the datalog rules involved in \u03c1\u2032 via \u03b8. Consequently, we will extract the (minimal) moduleM = {r4\u2013r6}."}, {"heading": "3.2 The Notion of Module Setting", "text": "The substitution \u03b8 and the ABoxes A0 and Ar, which determine the extracted module, can be chosen in different ways to ensure the preservation of different kinds of \u03a3consequences. The following notion of a module setting captures in a declarative way the main elements of our approach.\nDefinition 1. A module setting for T and \u03a3 is a tuple \u03c7 = \u3008\u03b8,A0,Ar\u3009 with \u03b8 a substitution from existentially quantified variables in T to constants, A0 a \u03a3-ABox, Ar a Sig(T )-ABox, and s.t. no constant in \u03c7 occurs in T .\nThe program of \u03c7 is the smallest datalog program P\u03c7 containing, for each r = \u03d5(x) \u2192 \u2203y.[ \u2228n i=1 \u03c8i(x,y)] in T , the rule \u03d5 \u2192 \u22a5 if n = 0 and all rules \u03d5 \u2192 \u03b3\u03b8 for each 1 \u2264 i \u2264 n and each atom \u03b3 in \u03c8i. The support of \u03c7 is the set of rules r \u2208 P\u03c7 that support a fact from Ar in P\u03c7 \u222aA0. The module M\u03c7 of \u03c7 is the set of rules in T that have a corresponding datalog rule in the support of \u03c7."}, {"heading": "3.3 Modules for each Inseparability Relation", "text": "We next consider each inseparability relation \u2261z\u03a3, where z \u2208 {m, q, f, i}, and formulate a specific setting \u03c7z which provably yields a \u2261z\u03a3-module of T .\nImplication Inseparability The example in Section 3.1 suggests a natural setting \u03c7i = \u3008\u03b8,A0,Ar\u3009 that guarantees implication inseparability. As in our example, we pick \u03b8 to be as \u201cgeneral\u201d as possible by Skolemising each existentially quantified variable to a fresh constant. For A and B predicates of the same arity n, proving that T entails a \u03a3implication \u03d5 = A(x1, . . . , xn)\u2192 B(x1, . . . , xn), amounts to showing that T \u222a {A(a1, . . . , an)} |= B(a1, . . . , an) for fresh constants a1, . . . , an. Thus, following the ideas of our example, we initialiseA0 with a fact A(c1A, . . . , cnA) for each n-ary predicate A \u2208 \u03a3, andAr with a fact B(c1A, . . . , cnA) for each pair of n-ary predicates {B,A} \u2286 \u03a3 with B 6= A. Definition 2. For each existentially quantified variable yj in T , let cyj be a fresh constant. Furthermore, for each A \u2208 \u03a3 of arity n, let c1A, . . . , c n A be also fresh constants. The setting \u03c7i = \u3008\u03b8i,Ai0,Air\u3009 is defined as follows: \u2022 \u03b8i = { yj 7\u2192 cyj | yj existentially quantified in T }, \u2022 Ai0 = {A(c1A, . . . , cnA) | A n-ary predicate in \u03a3}, and \u2022 Air = {B(c1A, . . . , cnA) |A 6= B n-ary predicates in \u03a3}.\nThe setting \u03c7i is reminiscent of the datalog encodings typically used to check whether a concept A is subsumed by concept B w.r.t. a \u201clightweight\u201d ontology T (Kro\u0308tzsch, Rudolph, and Hitzler 2008; Stefanoni, Motik, and Horrocks 2013). There, variables in rules are Skolemised as fresh constants to produce a datalog program P and it is then checked whether P \u222a {A(a)} |= B(a). Theorem 3. M\u03c7i \u2261i\u03a3 T .\nFact Inseparability The setting \u03c7i in Def. 2 cannot be used to ensure fact inseparability. Consider again T ex and \u03a3 = {B,C,D,G}, for which M\u03c7i = {r4, r5, r6}. For A = {B(a),C(a)}we have T ex\u222aA |= G(a) butM\u03c7i\u222aA 6|= G(a), and henceM\u03c7i is not fact inseparable from T ex.\nMore generally, M\u03c7i is only guaranteed to preserve \u03a3fact entailments T \u222a A |= \u03b3 where A is a singleton. However, for a module to be fact inseparable from T it must preserve all \u03a3-facts when coupled with any \u03a3-ABox. We achieve this by choosing A0 to be the critical ABox for \u03a3, which consists of all facts that can be constructed using \u03a3 and a single fresh constant (Marnette 2009). Every \u03a3-ABox can be homomorphically mapped into the critical \u03a3-ABox. In this way, we can show that all proofs of a \u03a3-fact in T \u222aA can be embedded in a proof of a relevant fact in P\u03c7 \u222a A0. Definition 4. Let constants cyi be as in Def. 2, and let \u2217 be a fresh constant. The setting \u03c7f = \u3008\u03b8f ,Af0,Afr\u3009 is defined as follows: (i) \u03b8f = \u03b8i, (ii) Af0 = {A(\u2217, . . . , \u2217) | A \u2208 \u03a3 }, and (iii) Afr = Af0\nThe datalog programs for \u03c7i and \u03c7f coincide and hence the only difference between the two settings is in the definition of their corresponding ABoxes. In our example, bothAf0 and Afr contain facts B(\u2217), C(\u2217), D(\u2217), and G(\u2217). Clearly, P\u03c7f \u222a A0 |= G(\u2217) and the proof additionally involves rule r3. ThusM\u03c7f = {r3, r4, r5, r6}. Theorem 5. M\u03c7f \u2261f\u03a3 T .\nQuery Inseparability Positive existential queries constitute a much richer query language than facts as they allow for existentially quantified variables. Thus, the query inseparability requirement invariably leads to larger modules.\nFor instance, let T = T ex and \u03a3 = {A,B}. Given the \u03a3-ABox A = {A(a)} and \u03a3-query q = \u2203y.B(y) we have that T ex\u222aA |= q (due to rule r1). The moduleM\u03c7f is, however, empty. Indeed, the materialisation ofP\u03c7f\u222a{A(\u2217)} consists of the additional facts R(\u2217, cy1) and B(cy1) and hence it does not contain any relevant fact mentioning only \u2217. Thus, M\u03c7f \u222a A 6|= q andM\u03c7f is not query inseparable from T ex.\nOur example suggests that, although the critical ABox is constrained enough to embed every \u03a3-ABox, we may need to consider additional relevant facts to capture all proofs of a \u03a3-query. In particular, rule r1 implies that B contains an instance whenever A does: a dependency that is then checked by q. This can be captured by considering fact B(cy1) as relevant, in which case rule r1 would be in the module.\nMore generally, we consider a module setting \u03c7 that differs from \u03c7f only in that all \u03a3-facts (and not just those over \u2217) are considered as relevant.\nDefinition 6. Let constants cyi and \u2217 be as in Def. 4. The setting \u03c7q = \u3008\u03b8q,Aq0,Aqr\u3009 is as follows: (i) \u03b8q = \u03b8f , (ii) A q 0 = Af0, and (iii) Aqr consists of all \u03a3-facts A(a1, . . . , an) with each aj either a constant cyi or \u2217.\nCorrectness is established by the following theorem:\nTheorem 7. M\u03c7q \u2261q\u03a3 T .\nModel Inseparability The modules generated by \u03c7q may not be model inseparable from T . To see this, let T = T ex and \u03a3 = {A,D,R}, in which case M\u03c7q = {r1, r2}. The interpretation I where \u2206I = {a, b}, AI = {a}, BI = CI = {b}, DI = \u2205 and RI = {(a, b)} is a model of M\u03c7q . This interpretation, however, cannot be extended to a model of r3 (and hence of T ) without reinterpreting A, R or D.\nThe main insight behind locality and reachability modules is to ensure that each model of the module can be extended to a model of T in a uniform way. Specifically, each model of a >\u22a5\u2217-locality or >\u22a5\u2217-reachability module can be extended to a model of T by interpreting all other predicates A as either \u2205 or (\u2206I)n with n the arity of A. Thus,M = {r1, r2, r3} is a \u2261m\u03a3-module of T ex since all its models can be extended by interpreting E, F and G as the domain, H as empty, and S as the Cartesian product of the domain. We can capture this idea in our framework by means of the following setting.\nDefinition 8. The setting \u03c7m = \u3008\u03b8m,Am0 ,Amr \u3009 is as follows: \u03b8m maps each existentially quantified variable to the fresh constant \u2217 and Am0 = Amr = Af0.\nIn our example, P\u03c7m \u222aAm0 entails the relevant facts A(\u2217), R(\u2217, \u2217) and D(\u2217), and henceM\u03c7m = {r1, r2, r3}.\nTo show that M\u03c7m is a \u2261m\u03a3-module we prove that all models I ofM\u03c7m can be extended to a model of T as follows: (i) predicates not occurring in the materialisation of P\u03c7m \u222a Am0 are interpreted as empty; (ii) predicates in the support of \u03c7m (and hence occurring inM\u03c7m ) are interpreted as in I; and (iii) all other predicates A are interpreted as (\u2206I)n with n the arity of A.\nTheorem 9. M\u03c7m \u2261m\u03a3 T ."}, {"heading": "3.4 Modules for Ontology Classification", "text": "Module extraction has been exploited for optimising ontology classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010). In this case, it is not only required that modules\nare implication inseparable from T , but also that they preserve all implications A(x)\u2192 B(x) with A \u2208 \u03a3 but B /\u2208 \u03a3. This requirement can be captured as given next.\nDefinition 10. TBoxes T and T \u2032 are \u03a3-classification inseparable (T \u2261c\u03a3 T \u2032) if for each \u03d5 of the form A(x) \u2192 B(x) with A \u2208 \u03a3, and B \u2208 Sig(T \u222a T \u2032) we have T |= \u03d5 iff T \u2032 |= \u03d5.\nClassification inseparability is a stronger requirement than implication inseparability. For T = {A(x) \u2192 B(x)} and \u03a3 = {A}, M = \u2205 is implication inseparable from T , whereas classification inseparability requires thatM = T .\nModular reasoners such as MORe and Chainsaw rely on locality \u22a5-modules, which satisfy this requirement. Each model of a \u22a5-module M can be extended to a model of T by interpreting all additional predicates as empty, which is not possible if A \u2208 \u03a3 and T entails A(x) \u2192 B(x) but M does not. We can cast \u22a5-modules in our framework with the following setting, which extends \u03c7m in Def. 8 by also considering as relevant facts involving predicates not in \u03a3.\nDefinition 11. The setting \u03c7b = \u3008\u03b8b,Ab0,Abr\u3009 is as follows: \u03b8b = \u03b8m,Ab0 = Am0 , andAr consists of all facts A(\u2217, . . . , \u2217) where A \u2208 Sig(T ).\nThe use of \u22a5-modules is, however, stricter than is needed for ontology classification. For instance, if we consider T = T ex and \u03a3 = {A} we have that M\u03c7b contains all rules r1\u2013r6, but since A does not have any subsumers in T ex the empty TBox is already classification inseparable from T ex.\nThe following module setting extends \u03c7i in Def. 2 to ensure classification inseparability. As in the case of \u03c7b in Def. 11 the only required modification is to also consider as relevant facts involving predicates outside \u03a3.\nDefinition 12. Setting \u03c7c = (\u03b8c,Ac0,Acr) is as follows: \u03b8c = \u03b8i, Ac0 = Ai0, and Acr consists of all facts B(c1A, . . . , cnA) s.t. A 6= B are n-ary predicates, A \u2208 \u03a3 and B \u2208 Sig(T ).\nIndeed, if we consider again T = T ex and \u03a3 = {A}, the module for \u03c7c is empty, as desired.\nTheorem 13. M\u03c7c \u2261c\u03a3 T ."}, {"heading": "3.5 Additional Properties of Modules", "text": "Although the essential property of a moduleM is that it captures all relevant \u03a3-consequences of T , in some applications it is desirable that modules satisfy additional requirements.\nIn ontology reuse scenarios, it is sometimes desirable that a module M does not \u201cleave any relevant information behind\u201d, in the sense that T \\ M does not entail any relevant \u03a3-consequence\u2014a property referred to as depletingness (Kontchakov, Wolter, and Zakharyaschev 2010).\nDefinition 14. Let \u2261z\u03a3 be an inseparability relation. A \u2261z\u03a3moduleM of T is depleting if T \\M \u2261z\u03a3 \u2205.\nNote that not all modules are depleting: for some relevant \u03a3-entailment \u03d5 it may be thatM |= \u03d5 (as required by the definition of module), but also that (T \\M) |= \u03d5, in which caseM is not depleting. The following theorem establishes that all modules defined in Section 3.3 are depleting.\nTheorem 15. M\u03c7z is depleting for each z \u2208 {m, q, f, i, c}.\nAnother common application of modules is to optimise the computation of justifications: minimal subsets of a TBox that are sufficient to entail a given formula (Kalyanpur et al. 2007; Suntisrivaraporn et al. 2008). Definition 16. Let T |= \u03d5. A justification for \u03d5 in T is a minimal subset T \u2032 \u2286 T such that T \u2032 |= \u03d5.\nJustifications are displayed in ontology development platforms as explanations of why an entailment holds, and tools typically compute all of them. Extracting justifications is a computationally intensive task, and locality-based modules have been used to reduce the size of the problem: if T \u2032 is a justification of \u03d5 in T , then T \u2032 is contained in a locality module of T for \u03a3 = Sig(\u03d5). Our modules are also justification-preserving, and we can adjust our modules depending on what kind of first-order sentence \u03d5 is. Theorem 17. Let T \u2032 be a justification for a first-order sentence \u03d5 in T and let Sig(\u03d5) \u2286 \u03a3. Then, T \u2032 \u2286 M\u03c7m . Additionally, the following properties hold: (i) if \u03d5 is a rule, then T \u2032 \u2286 M\u03c7q ; (ii) if \u03d5 is datalog, then T \u2032 \u2286 M\u03c7f ; and (iii) if \u03d5 is of the form A(x) \u2192 B(x), then T \u2032 \u2286 M\u03c7i; finally, if \u03d5 satisfies A \u2208 \u03a3, B \u2208 Sig(T ), then T \u2032 \u2286M\u03c7c ."}, {"heading": "3.6 Complexity of Module Extraction", "text": "We conclude this section by showing that our modules can be efficiently computed in most practically relevant cases. Theorem 18. Letm be a non-negative integer and L a class of TBoxes s.t. each rule in a TBox from L has at most m distinct universally quantified variables. The following problem is tractable: given z \u2208 {q, f, i, c}, T \u2208 L, and r \u2208 T , decide whether r \u2208M\u03c7z . The problem is solvable in polynomial time for arbitrary classes L of TBoxes if z = m.\nWe now provide a proof sketch for this result. Checking whether a datalog program P and an ABox A entail a fact is feasible in O(|P| \u00b7 nv), with n the number of constants in P\u222aA and v the maximum number of variables in a rule from P (Dantsin et al. 2001). Thus, although datalog reasoning is exponential in the size of v (and hence of P), it is tractable if v is bounded by a constant.\nGiven arbitrary T and \u03a3, and for z \u2208 {m, q, f, i, c}, the datalog program P\u03c7z can be computed in linear time in the size of |T |. The number of constants n in \u03c7z (and hence in P\u03c7z \u222a Az0) is linearly bounded in |T |, whereas the maximum number of variables v coincides with the maximum number of universally quantified variables in a rule from T . As shown in (Zhou et al. 2014), computing the support of a fact in a datalog program is no harder than fact entailment, and thus module extraction in our approach is feasible in O(|T |\u00b7nv), and thus tractable for ontology languages where rules have a bounded number of variables (as is the case for most DLs). Finally, if z = m the setting \u03c7m involves a single constant \u2217 and module extraction boils down to reasoning in propositional datalog (a tractable problem regardless of T )."}, {"heading": "3.7 Module Containment and Optimality", "text": "Intuitively, the more expressive the language for which preservation of consequences is required the larger modules need to be. The following proposition shows that our modules are consistent with this intuition.\nProposition 19. M\u03c7i \u2286 M\u03c7f \u2286 M\u03c7q \u2286 M\u03c7m \u2286 M\u03c7b andM\u03c7i \u2286M\u03c7c \u2286M\u03c7b\nAs already discussed, these containment relations are strict for many T and \u03a3.\nWe conclude this section by discussing whether each \u03c7z with z \u2208 {q, f, i, c} is optimal for its inseparability relation in the sense that there is no setting that produces smaller modules. To make optimality statements precise we need to consider families of module settings, that is, functions that assign a module setting for each pair of T and \u03a3. Definition 20. A setting family is a function \u03a8 that maps a TBox T and signature \u03a3 to a module setting for T and \u03a3. We say that \u03a8 is uniform if for every \u03a3 and pair of TBoxes T , T \u2032 with the same number of existentially quantified variables \u03a8(T ,\u03a3) = \u03a8(T \u2032,\u03a3). Let z \u2208 {i, f, q, c}; then, \u03a8 is z-admissible if, for each T and \u03a3,M\u03a8(T ,\u03a3) is a\u2261z\u03a3-module of T . Finally, \u03a8 is z-optimal ifM\u03a8(T ,\u03a3) \u2286 M\u03a8\u2032(T ,\u03a3) for every T , \u03a3 and every uniform \u03a8\u2032 that is z-admissible.\nUniformity ensures that settings do not depend on the specific shape of rules in T , but rather only on \u03a3 and the number of existentially quantified variables in T . In turn, admissibility ensures that each setting yields a module. The (uniform and admissible) family \u03a8z corresponding to each setting \u03c7z in Sections 3.3 and 3.4 is defined in the obvious way: for each T and \u03a3, \u03a8z(T ,\u03a3) is the setting \u03c7z for T and \u03a3.\nThe next theorem shows that \u03a8z is optimal for implication and classification inseparability. Theorem 21. \u03a8z is z-optimal for z \u2208 {i, c}.\nIn contrast, \u03a8q and \u03a8f are not optimal. To see this, let T = {A(x) \u2192 B(x),B(x) \u2192 A(x)} and \u03a3 = {A}. The empty TBox is fact inseparable from T since the only \u03a3consequence of T is the tautology A(x) \u2192 A(x). However, M\u03c7f = T since fact A(a) is in Afr and its support is included in the module. We can provide a family of settings that distinguishes tautological from non-tautological inferences (see appendix); however, this family yields settings of exponential size in |T |, which is undesirable in practice.\n4 Proof of Concept Evaluation We have implemented a prototype system for module extraction that uses RDFox for datalog materialisation (Motik et al. 2014). Additionally, the ontology reasoner PAGOdA (Zhou et al. 2014) provides functionality for computing the support of an entailed fact in datalog, which we have adapted for computing modules. We have evaluated our system on representative ontologies, including SNOMED (SCT), Fly Anatomy (FLY), the Gene Ontology (GO) and BioModels (BM).1 SCT is expressed in the EL profile of OWL 2, whereas FLY, GO and BM require expressive DLs (HornSRI, SHIQ and SRIQ, respectively). We have normalised all ontologies to make axioms equivalent to rules.\nWe compared the size of our modules with the localitybased modules computed using the OWL API. We have followed the experimental methodology from (Del Vescovo et\n1The ontologies used in our tests are available for download at http://www.cs.ox.ac.uk/isg/ontologies/UID/ under IDs 794 (FLY), 795 (SCT), 796 (GO) and 797 (BM).\nal. 2013) where two kinds of signatures are considered: genuine signatures corresponding to the signature of individual axioms, and random signatures with a given probability for a symbol to be included. For each type of signature and ontology, we took a sample of 400 runs and averaged module sizes. For random signatures we considered a probability of 1/1000. All experiments have been performed on a server with two Intel Xeon E5-2643 processors and 90GB of allocated RAM, running RDFox on 16 threads.\nTable 1 summarises our results. We compared\u22a5-modules with the modules for \u03c7c (Section 3.4) and >\u22a5\u2217-modules with those for \u03c7m, \u03c7q, \u03c7f , and \u03c7i (Section 3.3). We can see that module size consistently decreases as we consider weaker inseparability relations. In particular, the modules for \u03c7c can be 4 times smaller than \u22a5-modules. The difference between >\u22a5\u2217-modules and \u03c7i modules is even bigger, especially in the case of FLY. In fact, \u03c7i modules are sometimes empty, which is not surprising since two predicates in a large ontology are unlikely to be in an implication relationship. Also note that our modules for semantic inseparability slightly improve on >\u22a5\u2217-modules. Finally, recall that our modules may not be minimal for their inseparability relation. Since techniques for extracting minimal modules are available only for model inseparability, and for restricted languages, we could not assess how close our modules are to minimal ones and hence the quality of our approximation.\nComputation times were comparable for all settings \u03c7z with times being slightly higher for \u03c7i and \u03c7c as they involved a larger number of constants. Furthermore, extraction times were comparable to locality-based modules for genuine signatures with average times of 0.5s for FLY, 0.9s for SCT, 4.2 for GO and 5s for BM.\n5 Conclusion and Future Work We have proposed a novel approach to module extraction by exploiting off-the-shelf datalog reasoners, which allows us to efficiently compute approximations of minimal modules for different inseparability relations. Our results open the door to significant improvements in common applications of modules, such as computation of justifications, modular and incremental reasoning and ontology reuse, which currently rely mostly on locality-based modules.\nOur approach is novel, and we see many interesting open problems. For example, the issue of optimality requires fur-\nther investigation. Furthermore, it would be interesting to integrate our extraction techniques in existing modular reasoners as well as in systems for justification extraction.\nAcknowledgements This work was supported by the Royal Society, the EPSRC projects MaSI3, Score! and DBOnto, and by the EU FP7 project OPTIQUE.\nReferences Armas Romero, A.; Cuenca Grau, B.; and Horrocks, I. 2012. MORe: Modular combination of OWL reasoners for ontology classification. In ISWC, 1\u201316. Cuenca Grau, B.; Horrocks, I.; Kazakov, Y.; and Sattler, U. 2007. Just the right amount: Extracting modules from ontologies. In WWW, 717\u2013726. Cuenca Grau, B.; Horrocks, I.; Kazakov, Y.; and Sattler, U. 2008. Modular reuse of ontologies: Theory and practice. J. Artif. Intell. Res. 31:273\u2013318. Cuenca Grau, B.; Halaschek-Wiener, C.; Kazakov, Y.; and Suntisrivaraporn, B. 2010. Incremental classification of description logics ontologies. J. Autom. Reason. 44(4):337\u2013 369. Dantsin, E.; Eiter, T.; Gottlob, G.; and Voronkov, A. 2001. Complexity and expressive power of logic programming. ACM Comput. Surv. 33(3):374\u2013425. Del Vescovo, C.; Parsia, B.; Sattler, U.; and Schneider, T. 2011. The modular structure of an ontology: Atomic decomposition. In IJCAI, 2232\u20132237. Del Vescovo, C.; Klinov, P.; Parsia, B.; Sattler, U.; Schneider, T.; and Tsarkov, D. 2013. Empirical study of logicbased modules: Cheap is cheerful. In DL, 144\u2013155. Gatens, W.; Konev, B.; and Wolter, F. 2014. Lower and upper approximations for depleting modules of description logic ontologies. In ECAI, 345\u2013350. Jime\u0301nez-Ruiz, E., and Cuenca Grau, B. 2011. LogMap: Logic-based and scalable ontology matching. In ISWC, 273\u2013 288. Jime\u0301nez-Ruiz, E.; Cuenca Grau, B.; Sattler, U.; Schneider, T.; and Berlanga Llavori, R. 2008. Safe and economic re-use of ontologies: A logic-based methodology and tool support. In ESWC, 185\u2013199. Kalyanpur, A.; Parsia, B.; Horridge, M.; and Sirin, E. 2007. Finding all justifications of OWL DL entailments. In ISWC, 267\u2013280. Konev, B.; Lutz, C.; Walther, D.; and Wolter, F. 2013. Model-theoretic inseparability and modularity of description logic ontologies. Artif. Intell. 203:66\u2013103. Kontchakov, R.; Lutz, C.; Toman, D.; Wolter, F.; and Zakharyaschev, M. 2011. The combined approach to ontologybased data access. In IJCAI, 2656\u20132661. Kontchakov, R.; Wolter, F.; and Zakharyaschev, M. 2010. Logic-based ontology comparison and module extraction, with an application to DL-Lite. Artif. Intell. 174(15):1093\u2013 1141.\nKro\u0308tzsch, M.; Rudolph, S.; and Hitzler, P. 2008. ELP: Tractable rules for OWL 2. In ISWC, 649\u2013664. Ludwig, M. 2014. Just: a tool for computing justifications w.r.t. ELH ontologies. In ORE, 1\u20137. Lutz, C., and Wolter, F. 2010. Deciding inseparability and conservative extensions in the description logic EL. J. Symb. Comput. 45(2):194\u2013228. Marnette, B. 2009. Generalized schema-mappings: From termination to tractability. In PODS, 13\u201322. Motik, B.; Nenov, Y.; Piro, R.; Horrocks, I.; and Olteanu, D. 2014. Parallel materialisation of datalog programs in centralised, main-memory RDF systems. In AAAI, 129\u2013137. Nortje, R.; Britz, K.; and Meyer, T. 2013. Reachability modules for the description logic SRIQ. In LPAR, 636\u2013652. Sattler, U.; Schneider, T.; and Zakharyaschev, M. 2009. Which kind of module should I extract? In DL. Seidenberg, J., and Rector, A. L. 2006. Web ontology segmentation: Analysis, classification and use. In WWW, 13\u2013 22. Stefanoni, G.; Motik, B.; and Horrocks, I. 2013. Introducing nominals to the combined query answering approaches for EL. In AAAI, 1177\u20131183. Stuckenschmidt, H.; Parent, C.; and Spaccapietra, S., eds. 2009. Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, volume 5445 of LNCS. Springer. Suntisrivaraporn, B.; Qi, G.; Ji, Q.; and Haase, P. 2008. A modularization-based approach to finding all justifications for OWL DL entailments. In ASWC, 1\u201315. Suntisrivaraporn, B. 2008. Module extraction and incremental classification: A pragmatic approach for ontologies. In ESWC, 230\u2013244. Tsarkov, D., and Palmisano, I. 2012. Chainsaw: A metareasoner for large ontologies. In ORE. Zhou, Y.; Nenov, Y.; Cuenca Grau, B.; and Horrocks, I. 2014. Pay-as-you-go OWL query answering using a triple store. In AAAI, 1142\u20131148.\nA Inseparability Relations We start by giving an alternative characterization of \u03a3-query and \u03a3-fact inseparability that will allow us to prove our results in a more uniform and clear way.\nProposition 22. TBoxes T and T \u2032 are"}, {"heading": "1. \u03a3-query inseparable iff T |= r \u21d4 T \u2032 |= r holds for every rule r over \u03a3;", "text": ""}, {"heading": "2. \u03a3-fact inseparable iff T |= r \u21d4 T \u2032 |= r holds for every datalog rule r over \u03a3.", "text": "Proof. It suffices to observe that, for every TBox T and every rule r = \u03d5 \u2192 \u03c8 over \u03a3, T |= r iff T \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } |= \u03c8\u03c3, with \u03c3 a substitution mapping all free variables in r to fresh, pairwise distinct constants.\nProposition 23. \u2261m ( \u2261q ( \u2261f ( \u2261i.\nProof. The inclusion \u2261q \u2286 \u2261f is immediate by definition while \u2261f \u2286 \u2261i follows by Proposition 22. The inclusion \u2261m \u2286 \u2261q follows since rI = rI|\u03a3 = rI \u2032|\u03a3 = rI \u2032\nfor every rule r over \u03a3 whenever I and I \u2032 coincide on \u03a3. To show strictness of the inclusions, we can w.l.o.g. restrict ourselves to the signature \u03a3 = {Q,\u22a5} where Q is a unary predicate (if \u03a3 contains more symbols, one can consider T such that Sig(T ) \u2229 \u03a3 \u2286 {Q}; adapting the argument to higher arities for Q is also straightforward; finally, the presence of \u22a5 in \u03a3 is not relevant for the proof).\nFor \u2261m ( \u2261q, suppose T = {>(x) \u2192 \u2203y.[R(x, y) \u2227 A(y)],>(x) \u2192 \u2203y.[R(x, y) \u2227 B(y)],A(x) \u2227 B(x) \u2192 Q(x)}. Then T \u2261a \u2205. However, T 6\u2261m \u2205 since, for any interpretation I with a singleton domain such that QI = \u2205, I cannot be turned into a model of T without changing the interpretation of Q.\nFor \u2261q ( \u2261f , suppose T = {>(x) \u2192 \u2203y.[R(x, y) \u2227 Q(y)]}. Then T \u2261f \u2205 but T 6\u2261q \u2205 since T |= \u2203x.Q(x) while \u2205 6|= \u2203x.Q(x).\nFor \u2261f ( \u2261i, suppose T = {r} where r = Q(a) \u2227 Q(b)\u2192 Q(c). Then T \u2261i \u2205 but T 6\u2261d \u2205 since T |= r while \u2205 6|= r.\nB Deductive Inseparability Theorems 3, 5, 7, 13 are all shown by a similar argument, which we present next.\nHyperresolution Given r = \u03d5(x)\u2192 \u2203y.[ \u2228n i=1 \u03c8(x,y)] \u2208 T we denote with sk(r) the result of applying standard Skolemisation to r\u2014which replaces, for each y \u2208 y, all occurrences of y in r by fy(x), where fy is a fresh function symbol unique for y. Given a substitution \u03b8 mapping existentially quantified variables in T to constants and a Skolemised formula \u03d5, we write \u0393\u03b8(\u03d5) for the formula obtained from \u03d5 by replacing every occurrence of a functional term fy(t) by the constant y\u03b8.\nBy distributing disjunctions over conjunctions in the head of sk(r) we obtain a rule of the form \u03d5 \u2192 \u2227m j=1 \u03c8 \u2032 j where each \u03c8\u2032j is a disjunction of atoms. We denote with cnf(r) the set {\u03d5\u2192 \u03c8\u2032j | 1 \u2264 j \u2264 m } and extend this notation in the natural way to cnf(T ) = \u22c3 r\u2208T cnf(r). We call cnf(T ) a CNF TBox and each s \u2208 cnf(T ) a CNF rule. Clearly, cnf(T ) |= T , and hence T \u222a A |= \u03d5\u2032 implies cnf(T ) \u222a A |= \u03d5\u2032 for every A and \u03d5\u2032. Let \u03d5 be a disjunction of facts, A an ABox, and s = \u2227n i=1 \u03b3 \u2032 i \u2192 \u03c8 \u2208 cnf(T ). A formula \u03d5 is a hyperresolvent of s and\nground disjunctions \u03b31 \u2228 \u03c81, . . . , \u03b3n \u2228 \u03c8n (with each \u03c8i potentially empty) if \u03d5 = \u2228n i=1 \u03c8i \u2228 \u03c8\u03c3 with \u03c3 a MGU of \u03b3i, \u03b3\u2032i for each 1 \u2264 i \u2264 n. Let C be a CNF TBox. A hyperresolution proof (or simply a proof ) of \u03d5 in C \u222a A is a pair \u03c1 = (T, \u03bb) where T is a tree, \u03bb is a mapping from nodes in T to disjunctions of facts, and from edges in T to CNF rules in C, such that for every node v the following properties hold:\n1. \u03bb(v) = \u03d5 if v is the root of T ;\n2. \u03bb(v) \u2208 A if v is a leaf in T ; and 3. if v has children w1, . . . , wn then each edge from v to wi is labelled by the same CNF rule s and \u03bb(v) is a hyperresolvent of s and \u03bb(w1), . . . , \u03bb(wn).\nIf there exists a proof of \u03d5 in C \u222a A we write C \u222a A ` \u03d5. The support of \u03d5 is the set of CNF rules occurring in some proof of \u03d5 in C \u222a A.\nHyperresolution is sound (if C \u222aA ` \u03d5 then C \u222aA |= \u03d5) and complete in the following sense: if C \u222aA |= \u03d5 then there exists \u03c8 \u2286 \u03d5 such that C \u222a A ` \u03c8.\nGiven a module setting \u03c7 and r \u2208 T , we denote with \u039e\u03c7(r) the set of datalog rules in P\u03c7 corresponding to r, as described in Definition 1. The following auxiliary results provide the basis for correctness of our approach to module extraction.\nLemma 24. Let \u03c7 = \u3008\u03b8,A0,Ar\u3009 be a module setting. Let N be the set of constants mentioned in \u03c7. Let A be a functionfree ABox that only mentions constants that are fresh w.r.t. T and N. Let \u03bd be a mapping from constants in A to N such that A\u03bd \u2286 A0. Let \u03d5 be a disjunction of facts and \u03c1 = (T, \u03bb) a proof of \u03d5 in cnf(T ) \u222a A. The following properties hold: 1. P\u03c7 \u222a A0 ` \u0393\u03b8(\u03b3\u03bd) for every \u03b3 \u2208 \u03d5.\n2. For every r \u2208 T such that \u03c1 mentions some s \u2208 cnf(r) there exists \u03b3 \u2208 \u03d5 \u222a {\u22a5} and a proof of \u0393\u03b8(\u03b3\u03bd) in P\u03c7 \u222a A0 that mentions some rule in \u039e\u03c7(r).\nProof. We reason by induction on the depth d of \u03c1.\nd = 0 In this case \u03d5 must be a fact in A. Since A is function-free by assumption we have \u0393\u03b8(\u03d5\u03bd) = \u03d5\u03bd, and since A\u03bd \u2286 A0 we have \u03d5\u03bd \u2208 A0. Therefore, there exists a trivial proof of \u0393\u03b8(\u03d5\u03bd) in P\u03c7 \u222a A0 and property 1 is satisfied. Furthermore, if the depth of \u03c1 is 0 then there cannot be any rules in its support, so property 2 is trivially satisfied as well.\nd > 0 Let v be the root of T and w1, . . . , wn the children of v. Then it must be \u2013 \u03bb(wi) = \u03b4i \u2228 \u03c8i for each 1 \u2264 i \u2264 n; \u2013 \u03bb(v, wi) = s for each 1 \u2264 i \u2264 n with s \u2208 cnf(T ) of the form \u2227n i=1 \u03b4 \u2032 i \u2192 \u03d5\u2032; and\n\u2013 \u03d5 = \u2228n i=1 \u03c8i \u2228 \u03d5\u2032\u03c3 with \u03c3 a MGU of \u03b4i, \u03b4\u2032i for each 1 \u2264 i \u2264 n. Consider \u03b3 \u2208 \u03d5. To show property 1 we need to find a proof of \u0393\u03b8(\u03b3\u03bd) in P\u03c7 \u222a A0. If \u03b3 \u2208 \u03c8i then by i.h. we can find such a proof. If \u03b3 \u2208 \u03d5\u2032\u03c3 then it must be \u03b3 = \u03b3\u2032\u03c3 for some \u03b3\u2032 \u2208 \u03d5\u2032 and, by definition of P\u03c7, cnf(T ), and \u0393\u03b8, s \u2208 cnf(T ) implies \u2227n i=1 \u03b4 \u2032 i \u2192 \u0393\u03b8(\u03b3\u2032) \u2208 P\u03c7. Since \u03c3 is a MGU of \u03b4i, \u03b4\u2032i (with \u03b4i = \u03b4\u2032i\u03c3) for each 1 \u2264 i \u2264 n, \u03c3\u03bd must be a MGU of \u03b4i\u03bd, \u03b4\u2032i (with \u03b4i\u03bd = \u03b4 \u2032 i\u03c3\u03bd) for each 1 \u2264 i \u2264 n; furthermore, since \u03b4\u2032i is necessarily function-free, it is \u0393\u03b8(\u03b4\u2032i\u03c3\u03bd) = \u03b4\u2032i\u03c3\u03bd, and thus \u0393\u03b8(\u03b4i\u03bd) = \u03b4\u2032i\u03c3\u03bd and \u03c3\u03bd is also a MGU of \u0393\u03b8(\u03b4i\u03bd), \u03b4 \u2032 i for each 1 \u2264 i \u2264 n. By i.h. we have a proof in P\u03c7 \u222a A0 of\n\u0393\u03b8(\u03b4i\u03bd) for each 1 \u2264 i \u2264 n; it is easy to see that \u0393\u03b8(\u03b3\u2032)\u03c3\u03bd = \u0393\u03b8(\u03b3\u2032\u03c3\u03bd) = \u0393\u03b8(\u03b3\u03bd), so combining these proofs with rule\u2227n i=1 \u03b4 \u2032 i \u2192 \u0393\u03b8(\u03b3\u2032) yields a proof of \u0393\u03b8(\u03b3\u03bd) in P\u03c7 \u222a A0. Now consider r \u2208 T such that \u03c1 mentions some s\u2032 \u2208 cnf(r). To show property 2 we need to find \u03b3 \u2208 \u03d5 \u222a {\u22a5} and a proof of \u0393\u03b8(\u03b3\u03bd) that mentions some rule in \u039e\u03c7(r). Assume first that s\u2032 = s. If \u03d5\u2032 = \u2205 then it must be cnf(r) = { \u2227n i=1 \u03b4 \u2032 i \u2192 \u22a5} \u2286 \u039e\u03c7(r) and, as before, we can combine this rule with proofs in P\u03c7 \u222aA0 of the \u0393\u03b8(\u03b4i\u03bd) to obtain a proof of \u22a5 in P\u03c7 \u222aA0. If \u03d5\u2032 6= \u2205 then it must be { \u2227n i=1 \u03b4 \u2032 i \u2192 \u0393\u03b8(\u03b3\u2032) | \u03b3\u2032 \u2208 \u03d5\u2032 } \u2286 \u039e\u03c7(r). Since \u03d5 = \u2228n i=1 \u03c8i \u2228 \u03d5\u2032\u03c3, for each \u03b3\u2032 \u2208 \u03d5\u2032 it is \u03b3\u2032\u03c3 \u2208 \u03d5\nand, as we just saw, we can construct a proof of \u0393\u03b8(\u03b3\u2032\u03c3\u03bd) that mentions \u2227n i=1 \u03b4 \u2032 i \u2192 \u0393\u03b8(\u03b3\u2032). Finally, assume that s\u2032 6= s. Then there must be some i \u2208 {1, . . . , n} such that s\u2032 is mentioned by the proof \u03c1i of \u03b4i \u2228 \u03c8i that is embedded in \u03c1. Since \u03c1i is of depth < d, by i.h. there must be \u03b4\u2032\u2032 \u2208 \u03b4i \u2228 \u03c8i and a proof \u03c1\u2032\u2032 of \u0393\u03b8(\u03b4\u2032\u2032\u03bd) in P\u03c7 \u222aA0 that mentions some rule in \u039e\u03c7(r). If \u03b4\u2032\u2032 \u2208 \u03c8i then \u03b4\u2032\u2032 \u2208 \u03d5 already; if \u03b4\u2032\u2032 = \u03b4i then, as before, for any \u03b3 \u2208 \u03d5 we can construct a proof of \u0393\u03b8(\u03b3\u03bd) in P\u03c7 \u222a A0 such that \u03c1\u2032\u2032 is embedded in it.\nProposition 25. Let r = \u03d5(x) \u2192 \u03c8(x) with \u03d5 a conjunction and \u03c8 a disjunction of atoms. Let \u03c7 = \u3008\u03b8,A0,Ar\u3009 be a module setting satisfying {\u22a5} \u2286 Ar and such that for every substitution \u03c3 mapping all variables in r to pairwise distinct constants not in T there exists a mapping \u03bd\u03c3 with \u03d5\u03c3\u03bd\u03c3 \u2286 A0 and \u03c8\u03c3\u03bd\u03c3 \u2286 Ar. Then 1. T |= r iffM\u03c7 |= r;"}, {"heading": "2. if T \u2032 \u2286 T is a justification for r in T then T \u2032 \u2286M\u03c7;", "text": ""}, {"heading": "3. T \\M\u03c7 |= r iff \u2205 |= r.", "text": "Proof.\n1. By monotonicity, it is immediate that T |= r ifM\u03c7 |= r. Suppose T |= r and let \u03c3 be a substitution mapping all variables in r to fresh, pairwise distinct constants. Then we have that T \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } |= \u03c8\u03c3, which implies cnf(T ) \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } |= \u03c8\u03c3 and by completeness of hyperresolution cnf(T ) \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } ` \u03c8\u2032 for some \u03c8\u2032 \u2286 \u03c8\u03c3. Since { \u03b3\u03c3\u03bd\u03c3 | \u03b3 \u2208 \u03d5 } \u2286 A0, by Lemma 24 we have that for each s \u2208 T such that some p \u2208 cnf(s) supports \u03c8\u2032 in cnf(T ) \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } there exists \u03b3 \u2208 \u0393\u03b8(\u03c8\u2032\u03bd\u03c3) \u222a {\u22a5} that is supported in P\u03c7 \u222aA0 by some rule from \u039e\u03c7(s). By assumption, \u22a5 \u2208 Ar; also, \u03c8\u2032 is function-free so \u0393\u03b8(\u03c8\u2032\u03bd\u03c3) = \u03c8\u2032\u03bd\u03c3 , and hence, since \u03c8\u03c3\u03bd\u03c3 \u2286 Ar, we have that \u03c8\u2032\u03bd\u03c3 \u2286 Ar and also \u03b3 \u2208 Ar. In either case we have s \u2208M\u03c7 and consequentlyM\u03c7 |= r. 2. Let T \u2032 \u2286 T be a justification for r in T . As before, if \u03c3 is a ground substitution for r mapping variables in r to fresh, pairwise distinct constants, then cnf(T \u2032) \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } ` \u03c8\u2032 for some \u03c8\u2032 \u2286 \u03c8\u03c3. In fact, by minimality of justifications, for each s \u2208 T \u2032 some p \u2208 cnf(s) must be in the support of some \u03c8\u2032 \u2286 \u03c8\u03c3 in cnf(T \u2032)\u222a{ \u03b3\u03c3 | \u03b3 \u2208 \u03d5 }. As before, by Lemma 24, this implies s \u2208M\u03c7.\n3. By monotonicity, it is immediate that T \\M\u03c7 |= r if \u2205 |= r. Suppose T \\M\u03c7 |= r and let T \u2032 be a justification for r in T \\M\u03c7. Then T \u2032 is also a justification for r in T , and, as we just proved, T \u2032 \u2286M\u03c7. This implies that T \u2032 = \u2205, and therefore \u2205 |= r.\nProposition 26. Let r = \u03d5(x)\u2192 \u2203y.[ \u2228n i=1 \u03c8i(x,y)] be a rule. Let \u03c7 = \u3008\u03b8,A0,Ar\u3009 be a module setting satisfying\n\u2022 {\u22a5} \u2286 Ar and also \u03c8\u03c3 \u2286 Ar for every substitution \u03c3 mapping all variables in r to constants in \u03c7;\n\u2022 for every substitution \u03c3 mapping all variables in r to pairwise distinct constants not in T there exists a mapping \u03bd\u03c3 such that \u03d5\u03c3\u03bd\u03c3 \u2286 A0.\nThen 1. T |= r iffM\u03c7 |= r; 2. if T \u2032 \u2286 T is a justification for r in T then T \u2032 \u2286M\u03c7;"}, {"heading": "3. T \\M\u03c7 |= r iff \u2205 |= r.", "text": "Proof.\n1. By monotonicity, it is immediate that T \u222a A |= r ifM\u03c7 \u222a A |= r. Let Q be a fresh predicate and T\u03c8\u2192Q = {\u03c8i(x,y)\u2192 Q(x) | 1 \u2264 i \u2264 n }. Then\nT |= r iff T \u222a T\u03c8\u2192Q |= \u03d5(x)\u2192 Q(x) and M\u03c7 |= r iff M\u03c7 \u222a T\u03c8\u2192Q |= \u03d5(x)\u2192 Q(x) Consider T \u2032 = T \u222a T\u03c8\u2192Q and \u03a3\u2032 = \u03a3 \u222a {Q}. Clearly, T \u2032 has the exact same existentially quantified variables as T . Therefore \u03c7\u2032 = \u3008\u03b8,A0,A\u2032r\u3009 with A\u2032r = {Q(x)\u03c3 | \u03c3 is a substitution mapping all variables in x to constants in \u03c7 } is a module setting for T \u2032 and \u03a3\u2032 and by Proposition 25 we have that T \u2032 |= \u03d5(x)\u2192 Q(x) iffM\u03c7\u2032 |= \u03d5(x)\u2192 Q(x). If we show thatM\u03c7\u2032 \\ T\u03c8\u2192Q \u2286M\u03c7 then, by monotonicity, we will be able to conclude that\nM\u03c7 \u2032 |= \u03d5(x)\u2192 Q(x) impliesM\u03c7 \u222a T\u03c8\u2192Q |= \u03d5(x)\u2192 Q(x)\nand thus that T |= r impliesM\u03c7 |= r. Let s \u2208 M\u03c7\u2032 \\ T\u03c8\u2192Q. Some p \u2208 \u039e\u03c7 \u2032 (s) = \u039e\u03c7(s) must be in the support of some Q(x)\u03c3 \u2208 A\u2032r in P\u03c7\n\u2032 \u222a A0. In particular, p must be mentioned in some proof \u03c1 = (T, \u03bb) of Q(x)\u03c3 in P\u03c7\u2032 \u222a A0. Let v be the root of T and w1, . . . , wm its children nodes, there must be some \u2227m j=1 \u03b3j(x,y) \u2192 Q(x) \u2208 T\u03c8\u2192Q and a MGU \u03c3\u2032 of \u03b3j , \u03bb(wj) for each 1 \u2264 j \u2264 m. Since s /\u2208 T\u03c8\u2192Q, there must exist j \u2208 {1, . . . ,m} such that p is mentioned in the proof \u03c1j of \u03bb(wj) in P\u03c7 \u2032 \u222aA0 that is embedded in \u03c1. Furthermore, since Q does not occur in the body of any rule in P\u03c7\u2032 = P\u03c7 \u222a T\u03c8\u2192Q, all rules mentioned in \u03c1j must be in P\u03c7 and thus \u03c1j is a proof of \u03b3 in P\u03c7 \u222a A0. Since by assumption \u03bb(wj) = \u03b3j\u03c3\u2032 \u2208 Ar, this implies s \u2208M\u03c7. 2. Let T \u2032\u2032 \u2286 T be a justification for r in T . As before, T \u2032\u2032 |= r implies T \u2032\u2032 \u222a T\u03c8\u2192Q |= \u03d5(x) \u2192 Q(x) and in particular for any substitution \u03c3 mapping variables in r to pairwise distinct constants we have T \u2032\u2032 \u222a T\u03c8\u2192Q \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } |= Q(x)\u03c3 and therefore cnf(T \u2032\u2032 \u222a T\u03c8\u2192Q) \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 } ` Q(x)\u03c3. By minimality of justifications, for each s \u2208 T \u2032\u2032 there must be some p \u2208 cnf(s) in the support of Q(x)\u03c3 in cnf(T \u2032\u2032 \u222a T\u03c8\u2192Q) \u222a { \u03b3\u03c3 | \u03b3 \u2208 \u03d5 }. It is easy to see that p must also be in the support of Q(x)\u03c3\u03bd\u03c3 in cnf(T \u2032\u2032 \u222a T\u03c8\u2192Q) \u222a { \u03b3\u03c3\u03bd\u03c3 | \u03b3 \u2208 \u03d5 }. Since Q(x)\u03c3\u03bd\u03c3 \u2286 A\u2032r and { \u03b3\u03c3\u03bd\u03c3 | \u03b3 \u2208 \u03d5 } \u2286 A0, by Lemma 24 we have that s \u2208M\u03c7\u2032 . In particular, since s \u2208 T \u2032\u2032 \u2286 T , it must be s \u2208M\u03c7\u2032 \\ T\u03c8\u2192Q \u2286M\u03c7. 3. Again by monotonicity, it is immediate that T \\M\u03c7\u222aA |= r ifA |= r. By a similar argument to the one given in Proposition 25, it follows from 2 that any justification for r in T \\M\u03c7 must be empty and therefore if T \\M\u03c7 |= r then \u2205 |= r.\nTheorem 3. M\u03c7i \u2261i\u03a3 T .\nProof. Consider an arbitrary rule of the form A(x) \u2192 B(x) with A,B \u2208 \u03a3 and A 6= B (if A = B the rule is tautological). Since x is implicitly universally quantified, we can assume w.l.o.g. that x = (x1, . . . , xn) with x1, . . . , xn pairwise distinct. Let \u03c3 be a substitution mapping x1, . . . , xn, respectively, to c1, . . . , cn, pairwise distinct constants not in T . Now consider a mapping \u03bd\u03c3 such that ci\u03bd\u03c3 = ciA. This mapping is well-defined because c1, . . . , cn are pairwise distinct. By definition of \u03c7i, we have A(x)\u03c3\u03bd\u03c3 \u2208 Ai0 and B(x)\u03c3\u03bd\u03c3 \u2208 Air, and therefore, by Proposition 25, we have T |= A(x) \u2192 B(x) iff M\u03c7i |= A(x)\u2192 B(x).\nTheorem 5. M\u03c7f \u2261f\u03a3 T .\nProof. By Proposition 22 it suffices to show that for any datalog rule r = \u03d5 \u2192 \u03c8 we have T |= r iffM\u03c7f |= r. Let \u03c3 be a substitution mapping all variables in r to pairwise distinct constants not in T . Consider a mapping \u03bd\u2217 such that x\u03c3\u03bd\u2217 = \u2217 for each x \u2208 x. Clearly \u03d5\u03c3\u03bd\u2217 \u2286 Af0 and \u03c8\u03c3\u03bd\u2217 \u2286 Afr, and therefore, by Proposition 25, we have T |= r iffM\u03c7f |= r.\nTheorem 7. M\u03c7q \u2261q\u03a3 T .\nProof. By Proposition 22 it suffices to show that for any rule r = \u03d5\u2192 \u03c8 we have T |= r iffM\u03c7q |= r. Let \u03c3 be a substitution mapping all variables in r to pairwise distinct constants not in T . Given a mapping \u03bd\u2217 such that x\u03c3\u03bd\u2217 = \u2217 for each x \u2208 x it is clear that \u03d5\u03c3\u03bd\u2217 \u2286 Aq0. It is also immediate that \u03c8\u03c3\u2032 \u2286 Aqr for every substitution \u03c3\u2032 mapping all variables in r to constants in \u03c7q. Therefore, by Proposition 26, we have T |= r iffM\u03c7q |= r.\nTheorem 13. M\u03c7c \u2261c\u03a3 T .\nProof. Analogous to the proof of Theorem 3.\nC Model Inseparability Given an ABoxA and a datalog program P , let P(A) denote the materialisation of P \u222aA. Furthermore, given a module setting \u03c7, let supp(\u03c7) denote the support of \u03c7.\nTheorem 9. M\u03c7m \u2261m\u03a3 T .\nProof. Let I be a model ofM\u03c7m . We assume w.l.o.g that I is defined over all of Sig(T ). Consider the interpretation J over Sig(T ) such that \u2206J = \u2206I and\nAJ =  A I if A \u2208 (\u03a3 \u222a Sig(supp(\u03c7))) \\ {\u22a5}\nDarity(A) if A \u2208 Sig(P\u03c7m(Am0 )) \\ (\u03a3 \u222a Sig(supp(\u03c7))) \u2205 otherwise\nConsider r : \u03d5(x)\u2192 \u2203y.[ \u2228m j=1 \u03c8j(x,y)] \u2208 T . We will show that J |= r.\nAssume first m = 0. Then \u039e\u03c7m(r) = {\u03d5 \u2192 \u22a5}. If r \u2208 M\u03c7m then in particular Sig(r) \u2286 Sig(supp(\u03c7m)), so I and J agree over Sig(r), and J |= r. If r /\u2208 M\u03c7m then, since \u22a5 \u2208 A\u03c7mr and the only constant mentioned in P\u03c7m \u222a Am0 is \u2217, there must be \u03b3 \u2208 \u03d5 such that \u03b3\u2217 /\u2208 P\u03c7m(Am0 ) (where, in an abuse of notation, \u2217 denotes the substitution that maps all variables to \u2217), and in particular Sig(\u03b3) 6\u2286 Sig(P\u03c7m(Am0 )). Since \u03a3\u222a Sig(supp(\u03c7m)) \u2286 Sig(P\u03c7m(Am0 )), this implies that for A \u2208 Sig(\u03b3) it is AJ = \u2205 and therefore trivially J |= r.\nAssume now m > 0 and let \u03c3 be a substitution over all variables in r such that J |= \u03d5\u03c3 (if no such substitution exists then trivially J |= r). Since \u03a3 \u222a Sig(supp(\u03c7)) \u2286 Sig(P\u03c7m(Am0 )), all predicates in \u03d5 must occur in P\u03c7m(Am0 ). In particular it must be \u03b3\u2217 \u2208 P\u03c7m(Am0 ) for every \u03b3 \u2208 \u03d5. This implies \u03b4\u2217 \u2208 P\u03c7m(Am0 ) for every \u03b4 \u2208 \u22c3m j=1 \u03c8j and therefore for every predicate\nA in Sig( \u2228m j=1 \u03c8j) we have that either A\nJ = AI or AJ = \u2206arity(A)\u2014in particular AI \u2286 AJ . If AJ = \u2206arity(A) for every A \u2208 Sig( \u2228m j=1 \u03c8j), then it is immediate that J |= r. Suppose there exists A \u2208 Sig( \u2228m j=1 \u03c8j) such that A\nJ 6= \u2206arity(A). Then A \u2208 \u03a3 \u222a Sig(supp(\u03c7m)). If A \u2208 \u03a3 then A(\u2217, . . . , \u2217) \u2208 A\u03c7mr . Since A \u2208 Sig( \u2228m j=1 \u03c8j) and \u03b3\u2217 \u2208 P\u03c7m(Am0 ) for every \u03b3 \u2208 \u03d5, there is a proof \u03c1A,r of A(\u2217, . . . , \u2217) in P\u03c7m \u222aAm0 that mentions a rule in \u039e\u03c7m(r). Therefore r \u2208M\u03c7m . If A \u2208 Sig(supp(\u03c7m))\\\u03a3 then some other \u03b3\u2032 \u2208 Amr must be supported by a rule that has A in its signature. More specifically, there must be a proof of \u03b3\u2032 in P\u03c7m \u222a Am0 that has a proof of A(\u2217, . . . , \u2217) as a subproof. Replacing this subproof with \u03c1A,r results in a proof of \u03b3\u2032 in P\u03c7m \u222a Am0 that mentions a rule in \u039e\u03c7m(r). Therefore in this case r \u2208 M\u03c7m too. Now, since all rules in \u039e\u03c7m(r) have the same body as r, we have that Sig(\u03d5) \u2286 supp(\u03c7m) \\ {\u22a5} and therefore I and J agree over Sig(\u03d5). By assumption, J |= \u03d5\u03c3, so also I |= \u03d5\u03c3; furthermore I |= M\u03c7m implies I |= \u2228m j=1 \u03c8j\u03c3, which implies J |= \u2228m j=1 \u03c8j\u03c3 because A\nI \u2286 AJ for every predicate A \u2208 Sig( \u2228m j=1 \u03c8j). Since \u03c3 is arbitrary, we conclude that J |= r.\nD Depletingness and Preservation of Justifications Theorem 15. M\u03c7z is depleting for each z \u2208 {m, q, f, i, c}.\nProof. For z \u2208 {q, f, i, c} the statement follows from Propositions 22, 25 and 26 by the arguments already presented in the proofs for Theorems 3, 5 and 7.\nFor z = m, we will now show that T \\M\u03c7m \u2261m \u2205. Let I be a model of \u2205 and AI the ABox defined by I over \u03a3. Consider the datalog program P = \u22c3 r\u2208T \\M\u03c7m \u039e\u03c7m(r), and the materialisation P(AI) of P w.r.t. AI . We show that P(AI) is a model of T \\M that coincides with I over \u03a3. For this, it suffices to show the following two properties:\n\u2022 All facts over \u03a3 in P(AI) must already be in AI . Let \u03b3 \u2208 P(AI) be a fact over \u03a3. If \u03b3 /\u2208 AI then there must exist a proof \u03c1 of \u03b3 in P \u222a AI . Since AI only mentions predicates from \u03a3 and P \u2286 P\u03c7m , we can find a proof of \u03b3\u2217 \u2208 Amr in P\u03c7m \u222aAm0 that mentions the exact same rules as \u03c1. Let r be a rule mentioned in \u03c1, there must exist s \u2208 T \\M\u03c7m such that r \u2208 \u039e\u03c7m(s); however, because r is also mentioned in a proof of \u03b3\u2217 in P\u03c7m \u222a Am0 , it must also be s \u2208M\u03c7m . This is a contradiction, so \u03b3 \u2208 AI .\n\u2022 \u22a5 /\u2208 P(AI). Suppose\u22a5 \u2208 P(AI). Then there must be a proof \u03c1 of\u22a5 in P \u222aAI . Again, we can find a proof of\u22a5 in P\u03c7m \u222aAm0 supported by the exact same rules as \u03c1. Following a similar argument as before, we conclude that \u22a5 /\u2208 P(AI).\nTheorem 17. Let T \u2032 be a justification for a first-order sentence \u03d5 in T and let Sig(\u03d5) \u2286 \u03a3. Then, T \u2032 \u2286M\u03c7m . Additionally, the following properties hold: (i) if \u03d5 is a rule, then T \u2032 \u2286M\u03c7q ; (ii) if \u03d5 is datalog, then T \u2032 \u2286M\u03c7f ; and (iii) if \u03d5 is of the form A(x)\u2192 B(x), then T \u2032 \u2286M\u03c7i ; finally, if \u03d5 satisfies A \u2208 \u03a3, B \u2208 Sig(T ), then T \u2032 \u2286M\u03c7c .\nProof. The claim follows from Propositions 22, 25 and 26 similarly to Theorems 3, 5 and 7.\nE Module Containment Definition 27. Let \u03c7 = \u3008\u03b8,A0,Ar\u3009 and \u03c7\u2032 = \u3008\u03b8\u2032,A\u20320,A\u2032r\u3009 and let N and N\u2032 be the sets of constants mentioned in \u03c7 and \u03c7\u2032, respectively. A mapping \u00b5 : N \u2192 N\u2032 is a homomorphism from \u03c7 to \u03c7\u2032 if the following conditions hold: (i) \u03b8\u2032 = \u03b8\u00b5, (ii) A0\u00b5 \u2286 A\u20320; and (iii) Ar\u00b5 \u2286 A\u2032r. We write \u03c7 \u21aa\u2192 \u03c7\u2032 if a homomorphism from \u03c7 to \u03c7\u2032 exists.\nTheorem 28. If \u03c7, \u03c7\u2032 are s.t. \u03c7 \u21aa\u2192 \u03c7\u2032, thenM\u03c7 \u2286M\u03c7\u2032 .\nProof. Suppose \u03c7 = \u3008\u03b8,A0,Ar\u3009 and \u03c7\u2032 = \u3008\u03b8\u2032,A\u20320,A\u2032r\u3009with N and N\u2032 the sets of constants mentioned in \u03c7 and \u03c7\u2032, respectively. Let \u00b5 be a homomorphism from \u03c7 to \u03c7\u2032 and let r \u2208 M\u03c7. Some \u03b3 \u2208 Ar must be supported in P\u03c7 \u222a A0 by a rule in \u039e\u03c7(r). Since, by assumption, \u03b3\u00b5 \u2208 A\u2032r, it suffices for us to show that \u03b3\u00b5 is supported in P\u03c7 \u2032 \u222a A\u20320 by a rule from \u039e\u03c7 \u2032 (r).\nTo this end we will show that for any rule r \u2208 T and any fact \u03b3 such that there exists a proof \u03c1 = (T, \u03bb) of \u03b3 in P\u03c7 \u222a A0 mentioning s \u2208 \u039e\u03c7(r), there exists a proof of \u03b3\u00b5 in P\u03c7\u2032 \u222a A\u20320 mentioning \u039e\u03c7 \u2032 (r). We will reason by induction on the depth d of \u03c1\u2014which must be at least 1 since by assumption it uses s.\nd = 1 r must be of the form \u2227 i=1n \u03b4 \u2032 i(x)\u2192 \u2203y.[ \u2228m j=1 \u03c8j(x,y)] so s must be\n\u2013 \u2227 i=1n \u03b4 \u2032 i \u2192 \u03b3\u2032\u03b8 with \u03b3\u2032 \u2208 \u03c8j for some 1 \u2264 j \u2264 m if m > 0\nThe \u03bb-images of the leaves of T must be \u03b41, . . . , \u03b4n \u2208 A0 such that there exists a MGU \u03c3 of \u03b4i, \u03b4\u2032i for every 1 \u2264 i \u2264 n satisfying \u03b3 = \u03b3\u2032\u03b8\u03c3. By assumption, we have \u03b4i\u00b5 \u2208 A\u20320 for every 1 \u2264 i \u2264 n, and also s\u2032 = \u2227 i=1n \u03b4 \u2032 i \u2192 \u03b3\u2032\u03b8\u2032 \u2208 \u039e\u03c7 \u2032 (r) where \u03b8\u2032 = \u03b8\u00b5. Consider \u03c3\u2032 = \u03c3\u00b5. It is easy to see that \u00b5\u03c3\u00b5 = \u03c3\u00b5 since the domain of \u03c3 is disjoint with both the domain and the range of \u00b5. Therefore (\u03b4i\u00b5)\u03c3\u00b5 = \u03b4i\u03c3\u00b5 for every 1 \u2264 i \u2264 n. Furthermore, since \u03c3 is a MGU of \u03b4i, \u03b4\u2032i for every 1 \u2264 i \u2264 n, we have that \u03c3\u2032 is a MGU of \u03b4i\u00b5, \u03b4\u2032i for every 1 \u2264 i \u2264 n. Finally, since \u03b8\u2032 = \u03b8\u00b5, we have that \u03b3\u00b5 = \u03b3\u2032\u03b8\u03c3\u00b5 = \u03b3\u2032\u03b8\u00b5\u03c3\u00b5 = \u03b3\u2032\u03b8\u2032\u03c3\u2032 is a consequence of s\u2032 and \u03b41\u00b5, . . . , \u03b4n\u00b5, and hence we have a proof of \u03b3\u00b5 in P\u03c7\n\u2032 \u222aA\u20320 supported by s\u2032 \u2208 \u039e\u03c7\u2032(r).\n\u2013 \u2227 i=1n \u03b4 \u2032 i \u2192 \u22a5 if m = 0\nThen it must be \u03b3 = \u22a5 and, as in the previous case, the \u03bb-images of the leaves of T must be \u03b41, . . . , \u03b4n \u2208 A0 such that there exists a MGU \u03c3 of \u03b4i, \u03b4\u2032i for every 1 \u2264 i \u2264 n. Also, \u03b4i\u00b5 \u2208 A\u20320 for every 1 \u2264 i \u2264 n, s \u2208 \u039e\u03c7 \u2032 (r), and \u03c3\u2032 = \u03c3\u00b5 is a MGU of \u03b4i\u00b5, \u03b4\u2032i for every 1 \u2264 i \u2264 n, so we have a proof of \u03b3\u00b5 = \u22a5 in P\u03c7 \u2032 \u222a A\u20320 supported by s \u2208 \u039e\u03c7 \u2032 (r).\nd > 1 Let v be the root of T , let \u03b41, . . . , \u03b4n \u2208 A0 be the \u03bb-images of the children of v and let r\u2032 \u2208 T be such that the \u03bb-image of the edges connecting v with its children in T is a rule in \u039e\u03c7(r\u2032). Either s \u2208 \u039e\u03c7(r\u2032) or it is mentioned in some subproof of \u03c1. Our induction hypothesis implies that for each each r\u2032\u2032 \u2208 T , if some \u03b4i is supported in P\u03c7 \u222a A0 by a rule in \u039e\u03c7(r\u2032\u2032), then also \u03b4i\u00b5 is supported in P\u03c7 \u2032 \u222a A\u20320 by some rule in \u039e\u03c7 \u2032 (r\u2032\u2032). Therefore, in either case, following an argument similar to case\nd = 1, we can construct a proof \u03c1\u2032 of \u03b3\u00b5 in P\u03c7\u2032 \u222a A\u20320 from a collection of proofs of \u03b41\u00b5, . . . , \u03b4n\u00b5 in P\u03c7 \u2032 \u222a A\u20320 and a rule in \u039e\u03c7 \u2032 (r\u2032) in such a way that \u03c1\u2032 mentions a rule in \u039e\u03c7 \u2032 (r).\nProposition 19. M\u03c7i \u2286M\u03c7f \u2286M\u03c7q \u2286M\u03c7m \u2286M\u03c7b andM\u03c7i \u2286M\u03c7c \u2286M\u03c7b\nProof. This follows immediately from Theorem 28.\nF Optimality Definition 29. Let T be a TBox. Let \u03a3 \u2286 Sig(T ) and \u03a3\u2032 = \u03a3 \\ {\u22a5}. For each existentially quantified variable y in T , let cy be a fresh constant. Let \u03b8 = { y 7\u2192 cy | y existentially quantified in T }. Furthermore, for each pair \u3008A,B\u3009 \u2208 \u03a3\u2032 \u00d7 Sig(T ), let cA,B be a vector of fresh constants of size arity(A). We define \u03a8i0(T ,\u03a3) = \u3008\u03b8,A i0 0 ,Ai0r \u3009 where\n\u2022 Ai00 = {A(cA,B) | A,B \u2208 \u03a3\u2032,A 6= B, arity(A) = arity(B) } \u222a {A(cA,\u22a5) | A \u2208 \u03a3\u2032 } \u2022 Ai0r = {B(cA,B) | A,B \u2208 \u03a3\u2032,A 6= B, arity(A) = arity(B) } \u222a {\u22a5} We define \u03a8c0(T ,\u03a3) = \u3008\u03b8,A c0 0 ,Ac0r \u3009 where \u2022 Ac00 = {A(cA,B) | A \u2208 \u03a3\u2032,B \u2208 Sig(T ) \\ {\u22a5},A 6= B, arity(A) = arity(B) } \u222a {A(cA,\u22a5) | A \u2208 \u03a3\u2032 } \u2022 Ac0r = {B(cA,B) | A \u2208 \u03a3\u2032,B \u2208 Sig(T ) \\ {\u22a5},A 6= B, arity(A) = arity(B) } \u222a {\u22a5}\nFor each predicate B \u2208 \u03a3 and each v \u2208 {1, . . . , arity(B)}arity(B), let \u22171B,v, . . . , \u2217 arity(B)+1 B,v be fresh constants. We define \u03a8f0(T ,\u03a3) = \u3008\u03b8,A f0 0 ,Af0r \u3009 where\n\u2022 Af00 = {A(d) | A \u2208 \u03a3\u2032,B \u2208 \u03a3,v \u2208 {1, . . . , arity(B)}arity(B),d \u2208 {\u22171B,v, . . . , \u2217 arity(B)+1 B,v }arity(A),A(d) 6= B(\u2217vB,v) }\n\u2022 Af0r = {B(\u2217vB,v) | B \u2208 \u03a3,v \u2208 {1, . . . , arity(B)}arity(B) }\nProposition 30. Let z \u2208 {i, c}. Then, for every T and \u03a3,M\u03a8z(T ,\u03a3) =M\u03a8z0(T ,\u03a3).\nProof. It is easy to see that \u03a8z0(T ,\u03a3) \u21aa\u2192 \u03a8z(T ,\u03a3) for z \u2208 {i, c}. By Theorem 28, we thus have thatM\u03a8 z 0(T ,\u03a3) \u2286M\u03a8z(T ,\u03a3).\nBefore we continue, note that for each z \u2208 {i, c} the datalog programs P\u03a8z(T ,\u03a3) and P\u03a8z0(T ,\u03a3) coincide. For readability, we will denote this program with Pz .\nLet r \u2208 M\u03a8i(T ,\u03a3). Some fact \u03b3 \u2208 A\u03c7ir must be supported by a rule in \u039e\u03a8 i(T ,\u03a3)(r) = \u039e\u03a8 i 0(T ,\u03a3)(r). The fact \u03b3 must be either \u22a5 or B(cA) with A,B \u2208 \u03a3\u2032. It is easy to see how one can turn any proof of \u22a5 (resp. B(cA)) in P i \u222a Ai0 into a proof of \u22a5 (resp. B(cA,B)) in P i \u222a Ai00 that mentions the exact same rules. By construction of \u03a8i, both \u22a5 and B(cA,B) are in Ai0r , so r \u2208M\u03a8i0(T ,\u03a3). ThereforeM\u03a8i(T ,\u03a3) \u2286M\u03a8i0(T ,\u03a3).\nThe argument for z = c is analogous.\nTheorem 21. \u03a8z is z-optimal for z \u2208 {i, c}.\nProof. We show the claim for \u03a8i, the argument for \u03a8c is similar. Let \u03a3\u2032 = \u03a3 \\ {\u22a5}. For \u03a8i, suppose for contradiction there is a uniform, i-admissible \u03a8 and some T such thatM\u03a8i(T ,\u03a3) 6\u2286 M\u03a8(T ,\u03a3). Then, by Proposition 30,M\u03a8i0(T ,\u03a3) 6\u2286 M\u03a8(T ,\u03a3), and hence, by Theorem 28, \u03a8i0(T ,\u03a3) 6\u21aa\u2192 \u03a8(T ,\u03a3). Let \u03a8(T ,\u03a3) = \u3008\u03b8\u2032,A\u20320,A\u2032r\u3009. Since \u03a8i0(T ,\u03a3) 6\u21aa\u2192 \u03a8(T ,\u03a3), by construction of \u03a8i0, there are two cases to consider: \u2022 There are some A,B \u2208 \u03a3\u2032 with arity(A) = arity(B) such that for every vector c of size arity(A) of constants mentioned in\n\u03a8, A(c) /\u2208 A\u20320 or B(c) /\u2208 A\u2032r. Let\nT \u2032 = {A(x)\u2192 B(x)} \u222a {\u2192 \u2203y.Qy(y) | y existentially quantified in T , Qy fresh for every y }\nThen \u03a8(T \u2032,\u03a3) = \u03a8(T ,\u03a3) (by uniformity), and henceM\u03a8(T \u2032,\u03a3) = \u2205. Since \u2205 6|= A(x)\u2192 B(x), we haveM\u03a8(T \u2032,\u03a3) 6\u2261i T \u2032. \u2022 We have \u22a5 /\u2208 A\u2032r. Let\nT \u2032 = {A(x)\u2192 \u22a5} \u222a {\u2192 \u2203y.Qy(y) | y existentially quantified in T , Qy fresh for every y }\nfor some A \u2208 \u03a3\u2032. Then \u03a8(T \u2032,\u03a3) = \u03a8(T ,\u03a3) (by uniformity), and henceM\u03a8(T \u2032,\u03a3) = \u2205. Since \u2205 6|= A(x) \u2192 \u22a5, we have M\u03a8(T \u2032,\u03a3) 6\u2261i T \u2032.\nIn both cases, we obtain a contradiction to \u03a8 being i-admissible.\nProposition 31. The family \u03a8f0 is f-admissible.\nProof. By Propositions 22 and 25, it suffices to show that, given a datalog rule r = \u03d5 \u2192 \u03b3 and a substitution \u03c3 mapping all variables in r to distinct constants, we can construct a mapping \u03bd such that \u03d5\u03c3\u03bd \u2286 Af00 and \u03b3\u03c3\u03bd \u2208 Af0r . W.l.o.g. we can assume \u03b3 /\u2208 \u03d5 (otherwise r is a tautology and hence trivially entailed byM\u03a8f0(T ,\u03a3)) and therefore \u03b3\u03c3 /\u2208 \u03d5\u03c3 by injectivity of \u03c3.\nLet \u03b3\u03c3 = B(c). We construct \u03bd as follows. Let \u00b5 be an ordering of the constants in c. We define \u03bd such that c\u03bd = \u2217c\u00b5B,c\u00b5 if c \u2208 c and c\u03bd = \u2217arity(B)+1B,c\u00b5 otherwise. Since c\u00b5 \u2208 {1, . . . , arity(B)}arity(B) we have B(c)\u03bd \u2208 Af0r . Moreover, every fact in \u03d5\u03c3 is mapped by \u03bd to a fact A(d) where A \u2208 \u03a3 \\ {\u22a5}, d \u2208 {\u22171B,c, . . . , \u2217 arity(B)+1 B,c }arity(A), and A(d) 6= B(c)\u03bd since B(c) /\u2208 \u03d5\u03c3. Thus \u03d5\u03c3\u03bd \u2286 Af0r , and the claim follows.\nProposition 32. The family \u03a8f is not f-optimal.\nProof. By Proposition 31, it suffices to show thatM\u03a8f(T ,\u03a3) 6\u2286 M\u03a8f0(T ,\u03a3) for some T and \u03a3. Let T = {A(x) \u2192 A(x)} and \u03a3 = {A}. ThenM\u03a8f(T ,\u03a3) = T 6\u2286 \u2205 =M\u03a8f0(T ,\u03a3)."}], "references": [{"title": "MORe: Modular combination of OWL reasoners for ontology classification", "author": ["A. Armas Romero", "B. Cuenca Grau", "I. Horrocks"], "venue": "ISWC, 1\u201316.", "citeRegEx": "Romero et al\\.,? 2012", "shortCiteRegEx": "Romero et al\\.", "year": 2012}, {"title": "Just the right amount: Extracting modules from ontologies", "author": ["B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler"], "venue": "WWW, 717\u2013726.", "citeRegEx": "Grau et al\\.,? 2007", "shortCiteRegEx": "Grau et al\\.", "year": 2007}, {"title": "Modular reuse of ontologies: Theory and practice", "author": ["B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler"], "venue": "J. Artif. Intell. Res. 31:273\u2013318.", "citeRegEx": "Grau et al\\.,? 2008", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "Incremental classification of description logics ontologies", "author": ["B. Cuenca Grau", "C. Halaschek-Wiener", "Y. Kazakov", "B. Suntisrivaraporn"], "venue": "J. Autom. Reason. 44(4):337\u2013 369.", "citeRegEx": "Grau et al\\.,? 2010", "shortCiteRegEx": "Grau et al\\.", "year": 2010}, {"title": "Complexity and expressive power of logic programming", "author": ["E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov"], "venue": "ACM Comput. Surv. 33(3):374\u2013425.", "citeRegEx": "Dantsin et al\\.,? 2001", "shortCiteRegEx": "Dantsin et al\\.", "year": 2001}, {"title": "The modular structure of an ontology: Atomic decomposition", "author": ["C. Del Vescovo", "B. Parsia", "U. Sattler", "T. Schneider"], "venue": "IJCAI, 2232\u20132237.", "citeRegEx": "Vescovo et al\\.,? 2011", "shortCiteRegEx": "Vescovo et al\\.", "year": 2011}, {"title": "Empirical study of logicbased modules: Cheap is cheerful", "author": ["C. Del Vescovo", "P. Klinov", "B. Parsia", "U. Sattler", "T. Schneider", "D. Tsarkov"], "venue": "DL, 144\u2013155.", "citeRegEx": "Vescovo et al\\.,? 2013", "shortCiteRegEx": "Vescovo et al\\.", "year": 2013}, {"title": "Lower and upper approximations for depleting modules of description logic ontologies", "author": ["W. Gatens", "B. Konev", "F. Wolter"], "venue": "ECAI, 345\u2013350.", "citeRegEx": "Gatens et al\\.,? 2014", "shortCiteRegEx": "Gatens et al\\.", "year": 2014}, {"title": "LogMap: Logic-based and scalable ontology matching", "author": ["E. Jim\u00e9nez-Ruiz", "B. Cuenca Grau"], "venue": "ISWC, 273\u2013 288.", "citeRegEx": "Jim\u00e9nez.Ruiz and Grau,? 2011", "shortCiteRegEx": "Jim\u00e9nez.Ruiz and Grau", "year": 2011}, {"title": "Safe and economic re-use of ontologies: A logic-based methodology and tool support", "author": ["E. Jim\u00e9nez-Ruiz", "B. Cuenca Grau", "U. Sattler", "T. Schneider", "R. Berlanga Llavori"], "venue": "ESWC, 185\u2013199.", "citeRegEx": "Jim\u00e9nez.Ruiz et al\\.,? 2008", "shortCiteRegEx": "Jim\u00e9nez.Ruiz et al\\.", "year": 2008}, {"title": "Finding all justifications of OWL DL entailments", "author": ["A. Kalyanpur", "B. Parsia", "M. Horridge", "E. Sirin"], "venue": "ISWC, 267\u2013280.", "citeRegEx": "Kalyanpur et al\\.,? 2007", "shortCiteRegEx": "Kalyanpur et al\\.", "year": 2007}, {"title": "Model-theoretic inseparability and modularity of description logic ontologies", "author": ["B. Konev", "C. Lutz", "D. Walther", "F. Wolter"], "venue": "Artif. Intell. 203:66\u2013103.", "citeRegEx": "Konev et al\\.,? 2013", "shortCiteRegEx": "Konev et al\\.", "year": 2013}, {"title": "The combined approach to ontologybased data access", "author": ["R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev"], "venue": "IJCAI, 2656\u20132661.", "citeRegEx": "Kontchakov et al\\.,? 2011", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2011}, {"title": "Logic-based ontology comparison and module extraction, with an application to DL-Lite", "author": ["R. Kontchakov", "F. Wolter", "M. Zakharyaschev"], "venue": "Artif. Intell. 174(15):1093\u2013 1141.", "citeRegEx": "Kontchakov et al\\.,? 2010", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2010}, {"title": "ELP: Tractable rules for OWL 2", "author": ["M. Kr\u00f6tzsch", "S. Rudolph", "P. Hitzler"], "venue": "ISWC, 649\u2013664.", "citeRegEx": "Kr\u00f6tzsch et al\\.,? 2008", "shortCiteRegEx": "Kr\u00f6tzsch et al\\.", "year": 2008}, {"title": "Just: a tool for computing justifications w.r.t", "author": ["M. Ludwig"], "venue": "ELH ontologies. In ORE,", "citeRegEx": "Ludwig,? \\Q2014\\E", "shortCiteRegEx": "Ludwig", "year": 2014}, {"title": "Deciding inseparability and conservative extensions in the description logic EL", "author": ["C. Lutz", "F. Wolter"], "venue": "J. Symb. Comput. 45(2):194\u2013228.", "citeRegEx": "Lutz and Wolter,? 2010", "shortCiteRegEx": "Lutz and Wolter", "year": 2010}, {"title": "Generalized schema-mappings: From termination to tractability", "author": ["B. Marnette"], "venue": "PODS, 13\u201322.", "citeRegEx": "Marnette,? 2009", "shortCiteRegEx": "Marnette", "year": 2009}, {"title": "Parallel materialisation of datalog programs in centralised, main-memory RDF systems", "author": ["B. Motik", "Y. Nenov", "R. Piro", "I. Horrocks", "D. Olteanu"], "venue": "AAAI, 129\u2013137.", "citeRegEx": "Motik et al\\.,? 2014", "shortCiteRegEx": "Motik et al\\.", "year": 2014}, {"title": "Reachability modules for the description logic SRIQ", "author": ["R. Nortje", "K. Britz", "T. Meyer"], "venue": "LPAR, 636\u2013652.", "citeRegEx": "Nortje et al\\.,? 2013", "shortCiteRegEx": "Nortje et al\\.", "year": 2013}, {"title": "Which kind of module should I extract", "author": ["U. Sattler", "T. Schneider", "M. Zakharyaschev"], "venue": "In DL", "citeRegEx": "Sattler et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Sattler et al\\.", "year": 2009}, {"title": "Web ontology segmentation: Analysis, classification and use", "author": ["J. Seidenberg", "A.L. Rector"], "venue": "WWW, 13\u2013", "citeRegEx": "Seidenberg and Rector,? 2006", "shortCiteRegEx": "Seidenberg and Rector", "year": 2006}, {"title": "Introducing nominals to the combined query answering approaches for EL", "author": ["G. Stefanoni", "B. Motik", "I. Horrocks"], "venue": "AAAI, 1177\u20131183.", "citeRegEx": "Stefanoni et al\\.,? 2013", "shortCiteRegEx": "Stefanoni et al\\.", "year": 2013}, {"title": "Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, volume", "author": ["H. Stuckenschmidt", "C. Parent", "Spaccapietra", "eds"], "venue": null, "citeRegEx": "Stuckenschmidt et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Stuckenschmidt et al\\.", "year": 2009}, {"title": "A modularization-based approach to finding all justifications for OWL DL entailments", "author": ["B. Suntisrivaraporn", "G. Qi", "Q. Ji", "P. Haase"], "venue": "ASWC, 1\u201315.", "citeRegEx": "Suntisrivaraporn et al\\.,? 2008", "shortCiteRegEx": "Suntisrivaraporn et al\\.", "year": 2008}, {"title": "Module extraction and incremental classification: A pragmatic approach for ontologies", "author": ["B. Suntisrivaraporn"], "venue": "ESWC, 230\u2013244.", "citeRegEx": "Suntisrivaraporn,? 2008", "shortCiteRegEx": "Suntisrivaraporn", "year": 2008}, {"title": "Chainsaw: A metareasoner for large ontologies", "author": ["D. Tsarkov", "I. Palmisano"], "venue": "ORE.", "citeRegEx": "Tsarkov and Palmisano,? 2012", "shortCiteRegEx": "Tsarkov and Palmisano", "year": 2012}, {"title": "Pay-as-you-go OWL query answering using a triple store", "author": ["Y. Zhou", "Y. Nenov", "B. Cuenca Grau", "I. Horrocks"], "venue": "AAAI, 1142\u20131148.", "citeRegEx": "Zhou et al\\.,? 2014", "shortCiteRegEx": "Zhou et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 21, "context": "Module extraction has received a great deal of attention in recent years (Stuckenschmidt, Parent, and Spaccapietra 2009; Cuenca Grau et al. 2008; Seidenberg and Rector 2006; Kontchakov, Wolter, and Zakharyaschev 2010; Gatens, Konev, and Wolter 2014; Del Vescovo et al. 2011; Nortje, Britz, and Meyer 2013), and modules have found a wide range of applications, including ontology reuse (Cuenca Grau et al.", "startOffset": 73, "endOffset": 305}, {"referenceID": 9, "context": "2011; Nortje, Britz, and Meyer 2013), and modules have found a wide range of applications, including ontology reuse (Cuenca Grau et al. 2008; Jim\u00e9nez-Ruiz et al. 2008), matching (Jim\u00e9nez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al.", "startOffset": 116, "endOffset": 167}, {"referenceID": 24, "context": "2008), matching (Jim\u00e9nez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al. 2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al.", "startOffset": 63, "endOffset": 106}, {"referenceID": 15, "context": "2008), matching (Jim\u00e9nez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al. 2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al.", "startOffset": 63, "endOffset": 106}, {"referenceID": 26, "context": "2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010).", "startOffset": 38, "endOffset": 137}, {"referenceID": 11, "context": "\u03a3 (Konev et al. 2013).", "startOffset": 2, "endOffset": 21}, {"referenceID": 16, "context": ", the problem is already EXPTIME-hard for EL if we consider concept inclusions as the query language (Lutz and Wolter 2010).", "startOffset": 101, "endOffset": 123}, {"referenceID": 11, "context": "Practical algorithms that ensure minimality of the extracted modules are known only for acyclic ELI (Konev et al. 2013) and DLLite (Kontchakov, Wolter, and Zakharyaschev 2010).", "startOffset": 100, "endOffset": 119}, {"referenceID": 25, "context": "The connection between module extraction and datalog was first observed in (Suntisrivaraporn 2008), where it was shown that locality \u22a5-module extraction for EL ontologies could be reduced to propositional datalog reasoning.", "startOffset": 75, "endOffset": 98}, {"referenceID": 18, "context": "We have implemented our approach using the RDFox datalog engine (Motik et al. 2014).", "startOffset": 64, "endOffset": 83}, {"referenceID": 12, "context": "Our approach builds on recent techniques that exploit datalog engines for ontology reasoning (Kontchakov et al. 2011; Stefanoni, Motik, and Horrocks 2013; Zhou et al. 2014).", "startOffset": 93, "endOffset": 172}, {"referenceID": 27, "context": "Our approach builds on recent techniques that exploit datalog engines for ontology reasoning (Kontchakov et al. 2011; Stefanoni, Motik, and Horrocks 2013; Zhou et al. 2014).", "startOffset": 93, "endOffset": 172}, {"referenceID": 17, "context": "We achieve this by choosing A0 to be the critical ABox for \u03a3, which consists of all facts that can be constructed using \u03a3 and a single fresh constant (Marnette 2009).", "startOffset": 150, "endOffset": 165}, {"referenceID": 26, "context": "Module extraction has been exploited for optimising ontology classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010).", "startOffset": 76, "endOffset": 175}, {"referenceID": 10, "context": "Another common application of modules is to optimise the computation of justifications: minimal subsets of a TBox that are sufficient to entail a given formula (Kalyanpur et al. 2007; Suntisrivaraporn et al. 2008).", "startOffset": 160, "endOffset": 213}, {"referenceID": 24, "context": "Another common application of modules is to optimise the computation of justifications: minimal subsets of a TBox that are sufficient to entail a given formula (Kalyanpur et al. 2007; Suntisrivaraporn et al. 2008).", "startOffset": 160, "endOffset": 213}, {"referenceID": 4, "context": "Checking whether a datalog program P and an ABox A entail a fact is feasible in O(|P| \u00b7 n), with n the number of constants in P\u222aA and v the maximum number of variables in a rule from P (Dantsin et al. 2001).", "startOffset": 185, "endOffset": 206}, {"referenceID": 27, "context": "As shown in (Zhou et al. 2014), computing the support of a fact in a datalog program is no harder than fact entailment, and thus module extraction in our approach is feasible in O(|T |\u00b7n), and thus tractable for ontology languages where rules have a bounded number of variables (as is the case for most DLs).", "startOffset": 12, "endOffset": 30}, {"referenceID": 18, "context": "We have implemented a prototype system for module extraction that uses RDFox for datalog materialisation (Motik et al. 2014).", "startOffset": 105, "endOffset": 124}, {"referenceID": 27, "context": "Additionally, the ontology reasoner PAGOdA (Zhou et al. 2014) provides functionality for computing the support of an entailed fact in datalog, which we have adapted for computing modules.", "startOffset": 43, "endOffset": 61}], "year": 2014, "abstractText": "Module extraction\u2014the task of computing a (preferably small) fragment M of an ontology T that preserves entailments over a signature \u03a3\u2014has found many applications in recent years. Extracting modules of minimal size is, however, computationally hard, and often algorithmically infeasible. Thus, practical techniques are based on approximations, where M provably captures the relevant entailments, but is not guaranteed to be minimal. Existing approximations, however, ensure that M preserves all second-order entailments of T w.r.t. \u03a3, which is stronger than is required in many applications, and may lead to large modules in practice. In this paper we propose a novel approach in which module extraction is reduced to a reasoning problem in datalog. Our approach not only generalises existing approximations in an elegant way, but it can also be tailored to preserve only specific kinds of entailments, which allows us to extract significantly smaller modules. An evaluation on widely-used ontologies has shown very encouraging results.", "creator": "TeX"}}}