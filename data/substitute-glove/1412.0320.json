{"id": "1412.0320", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Dec-2014", "title": "Canonical Logic Programs are Succinctly Incomparable with Propositional Formulas", "abstract": "\\ emph {Canonical (intuitionistic) marketing} (CP) therefore only stress semantic programs sequential others necrotic $ any \\ clearly $. In result information we reform early question significant aware CP few \\ emph {unambiguously undoubted} although \\ emph {correlations assumptions} (PF ). Our central far reality not came PARITY serious, previously longer instead prevalently represented in PF making \\ emph {without} over multiplying objects in CP. In than phrase, PARITY \\ emph {extends} PF from CP. Simply stressed, fact use suggested gaussian smaller bedbug where frequently inevitable apparently translating a set another lexical in PF they an sum offers been CP (take introducing still parameters ). Furthermore, beginning on acknowledged though critical seen Lifschitz with Razborov one same is first entire result been outer CP few PF (circumstances $ \\ mathsf {P} \\ nsubseteq \\ mathsf {NC ^ 2006 / gabelli} $ ), be takes to CP taking PF people suggests summed lightness. From time although same given concept of geometry, a 40 form to whose all considered but several interpretation related already \\ emph {prototypes especially deterministic }, i. calls. , done directly giving malay in $ \\ mathsf {NC ^ vs. / gavilan} $ while fact consider in into set which english non-negative as formula_9 varies CP education.", "histories": [["v1", "Mon, 1 Dec 2014 01:10:30 GMT  (97kb)", "https://arxiv.org/abs/1412.0320v1", "This is an extended version of a conference paper with the same name in KR2014"], ["v2", "Sat, 24 Jan 2015 11:47:04 GMT  (97kb)", "http://arxiv.org/abs/1412.0320v2", "This is an extended version of a conference paper with the same name in KR2014"]], "COMMENTS": "This is an extended version of a conference paper with the same name in KR2014", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["yuping shen", "xishun zhao"], "accepted": false, "id": "1412.0320"}, "pdf": {"name": "1412.0320.pdf", "metadata": {"source": "CRF", "title": "Canonical Logic Programs are Succinctly Incomparable with Propositional Formulas", "authors": ["Yuping Shen", "Xishun Zhao"], "emails": ["hsszxs}@mail.sysu.edu.cn"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 2.\n03 20\nv2 [\ncs .L"}, {"heading": "1 Introduction", "text": "The study of logic programs under answer set semantics, i.e., answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades. As a competing approach to SAT [4], ASP has been successfully applied in many fields like Planning, Commonsense Reasoning, Scheduling, etc.\n\u2217Extended version of a paper with the same name in KR2014. \u2020Corresponding Author.\nThe relationship between logic programs and propositional formulas (PF) gains a lot of attention in the literature. A well-known theorem shown by Lin & Zhao [29] gives a method for translating a normal (logic) program (LP) to a (logically) equivalent set of formulas in PF, without introducing additional variables. However, it has been observed that the translation may result in an exponential number of socalled loop formulas in the worst case. In 2006, Lifschitz and Razborov proved that such exponential blowup is generally inevitable, more precisely, they showed that (a variant of) the P-complete problem PATH has polynomial size representations in LP, however, it cannot be polynomially represented in PF (assuming P * NC1/poly) [28]. In other words, we say PATH separates LP from PF.\nAs noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs. Therefore, NLP is stronger than PF in terms of the succinctness criterion (or the \u201ccomparative linguistics\u201d approach) proposed in [17]:\nThat is, we consider formalism A to be stronger than formalism B if and only if any knowledge base (KB) in B has an equivalent KB in A that is only polynomially longer, while there is a KB in A that can be translated to B only with an exponential blowup.\nSo the following footnote in [26] seems convincing at first glance:\n...ASP appears to be stronger than SAT in the sense of the \u201ccomparative linguistics\u201d approach to knowledge representation...\nHowever, since ASP involves many kinds of programs, the above statement probably needs further clarification. Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger. So a question naturally arises: Does there exist a problem that separates CP from PF? If there is such a problem, then CP and PF are succinctly incomparable (assuming P * NC1/poly).\nIn this paper we address the question and give a positive answer. Our main result shows that the problem PARITY separates PF from CP. Simply speaking, this means an exponential size blowup is generally inevitable when translating a set of formulas in PF into an equivalent program in CP (without introducing new variables). The PARITY problem asks whether a binary string contains an odd number of 1\u2019s, and it is well-known that (i) PARITY\u2208 NC1/poly, i.e., it has polynomial representations in PF2 [3, 21], (ii) PARITY/\u2208 AC0, i.e., it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].\nTo show PARITY separates PF from CP, we provide a procedure that simplifies every PARITY program \u03a0 into a shorter, loop-free program \u03a0\u2032. By Lin-Zhao\n1Extends LP with connective not not. 2NC1/poly (or non-uniform NC1) exactly contains languages computable (i.e., representable) by\npolynomial size propositional formulas.\nTheorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|. According to PARITY/\u2208 AC0, these circuits must be of exponential size, consequently, there are no polynomial size CP programs for PARITY.\nFrom the view of the theory of computation, the above result may also be considered as the separation of two models of computation [31], i.e., we identify a language in NC1/poly which is not in the set of languages computable by polynomial size CP programs. Based on the observation, we point out more separation results on some classes of logic programs, e.g., PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC1/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.\nThe rest of the paper is organized as follows: Section 2 gives preliminaries to the semantics of canonical programs, the concepts of succinctness and the PARITY problem. In Section 3 we briefly review the notation of boolean circuit, the completion semantics and the Lin-Zhao theorem. Section 4 illustrates how to simply an arbitrary PARITY program to be loop-free and presents the main theorem. In Section 5 we discuss the importance of succinctness research and point out more results on a family of logic program classes. Conclusions are drawn in the last Section."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 Canonical Programs", "text": "The following notations are adopted from [25, 22]. A rule element e is defined as\ne := \u22a4 | \u22a5 | x | not x | not not x\nin which \u22a4,\u22a5 are 0-ary connectives, x is a (boolean) variable (or an atom) and not is a unary connective3. A (nondisjunctive canonical) rule is an expression of the form\nH \u2190 B (1)\nwhere the head H is either a variable or the connective \u22a5, and the body B is a finite set of rule elements. A canonical program (CP) \u03a0 is a finite set of rules, \u03a0 is normal if it contains no connectives not not. A normal program \u03a0 is basic if it contains no connectives not. The following is a canonical program:\nx1 \u2190 not not x1, x2 \u2190 not not x2, x3 \u2190 not x1, not x2, x3 \u2190 x1, x2.\n(2)\n3According to [25], not not not x can be replaced by not x.\nThe satisfaction relation |= between a set of variables I and a rule element is defined as follows:\n\u2022 I |= \u22a4 and I 2 \u22a5,\n\u2022 I |= x iff I |= not not x iff x \u2208 I ,\n\u2022 I |= not x iff x /\u2208 I .\nSay I satisfies a set of rule elements B if I satisfies each rule elements in B. We say I is closed under a program \u03a0, if I is closed under every rule in \u03a0, i.e., for each rule H \u2190 B \u2208 \u03a0, I |= H whenever I |= B. Let \u03a0 be a basic program, Cn(\u03a0) denotes the minimal set (in terms of inclusion) closed under \u03a0, we say I is an answer set of \u03a0 if I = Cn(\u03a0). Note that a basic program has exactly one answer set.\nThe reduct \u03a0I of a canonical program \u03a0 w.r.t. I is a set of rules obtained from \u03a0 via: (i) Replacing each not not x with \u22a4 if I |= x, and with \u22a5 otherwise; (ii) Replacing each not x with \u22a4 if I 2 x, and with \u22a5 otherwise. Observe that \u03a0I must be a basic program. We say I is an answer set of \u03a0 if I = Cn(\u03a0I), i.e., I is an answer set of \u03a0I .\nThe following single rule canonical program \u03a0:\nx\u2190 not not x (3)\nhas two answer sets {x} and \u2205. To see this, check that \u03a0{x} is {x \u2190 \u22a4}, whose only answer set is {x}. Similarly, \u03a0\u2205 is {x\u2190 \u22a5}, whose only answer set is \u2205. For convenience, \u22a4 in the body is often omitted.\nFor a set of rule elements B, define var(B) = {e \u2208 B : e is a variable}. E.g., var({x1, not x2, not not x3}) = {x1}. Let \u03a0 be a program, by var(\u03a0) we denote the set of all variables involved in \u03a0 and by Ans(\u03a0) we denote the set of all answer sets of \u03a0. E.g., let \u03a0 be program (2), then var(\u03a0) = {x1, x2, x3} and Ans(\u03a0) = {{x1, x2, x3}, {x1}, {x2}, {x3}}. As a convention, by \u03a0n we refer to a program with n variables {x1, . . . , xn}, i.e., var(\u03a0n) = {x1, . . . , xn}. The size |\u03a0n| of a program \u03a0n, is the number of rules in it."}, {"heading": "2.2 Problem Representation and Succinctness", "text": "A string is a finite sequence of bits from {0, 1}. A string w of length n (i.e., w \u2208 {0, 1}n) can be written as w1w2 . . . wn, in which each bit wi \u2208 {0, 1}. Note that a string w \u2208 {0, 1}n defines a subset of variables {x1, . . . , xn}, e.g., 1010 stands for {x1, x3}. So a set of variables and a string is regarded as the same. A problem (or language ) L is a set of strings.\nDefinition 2.1 (Problem Representation). A problem L can be represented in a class of programs C (i.e., L \u2208 C), if there exists a sequence of programs {\u03a0n} (n = 1, 2, . . .) in C that computes L, i.e., for every string w \u2208 {0, 1}n,\nw \u2208 L \u21d4 w \u2208 Ans(\u03a0n).\nMoreover, say L has polynomial representations in C (i.e., L \u2208 Poly-C), if L \u2208 C and |\u03a0n| is bounded by a polynomial p(n).\nThe following concept is adopted from [17, 13].\nDefinition 2.2 (Succinctness). Let C, C\u2032 be two classes of programs and for every problem L, L \u2208 C \u21d4 L \u2208 C\u2032. Say C is at least as succinct as C\u2032 (i.e., C\u2032 C), if for every problem L,\nL \u2208 Poly-C\u2032 \u21d2 L \u2208 Poly-C.\nIf L \u2208 Poly-C but L 6\u2208 Poly-C\u2032 (i.e., C 6 C\u2032), then L separates C from C\u2032. If C\u2032 C and C 6 C\u2032, then C is strictly more succinct than C\u2032 (i.e., C\u2032 \u227a C). Moreover, C, C\u2032 are succinctly incomparable if there is a problem L separates C from C\u2032, and vice versa ( i.e.,C 6 C\u2032 and C\u2032 6 C).\nPlease note that the above notions also apply to formalisms like PF or boolean circuits, etc."}, {"heading": "2.3 The PARITY Problem", "text": "The PARITY problem is defined as:\nPARITY = {Binary strings with an odd number of 1\u2019s}.\nWe may simply call a string in PARITY an odd string, and PARITYn denotes the set of odd strings of length n. Observe that PARITYn contains 2n\u22121 strings. It is not hard to see that PARITYn for n = 1, 2 can be computed by normal programs \u03a01 = {x1 \u2190} and \u03a02 = {x1 \u2190 not x2, x2 \u2190 not x1} respectively. Since Ans(\u03a01) = {1} (i.e., {x1}), and Ans(\u03a02) = {10, 01} (i.e., {x1}, {x2}). However, as stated below, PARITYn for n \u2265 3 have no representations in normal programs.\nTheorem 2.1 (PARITY/\u2208LP). PARITY cannot be represented by normal programs.\nProof. Suppose there is a normal program \u03a0n that computes PARITYn for a fixed n \u2265 3. Then {x1} and {x1, x2, x3}, which are two odd strings, belong toAns(\u03a0n). However, this is impossible since it contradicts the anti-chain property of \u03a0n [28]: if strings I, I \u2032 \u2208 Ans(\u03a0n) and I \u2286 I \u2032 then I = I \u2032.\nOn the other hand, the anti-chain property is suppressed in CP. E.g., the answer set 111 of program (2) is a superset of the other three answer sets 100, 010, 001. Clearly, program (2) represents PARITY3, moreover, it suggests a \u201cpattern\u201d for representing PARITYn: The first part of the program (e.g., the first two rules in (2)) generates all possible strings of n \u2212 1 bits, the second part identifies the last bit to produce an odd string.\nTherefore, it is straightforward to give a sequence of canonical programs {\u03a0n} for PARITYn. The following is a PARITY4 program generated from the pattern:\nx1 \u2190 not not x1, x2 \u2190 not not x2, x3 \u2190 not not x3,\nx4 \u2190 x1, x2, not x3, x4 \u2190 x1, x3, not x2, x4 \u2190 x2, x3, not x1,\nx4 \u2190 not x1, not x2, not x3.\n(4)\nPlease note that the number of rules involved in the second part of the pattern grows exponentially, since the number of odd strings with the last bit 1 grows exponentially.\nTheorem 2.2 (PARITY\u2208CP). PARITY can be represented by exponential size canonical programs.\nBy PF we denote propositional formulas built on classical connectives {\u2227,\u2228,\u00ac} with boolean variables. Related concepts like satisfaction, model etc., are defined as usual. ByM(\u03c6) we denoted the set of models of \u03c6. The size |\u03c6| of a formula \u03c6 is the number of connectives occur in it. PARITYn for n = 1, 2 can be represented by formulas x1 and (x1 \u2227 \u00acx2)\u2228 (\u00acx2 \u2227 x1). Furthermore, it is a textbook result that PARITYn for n \u2265 3 has polynomial size formulas in PF, i.e., PARITY\u2208 NC1/poly (or Poly-PF) [3, 21].\n3 Boolean Circuits, Completion and PARITYn Programs for n \u2264 2"}, {"heading": "3.1 Boolean Circuits", "text": "A (boolean) circuit is a directed, cycle-free graph where each node is either a gate marked with one of {\u2227,\u2228,\u00ac} or a boolean variable. The in-degree (resp. out-degree) of a node is called its fan-in (resp. fan-out). A node marked with a variable always has fan-in 0 and is called an input. The output of the circuit is one gate designated with fan-out 0.\nThe value of a circuit Cn under inputs x1, . . . , xn, denoted by Cn(x1, . . . , xn), is the value of the output obtained from an iterative calculation through the inputs and the intermediate gates in the usual way. The size |Cn| of a circuit Cn is the number of gates occur in it. The depth of a circuit is the length of the longest path from an input to the output. We say a circuit computes (or represents) a problem L \u2286 {0, 1}n, if w \u2208 L \u21d4 Cn(w) = 1. E.g., a circuit C2 that computes PARITY2 is shown in Fig. 1. If L consists of strings of arbitrary lengths, then we introduce a sequence of circuits {Cn}(n = 1, 2, . . .) to represent L, as indicated in Definition 2.1.\nA circuit is said with bounded fan-in if each gate has at most fain-in 2. If we do not have such restriction then the circuit is with unbounded fan-in. The class AC0\nexactly contains all problems that can be computed by a sequence of circuits {Cn} in which the circuits Cn have constant depth and polynomial size p(n).\nE.g., a sequence of polynomial size CNFs {\u03c8n} computes an AC0 language, in which a CNF is a conjunction of clause of the form (L1 \u2228 . . . \u2228 Lm), where each Li is either a variable x or a negated variable \u00acx. Observe that CNF has constant depth 2 (\u00ac is usually not counted in the depth), and each clause can be regarded as an unbounded fan-in gate \u2228 with m inputs. Note that {\u03c8n} cannot represent PARITY since PARITY/\u2208 AC0. For more details about circuits, please see [3]."}, {"heading": "3.2 Completion and Related Theorems", "text": "The completion Comp(\u03a0) [6, 10] of a canonical program \u03a0, consists of a set (or conjunction) of formulas4:\n\u2022 x \u2261 B\u03031 \u2228 B\u03032 \u2228 \u00b7 \u00b7 \u00b7 \u2228 B\u0303m, where x \u2190 B1, . . . , x \u2190 Bm are all rules in \u03a0 with head x, and each B\u0303i is the conjunction of rule elements in Bi with connective not replaced by \u00ac,\n\u2022 x \u2261 \u22a5, if x is not a head of any rule in \u03a0,\n\u2022 \u00acB\u0303, if a rule \u22a5 \u2190 B is in \u03a0.\nProposition 3.1. Let \u03a0 be an arbitrary canonical program. Then Comp(\u03a0) is a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0|.\nProof. All propositional formulas are circuits of fan-out 1, so Comp(\u03a0) is definitely a circuit. Clearly, its size is polynomially bounded by |\u03a0|, and its depth is a constant for arbitrary program \u03a0. Moreover, there are no restrictions on the number of rule elements in a body or the number of rules in \u03a0, therefore the corresponding gates in Comp(\u03a0) are with unbounded fan-in.\nIt is well-known that every answer set of a canonical program \u03a0 is a model of Comp(\u03a0), but the inverse is generally not hold. E.g., the completion of the program x\u2190 x has two models {x} and \u2205, while it has a unique answer set \u2205. It turns\n4For convenience, we slightly abuse the connective \u2261 here.\nout that x\u2190 x gives rise to a so-called loop, which leads to an inappropriate model. It is shown in [29, 23] that the so-called loop formulas LF (\u03a0) nicely eliminate inappropriate models of Comp(\u03a0), s.t. the models of the union (or conjunction) of LF (\u03a0) and Comp(\u03a0) are coincided with Ans(\u03a0).\nThe (positive) dependency graph [2] of a canonical program \u03a0 is a pair (N,E) in which the set of nodes N = var(\u03a0), and E contains a directed edge (x, x\u2032) iff there is a rule H \u2190 B in \u03a0 s.t. H = x and x\u2032 \u2208 B. Note that rule elements of the form not x\u2032 or not not x\u2032 in B do not contribute to the edges. A non-empty set of variables U \u2286 var(\u03a0) is called a loop of \u03a0, if i) U is a singleton {x} and (x, x) \u2208 E, or ii) U is not a singleton and the restriction of the graph on U is strongly connected.\nLetU be a loop of \u03a0, defineR\u2212(U,\u03a0) = {H \u2190 B \u2208 \u03a0 : H \u2208 U, \u00ac\u2203 variable x \u2208 B s.t. x \u2208 U}. Let {B1, . . . , Bm} be all the bodies of the rules in R\u2212(U,\u03a0), then the loop formula LF (U,\u03a0) is the following:\n\u00ac[B\u03031 \u2228 . . . \u2228 B\u0303m] \u2283 \u2227\nx\u2208U\n\u00acx. (5)\nLF (\u03a0) denotes the conjunction of all loop formulas of \u03a0.\nTheorem 3.1 (Lin-Zhao Theorem[29, 23]). Let \u03a0 be a canonical program. Then \u03a0 is equivalent to Comp(\u03a0) \u222a LF (\u03a0), i.e., Ans(\u03a0) =M(Comp(\u03a0) \u222a LF (\u03a0)).\nBy Theorem 3.1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.e., completion-equivalent).\n3.3 PARITYn Programs for n \u2264 2\nProposition 3.2. Let \u03a01 be a PARITY1 canonical program. Then \u03a01 is equivalent to Comp(\u03a01).\nProof. By Theorem 3.1, the unique answer set {x1} of \u03a01 is a model ofComp(\u03a01)\u222a LF (\u03a01), which also is a model of LF (\u03a01). There are two cases about the loops in \u03a01: (i) \u03a01 has no loops. LF (\u03a01) is simply \u22a4; (ii) \u03a01 has a singleton loop {x1}. Recall that LF (\u03a01) is a formula of the form \u00ac[B\u03031 \u2228 . . . \u2228 B\u0303m] \u2283 \u00acx1, in which B1 . . . Bm are all the bodies of rules in R\u2212({x1},\u03a01). In both cases, \u2205 is a model of LF (\u03a01), so LF (\u03a01) is a tautology. Therefore, \u03a01 is equivalent to Comp(\u03a01).\nObserve that Proposition 3.2 does not hold for PARITY2 programs. Consider the following PARITY2 program:\nx1 \u2190 not x2, x2 \u2190 not x1, x1 \u2190 x1, x2 \u2190 x2.\n(6)\nClearly, {x1, x2} (i.e., 11) is not an answer set of (6), but a model of its completion {x1 \u2261 x1 \u2228 \u00acx2, x2 \u2261 x2 \u2228 \u00acx1}.\nNote that the rules {x1 \u2190 x1, x2 \u2190 x2} contribute to so-called singleton loops. We may check that without the above two rules, program (6) is a completionequivalent PARITY2 program. In fact, such \u201csingleton loop\u201d rules can be always safely removed, as stated in Proposition 3.3.\nLet \u03a0 be a basic program and I be a set of variables, define the Knaster-Tarski operator [2] as T\u03a0(I) = {H : H \u2190 B \u2208 \u03a0 and I |= B}. The operator T is monotone w.r.t. I therefore has a least fixed point T\u221e\n\u03a0 (\u2205), which can be computed\nby: (i) T 0 \u03a0 (\u2205) = \u2205; (ii) T i+1 \u03a0 (\u2205) = T\u03a0(T i \u03a0 (\u2205)) and (iii) T\u221e \u03a0 (\u2205) = \u22c3 i\u22650(T i \u03a0 (\u2205)). Moreover, T is also monotone w.r.t. \u03a0 for a given I , i.e., T\u03a0(I) \u2286 T\u03a0\u2032(I) if \u03a0 \u2286 \u03a0\u2032. It is pointed out in [15, 33] that I \u2208 Ans(\u03a0) iff I = T\u221e\n\u03a0I (\u2205) for a canonical\nprogram \u03a0.\nProposition 3.3. Let \u03a0 be a canonical program. Then removing each rule x \u2190 B \u2208 \u03a0 with x \u2208 var(B) results in a program \u03a0\u2032 s.t. Ans(\u03a0) = Ans(\u03a0\u2032).\nProof. It is sufficient to show T\u221e \u03a0I (\u2205) = T\u221e \u03a0\u2032I (\u2205) for any set I of variables. Suppose H \u2208 T\u221e\n\u03a0I (\u2205) for some I , then \u2203i > 0, H \u2208 T i \u03a0I (\u2205) and H /\u2208 T i\u22121 \u03a0I (\u2205). It is not\nhard to see that H must be obtained from a rule H \u2190 B in \u03a0 s.t. H /\u2208 var(B), H \u2190 var(B) \u2208 \u03a0I and T i\u22121\n\u03a0I (\u2205) |= var(B). Note that H \u2190 B \u2208 \u03a0\u2032 and\nH \u2190 var(B) is in \u03a0\u2032I as well. Now we show H \u2208 T\u221e \u03a0\u2032I (\u2205). Suppose H \u2208 T 1 \u03a0I (\u2205). So a rule H \u2190 is in \u03a0I and \u03a0\u2032I , clearly H \u2208 T\u221e\n\u03a0\u2032I (\u2205). Let k > 1 and assume for\nall i < k, T i \u03a0I (\u2205) \u2286 T\u221e \u03a0\u2032I (\u2205). Suppose H \u2032 \u2208 T k \u03a0I (\u2205), then \u2203H \u2032 \u2190 var(B\u2032) \u2208 \u03a0I s.t. T k\u22121 \u03a0I (\u2205) |= var(B\u2032). Obviously H \u2032 \u2208 T\u221e \u03a0\u2032I (\u2205) since H \u2032 \u2190 var(B\u2032) \u2208 \u03a0\u2032I and T\u221e \u03a0\u2032I (\u2205) |= var(B\u2032) by induction hypothesis. Therefore T\u221e \u03a0I (\u2205) \u2286 T\u221e \u03a0\u2032I\n(\u2205). Note that \u03a0\u2032I \u2286 \u03a0I since \u03a0\u2032 \u2286 \u03a0. It follows that T\u221e\n\u03a0\u2032I (\u2205) \u2286 T\u221e \u03a0I (\u2205) due to the\nmonotonicity of operator T . Hence T\u221e \u03a0I (\u2205) = T\u221e \u03a0\u2032I (\u2205).\nIt turns out that we have a more general observation: deleting all rules with variables in the body (thus removing all loops) does not affect the answer sets of a PARITY2 program!\nProposition 3.4. Let\u03a02 be a PARITY2 canonical program. Then there is a PARITY2 program \u03a0\u20322 which is equivalent to Comp(\u03a0 \u2032 2) and |\u03a0 \u2032 2| \u2264 |\u03a02|.\nProof. W.l.o.g., assume \u03a02 has no singleton loops. Let \u03a0\u20322 = {H \u2190 B \u2208 \u03a02 : var(B) = \u2205}, clearly \u03a0\u20322 \u2286 \u03a02 and thus |\u03a0 \u2032 2| \u2264 |\u03a02|. To see \u03a0 \u2032 2 is also a PARITY2 program, it is sufficient to show for any I \u2208 Ans(\u03a02), Cn(\u03a0I2) = Cn(\u03a0 \u2032I 2 ). Suppose H \u2208 I , i.e., H \u2208 Cn(\u03a0I2). We claim that H must be obtained from a rule H \u2190 B in \u03a02 s.t. (i) I |= B, and (ii) var(B) = \u2205. Clearly (i) holds. To see (ii), note that \u03a02 has exactly two answer sets {x1} and {x2}. W.l.o.g., let I = {x1} thus H = x1. Since \u03a02 has no singleton loops, x1 /\u2208 var(B), and x2 /\u2208 var(B) since I |= B. Hence var(B) = \u2205.\nNow it is easy to see H \u2190 B \u2208 \u03a0\u20322 and H \u2190\u2208 \u03a0 \u2032I 2 since I |= B and\nvar(B) = \u2205. Thus H \u2208 Cn(\u03a0\u2032I2 ). Therefore Cn(\u03a0 I 2) \u2286 Cn(\u03a0 \u2032I 2 ). Since \u03a0 \u2032 2 \u2286\n\u03a02, we have Cn(\u03a0\u2032I2 ) \u2286 Cn(\u03a0 I 2) due to the monotonicity of operator Cn(\u00b7). Consequently, Cn(\u03a0I2) = Cn(\u03a0 \u2032I 2 ). Observe that \u03a0 \u2032 2 has no loops, so \u03a0 \u2032 2 is equivalent to Comp(\u03a0\u20322) .\nConsider the following PARITY2 program (7), which has a non-singleton loop {x1, x2} but not completion-equivalent. One may see that removing the two rules in the second line makes it completion-equivalent, without affecting its answer sets.\nx1 \u2190 not x2, x1 \u2190 x2, not not x1, x2 \u2190 not x1, x2 \u2190 x1, not not x2.\n(7)\nIn the following, we shall introduce a general approach to simply an arbitrary PARITY program to be completion-equivalent.\n4 General Simplification of PARITYn Programs\nLet B be a set of rule elements built on associated variables V = {x1, . . . , xn}. We say B is consistent if there is a set of variables I s.t. I |= B. Define S(B) to be the set {I \u2286 V : I |= B}. E.g., let V = {x1, x2, x3, x4} and B = {x2, not x3, not not x4}, thenB is consistent and S(B) = {{x1, x2, x4}, {x2, x4}} = {1101, 0101}. Clearly, if B is not consistent then S(B) = \u2205. Note that if a rule has an inconsistent body, then it is redundant and can be safely removed.\nWe say B covers a variable x \u2208 V iff x \u2208 B or not x \u2208 B or not not x \u2208 B. If B covers every variable in V thenB fully covers V . E.g.,B = {x1, not x2, not not x3} fully covers V = {x1, x2, x3}. Obviously, B is consistent and fully covers V iff S(B) contains a unique string.\nIn the next section, we stipulate that the set of associated variables is var(\u03a0n) whenever \u03a0n is the program under discussion, we also assume that a PARITY program has no singleton-loops and contains no inconsistent bodies."}, {"heading": "4.1 Simplifying Full Coverage Rules", "text": "A rule H \u2190 B \u2208 \u03a0n is a full coverage rule if B fully covers var(\u03a0n).\nLemma 4.1. Let \u03a0n be a PARITYn program. Suppose there is a rule x \u2190 B in \u03a0n s.t. not not x \u2208 B and S(B) contains a unique even string. Then removing x\u2190 B from \u03a0n results in a PARITYn program \u03a0\u2032n.\nProof. We show for any set I of variables, I = Cn(\u03a0In) iff I = Cn(\u03a0 \u2032I n ). Observe that \u03a0\u2032n \u2286 \u03a0n, then Cn(\u03a0 \u2032I n ) \u2286 Cn(\u03a0 I n) for any I . So it is sufficient to show Cn(\u03a0In) \u2286 Cn(\u03a0 \u2032I n ). Assume Cn(\u03a0 I n) * Cn(\u03a0 \u2032I n ) for some I . It must be the case that x \u2208 Cn(\u03a0In) and x /\u2208 Cn(\u03a0 \u2032I n ) since \u03a0 \u2032 n \u222a {x \u2190 B} = \u03a0n. Moreover, we have x \u2190 var(B) \u2208 \u03a0In and Cn(\u03a0 I n) |= var(B). The former implies that I |= B \\ var(B). Since not not x \u2208 B \\ var(B), we have I |= not not x (i.e., x \u2208 I).\nNow suppose I = Cn(\u03a0In), then I is an odd string. However, recall that I |= B \\ var(B) and I = Cn(\u03a0In) |= var(B). Hence we have I |= B, i.e., I \u2208 S(B). This contradicts the fact that I \u2208 S(B) is an even string. So Cn(\u03a0In) \u2286 Cn(\u03a0 \u2032I n ).\nSuppose I = Cn(\u03a0\u2032In ). As mentioned above, Cn(\u03a0 I n) * Cn(\u03a0 \u2032I n ) implies that\nx /\u2208 Cn(\u03a0\u2032In ) and x \u2208 I . However, recall that I = Cn(\u03a0 \u2032I n ), hence x \u2208 Cn(\u03a0 \u2032I n ), a contradiction. So Cn(\u03a0In) \u2286 Cn(\u03a0 \u2032I n ).\nNote that Lemma 4.1 also justifies our simplification for (7).\nLemma 4.2. Let \u03a0n be a PARITYn program. Suppose there is a rule x \u2190 B in \u03a0n s.t. not not x \u2208 B and S(B) contains a unique odd string. Then replacing its body B with B\u2032 = B \\ {not not x} results in a PARITYn program \u03a0\u2032n.\nProof. We show that I = Cn(\u03a0In) iff I = Cn(\u03a0 \u2032I n ) for any set I of variables. Suppose I = Cn(\u03a0In), we shall prove Cn(\u03a0 I n) = Cn(\u03a0 \u2032I n ). Consider the following cases:\n\u2022 I |= B \\ var(B). Since B\u2032 = B \\ {not not x}, clearly, B\u2032 \\ var(B\u2032) \u2286 B \\var(B), hence I |= B\u2032\\var(B\u2032). It follows that x\u2190 var(B) \u2208 \u03a0In and x \u2190 var(B\u2032) \u2208 \u03a0\u2032In . Furthermore, note that \u03a0n \\ {x \u2190 B} = \u03a0 \u2032 n \\ {x \u2190\nB\u2032} and var(B) = var(B\u2032), thus \u03a0In = \u03a0 \u2032I n . So Cn(\u03a0 I n) = Cn(\u03a0 \u2032I n ).\n\u2022 I 2 B \\ var(B). Consider the following subcases:\n\u2013 I 2 B\u2032 \\ var(B\u2032). Similarly, we have \u03a0\u2032In = \u03a0 I n, thus Cn(\u03a0 \u2032I n ) =\nCn(\u03a0In).\n\u2013 I |= B\u2032 \\ var(B\u2032). Clearly, in this case I 2 not not x. Now suppose I |= var(B\u2032), so we have I |= B\u2032. Recall that (i) not not x \u2208 B, (ii) x /\u2208 B since \u03a0n has no singleton loops, (iii) B\u2032 = B \\{not not x} and (iv) S(B) contains a unique odd string, say I \u2032. It follows that S(B\u2032) = {I \u2032, I \u2032 \\ {x}}. Obviously I must be I \u2032 \\ {x} since I \u2032 |= not not x. However, this is a contradiction since I \u2032 \\ {x} is an even string and I is an odd string since I is an answer set of \u03a0n. So suppose I 2 var(B). Note that in this case \u03a0\u2032In = \u03a0 I n \u222a {x \u2190 var(B)}, we show\nCn(\u03a0In) = Cn(\u03a0 I n \u222a {x \u2190 var(B)}), i.e., Cn(\u03a0 I n) = Cn(\u03a0 \u2032I n ). Firstly, Cn(\u03a0In) \u2286 Cn(\u03a0 I n \u222a{x\u2190 var(B)}) due to the monotonicity of operator Cn(\u00b7). Assume Cn(\u03a0In \u222a {x \u2190 var(B)}) * Cn(\u03a0 I n), it must be Cn(\u03a0In) |= var(B) and x \u2208 Cn(\u03a0 I n \u222a {x \u2190 var(B)}), x /\u2208 Cn(\u03a0In). However this is impossible since I = Cn(\u03a0 I n) and I 2 var(B). Therefore Cn(\u03a0In \u222a {x\u2190 var(B)}) \u2286 Cn(\u03a0 I n).\nSuppose I = Cn(\u03a0\u2032In ), we shall prove Cn(\u03a0 I n) = Cn(\u03a0 \u2032I n ). Consider the\nfollowing cases:\n\u2022 x \u2190 var(B\u2032) /\u2208 \u03a0\u2032In . Clearly, I 2 B \u2032 \\ var(B\u2032). So I 2 B \\ var(B) since\nB\u2032 \\ var(B\u2032) \u2286 B \\ var(B). Therefore x \u2190 var(B) /\u2208 \u03a0In and we have \u03a0\u2032In = \u03a0 I n. Hence Cn(\u03a0 \u2032I n ) = Cn(\u03a0 I n).\n\u2022 x\u2190 var(B\u2032) \u2208 \u03a0\u2032In . There are two subcases:\n\u2013 x \u2190 var(B) \u2208 \u03a0In. Similarly, \u03a0 \u2032I n = \u03a0 I n and then Cn(\u03a0 \u2032I n ) =\nCn(\u03a0In).\n\u2013 x \u2190 var(B) /\u2208 \u03a0In. Clearly, I 2 not not x, i.e., x /\u2208 I . Furthermore, recall that \u03a0\u2032In = \u03a0 I n \u222a {x \u2190 var(B\n\u2032)}, We shall show Cn(\u03a0\u2032In ) = Cn(\u03a0In). Obviously Cn(\u03a0 I n) \u2286 Cn(\u03a0 \u2032I n ). Now assume Cn(\u03a0 \u2032I n ) * Cn(\u03a0In). It must be the case that x \u2208 Cn(\u03a0 \u2032I n ) but x /\u2208 Cn(\u03a0 I n). However, since I = Cn(\u03a0\u2032In ), we have x \u2208 I , a contradiction. So Cn(\u03a0\u2032In ) \u2286 Cn(\u03a0 I n), therefore Cn(\u03a0 \u2032I n ) = Cn(\u03a0 I n).\n4.2 Standard PARITYn Programs\nA PARITYn program \u03a0n is standard if for each rule x\u2190 B \u2208 \u03a0n, not not x /\u2208 B whenever S(B \u222a {x}) contains a unique string. E.g., the PARITY program (2) is standard, while (7) is not. Note that if \u03a0n is standard, then for any rule x \u2190 B \u2208 \u03a0n, B does not cover x, i.e., x /\u2208 B, not x /\u2208 B and not not x /\u2208 B, since \u03a0n has no singleton loops and S(B \u222a {x}) is consistent.\nProposition 4.1. Let \u03a0n be a PARITYn program. Then there is a standard PARITYn program \u03a0\u2032n s.t. |\u03a0 \u2032 n| \u2264 |\u03a0n|.\nProof. For each rule x \u2190 B \u2208 \u03a0n in which not not x \u2208 B and S(B) contains a unique string: (i) Delete x \u2190 B from \u03a0n if S(B) contains an even string; (ii) Remove not not x from B if S(B) contains an odd string. By Lemma 4.1 and 4.2, the above procedure results in a standard PARITYn program \u03a0\u2032n and |\u03a0 \u2032 n| \u2264 |\u03a0n|.\nProposition 4.2. Let \u03a0n be a standard PARITYn program. Then \u03a0n is equivalent to its completion Comp(\u03a0n).\nThe proof idea of Proposition 4.2 is that every standard PARITYn program \u03a0n can be equivalently rewritten to a loop-free program \u03a0\u2032n by replacing each x \u2208 var(B) with not not x for every rule bodyB in \u03a0n. By the Lin-Zhao Theorem or the (generalized) Fages Theorem, \u03a0\u2032n is equivalent to its completion Comp(\u03a0 \u2032 n). And then the proposition follows from the fact that Comp(\u03a0\u2032n) = Comp(\u03a0n), since not is treated as classical negation \u00ac in the completion. The detailed proof is presented in subsection 4.3."}, {"heading": "4.3 Proof of Proposition 4.2", "text": "For technical reasons, we divide the rewriting procedure into two steps, in the first step a standard PARITY program is converted to so-called almost pure program and in the second step the program is converted to a pure one, i.e., a PARITY program that does not have any loops. Before doing so we show some lemmas.\nLemma 4.3. Let \u03a0n be a standard PARITYn program. For each rule x\u2190 B \u2208 \u03a0n, if S(B \u222a {x}) contains a unique string, then the string must be odd.\nProof. Since \u03a0n is standard, B does not cover x. So we have S(B) = {I, I \\{x}}. Assume I is an even string, then I \\ {x} must be an odd string. It follows that I \\ {x} is not closed under x\u2190 B, since I \\ {x} |= B but I \\ {x} 2 x. However, \u03a0n is a PARITYn program, every odd string must be closed under x \u2190 B. A contradiction.\nLemma 4.4. Let \u03a0n be a PARITYn program.\n(i) If there is a rule x\u2190 B \u2208 \u03a0n s.t. B is consistent and B \u222a {x} does not fully cover var(\u03a0n), then not not x \u2208 B.\n(ii) If there is a rule H \u2190 B \u2208 \u03a0n s.t. B is consistent and B \u222a {H} is inconsistent, then B fully covers var(\u03a0n).\nProof. Note that for any rule x \u2190 B in a PARITY1 program, B \u222a {x} must fully cover var(\u03a01) since \u03a01 involves only one variable. So in the following we consider n \u2265 2.\n(i) Equivalently, we show that if B is consistent and not not x /\u2208 B, then B \u222a {x} fully covers var(\u03a0n). Assume B \u222a {x} does not fully cover var(\u03a0n). It follows that B covers 0 \u2264 i < n variables in var(\u03a0n) (i.e., B does not fully cover var(\u03a0n)). Consider the following cases:\n\u2022 not x \u2208 B. Note that B is consistent and n \u2265 2. It is not hard to see S(B) has exactly 2n\u2212i\u22121 \u2265 1 odd strings. It means there is at least one odd string I , I |= B and I 2 x. Therefore I is not close under x\u2190 B. However, since \u03a0n is a PARITYn program, every odd string must be closed under x \u2190 B. A contradiction.\n\u2022 not x /\u2208 B. B does not cover x, since not not x /\u2208 B and x /\u2208 B for \u03a0n has no singleton loops. Recall that B is consistent and n \u2265 2, thus S(B) has exactly 2n\u2212i\u22121 odd strings. Obviously, half of these strings do not satisfy x. To be more precise, there are 2n\u2212i\u22122 odd strings I , I |= B and I 2 x. We have 2n\u2212i\u22122 \u2265 1 since i is at most n\u22122. In other words, there is at least one odd string I which is not close under x\u2190 B. Again a contradiction.\nConsequently, B \u222a {x} must fully cover var(\u03a0n). (ii) There are two cases about H:\n\u2022 H is \u22a5. Assume B does not fully cover var(\u03a0n), i.e., B covers i variables in var(\u03a0n) with 0 \u2264 i < n. Since B is consistent, it is easy to see S(B) has exactly 2n\u2212i\u22121 \u2265 1 odd strings. So there exists at least one odd string I is not closed under \u22a5 \u2190 B. A contradiction.\n\u2022 H is a variable x \u2208 var(\u03a0n). SinceB\u222a{x} is inconsistent, we have not x \u2208 B. It is not hard to see in this case x \u2190 B can be rewritten as \u22a5 \u2190 B. By an argument similar to the above, B must fully cover var(\u03a0n).\n4.3.1 Almost Pure PARITYn Programs\nLet \u03a0n be a standard PARITYn program in CP, by F\u2212(\u03a0n) we denote the set of rules H \u2190 B \u2208 \u03a0n s.t. B \u222a {H} does not fully cover var(\u03a0n), by F+(\u03a0n) we denote \u03a0n \\ F\u2212(\u03a0n). If for each rule H \u2190 B \u2208 F+(\u03a0n) we have var(B) = \u2205, then \u03a0n is called almost pure.\nBy Lemma 4.4, it is not hard to see that every rule of the form x\u2190 B,not not x is in F\u2212(\u03a0n), and every rule of the form \u22a5 \u2190 B or x\u2190 B,not x is in F+(\u03a0n).\nProposition 4.3. Let \u03a0n be a standard PARITYn program. Then there is an almost pure PARITYn program \u03a0\u2032n s.t. |\u03a0 \u2032 n| \u2264 |\u03a0n|.\nProof. Let B\u2032 be the set obtained from B by replacing every x \u2208 var(B) with not not x. Note that I |= B iff I |= B\u2032 for any set of variables I . Let \u03a0\u2032n be the program obtained from \u03a0n by replacing every rule H \u2190 B \u2208 F+(\u03a0n) with H \u2190 B\u2032. Clearly \u03a0\u2032n is almost pure and |\u03a0 \u2032 n| \u2264 |\u03a0n|. It remains to prove that \u03a0 \u2032 n is also a PARITYn program, i.e., I = T\u221e\u03a0In (\u2205) iff I = T\u221e \u03a0\u2032In (\u2205).\n(\u21d2) Suppose I is an answer set of \u03a0n, i.e., I = T\u221e\u03a0In (\u2205), we shall show\nT\u221e \u03a0In (\u2205) = T\u221e \u03a0\u2032In (\u2205):\n\u2022 T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032In (\u2205). Note that \u22a5 /\u2208 T\u221e \u03a0In (\u2205) since T\u221e \u03a0In (\u2205) is an answer set.\nSuppose x \u2208 T 1 \u03a0In (\u2205), then \u2203x \u2190 B \u2208 \u03a0n s.t. var(B) = \u2205 and I |= B. Clearly, we have x \u2190 B \u2208 \u03a0\u2032n. It follows that x \u2190\u2208 \u03a0 \u2032I n and then x \u2208 T\u221e \u03a0\u2032In (\u2205). Let k > 1 and assume for all i < k, T i \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032In (\u2205). Suppose x \u2208 T k \u03a0In (\u2205) but x /\u2208 T k\u22121 \u03a0In\n(\u2205). Then \u2203x \u2190 B \u2208 \u03a0n s.t. x \u2190 var(B) \u2208 \u03a0In and T k\u22121\n\u03a0In (\u2205) |= var(B). Observe that either x\u2190 B \u2208 \u03a0\u2032n or x\u2190 B \u2032 \u2208 \u03a0\u2032n.\nThe former implies that x \u2190 var(B) \u2208 \u03a0\u2032In , clearly, T \u221e \u03a0\u2032In (\u2205) |= var(B) by induction hypothesis, and thus x \u2208 T\u221e \u03a0\u2032In (\u2205). The latter implies that x \u2190\u2208 \u03a0\u2032In , trivially, x \u2208 T \u221e \u03a0\u2032In (\u2205). Therefore, T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032In (\u2205).\n\u2022 T\u221e \u03a0\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205). We first show \u22a5 /\u2208 T\u221e \u03a0\u2032In (\u2205). Assume \u22a5 \u2208 T\u221e \u03a0\u2032In (\u2205), then\n\u2203\u22a5 \u2190 B1 \u2208 \u03a0 \u2032 n s.t. I |= B1 \\ var(B1). Consider its source \u22a5 \u2190 B in \u03a0n. Recall that \u03a0n has no singleton loops and B is consistent since \u03a0n is standard. Furthermore, B \u222a {\u22a5} is inconsistent, then \u22a5 \u2190 B \u2208 F+(\u03a0n) by Lemma 4.4 (ii). So var(B1) = \u2205, I |= B1 and thus I |= B. The latter means that I is not closed under \u22a5 \u2190 B \u2208 \u03a0n, which contradicts the fact that I is an answer set of \u03a0n. So \u22a5 /\u2208 T\u221e\u03a0\u2032In (\u2205). Now suppose x \u2208 T 1 \u03a0\u2032In (\u2205), then \u2203x \u2190 B1 \u2208 \u03a0\u2032n s.t. x \u2190\u2208 \u03a0 \u2032I n and I |= B1. Consider the source of x\u2190 B1:\n(i) x \u2190 B1 \u2208 \u03a0n, var(B1) = \u2205. Since I |= B1, x \u2190\u2208 \u03a0In, we have x \u2208 T\u221e\n\u03a0In (\u2205).\n(ii) x\u2190 B \u2208 F+(\u03a0n), var(B) 6= \u2205 and B1 = B\u2032. Note that I |= B since I |= B1. Furthermore, I is closed under x \u2190 B since I is an answer set of \u03a0n. So x \u2208 I , i.e, x \u2208 T\u221e\u03a0In (\u2205).\nSuppose x \u2208 T k \u03a0\u2032In (\u2205) but x /\u2208 T k\u22121 \u03a0\u2032In (\u2205) for some k > 1. It means that \u2203x\u2190 B1 \u2208 \u03a0 \u2032 n s.t. var(B1) 6= \u2205, x\u2190 var(B1) \u2208 \u03a0 \u2032I n , I |= B1 \\ var(B1) and T k\u22121 \u03a0\u2032In (\u2205) |= var(B1). Note that var(B1) 6= \u2205 implies that x \u2190 B1 \u2208 F\u2212(\u03a0n), B1 \u222a {x} does not fully cover var(\u03a0n). By Lemma 4.4 (i), we have not not x \u2208 B1. Recall that I |= B1 \\ var(B1), so I |= not not x, i.e., x \u2208 T\u221e\n\u03a0In (\u2205). Therefore, T\u221e \u03a0\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205).\n(\u21d0) Suppose I is an answer set of \u03a0\u2032n, i.e., I = T \u221e \u03a0\u2032In (\u2205), we shall show\nT\u221e \u03a0\u2032In (\u2205) = T\u221e \u03a0In (\u2205):\n\u2022 T\u221e \u03a0\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205). Note that \u22a5 /\u2208 T\u221e \u03a0\u2032In (\u2205). Suppose x \u2208 T 1 \u03a0\u2032In (\u2205), then\n\u2203x \u2190 B1 \u2208 \u03a0 \u2032 n s.t. var(B1) = \u2205, x \u2190\u2208 \u03a0 \u2032I n and I |= B1. Now consider the source of x\u2190 B1:\n(i) x\u2190 B1 \u2208 \u03a0n. So x\u2190\u2208 \u03a0In and clearly x \u2208 T \u221e \u03a0In (\u2205).\n(ii) x\u2190 B \u2208 F+(\u03a0n), var(B) 6= \u2205 and B1 = B. Note that I |= B1\u222a{x} since x \u2208 I and I |= B1, it follows that I |= B\u222a{x}. Clearly, B\u222a{x} is consistent and fully covers var(\u03a0n). By Lemma 4.3, I is exactly the unique odd string in S(B \u222a {x}). Recall that \u03a0n is a PARITYn program, so I must be an answer set of \u03a0n, i.e., I = T\u221e\u03a0In (\u2205). Therefore\nx \u2208 T\u221e \u03a0In (\u2205).\nLet k > 1 and assume for all i < k, T i \u03a0\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205). Suppose x \u2208 T k \u03a0\u2032In (\u2205) but x /\u2208 T k\u22121 \u03a0\u2032In (\u2205). Then \u2203x \u2190 B1 \u2208 \u03a0\u2032n s.t. var(B1) 6= \u2205, x \u2190 var(B1) \u2208 \u03a0 \u2032I n , I |= B1 \\ var(B1) and T\nk\u22121 \u03a0\u2032In (\u2205) |= var(B1). Note that\nvar(B1) 6= \u2205 implies x \u2190 B1 \u2208 F\u2212(\u03a0n). Moreover, x \u2190 var(B1) \u2208 \u03a0In. By inductive hypothesis, T\n\u221e \u03a0In (\u2205) |= var(B1), therefore x \u2208 T\u221e\u03a0In (\u2205).\nConsequently, T\u221e \u03a0\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205).\n\u2022 T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032In (\u2205). We first show x \u2208 T\u221e \u03a0In (\u2205) implies x \u2208 T\u221e \u03a0\u2032In (\u2205). Suppose\nx \u2208 T 1 \u03a0In (\u2205), then \u2203x \u2190 B \u2208 \u03a0n, var(B) = \u2205 and I |= B. It follows that x \u2190 B \u2208 \u03a0\u2032n and x \u2190\u2208 \u03a0 \u2032I n . Clearly, x \u2208 T\n\u221e \u03a0\u2032In (\u2205). Let k > 1 and assume\nfor all i < k, x \u2208 T i \u03a0In (\u2205) implies x \u2208 T\u221e \u03a0\u2032In (\u2205). Suppose x \u2208 T k \u03a0In (\u2205) but x /\u2208 T k\u22121 \u03a0In (\u2205). Then \u2203x \u2190 B \u2208 \u03a0n s.t. x \u2190 var(B) \u2208 \u03a0In, var(B) 6= \u2205, I |= B \\ var(B) and T k\u22121 \u03a0In (\u2205) |= var(B). By induction hypothesis, T\u221e \u03a0\u2032In (\u2205) |= var(B), i.e., I |= var(B). Now I |= B since I |= B \\ var(B) and I |= var(B), hence I |= B\u2032. Observe that either x \u2190 B\u2032 \u2208 \u03a0\u2032n or\nx \u2190 B \u2208 \u03a0\u2032n, in both cases I |= x since I is an answer set of \u03a0 \u2032 n and must be closed under every rule of \u03a0\u2032n.Consequently, x \u2208 T \u221e \u03a0In (\u2205) implies x \u2208 T\u221e \u03a0\u2032In (\u2205). It remains to show \u22a5 /\u2208 T\u221e \u03a0In (\u2205). Assume \u22a5 \u2208 T\u221e \u03a0In (\u2205), then \u2203\u22a5 \u2190 B in F+(\u03a0n) s.t. I |= B \\ var(B) and T k\u03a0In (\u2205) |= var(B) for some k \u2265 1. Notice that the latter means I |= var(B), since variables T k \u03a0In (\u2205) |= var(B) implies T\u221e \u03a0\u2032In (\u2205) |= var(B) by the previous result and I = T\u221e \u03a0\u2032In (\u2205). So I |= B, i.e., I |= B\u2032. However, note that \u22a5 \u2190 B\u2032 in \u03a0\u2032n and I is not closed under \u22a5 \u2190 B\u2032. This contradicts the fact that I is an answer set of \u03a0\u2032n. Therefore \u22a5 /\u2208 T\n\u221e \u03a0In (\u2205), and hence T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032In (\u2205).\n4.3.2 Pure PARITYn Programs\nLet \u03a0n be an almost pure PARITYn program. If for every rule H \u2190 B \u2208 \u03a0n we have var(B) = \u2205, then \u03a0n is called pure. Clearly, a pure program has no loops and is hence completion-equivalent.\nProposition 4.4. Let \u03a0n be an almost pure PARITYn program. Then there is a pure PARITYn program \u03a0\u2032n s.t. |\u03a0 \u2032 n| \u2264 |\u03a0n|.\nProof. A rule H \u2190 B is non-pure if var(B) 6= \u2205. We show by induction on the number m of non-pure rules in \u03a0n. Base step m = 0, the claim trivially holds. Let m > 0 and assume the claim holds for all almost pure PARITYn programs containing j < m non-pure rules. Suppose \u03a0n is an almost pure PARITYn program with m non-pure rules, and let H \u2190 B be a non-pure rule in \u03a0n. Note that H \u2190 B must be in F\u2212(\u03a0n) and H is a variable x, since \u03a0n is almost pure. Let B\u2032 be obtained from B by replacing each variable x \u2208 var(B) with not not x. Note that I |= B iff I |= B\u2032 for any set of variables I . Let \u03a0 be \u03a0n \\ {H \u2190 B} and let \u03a0\u2032\u2032n = \u03a0\u222a{H \u2190 B \u2032}. Clearly, \u03a0\u2032\u2032n is almost pure and |\u03a0 \u2032\u2032 n| \u2264 |\u03a0n|. We shall show that \u03a0\u2032\u2032n is also a PARITYn program, i.e., I = T \u221e \u03a0In (\u2205) iff I = T\u221e \u03a0\u2032\u2032In (\u2205).\n(\u21d2) Suppose I = T\u221e \u03a0In (\u2205), we prove T\u221e \u03a0In (\u2205) = T\u221e \u03a0\u2032\u2032In (\u2205):\n\u2022 T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032\u2032In (\u2205). Note that \u22a5 /\u2208 T\u221e \u03a0In (\u2205) since T\u221e \u03a0In (\u2205) is an answer set.\nSuppose x \u2208 T 1 \u03a0In (\u2205), then \u2203x \u2190 B1 \u2208 \u03a0n s.t. var(B1) = \u2205 and I |= B1. Clearly, x \u2190 B1 \u2208 \u03a0\u2032\u2032n and x \u2190\u2208 \u03a0 \u2032\u2032I n , thus x \u2208 T\n\u221e \u03a0\u2032\u2032In (\u2205). Let k > 1\nand assume for all i < k, T i \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032\u2032In (\u2205). Suppose x \u2208 T k \u03a0In (\u2205) but x /\u2208 T k\u22121 \u03a0In\n(\u2205). Then \u2203x \u2190 B1 \u2208 \u03a0n s.t. var(B1) 6= \u2205, x \u2190 var(B1) \u2208 \u03a0In and T k\u22121\n\u03a0In (\u2205) |= var(B1). Hence if x = H,B1 = B then x \u2190 B\u2032 \u2208 \u03a0\u2032\u2032n,\notherwise x \u2190 B1 \u2208 \u03a0\u2032\u2032n. The former implies x \u2190\u2208 \u03a0 \u2032\u2032I n since var(B \u2032) = \u2205, and I |= B\u2032 due to I |= B1, trivially, x \u2208 T\u221e\u03a0\u2032\u2032In (\u2205). The latter implies x\u2190 var(B1) \u2208 \u03a0 \u2032\u2032I n , clearly, T\n\u221e \u03a0\u2032\u2032In (\u2205) |= var(B1) by induction hypothesis,\nand thus x \u2208 T\u221e \u03a0\u2032\u2032In (\u2205). Therefore, T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032\u2032In (\u2205).\n\u2022 T\u221e \u03a0\u2032\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205). We first show that \u22a5 /\u2208 T\u221e \u03a0\u2032\u2032In (\u2205). Assume \u22a5 \u2208 T\u221e \u03a0\u2032\u2032In (\u2205).\nSo \u2203\u22a5 \u2190 B1 \u2208 \u03a0\u2032\u2032n s.t. \u22a5 \u2190 var(B1) \u2208 \u03a0 \u2032\u2032I n and I |= B1 \\ var(B1). Note that \u22a5 \u2190 B1 must be in F+(\u03a0n) since \u03a0n is almost pure. Hence var(B1) = \u2205, I |= B1 thus I |= B. The latter means that I is not closed under \u22a5 \u2190 B1 \u2208 \u03a0n, which contradicts the fact that I is an answer set of \u03a0n. So \u22a5 /\u2208 T\u221e\u03a0\u2032\u2032In (\u2205). Suppose x \u2208 T 1 \u03a0\u2032\u2032In (\u2205), then \u2203x \u2190 B1 \u2208 \u03a0\u2032\u2032n s.t. x\u2190\u2208 \u03a0\u2032\u2032In and I |= B1. There are two cases about the source of x\u2190 B1: (i) x\u2190 B1 \u2208 \u03a0n, var(B1) = \u2205. Since I |= B1, so x\u2190\u2208 \u03a0In, x \u2208 T \u221e \u03a0In (\u2205). (ii)x \u2190 B1 is obtained from H \u2190 B \u2208 F\u2212(\u03a0n), i.e., H = x, var(B) 6= \u2205 and B1 = B\u2032. Note that I |= B since I |= B1. Recall that not not x \u2208 B, so x \u2208 I , i.e, x \u2208 T\u221e\n\u03a0In (\u2205).\nNow suppose x \u2208 T k \u03a0\u2032\u2032In (\u2205) but x /\u2208 T k\u22121 \u03a0\u2032\u2032In (\u2205) for some k > 1. It means that \u2203x\u2190 B1 \u2208 \u03a0 \u2032\u2032 n s.t. var(B1) 6= \u2205, x\u2190 var(B1) \u2208 \u03a0 \u2032\u2032I n , I |= B1 \\ var(B1) and T k\u22121 \u03a0\u2032\u2032In (\u2205) |= var(B1). Since \u03a0n is almost pure, var(B1) 6= \u2205 implies that x \u2190 B1 \u2208 F\u2212(\u03a0n). By Lemma 4.4 (i), not not x \u2208 B1. Recall that I |= B1 \\ var(B1), so I |= not not x, i.e., x \u2208 T\u221e\u03a0In (\u2205). Therefore, T\u221e \u03a0\u2032\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205).\n(\u21d0) Suppose I = T\u221e \u03a0\u2032\u2032In (\u2205), we show T\u221e \u03a0\u2032\u2032In (\u2205) = T\u221e \u03a0In (\u2205).\n\u2022 T\u221e \u03a0\u2032\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205). Note that \u22a5 /\u2208 T\u221e \u03a0\u2032\u2032In (\u2205). Suppose x \u2208 T 1 \u03a0\u2032\u2032In (\u2205), then\n\u2203x \u2190 B1 \u2208 \u03a0 \u2032\u2032 n s.t. x \u2190\u2208 \u03a0 \u2032\u2032I n and I |= B1. Now consider the source of x\u2190 B1:\n(i) x \u2190 B1 \u2208 \u03a0n and var(B1) = \u2205. It follows that x \u2190\u2208 \u03a0In and clearly x \u2208 T\u221e\n\u03a0In (\u2205).\n(ii) x\u2190 B1 is obtained from H \u2190 B \u2208 F\u2212(\u03a0n), i.e.,H = x and B1 = B\u2032. So x \u2190 var(B) \u2208 \u03a0In and I |= B. The latter implies T\n\u221e \u03a0\u2032\u2032In (\u2205) |= B thus\nT\u221e \u03a0\u2032\u2032In (\u2205) |= var(B). Note that \u03a0\u2032\u2032In = \u03a0 I \u222a {x \u2190}, and x /\u2208 var(B) since \u03a0n is almost pure, it has no singleton loops. We prove by induction that T\u221e\n\u03a0I (\u2205) |= var(B). Suppose x\u2032 \u2208 var(B) and x\u2032 \u2208 T 1 \u03a0\u2032\u2032In (\u2205), then\n\u2203x\u2032 \u2190 B2 \u2208 \u03a0 \u2032\u2032, var(B2) = \u2205 and I |= B2. Clearly, x\u2032 \u2190\u2208 \u03a0I , thus x\u2032 \u2208 T\u221e \u03a0I\n(\u2205). Let s > 1 and assume for all t < s, x\u2032 \u2208 var(B) and x\u2032 \u2208 T t \u03a0\u2032\u2032In (\u2205) implies x\u2032 \u2208 T\u221e \u03a0In (\u2205). Suppose x\u2032 \u2208 var(B) and x\u2032 \u2208 T s \u03a0\u2032\u2032In (\u2205). Then \u2203x\u2032 \u2190 B2 \u2208 \u03a0\u2032\u2032, x\u2032 \u2190 var(B2) \u2208 \u03a0\u2032\u2032I and T s\u22121 \u03a0\u2032\u2032In (\u2205) |= var(B2). Recall that x 6= x\u2032 since x /\u2208 var(B), so x\u2032 \u2190 var(B2) \u2208 \u03a0I . By induction hypothesis, T\u221e\n\u03a0In (\u2205) |= var(B2), x\u2032 \u2208 T\u221e\u03a0In (\u2205). Hence T\u221e \u03a0I (\u2205) |= var(B).\nFurthermore, \u03a0In = \u03a0 I \u222a {x \u2190 var(B)}, so T\u221e \u03a0I (\u2205) \u2286 T\u221e \u03a0In (\u2205), T\u221e \u03a0In (\u2205) |= var(B). Therefore T\u221e \u03a0In (\u2205) |= x, i.e., x \u2208 T\u221e \u03a0In (\u2205).\nLet k > 1 and assume for all i < k, T i \u03a0\u2032\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205). Suppose x \u2208 T k \u03a0\u2032\u2032In (\u2205), then \u2203x \u2190 B1 \u2208 \u03a0\u2032\u2032n, var(B1) 6= \u2205, x \u2190 var(B1) \u2208 \u03a0 \u2032\u2032I n , T k\u22121 \u03a0\u2032\u2032In (\u2205) |= var(B1). Clearly, x \u2190 var(B1) \u2208 \u03a0I . It follows that x \u2190 var(B1) \u2208 \u03a0 I n since \u03a0\nI \u2286 \u03a0In. By induction hypothesis, T \u221e \u03a0In (\u2205) |= var(B1).\nHence T\u221e \u03a0In (\u2205) |= x, i.e., x \u2208 T\u221e \u03a0In (\u2205). Therefore, T\u221e \u03a0\u2032\u2032In (\u2205) \u2286 T\u221e \u03a0In (\u2205).\n\u2022 T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032\u2032In (\u2205). We first show for any variable x, x \u2208 T\u221e \u03a0In (\u2205) implies\nx \u2208 T\u221e \u03a0\u2032\u2032In (\u2205). Suppose x \u2208 T 1 \u03a0In (\u2205), then \u2203x\u2190 B1 \u2208 \u03a0n, var(B1) = \u2205 and I |= B1. It follows that x \u2190 B1 \u2208 \u03a0\u2032\u2032n and x \u2190\u2208 \u03a0 \u2032\u2032I n . So x \u2208 T\n\u221e \u03a0\u2032\u2032In (\u2205).\nLet k > 1 and assume for all i < k, x \u2208 T i \u03a0In (\u2205) implies x \u2208 T\u221e \u03a0\u2032\u2032In (\u2205). Suppose x \u2208 T k \u03a0In (\u2205), then \u2203x \u2190 B1 \u2208 \u03a0n s.t. x \u2190 var(B1) \u2208 \u03a0In, var(B1) 6= \u2205, I |= B1 \\ var(B1) and T k\u22121 \u03a0In (\u2205) |= var(B1). By induction hypothesis, T\u221e \u03a0\u2032\u2032In (\u2205) |= var(B1), i.e., I |= var(B1). Now I |= B1 since I |= B1 \\ var(B1) and I |= var(B1), hence I |= B1. Observe that if H = x and B1 = B then x \u2190 B\u2032 \u2208 \u03a0\u2032\u2032n, otherwise x \u2190 B1 \u2208 \u03a0 \u2032\u2032 n. In both cases I |= x since I is an answer set of \u03a0\u2032\u2032n and it must be closed under every rule of \u03a0\u2032\u2032n. Consequently, x \u2208 T\n\u221e \u03a0In (\u2205) implies x \u2208 T\u221e \u03a0\u2032\u2032In (\u2205).\nIt remains to show \u22a5 /\u2208 T\u221e \u03a0In (\u2205). Assume \u22a5 \u2208 T\u221e \u03a0In (\u2205), then \u2203\u22a5 \u2190 B1 in F+(\u03a0n) s.t. \u22a5 \u2190\u2208 \u03a0In and I |= B1. Notice that var(B1) = \u2205 since \u03a0n is almost pure. Furthermore, \u22a5 \u2190 B1 must be in \u03a0\u2032\u2032n, therefore I |= \u22a5 since I |= B1.However, this contradicts the fact that I is an answer set of \u03a0\u2032\u2032n. Therefore \u22a5 /\u2208 T\u221e\n\u03a0In (\u2205), and hence T\u221e \u03a0In (\u2205) \u2286 T\u221e \u03a0\u2032\u2032In (\u2205).\nConsequently, \u03a0\u2032\u2032n is an almost pure PARITYn program with m \u2212 1 non-pure rules. By induction hypothesis, there is a pure PARITYn program \u03a0\u2032n with |\u03a0 \u2032 n| \u2264 |\u03a0\u2032\u2032n| \u2264 |\u03a0n|."}, {"heading": "4.4 The Main Results", "text": "The main lemma below easily follows from Proposition 4.1 and 4.2.\nLemma 4.5 (Main Lemma). Let \u03a0n be a PARITYn program. Then there is a PARITYn program \u03a0\u2032n s.t. \u03a0 \u2032 n is equivalent to Comp(\u03a0 \u2032 n) and |\u03a0 \u2032 n| \u2264 |\u03a0n|.\nTheorem 4.1 (PARITY/\u2208Poly-CP). PARITY has no polynomial size CP programs.\nProof. Assume the contrary that there is a sequence of programs {\u03a0n} in CP which represents PARITY, and |\u03a0n| is bounded by a polynomial p(n). By Lemma 4.5, there is a sequence of completion-equivalent PARITY programs {\u03a0\u2032n} in which |\u03a0\u2032n| is also bounded by the polynomial p(n). By Proposition 3.1, {\u03a0 \u2032 n} represents a language in AC0. This contradicts PARITY/\u2208 AC0.\nCorollary 4.1. PARITY separates PF from CP.\nCorollary 4.2. Suppose P * NC1/poly. Then CP and PF are succinctly incomparable."}, {"heading": "5 Discussion and Some More Results", "text": "Interestingly, our main result may at first appear counter-intuitive: the P-complete problem PATH has Poly-CP representations, while this does not hold for an \u201ceasy\u201d problem PARITY. Actually, there is no contradiction. As noted in [1, 8], a complete problem in a complexity class can be represented in a formalism C, does not imply that all problems in that class can be represented in C.\nGenerally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same. In terms of the theory of computation, succinctness essentially concerns with the computational power of different formalisms (i.e., models of computation). This is particularly interesting if the formalisms are equally expressive and share the same reasoning complexity. E.g., logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking. But they have a non-trivial succinctness picture, see Fig. 2.\nBesides the theoretical interests, succinctness also tells us something like \u201cwhich for what is the best\u201d in choosing KR formalisms for a given application. E.g., one should choose ASP instead of SAT if the application involves reasoning about PATH or Transitive Closure5, because the former provides compact representations to avoid unnecessary overload. Recall that from the complexity viewpoint, even one extra variable may double the search space for intractable problems.\nIn the following we shall briefly discuss some succinctness results illustrated\n5An NL-complete problem. It is believed that NL * NC1/Poly.\nin Fig. 2, note that all mentioned formalisms have the same expressive power and same reasoning complexity."}, {"heading": "5.1 Logic Programs with Cardinality Constraints (CC)", "text": "Simply speaking, CC extends normal programs (LP) with so-called cardinality constraints and choice rules [32]. A choice rule\n{x} \u2190 (8)\nhas two answer sets {x} and \u2205, i.e., same as x \u2190 not not x. Moreover, a choice rule {x1, . . . , xn} \u2190 produces 2n answer sets, i.e., all subsets of {x1, . . . , xn}. A cardinality constraint is an expression of the form\nl \u2264 B \u2264 u (9)\nin whichB is a finite set of rule elements of the form x or not x, and integer l (resp. u) is the lower (resp. upper) bound on B. In this paper we assume the magnitude of l (and u) is polynomially bounded by n.\nIntuitively, a set of variables I satisfies (9), if the number of satisfied rule elements in B fulfills the related bounds. E.g., {x1} satisfies 1 \u2264 {x1, x2, x3} \u2264 1 but not 2 \u2264 {x1, x2, x3} \u2264 3, while {x2, x3} satisfies the latter. Informally, we may think of (9) as a special kind of rule element, and the answer set semantics is defined accordingly.\nThe following is a PARITY3 program in CC:\n{x1, x2, x3} \u2190, \u22a5 \u2190 0 \u2264 {x1, x2, x3} \u2264 0, \u22a5 \u2190 2 \u2264 {x1, x2, x3} \u2264 2,\n(10)\nClearly, the pattern applies to all PARITYn and the program grows linearly. We define the size of a CC program to be the number of cardinality constraints occur in it.\nTheorem 5.1 (PARITY\u2208Poly-CC). PARITY has polynomial size programs in CC.\nAn equivalent translation from CC to NLP was presented in [12], however, the translation may involve exponential size blowup, since every cardinality constraint is simply converted to a formula via a brute force enumeration. In fact, such a translation can be reduced to be polynomial by adopting a non-trivial, sophisticated encoding for so-called threshold functions6 . Therefore, we have:\nTheorem 5.2. NLP is at least as succinct as CC. 6E.g., see Chapter 2 of [31]."}, {"heading": "5.2 Definite Causal Theories (DT)", "text": "A variable x or negated variable \u00acx is called a literal. A definite (causal) theory Dn on signature {x1, . . . , xn} is a finite set of (causal) rules of the form\nH \u21d0 G (11)\nin which H is either a literal or \u22a5, and G is a propositional formula. If every G is a conjunction of variables or negated variables, then Dn is called simple (SDT)7.\nThe reduct DIn of Dn w.r.t. a set of variables I , is the set of the heads H of all rules in Dn whose bodies G are satisfied by I . Say I is a model of Dn if I is the unique model of DIn. The following theory:\nx\u21d0 x, \u00acx\u21d0 \u00acx (12)\nhas two models {x} and \u2205, which is equivalent to program x \u2190 not not x or {x} \u2190.\nIf a definite theory Dn is simple, then its size |Dn| is defined as the number of rules in it, otherwise |Dn| is the number of connectives in it. It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16]. It means that definite theories are fragments of PF, i.e., DT PF. Therefore, the problems that can be represented by Poly-DT are in NC1/poly as well. Moreover, the completion of a simple definite theory is also a constant depth, unbounded fan-in circuit whose size is polynomially bounded. By a proof similar to that of Theorem 4.1, we have the following theorem:\nTheorem 5.3 (PARITY/\u2208Poly-SDT). PARITY has no polynomial size theories in SDT.\nConsider the (non-simple) causal theory (13) for PARITY2, where the body of the last rule is the negation of a PARITY2 formula:\nx1 \u21d0 x1, \u00acx1 \u21d0 \u00acx1, x2 \u21d0 x2, \u00acx2 \u21d0 \u00acx2, \u22a5 \u21d0 \u00ac((x1 \u2227 \u00acx2) \u2228 (\u00acx2 \u2227 x1)).\n(13)\nRecall that PARITY have polynomial formulas in PF, therefore it is not hard to see we can have polynomial DT theory for PARITY by the above pattern.\nTheorem 5.4 (PARITY\u2208Poly-DT). PARITY has polynomial size theories in DT.\nSince PATH is P-complete [28], therefore if PATH has polynomial representations in Poly-DT, then P \u2286 NC1/poly, which is believed impossible.\nTheorem 5.5 (PATH/\u2208Poly-DT). Suppose P * NC1/poly. Then PATH has no polynomial size definite theories.\n7SDT is originally named as Objective Programs in [30].\nBy the fact that PATH has polynomial size CP programs, we have:\nCorollary 5.1. Suppose P * NC1/poly. Then CP and DT are succinctly incomparable.\nIt is worth to point out that some difficulties observed in the literature could be nicely explained by the above succinctness results. E.g., DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9]. Recall that Poly-DT represents problems in NC1/Poly, and TC is a problem in NC2/poly [18], a class widely believed strictly contains NC1/poly. So unless the two classes coincide, TC has no polynomial size definite theories."}, {"heading": "5.3 Two-Valued Logic Programs (TV)", "text": "A (two-valued) program [27] \u03a0n on signature {x1, . . . , xn} is a finite set of (twovalued) rules of the form:\nH \u2190 B : G (14)\nin which B \u222a {H} is a finite set of literals and G is a formula. The reduct \u03a0In of \u03a0n w.r.t. a set of variables I , is the set of rules\nH \u2190 B (15)\nfrom \u03a0n s.t. I satisfies G. A set of literals J is closed under rule (15) if H \u2208 J whenever B \u2286 J . We say I is a model of \u03a0n if I is the unique model of the minimal closure J under every rule of \u03a0In. The following program \u03a02 in TV\nx\u2190: x, \u00acx\u2190: \u00acx (16)\nhas two models {x} and \u2205, which is equivalent to (12). The following observations were pointed out in [27]. A formula \u03c6n can be rewritten in TV (i \u2208 {1, . . . , n})8:\nxi \u2190: xi, \u00acxi \u2190: \u00acxi, \u22a5 \u2190: \u00ac\u03c6n. (17)\nA causal rule H \u21d0 G can be equivalently rewritten as H \u2190: G. Moreover, to equivalently rewrite a CP program \u03a0n, each rule:\nH \u2190 u1, . . . , uj , not yj+1, . . . , not ym, not not zm+1, . . . , not not zk\n(18)\ncan be translated as:\nH \u2190 u1, . . . , uj : \u00acyj+1\u2227, . . .\u00acym \u2227 zm+1 \u2227 . . . zk (19)\nand add \u00acx\u2190: \u00acx for every x \u2208 var(\u03a0n). All together, we have:\nTheorem 5.6. Two valued programs are strictly more succinct than: (i) propositional formulas and definite theories, if P * NC1/poly; (ii) canonical programs.\n8 \u22a5 \u2190: \u00ac\u03c6n is a shorthand of x1 \u2190: \u00ac\u03c6n, \u00acx1 \u2190: \u00ac\u03c6n."}, {"heading": "6 Conclusions", "text": "The main result of the paper is that the PARITY problem separates PF from CP, i.e., PARITY has no polynomial size CP programs, but has polynomial size PF formulas. Together with Lifschitz and Razborov\u2019s separation result, i.e., there exists a problem separates CP from PF (assuming P * NC1/poly), we conclude that the two well-known KR formalisms are succinctly incomparable. In other words, if we consider CP and PF as two different models of computation, the above result just states that they are incomparable in terms of computational power. We also give a non-trivial succinctness picture on a family of logic program classes which posses the same expressive power and same reasoning complexity as PF.\nIn future work, we plan to investigate some missing connections in Fig. 2, e.g., we conjecture that there is a problem separates NLP from CP, SDT and CP are succinctly incomparable."}, {"heading": "Acknowledgement", "text": "We are grateful to the anonymous reviewers for their valuable comments. Thanks to Shiguang Feng, Yan Zhang, Jiankun He, Guangrui Dang and Xiaolong Liang for their helpful discussions. The research was partially supported by NSFC Grant 61272059, MOE Grant 11JJD720020, NSSFC Grant 13&ZD186, 14CZX058 and the Fundamental Research Funds for the Central Universities Grant 1409025."}], "references": [{"title": "Towards a theory of declarative knowledge", "author": ["K.R. Apt", "H.A. Blair", "A. Walker"], "venue": "Foundations of Deductive Databases and Logic Programming,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1988}, {"title": "Computational Complexity: A Modern Approach", "author": ["Sanjeev Arora", "Boaz Barak"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications", "author": ["Armin Biere", "Marijn Heule", "Hans van Maaren", "Toby Walsh", "editors"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Answer set programming at a glance", "author": ["Gerhard Brewka", "Thomas Eiter", "Miroslaw Truszczynski"], "venue": "Communications of the ACM,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Negation as failure", "author": ["Keith L. Clark"], "venue": "Logic and Data Bases,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1978}, {"title": "Expressive power and succinctness of propositional languages for preference representation", "author": ["Sylvie Coste-Marquis", "J\u00e9r\u00f4me Lang", "Paolo Liberatore", "Pierre Marquis"], "venue": "In Proceedings of the Ninth International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2004}, {"title": "Complexity and expressive power of logic programming", "author": ["Evgeny Dantsin", "Thomas Eiter", "Georg Gottlob", "Andrei Voronkov"], "venue": "ACM Computing Surveys,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2001}, {"title": "Almost definite causal theories", "author": ["Semra Do\u011fanda\u011f", "Paolo Ferraris", "Vladimir Lifschitz"], "venue": "Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "Tight logic programs", "author": ["Esra Erdem", "Vladimir Lifschitz"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "Consistency of clark\u2019s completion and existence of stable models", "author": ["Fran\u00e7ois Fages"], "venue": "Journal of Methods of Logic in Computer Science,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1994}, {"title": "Weight constraints as nested expressions", "author": ["Paolo Ferraris", "Vladimir Lifschitz"], "venue": "Theory Pract. Log. Program.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2005}, {"title": "On the succinctness of some modal logics", "author": ["Tim French", "Wiebe van der Hoek", "Petar Iliev", "Barteld P. Kooi"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "Parity, circuits, and the polynomial-time hierarchy", "author": ["Merrick L. Furst", "James B. Saxe", "Michael Sipser"], "venue": "Mathematical Systems Theory,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1984}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1988}, {"title": "Nonmonotonic causal theories", "author": ["Enrico Giunchiglia", "Joohyung Lee", "Vladimir Lifschitz", "Norman McCain", "Hudson Turner", "Joohyung Lee Vladimir Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2004}, {"title": "The comparative linguistics of knowledge representation", "author": ["Goran Gogic", "Henry A. Kautz", "Christos H. Papadimitriou", "Bart Selman"], "venue": "In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1995}, {"title": "Limits to parallel computation: P-completeness theory", "author": ["Raymond Greenlaw", "H. James Hoover", "Walter L. Ruzzo"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1995}, {"title": "The succinctness of first-order logic on linear orders", "author": ["Martin Grohe", "Nicole Schweikardt"], "venue": "Logical Methods in Computer Science,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2005}, {"title": "Almost optimal lower bounds for small depth circuits", "author": ["Johan Hastad"], "venue": "In Proceedings of the eighteenth annual ACM symposium on Theory of computing,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1986}, {"title": "Boolean Function Complexity - Advances and Frontiers, volume 27 of Algorithms and combinatorics", "author": ["Stasys Jukna"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["Joohyung Lee"], "venue": "In Proceedings of the 19th international joint conference on Artificial intelligence,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2005}, {"title": "Loop formulas for disjunctive logic programs", "author": ["Joohyung Lee", "Vladimir Lifschitz"], "venue": "Logic Programming,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "Action language BC: Preliminary report", "author": ["Joohyung Lee", "Vladimir Lifschitz", "Fangkai Yang"], "venue": "In Proceedings of the 23rd International Joint Conference on Artificial Intelligence,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2013}, {"title": "Nested expressions in logic programs", "author": ["Vladimir Lifschitz"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1999}, {"title": "What is answer set programming", "author": ["Vladimir Lifschitz"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2008}, {"title": "Two-valued logic programs", "author": ["Vladimir Lifschitz"], "venue": "Technical Communications of the 28th International Conference on Logic Programming,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2012}, {"title": "Why are there so many loop formulas", "author": ["Vladimir Lifschitz", "Alexander Razborov"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["Fangzhen Lin", "Yuting Zhao"], "venue": "Artificial Intelligence,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2004}, {"title": "Causality in Commonsense Reasoning about Actions", "author": ["Norman McCain"], "venue": "PhD thesis, University of Texas at Austin,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1997}, {"title": "Models of computation", "author": ["John E Savage"], "venue": "Exploring the Power of Computing. Addison-Wesley,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1998}, {"title": "Extending and implementing the stable model semantics", "author": ["Patrik Simons", "Ilkka Niemel\u00e4", "Timo Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2002}, {"title": "On the equivalence between answer sets and models of completion for nested logic programs", "author": ["Jia-Huai You", "Li-Yan Yuan", "Mingyi Zhang"], "venue": "In Proceedings of the 18th international joint conference on Artificial intelligence,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2003}], "referenceMentions": [{"referenceID": 13, "context": ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.", "startOffset": 31, "endOffset": 42}, {"referenceID": 24, "context": ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.", "startOffset": 31, "endOffset": 42}, {"referenceID": 3, "context": ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.", "startOffset": 31, "endOffset": 42}, {"referenceID": 2, "context": "As a competing approach to SAT [4], ASP has been successfully applied in many fields like Planning, Commonsense Reasoning, Scheduling, etc.", "startOffset": 31, "endOffset": 34}, {"referenceID": 27, "context": "A well-known theorem shown by Lin & Zhao [29] gives a method for translating a normal (logic) program (LP) to a (logically) equivalent set of formulas in PF, without introducing additional variables.", "startOffset": 41, "endOffset": 45}, {"referenceID": 26, "context": "In 2006, Lifschitz and Razborov proved that such exponential blowup is generally inevitable, more precisely, they showed that (a variant of) the P-complete problem PATH has polynomial size representations in LP, however, it cannot be polynomially represented in PF (assuming P * NC/poly) [28].", "startOffset": 288, "endOffset": 292}, {"referenceID": 26, "context": "As noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs.", "startOffset": 12, "endOffset": 16}, {"referenceID": 23, "context": "As noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs.", "startOffset": 99, "endOffset": 103}, {"referenceID": 15, "context": "Therefore, NLP is stronger than PF in terms of the succinctness criterion (or the \u201ccomparative linguistics\u201d approach) proposed in [17]:", "startOffset": 130, "endOffset": 134}, {"referenceID": 24, "context": "So the following footnote in [26] seems convincing at first glance:", "startOffset": 29, "endOffset": 33}, {"referenceID": 20, "context": "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.", "startOffset": 70, "endOffset": 82}, {"referenceID": 23, "context": "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.", "startOffset": 70, "endOffset": 82}, {"referenceID": 22, "context": "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.", "startOffset": 70, "endOffset": 82}, {"referenceID": 1, "context": ", it has polynomial representations in PF2 [3, 21], (ii) PARITY/ \u2208 AC, i.", "startOffset": 43, "endOffset": 50}, {"referenceID": 19, "context": ", it has polynomial representations in PF2 [3, 21], (ii) PARITY/ \u2208 AC, i.", "startOffset": 43, "endOffset": 50}, {"referenceID": 12, "context": ", it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].", "startOffset": 104, "endOffset": 112}, {"referenceID": 18, "context": ", it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].", "startOffset": 104, "endOffset": 112}, {"referenceID": 9, "context": "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|.", "startOffset": 44, "endOffset": 56}, {"referenceID": 8, "context": "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|.", "startOffset": 44, "endOffset": 56}, {"referenceID": 31, "context": "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|.", "startOffset": 44, "endOffset": 56}, {"referenceID": 29, "context": "From the view of the theory of computation, the above result may also be considered as the separation of two models of computation [31], i.", "startOffset": 131, "endOffset": 135}, {"referenceID": 30, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 85, "endOffset": 89}, {"referenceID": 28, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 158, "endOffset": 166}, {"referenceID": 14, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 158, "endOffset": 166}, {"referenceID": 25, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 221, "endOffset": 225}, {"referenceID": 23, "context": "The following notations are adopted from [25, 22].", "startOffset": 41, "endOffset": 49}, {"referenceID": 20, "context": "The following notations are adopted from [25, 22].", "startOffset": 41, "endOffset": 49}, {"referenceID": 23, "context": "According to [25], not not not x can be replaced by not x.", "startOffset": 13, "endOffset": 17}, {"referenceID": 15, "context": "The following concept is adopted from [17, 13].", "startOffset": 38, "endOffset": 46}, {"referenceID": 11, "context": "The following concept is adopted from [17, 13].", "startOffset": 38, "endOffset": 46}, {"referenceID": 26, "context": "However, this is impossible since it contradicts the anti-chain property of \u03a0n [28]: if strings I, I \u2032 \u2208 Ans(\u03a0n) and I \u2286 I \u2032 then I = I \u2032.", "startOffset": 79, "endOffset": 83}, {"referenceID": 1, "context": ", PARITY\u2208 NC/poly (or Poly-PF) [3, 21].", "startOffset": 31, "endOffset": 38}, {"referenceID": 19, "context": ", PARITY\u2208 NC/poly (or Poly-PF) [3, 21].", "startOffset": 31, "endOffset": 38}, {"referenceID": 1, "context": "For more details about circuits, please see [3].", "startOffset": 44, "endOffset": 47}, {"referenceID": 4, "context": "The completion Comp(\u03a0) [6, 10] of a canonical program \u03a0, consists of a set (or conjunction) of formulas4:", "startOffset": 23, "endOffset": 30}, {"referenceID": 8, "context": "The completion Comp(\u03a0) [6, 10] of a canonical program \u03a0, consists of a set (or conjunction) of formulas4:", "startOffset": 23, "endOffset": 30}, {"referenceID": 27, "context": "It is shown in [29, 23] that the so-called loop formulas LF (\u03a0) nicely eliminate inappropriate models of Comp(\u03a0), s.", "startOffset": 15, "endOffset": 23}, {"referenceID": 21, "context": "It is shown in [29, 23] that the so-called loop formulas LF (\u03a0) nicely eliminate inappropriate models of Comp(\u03a0), s.", "startOffset": 15, "endOffset": 23}, {"referenceID": 0, "context": "The (positive) dependency graph [2] of a canonical program \u03a0 is a pair (N,E) in which the set of nodes N = var(\u03a0), and E contains a directed edge (x, x\u2032) iff there is a rule H \u2190 B in \u03a0 s.", "startOffset": 32, "endOffset": 35}, {"referenceID": 27, "context": "1 (Lin-Zhao Theorem[29, 23]).", "startOffset": 19, "endOffset": 27}, {"referenceID": 21, "context": "1 (Lin-Zhao Theorem[29, 23]).", "startOffset": 19, "endOffset": 27}, {"referenceID": 9, "context": "1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.", "startOffset": 38, "endOffset": 50}, {"referenceID": 8, "context": "1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.", "startOffset": 38, "endOffset": 50}, {"referenceID": 31, "context": "1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.", "startOffset": 38, "endOffset": 50}, {"referenceID": 0, "context": "Let \u03a0 be a basic program and I be a set of variables, define the Knaster-Tarski operator [2] as T\u03a0(I) = {H : H \u2190 B \u2208 \u03a0 and I |= B}.", "startOffset": 89, "endOffset": 92}, {"referenceID": 13, "context": "It is pointed out in [15, 33] that I \u2208 Ans(\u03a0) iff I = T\u221e \u03a0 (\u2205) for a canonical program \u03a0.", "startOffset": 21, "endOffset": 29}, {"referenceID": 31, "context": "It is pointed out in [15, 33] that I \u2208 Ans(\u03a0) iff I = T\u221e \u03a0 (\u2205) for a canonical program \u03a0.", "startOffset": 21, "endOffset": 29}, {"referenceID": 6, "context": "As noted in [1, 8], a complete problem in a complexity class can be represented in a formalism C, does not imply that all problems in that class can be represented in C.", "startOffset": 12, "endOffset": 18}, {"referenceID": 15, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 5, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 17, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 11, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 30, "context": ", logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.", "startOffset": 96, "endOffset": 100}, {"referenceID": 14, "context": ", logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.", "startOffset": 143, "endOffset": 147}, {"referenceID": 25, "context": ", logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.", "startOffset": 177, "endOffset": 181}, {"referenceID": 30, "context": "Simply speaking, CC extends normal programs (LP) with so-called cardinality constraints and choice rules [32].", "startOffset": 105, "endOffset": 109}, {"referenceID": 10, "context": "An equivalent translation from CC to NLP was presented in [12], however, the translation may involve exponential size blowup, since every cardinality constraint is simply converted to a formula via a brute force enumeration.", "startOffset": 58, "endOffset": 62}, {"referenceID": 29, "context": ", see Chapter 2 of [31].", "startOffset": 19, "endOffset": 23}, {"referenceID": 28, "context": "It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16].", "startOffset": 138, "endOffset": 146}, {"referenceID": 14, "context": "It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16].", "startOffset": 138, "endOffset": 146}, {"referenceID": 26, "context": "Since PATH is P-complete [28], therefore if PATH has polynomial representations in Poly-DT, then P \u2286 NC/poly, which is believed impossible.", "startOffset": 25, "endOffset": 29}, {"referenceID": 28, "context": "SDT is originally named as Objective Programs in [30].", "startOffset": 49, "endOffset": 53}, {"referenceID": 14, "context": ", DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9].", "startOffset": 72, "endOffset": 79}, {"referenceID": 7, "context": ", DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9].", "startOffset": 72, "endOffset": 79}, {"referenceID": 16, "context": "Recall that Poly-DT represents problems in NC/Poly, and TC is a problem in NC/poly [18], a class widely believed strictly contains NC/poly.", "startOffset": 83, "endOffset": 87}, {"referenceID": 25, "context": "3 Two-Valued Logic Programs (TV) A (two-valued) program [27] \u03a0n on signature {x1, .", "startOffset": 56, "endOffset": 60}, {"referenceID": 25, "context": "The following observations were pointed out in [27].", "startOffset": 47, "endOffset": 51}], "year": 2015, "abstractText": "Canonical (logic) programs (CP) refer to normal logic programs augmented with connective not not. In this paper we address the question of whether CP are succinctly incomparable with propositional formulas (PF). Our main result shows that the PARITY problem, which can be polynomially represented in PF but only has exponential representations in CP. In other words, PARITY separates PF from CP. Simply speaking, this means that exponential size blowup is generally inevitable when translating a set of formulas in PF into an equivalent program in CP (without introducing new variables). Furthermore, since it has been shown by Lifschitz and Razborov that there is also a problem that separates CP from PF (assuming P * NC/poly), it follows that CP and PF are indeed succinctly incomparable. From the view of the theory of computation, the above result may also be considered as the separation of two models of computation, i.e., we identify a language in NC/poly which is not in the set of languages computable by polynomial size CP programs.", "creator": "LaTeX with hyperref package"}}}