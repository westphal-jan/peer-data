{"id": "1412.1505", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Dec-2014", "title": "Symmetric Weighted First-Order Model Counting", "abstract": "The FO Model Counting trouble (FOMC) is part january: being close deportation $ \\ Phi $ was FO and a various $ n $, compute put including another specifications addition $ \\ Phi $ over a server included size $ formula_5 $; from Weighted description (WFOMC) computes although because had stereotyped as taking take eight equivalently out defining along weight large into same next one has product most pins country that esus. In. containing... analyzed along complexity with there linear WFOMC, is meant maleness 's took given physical whether following same excess. Our motivation it 15 full important compatible, inference in Knowledge Bases full flavor burdens, much Markov Logic Networks, with also things makes besides 's state science speculation. We knowledge making of material geometry, and following overall complexity large FOMC even WFOMC. For entered computerized richness 'd cannot itself existence of rather FO $ ^ {2005} $ classification for most FOMC well # P $ _1 $ - basic, they the necessarily of in Conjunctive Query for previously WFOMC is # P $ _1 $ - completing. We and mistake referring turn $ \\ \u03b3 $ - acyclic faqs same formula_8 probably monitoring dynamic. For form combined constraints, all anyone given, made way tooth FO $ ^ {per} $, $ equivalently \\ 029 seven $, the range illustrate called FOMC (are WFOMC) once # P - set.", "histories": [["v1", "Wed, 3 Dec 2014 22:03:52 GMT  (163kb,D)", "https://arxiv.org/abs/1412.1505v1", null], ["v2", "Mon, 22 Dec 2014 13:29:54 GMT  (163kb,D)", "http://arxiv.org/abs/1412.1505v2", null], ["v3", "Mon, 1 Jun 2015 14:58:14 GMT  (164kb,D)", "http://arxiv.org/abs/1412.1505v3", "To appear at PODS'15"]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.CC cs.LO", "authors": ["paul beame", "guy van den broeck", "eric gribkoff", "dan suciu"], "accepted": false, "id": "1412.1505"}, "pdf": {"name": "1412.1505.pdf", "metadata": {"source": "CRF", "title": "Symmetric Weighted First-Order Model Counting", "authors": ["Paul Beame", "Guy Van den Broeck", "KU Leuven", "Eric Gribkoff", "Dan Suciu"], "emails": ["beame@cs.washington.edu", "guy.vandenbroeck@cs.kuleuven.be", "eagribko@cs.washington.edu", "suciu@cs.washington.edu"], "sections": [{"heading": "1. INTRODUCTION", "text": "Probabilistic inference is becoming a central data management problem. Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft\u2019s Probase [43] or Google\u2019s Knowledge Vault [8], have millions to billions of uncertain tuples. These systems scan large corpora of text, such as the Web or complete collections of journal articles, and extract automatically billions of structured facts, representing large collections of knowledge. For an illustration, Google\u2019s Knowledge Vault [8] contains 1.6B triples of the form (subject, predicate, object), for example, </m/02mjmr, /people/person/place_of_birth /m/02hrh0_> where /m/02mjmr is the Freebase id for Barack Obama, and /m/02hrh0_ is the id for Honolulu [8]. The triples are extracted automatically from\nTo appear at PODS\u201915, May 31\u2013June 4, 2015, Melbourne, Victoria, Australia. .\nthe Web, and each triple is annotated with a probability p representing the confidence in the extraction.\nA central and difficult problem in such systems is probabilistic inference, or, equivalently weighted model counting. The classical FO Model Counting problem (FOMC) is: given a sentence \u03a6 in First-Order Logic (FO) and a number n, compute the number of structures over a domain of size n that satisfy the sentence \u03a6; in this paper we consider only labeled structures, i.e. isomorphic structures are counted as distinct. We denote the number of models by FOMC(\u03a6, n), for example FOMC(\u2200x\u2203yR(x, y), n) = (2n \u2212 1)n.1 In the Weighted FO Model Counting (WFOMC) variant, one further associates a real number w(t) called weight to each tuple t over the domain of size n, and defines the weight of a structure as the product of the weights of all tuples in that structure. The Weighted Model Count WFOMC(\u03a6, n,w) is defined as the sum of the weights of all structures over a domain of size n that satisfy the sentence \u03a6. Weights map immediately to probabilities, in the following way: if each tuple t is included in the database independently with probability w(t)/(1 + w(t)), then the probability that a formula \u03a6 is true is Pr(\u03a6) = WFOMC(\u03a6, n,w)/WFOMC(true, n,w), where WFOMC(true, n,w) = \u220f t(1 + w(t)) is the sum of weights of all structures. In this paper we study the symmetric WFMOC problem, where all tuples from the same relation have the same weight, which we denote wi. For example, a random graph G(n, p) is a symmetric structure, since every edge is present with the same probability p (equivalently: has weight p/(1 \u2212 p)), and FOMC is another special case where all weights are set to 1. The symmetric WFMOC problem occurs naturally in Knowledge Bases with soft constraints, as we illustrate next.\nExample 1.1. A Markov Logic Network (MLN) [7] is a finite set of soft or hard constraints. Each constraint is a pair (w,\u03d5), where \u03d5 is a formula, possibly with free variables x, and w \u2208 [0,\u221e] is a weight2. For example, 1For a fixed x, there are 2n assignments to R(x, y), which all satisfy \u2203yR(x, y), except the one where all atoms are false. Moreover, the models for the n values of x can be counted independently and multiplied. 2In typical MLN systems, users specify the log of the weight rather than the weight. The pair (1.098, \u03d5) means that the weight of \u03d5 is w = exp(1.098) \u2248 3. Using logs simplifies the learning task. We do not address learning and will omit logs; (w,\u03d5) means that \u03d5 has weight w.\nar X\niv :1\n41 2.\n15 05\nv3 [\ncs .D\nB ]\n1 J\nun 2\n01 5\nthe soft constraint\n(3,Spouse(x, y) \u2227 Female(x)\u21d2 Male(y)) (1) specifies that, typically, a female\u2019s spouse is male, and associates the weight w = 3 to this constraint. If w = \u221e then we call (w,\u03d5) a hard constraint.\nThe semantics of MLNs naturally extend the Weighted Model Counting setting. Given a finite domain (set of constants), an MLN defines a probability distribution over all structures for that domain (also called possible worlds). Every structure D has a weight\nW (D) = \u220f\n(w,\u03d5(x))\u2208MLN,a\u2208D|x|:w<\u221e\u2227D|=\u03d5[a/x] w\nIn other words, for each soft constraint (W,\u03d5), and for every tuple of constants a such that \u03d5(a) holds in D, we multiply D\u2019s weight by w. For example, given the MLN that consists only of the soft constraint (1), the weight of a world D is 3N , where N is the number of pairs of constants a, b for which Spouse(a, b),Female(a) \u21d2 Male(b) holds in D. The weight W (\u03a6) of a sentence \u03a6 is defined as the sum of weights of all worlds D that satisfy both \u03a6 and all hard constraints in the MLN; its probability is obtained by normalizing PrMLN (\u03a6) = W (\u03a6)/W (true). Notice that the symmetric WFOMC problem corresponds to the special case of an MLN consisting of one soft constraint (wi, Ri(xi)) for each relation Ri, where |xi| = arity(Ri).\nToday\u2019s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference. The theoretical convergence guarantees of MC-SAT require access to a uniform sampler over satisfying assignments to a set of constraints. In practice, MC-SAT implementations rely on SampleSAT [42], which provides no guarantees on the uniformity of solutions. Several complex examples are known in the literature where model counting based on SampleSAT leads to highly inaccurate estimates [16].\nA totally different approach to computing PrMLN (\u03a6) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper. We review here briefly one such reduction, adapting from [22, 37].\nExample 1.2. Given an MLN, replace every soft constraint (w,\u03d5(x)) by two new constraints: (\u221e,\u2200x(R(x)\u2228 \u03d5(x))) and (1/(w \u2212 1), R(x)). Here R is a new relational symbol with the same arity as the number of free variables in \u03d5, and the constraint (1/(w\u22121), R(x)) defines R as a relation where all tuples have weight 1/(w \u2212 1). Therefore, the probability of a formula \u03a6 in the MLN can be computed as a conditional probability over a symmetric, tuple-independent database: PrMLN (\u03a6) = Pr(\u03a6|\u0393), where \u0393 is the conjunction of all hard constraints3. Note that this reduction to WFOMC is independent of the finite domain under consideration. 3The reason why this works is the following: in original MLN, each tuple a contributes to W (D) a factor of 1 or w, depending on whether \u03d5(a) is false or true in D; after the rewriting, the contribution of a is 1/(w\u22121) when \u03d5(a) is false, because in that case R(a) must be true, or 1 + 1/(w \u2212 1) = w/(w\u22121) when \u03d5(a) is true, because R(a) can be either false or true. The ratio is the same 1 : w = [1/(w\u22121)] : [w/(w\u22121)].\nFor example, the soft constraint in (1) is translated into the hard constraint:\n\u2200x, y(R(x, y) \u2228 \u00acSpouse(x, y) \u2228 \u00acFemale(x) \u2228Male(y)) and a tuple-independent probabilistic relation R where all tuples have weight 1/(3\u2212 1) = 1/2, or, equivalently, have probability (1/2)/(1 + (1/2)) = 1/3.\nThus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41]. Some tasks on MLNs, such as parameter learning [38], naturally exhibit symmetries. For others, such as computing conditional probabilities given a large \u201cevidence\u201d database, the symmetric WFOMC model is applicable when the database has bounded Boolean rank [36]. Moreover, the problem is of independent theoretical interest as we explain below. We study both the data complexity, and the combined complexity. In both settings we assume that the vocabulary \u03c3 = (R1, . . . , Rm) is fixed, and so are the weights w = (w1, . . . , wm) associated with the relations. In data complexity, the formula \u03a6 is fixed, and the only input is the number n representing the size of the domain. In this case WFOMC is a counting problem over a unary alphabet: given an input 1n, compute WFOMC(\u03a6, n,w). It is immediate that this problem belongs to the class #P1, which is the set of #P problems over a unary input alphabet [34]. In the combined complexity, both n and the formula \u03a6 are input.\nIn this paper we present results on the data complexity and the combined complexity of the FOMC and WFOMC problem, and also some results on the associated decision problem."}, {"heading": "Results on Data Complexity", "text": "In a surprising result [37] has proven that for FO2 the data complexity of symmetric WFOMC is in PTIME (reviewed in Appendix C).4 This is surprising because FO2 (the class of FO formulas restricted to two logical variables) contains many formulas for which the asymmetric problem was known to be #P-hard. An example is \u03a6 = \u2203x\u2203y(R(x) \u2227 S(x, y) \u2227 T (y)), which is #P-hard over asymmetric structures, but the number of models\nis5 22n+n 2 \u2212\u2211k,m (nk)(nm)2n2\u2212km, which is a number computable in time polynomial in n.6 More generally, the symmetric WFOMC problem for \u03a6 is in PTIME.\nThis begs the question: could it be the case that every FO formula is in PTIME? The answer was shown to be negative by Jaeger and Van den Broeck [21, 20], using the following argument. Recall that the spectrum, Spec(\u03a6), of a formula \u03a6 is the set of numbers n for which \u03a6 has a model over a domain of size n [9]. Jaeger and Van den Broeck observed that the spectrum membership problem, \u201cis n \u2208 Spec(\u03a6)?\u201d, can be reduced to WFOMC, by checking whether FOMC(\u03a6, n) > 0.\n4PTIME data complexity for symmetric WFOMC is called domain-liftability in the AI and lifted inference literature [35]. 5Fix the relations R, T , and let their cardinalities be |R| = k and |T | = m. Then the structure does not satisfy \u03a6 iff S contains none of the km tuples in R\u00d7T , proving the formula. 6Tractability of \u03a6 was noted before in, for example [32, 35].\nThen, using a result in [23], if ETIME 6= NETIME, then there exists a formula \u03a6 for which computing WFOMC is not in polynomial time7. However, no hardness results for the symmetric WFOMC were known to date.\nWhat makes the data complexity of the symmetric WFOMC difficult to analyze is the fact that the input is a single number n. Valiant already observed in [34] that such problems are probably not candidates for being #P-complete. Instead, he defined the complexity class #P1, to be the set of counting problems for NP computations over a single-letter input alphabet. Very few hardness results are known for this class: we are aware only of a graph matching problem that was proven by Valiant, and of a language-theoretic problem by Bertoni and Goldwurm [1].\nOur data complexity results are the following. First, we establish the existence of an FO sentence \u03981 for which the data complexity of the FOMC problem is #P1-hard; and we also establish the existence of a conjunctive query \u03a51 for which the data complexity of the WFOMC problem is #P1-hard. Second, we prove that every \u03b3-acyclic conjunctive query without self-joins is in polynomial time, extending the result in [37] from FO2 to \u03b3-acyclic conjunctive queries. We give now more details about our results, and explain their significance.\nThe tractability for FO2 [37] raises a natural question: do other restrictions of FO, like FOk for k \u2265 3, also have polynomial data complexity? By carefully analyzing the details of the construction of \u03981 we prove that it is actually in FO3. This implies a sharp boundary in the FOk hierarchy where symmetric WFOMC transitions from tractable to intractable: for k between 2 and 3. The tractability of \u03b3-acyclic queries raises another question: could all conjunctive queries be tractable for symmetric WFOMC? We answer this also in the negative: we prove that there exists a conjunctive query \u03a51 for which the symmetric WFOMC problem is #P1-hard. It is interesting to note that the decision problem associated to WFOMC, namely given n, does n \u2208 Spec(\u03a6)? is trivial for conjunctive queries, since every conjunctive query has a model over any domain of size n \u2265 1. Therefore, our #P1-hardness result for \u03a51 is an instance where the decision problem is easy while the corresponding weighted counting problem is hard. We note that, unlike WFOMC, we do not know the exact complexity of the unweighted, FOMC problem for conjunctive queries.\n0-1 Laws. Our data complexity hardness result sheds some interesting light on 0-1 laws. Recall that, if C is a class of finite structures and P is a property over these structures, then \u00b5n(P ) denotes the fraction of labeled8 structures in C over a domain of size n that satisfy the property P [27]. A logic has a 0-1 law over the class of structures C, if for any property P\n7Recall that ETIME = \u22c3\nc\u22651 DTIME(2 cn) and NETIME =\u22c3\nc\u22651 NTIME(2 cn), and are not to be confused with the more familiar classes EXPTIME and NEXPTIME, which are\u22c3 c\u22651 DTIME(2 nc) and \u22c3 c\u22651 NTIME(2 nc) respectively. 8The attribute labeled means that isomorphic structures are counted as distinct; 0-1 laws for unlabeled structures also exist. In this paper, we discuss labeled structures only.\nexpressible in that logic, \u00b5(P ) def = limn\u2192\u221e \u00b5n(P ) is either 0 or 1. Fagin [13] proved a 0-1 law for First-Order logic and all structures, by using an elegant transfer theorem: there exists a unique, countable structure R, which is characterized by an infinite set of extension axioms, \u03c4 . He proved that, for every extension axiom, lim\u00b5n(\u03c4) = 1, and this implies lim\u00b5n(\u03a6) = 1 if \u03a6 is true in R, and lim\u00b5n(\u03a6) = 0 if \u03a6 is false in R. Compton [3] proved 0-1 laws for several classes of structures C. A natural question to ask is the following: does there exists an elementary proof of the 0-1 laws, by computing a closed formula FOMC(\u03a6, n) for every \u03a6, then using elementary calculus to prove that that \u00b5n(\u03a6) converges to 0 or 1? For example, if \u03a6 = \u2200x\u2203yR(x, y), then FOMC(\u03a6, n) = (2n \u2212 1)n and \u00b5n(\u03a6) = (2\nn \u2212 1)n/2n2 \u2192 0; can we repeat this argument for every \u03a6? On a historical note, Fagin confirms in personal communication that he originally tried to prove the 0-1 law by trying to find such a closed formula, which failed as an approach. Our #P1-result for FO proves that no such elementary proof is possible, because no closed formula for FOMC(\u03a6, n) can be computed in general (unless #P1 is in PTIME)."}, {"heading": "Results on the Combined Complexity", "text": "Our main result on the combined complexity is the following. We show that, for any k \u2265 2, the combined complexity of FOMC for FOk is #P-complete; membership is a standard application of Scott\u2019s reduction, while hardness is by reduction from the model counting problem for Boolean formulas. Recall that the vocabulary \u03c3 is always assumed to be fixed: if it were allowed to be part of the input, then every Boolean formula is a special case of an FO0 formula, by creating a new relational symbol of arity zero for each Boolean variable, and all hardness results for Boolean formulas carry over immediately to FO0."}, {"heading": "The Associated Decision Problem", "text": "We also discuss and present some new results on the decision problem associated with (W)FOMC: \u201cgiven \u03a6, n, does \u03a6 have a model over a domain of size n?\u201d. The data complexity variant is, of course, the spectrum membership problem, which has been completely solved by Jones and Selman [23], by proving that the class of spectra coincides with NETIME, that is, {Spec(\u03a6) | \u03a6 \u2208 FO} = NETIME. Their result assumes that the input n is represented in binary, thus the input size is log n. In this paper we are interested in the unary representation of n, as 1n, which is also called the tally notation, in which case case NETIME naturally identifies with NP1. Fagin proved that, in the tally notation, {Spec(\u03a6) | \u03a6 \u2208 FO} = NP1 [12, Theorem 6, Part 2].\nFor the decision problem, our result is for the combined complexity: given both \u03a6, n, does n \u2208 Spec(\u03a6)? We prove that this problem is NP-complete for FO2, and PSPACE-complete for FO. The first of these results has an interesting connection to the finite satisfiability problem for FO2, which we discuss here. Recall the classical satisfiability problem in finite model theory: \u201cgiven a formula \u03a6 does it have a finite model?\u201d, which is equivalent to checking Spec(\u03a6) 6= \u2205. Gra\u0308del, Kolaitis and Vardi [17] have proven the following two\nresults for FO2: if a formula \u03a6 is satisfiable then it has a finite model of size at most exponential in the size of the sentence \u03a6, and deciding whether \u03a6 is satisfiable is NEXPTIME-complete in the size of \u03a6. These two results already prove that the combined complexity for deciding n \u2208 Spec(\u03a6) cannot be in polynomial time: otherwise, we could check satisfiability in EXPTIME by iterating n from 1 to exponential in the size of \u03a6, and checking n \u2208 Spec(\u03a6). Our result settles the combined complexity, proving that it is NP-complete.\nThe paper is organized as follows: we introduce the basic definitions in Section 2, present our results for the data complexity of the FOMC and WFOMC problems in Section 3, present all results on the combined complexity in Section 4, then conclude in Section 5."}, {"heading": "2. BACKGROUND", "text": "We review here briefly the main concepts, some already introduced in Section 1.\nWeighted Model Counting (WMC). The Model Counting problem is: given a Boolean formula F , compute the number of satisfying assignments #F . In Weighted Model Counting we are given two real functions w, w\u0304 : Vars(F ) \u2192 R associating two weights w(X), w\u0304(X) to each variable in Vars(F ) = {X1, . . . , Xn}. The weighted model count WMC(F,w, w\u0304) is defined as:\nWMC(F,w, w\u0304) def = \u2211 \u03b8:\u03b8(F )=1 W (\u03b8) (2)\nwhere, \u2200\u03b8 : Vars(F )\u2192 {0, 1}:\nW (\u03b8) def = \u220f i:\u03b8(Xi)=0 w\u0304(Xi)\u00d7 \u220f i:\u03b8(Xi)=1 w(Xi) (3)\nThe model count is a special case #F = WMC(F, 1, 1).\nThe standard definition of WMC in the literature does not mention w\u0304, instead sets w\u0304 = 1; as we will see, our extension is non-essential. When w\u0304 = 1, then we simply drop w\u0304 from the notation, and write WMC(F,w) instead of WMC(F,w, 1). In the probability computation problem, each variable Xi is set to true with some known probability p(Xi) \u2208 [0, 1], and we want to compute Pr(F, p) def = WMC(F, p, 1\u2212 p), the probability that F is true. All these variations are equivalent, because of the following identities:\nWMC(F,w, w\u0304) = WMC(F,w/w\u0304, 1)\u00d7 \u220f i w\u0304(Xi) (4)\nWMC(F,w, w\u0304) = Pr(F,w/(w + w\u0304))\u00d7 \u220f i (w(Xi) + w\u0304(Xi)) Throughout the paper we write 1 for the constant function with value 1, and w1 +w2, and w1/w2 for functions X 7\u2192 w1(X) + w2(X) and X 7\u2192 w1(X)/w2(X) resp."}, {"heading": "Weighted First-Order Model Counting (WFOMC).", "text": "Consider FO formulas over a fixed relational vocabulary \u03c3 = (R1, . . . , Rm) and equality =. Given a domain size n, denote Tup(n) the set of ground tuples (i.e., ground atoms without equality) over the domain, thus\n|Tup(n)| = \u2211i narity(Ri). The lineage of an FO sentence \u03a6 refers to a Boolean function F\u03a6,n over Tup(n) (a ground FO sentence), as well as the corresponding Boolean function over propositional variables referring to ground tuples (a propositional sentence). It is defined inductively by Ft,n = t for ground tuples t, F\u00ac\u03a6,n = \u00acF\u03a6,n, F(\u03a61 op \u03a62),n = F\u03a61,n op F\u03a62,n for op \u2208 {\u2227,\u2228}, Fa=b,n = false, Fa=a,n = true and F\u2203x\u03a6,n = \u2228 a\u2208[n] F\u03a6[a/x],n, F\u2200x\u03a6,n = \u2227 a\u2208[n] F\u03a6[a/x],n. For any fixed sentence \u03a6, the size of its lineage is polynomial in n. Given a domain size n and weight functions w, w\u0304 : Tup(n) \u2192 R, the Weighted FirstOrder Model Count of \u03a6 is WFOMC(\u03a6, n, w, w\u0304) def = WMC(F\u03a6,n, w, w\u0304).\nSymmetric WFOMC. In the symmetric WFOMC, the weight of a tuple depends only on the relation name and not on the domain constants. We call a weighted vocabulary a triple (\u03c3,w, w\u0304) where \u03c3 = (R1, . . . , Rm) is a relational vocabulary and w = (w1, . . . , wm), w\u0304 = (w\u03041, . . . , w\u0304m) represent the weights (real numbers) for the relational symbols. For any domain size n, we extend these weights to Tup(n) by setting w\u2032(Ri(a1, . . . , ak)) = wi and w\u0304 \u2032(Ri(a1, . . . , ak)) = w\u0304i, and we define WFOMC(\u03a6, n,w, w\u0304) def = WFOMC(\u03a6, n, w\u2032, w\u0304\u2032). Throughout this paper we assume that WFOMC refers to the symmetric variant, unless otherwise stated.\nFor a simple illustration, consider the sentence \u03d5 = \u2203yS(y). Then WFOMC(\u03d5, n,wS , w\u0304S) = (w\u0304S + wS)n \u2212 (w\u0304S)\nn, because the sum of the weights of all possible worlds is (w\u0304S + wS)\nn, and we have to subtract the weight of the world where S = \u2205. For another example, consider \u03a6 = \u2200x\u2203yR(x, y). The reader may check that WFOMC(\u03a6, n, wR, w\u0304R) = ((wR + w\u0304R) n \u2212 w\u0304nR) n. In particular, over a domain of size n, the formula \u03a6 has (2n \u2212 1)n models (by setting wR = w\u0304R = 1).\nData Complexity and Combined Complexity. We consider the weighted vocabulary (\u03c3,w, w\u0304) fixed. In the data complexity, we fix \u03a6 and study the complexity of the problem: given n, compute WFOMC(\u03a6, n,w, w\u0304). In the combined complexity, we study the complexity of the problem: given \u03a6, n, compute WFOMC(\u03a6, n,w, w\u0304). All our upper bounds continue to hold if the weights w, w\u0304 are part of the input. We also consider the data- and combined-complexity of the associated decision problem (where we ignore the weights) given n, does \u03a6 have a model over a domain of size n?\nWeights and Probabilities. While in practical applications the weights are positive real numbers, and the probabilities are numbers in [0, 1], in this paper we impose no restrictions on the values of the weights and probabilities. The definition (2) of WMC(F,w) applies equally well to negative weights, and, in fact, to any semiring structure for the weights [25]. There is, in fact, at least one application of negative probabilities [22], namely the particular reduction from MLNs to WFOMC described in Example 1.2: a newly introduced relation has weight 1/(w \u2212 1), which is negative when\nw < 1. Then, the associated probability p = w/(1 +w) belongs to (\u2212\u221e, 0) \u222a (1,\u221e).\nAs a final comment on negative weights, we note that the complexity of the symmetric WFOMC problem is the same for arbitrary weights as for positive weights. Indeed, the expression WFOMC(\u03a6, n,w) is a multivariate polynomial in m variables w1, . . . , wm, where each variable has degree n. The polynomial has (n + 1)m = nO(1) real coefficients. Given access to an oracle computing this polynomial for arbitrary positive values for w, we can compute in polynomial time all nO(1) coefficients with as many calls to the oracle; once we know the coefficients we can compute the polynomial at any values w1, . . . , wm, positive or negative.\nFor all upper bounds in this paper we assume that the weights w, w\u0304, or probabilities p, are given as rational numbers represented as fractions of two integers of n bits each. We assume w.l.o.g. that all fractions have the same denominator: this can be enforced by replacing the denominators by their least common multiplier, at the cost of increasing the number of bits of all integers to at most n2. It follows that the weight of a world W (\u03b8) (Eq.(3)) and WMC(F,w, w\u0304) can be represented as ratios of two integers, each with nO(1) bits.\nSummary. Table 1 summarizes the taxonomy and illustrates the various weighted model counting problems considered in this paper. Throughout the rest of the paper, FOMC and WFOMC refer to the symmetric variant, unless otherwise mentioned."}, {"heading": "3. DATA COMPLEXITY", "text": "Recall that the language FOk consists of FO formulas with at most k distinct logical variables."}, {"heading": "3.1 Lower Bounds", "text": "Our first lower bound is for an FO3 sentence:\nTheorem 3.1. There exists an FO3 sentence, denoted \u03981, s.t. the FOMC problem for \u03981 is #P1-complete.\nVan den Broeck et al. [37] have shown that the Symmetric WFOMC problem for every FO2 formula has polynomial time data complexity (the proof is reviewed in Appendix C); Theorem 3.1 shows that, unless #P1 is in PTIME, the result cannot extend to FOk for k > 2.\nOur second lower bound is for a conjunctive query, or, dually, a positive clause without equality. Recall that a clause is a universally quantified disjunction of literals,\nfor example \u2200x\u2200y(R(x)\u2228\u00acS(x, y)). A positive clause is a clause where all relational atoms are positive. A conjunctive query (CQ) is an existentially quantified conjunction of positive literals, e.g. \u2203x\u2203y(R(x) \u2227 S(x, y)). Positive clauses without the equality predicate are the duals of CQs, and therefore the WFOMC problem is essentially the same for positive clauses without equality as for CQs. Note that the dual of a clause with the equality predicate is a CQ with 6=, e.g. the dual of \u2200x\u2200y(R(x, y) \u2228 x = y) is \u2203x\u2203y(R(x, y) \u2227 x 6= y). Corollary 3.2. There exists a positive clause \u039e1 without equality s.t. the Symmetric WFOMC problem for \u039e1 is #P1-hard. Dually, there exists a CQ \u03a51 s.t. the Symmetric WFOMC problem for \u03a51 is #P1-hard.\nCorollary 3.2 shows that the tractability result for \u03b3-acyclic conjunctive queries (discussed below in Theorem 3.6) cannot be extended to all CQs. The proof of the Corollary follows easily from three lemmas, which are of independent interest, and which we present here; the proofs of the lemmas are in the appendix. We say that a vocabulary \u03c3\u2032 extends \u03c3 if \u03c3 \u2286 \u03c3\u2032, and that a weighted vocabulary (\u03c3\u2032,w\u2032, w\u0304\u2032) extends (\u03c3,w, w\u0304) if \u03c3 \u2286 \u03c3\u2032 and the tuples w\u2032, w\u0304\u2032 extend w, w\u0304. Lemma 3.3. Let (\u03c3,w, w\u0304) be a weighted vocabulary and \u03a6 an FO sentence over \u03c3. There exists an extended weighted vocabulary (\u03c3\u2032,w\u2032, w\u0304\u2032) and sentence \u03a6\u2032 over \u03c3\u2032, such that \u03a6\u2032 is in prenex-normal form with a quantifier prefix \u2200\u2217, and WFOMC(\u03a6, n,w, w\u0304) = WFOMC(\u03a6\u2032, n,w\u2032, w\u0304\u2032) for all n.\nThis lemma was proven by [37], and says that all existential quantifiers can be eliminated. The main idea is to replace a sentence of the form \u2200x \u2203y \u03c8(x, y) by \u2200x \u2200y (\u00ac\u03c8(x, y) \u2228 A(x)), where A is a new relational symbol of arity |x| and with weights wA = 1, w\u0304A = \u22121. For every value x = v, in a world where \u2203y \u03c8(v, y) holds, A(v) holds too and the new symbol contributes a factor +1 to the weight; in a world where \u2203y \u03c8(v, y) does not hold, then A(v) may be true or false, and the weights of the two worlds cancel each other out.\nNote that the lemma tells us nothing about the model count of \u03a6 and \u03a6\u2032, since in \u03a6\u2032 we are forced to set some negative weights. If we had FOMC(\u03a6, n) = FOMC(\u03a6\u2032, n), then we could reduce the satisfiability problem for an arbitrary FO sentence \u03a6 to that for a sentence with a \u2200\u2217 quantifier prefix, which is impossible, since the former is undecidable while the latter is decidable.\nThe next lemma, also following the proof in [37], says that all negations can be eliminated.\nLemma 3.4. Let (\u03c3,w, w\u0304) be a weighted vocabulary and \u03a6 a sentence over \u03c3 in prenex-normal form with quantifier prefix \u2200\u2217. Then there exists an extended weighted vocabulary (\u03c3\u2032,w\u2032, w\u0304\u2032) and a positive FO sentence \u03a6\u2032 over \u03c3\u2032, also in prenex-normal form with quantifier prefix \u2200\u2217, s.t. WFOMC(\u03a6, n,w, w\u0304) = WFOMC(\u03a6\u2032, n,w\u2032, w\u0304\u2032) for all n.\nThe idea is to create two new relational symbols A,B for every negated subformula \u00ac\u03c8(x), replace the formula by A(x), and add the sentence \u2200x(\u03c8(x)\u2228A(x))\u2227 (A(x) \u2228B(x)) \u2227 (\u03c8(x) \u2228B(x)). By setting the weights wA = w\u0304A = wB = 1, w\u0304B = \u22121 we ensure that, for every constant x = v, either \u00ac\u03c8(v) \u2261 A(v), in which case B(v) is forced to be true and the two new symbols contribute a factor +1 to the weight, or \u03c8(v) \u2261 A(v) \u2261 true, in which case B(v) can be either true or false, and the weights cancel out.\nFinally, we remove the = predicate.\nLemma 3.5. Let (\u03c3,w, w\u0304) be a weighted vocabulary and \u03a6 a sentence over \u03c3. Then there exists an extended vocabulary \u03c3\u2032 and sentence \u03a6\u2032 without the equality predicate =, such that, for all n, WFOMC(\u03a6, n,w, w\u0304) can be computed in polynomial time using n+ 1 calls to an oracle for WFOMC(\u03a6\u2032, n,w\u2032, w\u0304\u2032), where (\u03c3\u2032,w\u2032, w\u0304\u2032) is an extension of (\u03c3,w, w\u0304).\nThe idea is to introduce a new relational symbol E, replace every atom x = y with E(x, y), and add the sentence \u2200x E(x, x). Let w\u2032, w\u0304\u2032 be the extension of w, w\u0304 with w\u2032E = z, w\u0304 \u2032 E = 1. Then WFOMC(\u03a6\n\u2032, n,w\u2032, w\u0304\u2032) is a polynomial of degree n2 in z where each monomial has degree \u2265 n in z, because the hard constraint \u2200x E(x, x) forces |E| \u2265 n. Moreover, the coefficient of zn is precisely WFOMC(\u03a6, n,w, w\u0304), because that corresponds to the worlds where |E| = n, hence it coincides with =. We compute this coefficient using n+ 1 calls to an oracle for WFOMC(\u03a6\u2032, n,w\u2032, w\u0304\u2032).\nNow we give the proof of Corollary 3.2. Starting with the #P1-complete sentence \u03981, we apply the three lemmas and obtain a positive sentence \u03a6, with quantifier prefix \u2200\u2217 and without the equality predicate, that is #P1-hard. We write it as a conjunction of clauses, \u03a6 = C1\u2227C2\u2227\u00b7 \u00b7 \u00b7\u2227Ck (recall that a clause is universally quantified), and then apply the inclusion-exclusion formula: Pr(\u03a6) = \u2211 s\u2286[k],s 6=\u2205(\u22121)|s|+1 Pr( \u2228 i\u2208s Ci). Since any disjunction of clauses is equivalent to a single clause, we have reduced the computation problem Pr(\u03a6) to computing the probabilities of 2k \u2212 1 clauses. By duality, this reduces to computing the probabilities of 2k\u22121 conjunctive queries, Pr(Q1),Pr(Q2), . . . ,Pr(Q2k\u22121). We can reduce this problem to that of computing the probability of a single conjunctive query \u03a51, by the following argument. Create 2k \u2212 1 copies of the relational symbols in the FO vocabulary, and take the conjunction of all queries, where each query uses a fresh copy of the vocabulary. Then Pr(Q1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Q2k\u22121) = Pr(Q1) \u00b7 \u00b7 \u00b7Pr(Q2k\u22121), because now every two distinct queries Qi, Qj have distinct relational symbols. Using\nan oracle to compute the probability of \u03a51 def = \u2227 iQi, we can compute any Pr(Qi) by setting to 1 the probabilities of all relations occurring in Qj , for j 6= i: in other words, the only possible world for a relation R\nin Qj is one where R is the cartesian product of the domain; assuming n \u2265 1, Qj is true, Pr(Qj) = 1, and hence Pr(\u03a51) = Pr(Qi). We repeat this for every i and compute Pr(Q1), . . . ,Pr(Q2k\u22121). This proves that the CQ \u03a51 is #P1-hard. Its dual, \u039e1, is a #P1-hard positive clause without equality. This proves Corollary 3.2."}, {"heading": "3.2 Upper Bounds", "text": "A CQ is without self-joins if all atoms refer to distinct relational symbols. It is standard to associate a hypergraph with CQs, where the variables are nodes, and the atoms are hyper-edges. We define a \u03b3-acyclic conjunctive query to be a conjunctive query w/o self-joins whose associated hypergraph is \u03b3-acyclic. We prove:\nTheorem 3.6. The data complexity of Symmetric WFOMC for \u03b3-acyclic CQs is in PTIME.\nFagin\u2019s definition of \u03b3-acyclic hypergraphs [14] is reviewed in the proof of Theorem 3.6.\nAn open problem is to characterize the conjunctive queries without self-joins that are in polynomial time. While no such query has yet been proven to be hard (\u03a51 in Corollary 3.2 has self-joins), it is widely believed that, for any k \u2265 3, the symmetric WFOMC problem for a typed cycle of length k, Ck = \u2203x1 \u00b7 \u00b7 \u00b7xk(R1(x1, x2), R2(x2, x3), . . . , Rk(xk, x1)), is hard. We discuss here several insights into finding the tractability border for conjunctive queries, summarized in Figure 1.\nThis boundary does not lie at \u03b3-acyclicity: the query c\u03b3 = R(x, z), S(x, y, z), T (y, z) is \u03b3-cyclic (with cycle RxSyTzR; see Fagin [14]), yet it still has PTIME data complexity. The key observation is that \u03b3-cycles allow the last variable z to appear in all predicates, turning it into a separator variable [5], hence Pr(Q) =\u220f a\u2208[n] Pr(Q[a/z]), which is [Pr(Q[a/z])] n by symmetry; Q[a/z] is isomorphic to the query in Table 1 and can be computed in polynomial time. A weaker notion of acyclicity, called jtdb (for join tree with disjoint branches), can be found in [10]. It also does not characterize the tractability boundary: jtdb contains the \u03b3cyclic query above, but it does not contain the PTIME query cjtdb = R(x, y, z, u), S(x, y), T (x, z), V (x, u).\nFagin [14] defines two increasingly weaker notions of acyclicity: \u03b2- and \u03b1-acyclic. \u03b1-Acyclic queries are as hard as any conjunctive query without self-joins. Indeed, if Q = \u2203x\u03d5(x) is a conjunctive query w/o selfjoins, then the query Q\u2032 = \u2203x(A(x)\u2227\u03d5(x)) is \u03b1-acyclic, where A is a new relational symbol, containing all variables of Q. By setting the probability of A to 1, we have Pr(Q) = Pr(Q\u2032). Thus, if all \u03b1-acyclic queries have PTIME data complexity, then all conjunctive queries w/o self-joins have PTIME data complexity.\nFor all we know, \u03b2-acyclic queries could well coincide with the class of tractable conjunctive queries w/o self joins. We present here some evidence that all \u03b2-cyclic queries are hard, by reduction from typed cycles, Ck. For that, we need to consider a slight generalization of WFOMC for conjunctive queries w/o self-joins, were each existential variable xi ranges over a distinct domain, of size ni: the standard semantics corresponds to the special case where all domains sizes ni are equal. We prove that for any \u03b2-cyclic query Q, there exists k such that WFOMC(Ck,n,w, w\u0304) can be reduced to\nWFOMC(Q,n\u2032,w\u2032, w\u0304\u2032). Hence, the existence of a \u03b2cyclic query with PTIME data complexity would imply PTIME data complexity for at least one Ck (informally called Ck-hardness in Fig. 1). The reduction is as follows. By definition, a \u03b2-cyclic query Q contains a weak \u03b2-cycle [14] of the form R1x1R2x2 . . . xk\u22121RkxkRk+1, where k \u2265 3, all xi and Ri are distinct, each xi occurs in both Ri and Ri+1, but in no other Rj , and Rk+1 = R1. Then, we reduce the WFOMC for Ck to that of Q. First, for each relational symbol Rj in Q, if Rj appears in the cycle then we define w \u2032 j = wj and w\u0304\u2032j = w\u0304j , otherwise w \u2032 j = w\u0304 \u2032 j = 1. Second, for all variables xi that appear in the cycle we set their domain size ni to be the same as that of the corresponding variable in Ck, otherwise we set ni = 1. Then Q and Ck have the same WFOMC.\nFinally, we discuss a peculiar sentence, whose complexity we left open in [18]:\nTheorem 3.7. The data complexity of the symmetric WFOMC problem is in PTIME for the query\nQS4 =\u2200x1\u2200x2\u2200y1\u2200y2(S(x1, y1)\u2228 \u00acS(x2, y1) \u2228 S(x2, y2) \u2228 \u00acS(x1, y2))\nIn [18] we showed that QS4 is in PTIME under the modified semantics, where S is a bipartite graph. This implies that the range of the variables x1, x2 is disjoint from the range of the variables y1, y2. Now we extended the proof to the standard semantics used in this paper. What makes this query interesting is that the algorithm used to compute it requires a subtle use of dynamic programming, and none of the existing lifted inference rules in the literature are sufficient to compute this query. This suggests that we do not yet have a candidate for a complete set of lifted inference rules for the symmetric WFOMC."}, {"heading": "3.3 Proofs", "text": "Proof of Theorem 3.1. We briefly recall the basic notions from Valiant\u2019s original papers [33, 34]. A counting Turing machine is a nondeterministic TM with a read-only input tape and a work tape, that (magically) prints in binary, on a special output tape, the number of its accepting computations. The class #P1 consists of all functions computed by some counting TM with polynomial (non-deterministic) running time and a unary input alphabet. A function f is #P1-hard if, for any function g in #P1 there exists a polynomial time, deterministic TM Tdet with access to an oracle\nfor f that computes g. Notice that Tdet\u2019s input alphabet is unary. As usual, f is called #P1-complete if it is both hard, and in #P1.\nOur proof of Theorem 3.1 consists of two steps. First we construct a #P1-complete function f , which is computable by a linear time counting TM U1, which we call a universal #P1 machine; in fact, we will define f by describing U1. A similar construction in [34] is sketched too briefly to see how the particular pairing function can work; we use a different pairing function and give full details. To prove FO3 membership, we also need to ensure U1 runs in (nondeterministic) linear time, which requires some care given that the input is given in unary. Once we have defined U1, the second step of the proof is a standard construction of an FO formula to simulate U1: we follow Libkin [28, p. 167], but make several changes to ensure that the formula is in FO3. The two steps are:\nLemma 3.8. There exists a counting TM, U1, with a unary input alphabet, such that (i) U1 runs in linear time, and (ii) the function f that it computes is #P1hard.\nIt follows immediately that f is #P1-complete.\nLemma 3.9. Let T be any counting TM with a unary input alphabet computing some function f . Suppose T runs in time O(na). Then there exists an FOk formula \u03a6 over some relational vocabulary \u03c3, s.t. f(n) = FOMC(\u03a6, n)/(n!), where k = 3a for a \u2265 1.\nTheorem 3.1 follows by applying this lemma to U1, hence a = 1 and the formula is in FO3. By allowing runtimes O(na) with a > 1, the lemma implies: #P1 = {f | \u2203\u03a6 \u2208 FO ,\u2200n : f(n) = bFOMC(\u03a6, n)/n!c}; this is an extension of the classic result by Jones and Selman [23], which, restated for the tally notation says NP1 = {Spec(\u03a6) | \u03a6 \u2208 FO} (see [12], [9, Sec.5]). By considering FOMC over unlabeled structures, denoted UFOMC, the correspondence becomes even stronger. In UFOMC, all models that are identical up to a permutation of the constants are counted once, and #P1 = {UFOMC(\u03a6, n) | \u03a6 \u2208 FO}.\nProof of Lemma 3.8. The idea for U1 is simple: its input n is represented in unary and encodes two numbers i, j: n = e(i, j), for some encoding function e to be defined below. U1 first computes i, j from n, then simulates the ith #P1 counting TM on input j. The difficult part is to ensure that U1 runs in linear time:\nevery TM i that it simulates runs in time O(jki) for some exponent ki that depends on i, and thus if we construct U1 naively to simply simulate machine i on input j, then its runtime is no longer polynomial.\nWe start by describing an enumeration of counting TMs in #P1, M1,M2, . . . ,Mi, . . ., with the property that Mi runs in time \u2264 (i \u00b7 ji + i)2 on an input j. We start by listing all counting TMs over a unary input alphabet in standard order M \u20321,M \u2032 2, . . .. Then we dovetail pairs of the form Mi = (M \u2032 r, s) where r is an index in the standard TM order and s is a number. Mi represents the counting TM that simulates M \u2032r on input j with a timer for s \u00b7 js + s steps. The machine Mi can be constructed with at most quadratic slowdown over M \u2032r (due to the need to increment the counter). We further ensure that dovetailing Mi = (M \u2032 r, s) is done such that i \u2265 s; for that, it suffices to advance r in such a way that i advances at least as fast as s, that is, M1 = (M \u2032 1, 1),M2 = (M \u2032 2, 1),M3 = (M \u2032 1, 2),M4 = (M \u20322, 2),M5 = (M \u2032 1, 3), . . .. It follows that, for every i, the runtime of Mi on input j is \u2264 (i \u00b7 ji + i)2. It remains to show that the list M1,M2, . . . ,Mi, . . . enumerates precisely all #P1 functions. Indeed, each function in this list is in #P1, because the runtime of Mi is polynomial in the input j. Conversely, every function in #P1 is computed by some Mi in our list, because it is computed by some M \u2032r whose runtime on input j is \u2264 ar \u00b7 jkr + br and this is \u2264 s \u00b7 js + s if we choose s def = max(ar, br, kr). This completes the construction of the enumeration M1,M2, . . .. We describe now the counting machine U1. Its input is a number n in unary, which represents an encoding n = e(i, j) of two integers i, j. We will choose the encoding function e below such that it satisfies three properties: (a) U1 can compute i, j from n = e(i, j) in linear time (with auxiliary tapes), (b) e(i, j) \u2265 (i \u00b7 ji + i)2, and (c) for every fixed i, the function j 7\u2192 e(i, j) can be computed in PTIME. We first prove the lemma, assuming that e satisfies these three properties.\nThe counting machine U1 starts by computing a binary representation of its unary input n on its work tape: this step takes linear time in n. Next, it extracts i, j in linear time in n (by property (a)), then it simulates Mi on input j. The runtime of the last step is \u2264 (i \u00b7 ji + i)2 \u2264 e(i, j) (by property (b)), hence U1 runs in linear time in the input n = e(i, j). It remains to prove that the function f computed by U1 is #P1hard. Consider any function g in #P1: we will describe a polynomial-time, deterministic Turing machine Tdet with an oracle for f that computes g. Since g is in #P1 there exists i such that g is computed by Mi. On input j, Tdet computes n = e(i, j) in PTIME (by property (c)), stores it on the oracle tape, then invokes U1 and obtains the result g(j) = f(n).\nIt remains to describe the encoding function e. We take e(i, j) = 2i34i\u00b7dlog3 je(6j + 1). To prove (a), note that i is obtained by counting the trailing zeroes in the binary representation of n, j is obtained by first computing a ternary representation of 34i\u00b7dlog3 je(6j+1), ignoring trailing zeros and deriving j from 6j + 1. (b) 2i34i\u00b7dlog3 je(6j+ 1) \u2265 (i \u00b7 ji + i)2 follows through direct\ncalculations, using the fact that 34i\u00b7dlog3 je \u2265 j4i. (c) is straightforward.\nProof of Lemma 3.9. We describe here the most important steps of the proof, and delegate the details to Appendix B. We will consider only the case k = 1, i.e. the counting TM runs in linear time: the case when k > 1 is handled using a standard technique that encodes nk time stamps using a relation of arity k. We briefly review Trakhtenbrot\u2019s proof from Libkin [28, p. 167]: for every deterministic TM, there is a procedure that generates a formula \u03981 such that TM has an accepting computation starting with an empty input tape iff \u03981 is satisfiable. The signature for \u03981 is (this is a minor variation over Libkin\u2019s):\n\u03c3 ={<,Min, T0, T1, H, (Sq)q\u2208States(T )} Then \u03981 states that (1) x < y is a total order on the domain and Min(x) is its minimum element, (2) T0(t, p) (or T1(t, p)) is true iff at time t the tape has a 0 (or a 1) on position p, (3) H(t, p) is true iff at time t the head is on position p, and Sq(t) is true iff at time t the machine is in state q. Libkin [28] describes the sentence \u03981 that states that all these constraints are satisfied.\nWe adapt this to a more general construction that is sufficient to prove Lemma 3.9. We address five changes: (1) Our TM is non-deterministic, (2) has k tapes instead of 1, (3) its runtime is c \u00b7n instead of n, for some c > 1, (4) the input tape initially contains n symbols 1, and (5) \u03981 needs to be in FO\n3. Support for non-deterministic transitions requires only a slight modification to the sentences. It is also easy to represent multiple tapes, by using k different relations T0\u03c4i , T1\u03c4i , and similarly k head relations H\u03c4i , for i = 1, k. To encode transitions in FO3, we will assume that the multi-tape TM always reads or writes only one tape at each time. This is without loss of generality: a state that reads and writes all tapes can be converted into a sequence of 2k states that first read one by one each tape and \u201cremember\u201d their symbols, then write one by one each tape and move their heads.\nNext, we show how to encode running times (and space) up to c \u00b7 n for some integer constant c > 1, with only a domain of size n available. The standard way is to increase the arity of the relations, e.g. with arity a we can represent na time steps, but this is not possible within FO3. Instead, we partition the computation into c epochs, each having exactly n time steps, and similarly we partition the tapes into c regions, each with n cells. We denote T0\u03c4er(t, p), T1\u03c4er(t, p) the relations T0, T1 specialized to tape \u03c4 , epoch e, and region r, and similarly define H\u03c4er and Sqe. Furthermore, we modify the sentences that encode the TM transition relation to move the heads across epochs and regions, using only 3 variables. The fourth item is easy: we write a formula stating that initially (at time 1 of epoch 1), region 1 of (input) tape \u03c41 is full of 1\u2019s, and all other regions and tapes are full of 0\u2019s. Moreover, Appendix B shows that \u03981 can be written in FO\n3. Finally, FOMC(\u03981, n) is precisely the number of accepting computations of the TM on input n, times n!, coming from the n! ways of ordering the domain.\nProof of Theorem 3.6. We show how to compute Pr(Q) rather than WFOMC(Q,n): we have seen in Sec. 2 that these two are equivalent. We actually prove the theorem for a more general form of query, where each variable xi range over a domain of size ni, thus, Q = \u2203x1 \u2208 [n1], . . . ,\u2203xm \u2208 [nm]\u03d5, where \u03d5 is quantifier-free. The probability of a query under the standard semantics (when all variables range over the same domain [n]) is obtained by simply setting n1 = \u00b7 \u00b7 \u00b7 = nm = n.\nTo prove the theorem, we use an equivalent definition of \u03b3-acyclicity given by Fagin [14], which we give here together with our algorithm for computing Pr(Q). The graph is \u03b3-acyclic if it can be reduced to an empty graph by applying the following rules, in any order.\n(a) If a node x is isolated (i.e., it belongs to precisely one edge, say R(x, y, z)), then delete x. In this case we replace the relation R(x, y, z) by a new relation R\u2032(y, z), where each tuple has probability 1\u2212 (1\u2212 p)nx , where p is the probability of tuples in R.\n(b) If an edge R(x) is a singleton (i.e., if it contains exactly one node), then delete that edge (but do not delete the node from other edges that might contain it). Here, we condition on the size k = |R|. For each k, let pk be the probability of the residual query obtained by removing R(x) and restricting the range of x to [k]. By symmetry, this probability depends only on k = |R|, and does not depend on the choice of the k elements in the domain. Then Pr(Q) = \u2211 k ( nx k ) pkR(1 \u2212 pR)nx\u2212kpk, where pR de-\nnotes the probability of a tuple Pr(R(i)), and is the same for all constants i (by symmetry).\n(c) If an edge is empty, R(), then delete it. We multiply the probability of the residual query by pR.\n(d) If two edges (say R(x, y, z), S(x, y, z)) contain precisely the same nodes, then delete one of these edges. Here we replace the two atoms by a new atom R\u2032(x, y, z) whose probability is pR \u00b7 pS .\n(e) If two nodes x, y are edge-equivalent, then delete one of them from every edge that contains it. (Recall that two nodes are edge-equivalent if they are in precisely the same edges.) Here we replace the two variables x, y by a new variable z, whose range\nhas size nz def = nx \u00b7 ny.\nEach operation above is in polynomial time in the size of the binary representation of the inputs, and there are only polynomially many operations. Therefore the entire computation is in polynomial time, because each intermediate result can be represented using polynomially many bits. This follows from the fact that the number of models is 2O(n\na), where a is the maximum arity of any relation in Q, hence the number of models can be represented using O(na) = nO(1) bits.\nExample 3.10. Consider the following linear chain query:\nQ =\u2203x0\u2203x1 \u00b7 \u00b7 \u00b7 \u2203xmR1(x0, x1) \u2227 \u00b7 \u00b7 \u00b7Rm(xm\u22121, xm) where the probabilities of the m relations are p1, . . . , pm. Denote Pn0,...,nm the probability of Q when the domains of x0, x1, . . . , xm are sets of sizes n0, n1, . . . , nm (thus,\ninitially n0 = n1 = \u00b7 \u00b7 \u00b7 = nm = n). Then the variable xm is isolated (item a), hence we can eliminate it and update the probability of Rm to 1\u2212(1\u2212pm)nm . Now Rm is a singleton relation, hence we can remove it (item b), and restrict the domain of xm\u22121 to have size km\u22121, for km\u22121 = 1, nm\u22121. Therefore:\nPn0,...,nm\u22121,nm = \u2211\nkm\u22121=1,nm\u22121\nPn0,...,nm\u22122,km\u22121 \u00b7 ( nm km ) \u00b7 [1\u2212 (1\u2212 pm)km ]km\u22121 \u00b7 [(1\u2212 pm)km ]nm\u22121\u2212km\u22121\nRepeating this process we arrive at an expression that is computable in polynomial time in n (for a fixed m). Notice that this formula does not appear to be computable in polynomial time in both n and m. We leave open the combined complexity of acyclic queries.\nProof of Theorem 3.7. First note that, by using resolution, the query implies the following statement, for every k \u2265 2:\n\u2200x1, y1, . . . , xk, yk(S(x1, y1) \u2228 \u00acS(x2, y1) \u2228S(x2, y2) \u2228 \u00acS(x2, y3) \u2228 . . . \u2228 \u00acS(x1, yk)) (5)\nFor any two numbers n1, n2, denote Qn1n2 = \u2200x1 \u2208 [n1],\u2200x2 \u2208 [n1],\u2200y1 \u2208 [n2],\u2200y2 \u2208 [n2], (S(x1, y1) \u2228 \u00acS(x2, y1) \u2228 S(x2, y2) \u2228 \u00acS(x1, y2)), in other words we restrict the range of the variables to some domains [n1], [n2]. These domains are not required to be disjoint, instead we use the standard assumption n1 \u2264 n2 implies [n1] \u2286 [n2]. When n1 = n2 = n then Qn1n2 is equivalent to QS4. We claim the following. If D is a model of Qn1n2 , then either property Pa or Pb holds in D:\nPa \u2261\u2203x \u2208 [n1],\u2200y \u2208 [n2], S(x, y) Pb \u2261\u2203y \u2208 [n2],\u2200x \u2208 [n1],\u00acS(x, y)\nSuppose not. Consider any model of Qn1n2 that does not satisfy Pa, Pb. Pick any element x1 \u2208 [n1]. As Pa does not hold, \u2203y1 \u2208 [n2]\u00acS(x1, y1). As Pb does not hold, \u2203x2 \u2208 [n1], S(x2, y1). Continuing, \u2203y2 \u2208 [n2], \u00acS(x2, y2), \u2203x3 \u2208 [n1], S(x3, y2) and \u2203y3 \u2208 [n2], \u00acS(x3, y3). Continuing, we obtain an arbitrarily long sequence of values x1, y1, x2, . . . such that: \u00acS(x1, y1), S(x2, y1), \u00acS(x2, y2), . . . , S(xn1 , yn1\u22121), \u00acS(xn1 , yn1). Note that we can never have xi = xj or yi = yj , for i 6= j, because that would violate Eq.(5) for k = j \u2212 i. Since the domain is finite, this is a contradiction.\nTherefore, either Pa or Pb holds. Clearly, both statements cannot hold, as they are exclusive events. Denote f and g the weighted model count for Qn1n2 in these two cases:\nf(n1, n2) = WFOMC(Qn1n2 \u2227 Pa, n, w, w\u0304) g(n1, n2) = WFOMC(Qn1n2 \u2227 Pb, n, w, w\u0304)\nThen we have WFOMC(Qn1n2 , n, w, w\u0304) = f(n1, n2) + g(n1, n2). It remains to show how to compute f, g.\nConsider a model that satisfies Pa, hence the set X = {x | \u2200y \u2208 [n2], S(x, y)} is non-empty, hence k = |X| \u2265 1.\nRemove the elements X from the domain [n1] (and rename the elements such that [n1]\u2212X = [n1 \u2212 k]) and call D\u2032 the resulting substructure. Then D\u2032 still satisfies the query Q(n1\u2212k),n2 , and, by the removal of all elements X, cannot satisfy Pa, hence it must satisfy Pb. This justifies the following recurrence, completing the proof of Theorem 3.7:\nf(n1, 0) = 1 f(n1, n2) = n1\u2211 k=1 ( n1 k ) wkn2g(n1 \u2212 k, n2)\ng(0, n2) = 1 g(n1, n2) = n2\u2211 `=1 ( n2 ` ) w\u0304n1`f(n1, n2 \u2212 `)"}, {"heading": "4. COMBINED COMPLEXITY", "text": "In the combined complexity we consider a fixed vocabulary \u03c3 = (R1, . . . , Rm), and assume that both \u03a6 and n are given as part of the input. As before, n is given in unary (tally) notation. We consider both the FOMC problem, \u201ccompute FOMC(\u03a6, n)\u201d, and the associated decision problem \u201cis n \u2208 Spec(\u03a6)?\u201d. Our upper bound for FOMC also holds for WFOMC. Recall that the spectrum Spec(\u03a6) of a formula \u03a6 is the set of numbers n for which \u03a6 has a model over a domain of size n.\nVardi [40] proved that the model checking problem, \u201cgiven \u03a6 and a structure D, is \u03a6 true in D?\u201d is PSPACE-complete. This implies that the above decision problem is also in PSPACE: to check n \u2208 Spec(\u03a6) enumerate over all structures D of a domain of size n, and check if \u03a6 is true in D. By the same argument, FOMC is also in PSPACE. We prove:\nTheorem 4.1. (1) For every k \u2265 2, the combined complexity for FOMC for FOk is #P-complete. (2) The combined complexity for the decision problem n \u2208 Spec(\u03a6) is NP-complete for FO2, and is PSPACEcomplete for FO.\nThe #P-membership in (1) also holds for the WFOMC problem. Recall that the vocabulary \u03c3 is fixed. If \u03c3 were allowed to be part of the input, then the lower bound in (1) follows immediately from the #P-hardness result for #SAT, because any Boolean formula is trivially encoded as an FO0 formula, by introducing a new, zero-ary relational symbol for every Boolean variable.\nProof of Theorem 4.1. We start by proving item (1) of Theorem 4.1. To prove membership in #P, it suffices to show that the lineage of a sentence \u03d5 of size s over a domain of size n is polynomial in s and n, then use the fact that WMC for Boolean functions is in #P. However, FOk formulas have, in general, exponentially large lineage, e.g. the formula checking for the existence of a path of length n, \u2203x\u2203y(R(x, y) \u2227 \u2203x(R(y, x) \u2227 \u2203y(R(y, x) \u2227 . . .))), over a domain of size n has lineage of size \u2126(nn). Instead, we first transform the formula by removing all nested variables. For that, we apply Scott\u2019s reduction, which we give below, following the presentation by Gra\u0308del, Kolaitis, and Vardi [17, Prop.3.1]; while Scott\u2019s reduction was described for FO2, it carries over unchanged to FOk. More precisely, the reduction converts a sentence \u03d5 of size s into a new sentence \u03d5\u2217 over an extended vocabulary, satisfying the following properties:\n1. The finite models of \u03d5 and \u03d5\u2217 are in one-toone correspondence, and the corresponding models have the same weight.\n2. \u03d5\u2217 has size O(s).\n3. \u03d5\u2217 is a conjunction of sentences in prenex normal form, i.e. Q1x1Q2x2 \u00b7 \u00b7 \u00b7Qkxk\u03c8 where each Qi is either \u2200 or \u2203, and \u03c8 is quantifier-free.\nThe new formula has a lineage of size O(nks), because its quantifier depth is bounded by k = O(1), which implies WFOMC is in #P. It remains to describe Scott\u2019s reduction, which we review here briefly, for completeness. Introduce a new relational symbol S\u03c8 for every subformula \u03c8 of \u03d5, where the arity of S\u03c8 equals the number of free variables in \u03c8, and define the sentence \u03b8\u03c8 \u2261 \u2200x1 \u00b7 \u00b7 \u00b7 \u2200x`(S\u03c8(x1, . . . , x`) \u21d4 \u03b8\u2032\u03c8), where \u03b8\u2032\u03c8 depends on the structure of \u03c8 as follows: if \u03c8 is an atomic formula, then \u03b8\u2032\u03c8 = \u03c8, if \u03c8 = \u03c81 \u2227 \u03c82 then \u03b8\u2032\u03c8 = S\u03c81 \u2227 S\u03c82 , if \u03c8 = \u00ac\u03c81 then \u03b8\u2032\u03c8 = \u00acS\u03c81 and if \u03c8 = \u2200x\u03c81 then \u03b8\u2032\u03c8 = \u2200xS\u03c81 . The new formula \u03d5\u2217 is defined as S\u03d5 \u2227 \u2227 \u03c8 \u03b8\u03c8. By setting w(S\u03c8) = w\u0304(S\u03c8) = 1 for all new symbols, we ensure that the models of \u03d5 and \u03d5\u2217 are not just in one-to-one correspondence; they have the same weights.\nNext we prove #P-hardness for FO2 (this implies hardness for FOk for every k \u2265 2). We use reduction from #SAT: given a Boolean formula F over n variables X1, . . . , Xn, compute #F . This problem is #P-hard [33].\nDefine the vocabulary \u03c3 consisting of 3 unary symbols A,B,C, and 2 binary symbols R,S. Given a Boolean formula F , we construct an FO2 sentence \u03d5F such that, over a domain of size n + 1, the number of models of \u03d5F is FOMC(\u03d5F , n+ 1) = (n+ 1)! \u00b7#F . The sentence \u03d5F enforces a particular graph structure, as illustrated in Figure 2, by asserting the following:\n\u2022 There exists three unique, distinct elements x, y, z such that A(x), B(y), C(z) are true: \u2203xA(x) \u2227 \u2200x, \u2200y(A(x) \u2227 A(y)) \u21d2 x = y, and similarly for B and C; \u00ac\u2203x(A(x)\u2227B(x)) and similarly for A,C, and B,C. \u2022 There exist n elements x1, . . . , xn such that the\nfollowing holds: A(x1), R(x1, x2), R(x2, x3), . . . , R(xn\u22121, xn), B(xn). This is expressible in FO2, by reusing variables.\n\u2022 For every number m \u2208 [2n]\u2212{n}, it is not the case that there exists m elements x1, . . . , xm such that: A(x1), R(x1, x2), R(x2, x3), . . . , R(xm\u22121, xm), B(xm).\n\u2022 For all x, y, if R(x, y) then neither C(x) nor C(y). \u2022 For all x, y, if S(x, y) then C(x). \u2022 Finally, \u03d5F contains a statement obtained from F\nby replacing each Boolean variable Xi by the sentence \u03b3i def = \u2203x, \u2203z(S(z, x) \u2227 \u03b1i(x)), where \u03b1i(x) is the following formula with free variable x: there exists a path A(x1), R(x1, x2), . . . , R(xi\u22121, x) (if i = 1 then \u03b11(x) \u2261 A(x)).\nThe reader may check that, for any database instance D over a domain of size n+1 that satisfies \u03d5F there exists a unique permutation c0, c1, . . . , cn over its domain such that the relations A,B,C and R contain precisely the following tuples: C(c0), A(c1), B(cn), R(c1, c2), . . . , R(cn\u22121, cn). Indeed, if it contained some R(ci, cj) with j 6= i + 1, then c1, . . . , ci, cj , cj+1, . . . , cn forms a path from A to B of some length m \u2264 2n and m 6= n, which contradicts the sentence \u03d5F ; notice also that \u03b1i(x) is true iff x = ci. Therefore the only relation that is left unspecified in D is S, which may contain an arbitrary number of tuples of the form S(c0, ci). These tuples are in one-to-one correspondence with the Boolean variables Xi, proving our claim.\nNow we prove item (2) of Theorem 4.1. The claim for FO2 follows immediately from the proof above. It remains to prove that the combined complexity for FO is PSPACE, for which we use a reduction from the Quantified Boolean Formula (QBF) problem, which is known to be PSPACE complete. A Quantified Boolean Formula is a formula of the form Q1X1Q2X2 . . . QnXnF where each Qi is a quantifier \u2200 or \u2203, and F is a Boolean formula over the variablesX1, . . . , Xn. We make the following change to the construction above. Recall that a Boolean variable Xi in F was represented by S(c0, ci). Now we extend S to a ternary relation S(x, y, u), restrict u to two constants (we choose c1 and cn arbitrarily) and represent Xi by S(c0, ci, c1) and \u00acXi by S(c0, ci, cn). Then, we replace the quantifiers \u2200Xi or \u2203Xi with \u2200u or \u2203u. More precisely, the new formula \u03d5F contains the following statements:\n\u2022 If S(x, y, u) is true, then u is either the distinguished A or the distinguished B element: \u2200x, y, u(S(x, y, u)\u21d2 A(u) \u2228B(u)). \u2022 If u, v are the distinguished A and B el-\nements, then S(x, y, u) is the negation of S(x, y, v): \u2200u, v, x, y(A(u) \u2227 B(v) \u21d2 (S(x, y, u) xor S(x, y, v))).\nFinally, we rewrite a QBF \u2200Xi(. . .) into \u2200u(A(u) \u2228 B(u) \u21d2 . . .) and a QBF \u2203Xi(. . .) into \u2203u((A(u) \u2228 B(u)) \u2227 . . .). We omit the straightforward details."}, {"heading": "5. CONCLUSIONS", "text": "In this paper we discuss the symmetric Weighted FO Model Counting Problem. Our motivation comes from probabilistic inference in Markov Logic Networks, with applications to modern, large knowledge bases, but the problem is also of independent theoretical interest. We studied both the data complexity, and the combined complexity. For the data complexity we established for the first time the existence of an FO sentence for which the Symmetric Model Counting problem is #P1hard, and also the existence of a Conjunctive Query for which the Symmetric Weighted Model Counting problem is #P1-hard. We also showed that for all \u03b3-acyclic conjunctive queries WFOMC can be computed in polynomial time. For the combined complexity, we proved a tight bound of #P-completeness for FO2. We also discussed the associate decisions problem.\nWe end this paper with a list of open problems, listed in Table 2: for each query in the table, the complexity of the FOMC or the WFOMC problem is open.\nAcknowledgments. We thank Ronald Fagin, Phokion Kolaitis and Lidia Tendera for discussions on topics related to this paper. This work was partially supported by NSF IIS-1115188, IIS-0911036, CCF-1217099, and the Research Foundation-Flanders (FWO-Vlaanderen)."}, {"heading": "6. REFERENCES", "text": "[1] Alberto Bertoni and Massimiliano Goldwurm. On\nranking 1-way finitely ambiguous NL languages and #P1-complete census functions. ITA, 27(2):135\u2013148, 1993.\n[2] Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam R. Hruschka Jr., and Tom M. Mitchell. Toward an architecture for never-ending language learning. In AAAI, 2010.\n[3] Kevin J. Compton. The computational complexity of asymptotic problems i: Partial orders. Inf. Comput., 78(2):108\u2013123, 1988.\n[4] Nilesh N. Dalvi and Dan Suciu. Efficient query evaluation on probabilistic databases. VLDB J., 16(4):523\u2013544, 2007.\n[5] Nilesh N. Dalvi and Dan Suciu. The dichotomy of probabilistic inference for unions of conjunctive queries. J. ACM, 59(6):30, 2012.\n[6] http://deepdive.stanford.edu/. [7] Pedro Domingos and Daniel Lowd. Markov Logic:\nAn Interface Layer for Artificial Intelligence. Morgan & Claypool Publishers, 2009.\n[8] X. Dong, E. Gabrilovich, G. Heitz, W. Horn, N. Lao, K. Murphy, T. Strohmann, S. Sun, and W. Zhang. Knowledge vault: A web-scale approach to probabilistic knowledge fusion. In KDD, 2014.\n[9] Arnaud Durand, Neil D. Jones, Johann A. Makowsky, and Malika More. Fifty years of the spectrum problem: survey and new results. Bulletin of Symbolic Logic, 18(4):505\u2013553, 2012.\n[10] David Duris. Some characterizations of \u03b3 and \u03b2-acyclicity of hypergraphs. Information Processing Letters, 112(16):617\u2013620, 2012.\n[11] Anthony Fader, Stephen Soderland, and Oren Etzioni. Identifying relations for open information extraction. In EMNLP, pages 1535\u20131545, 2011.\n[12] Ronald Fagin. Generalized first-order spectra and polynomial-time recognizable sets. In SIAM-AMS Proceedings 7, pages 43\u201373, 1974.\n[13] Ronald Fagin. Probabilities on finite models. J. Symb. Log., 41(1):50\u201358, 1976.\n[14] Ronald Fagin. Degrees of acyclicity for hypergraphs and relational database schemes. J. ACM, 30(3):514\u2013550, 1983.\n[15] Vibhav Gogate and Pedro Domingos. Probabilistic theorem proving. In UAI, pages 256\u2013265, 2011.\n[16] Carla P Gomes, Joerg Hoffmann, Ashish Sabharwal, and Bart Selman. From sampling to model counting. In IJCAI, pages 2293\u20132299, 2007.\n[17] Erich Gra\u0308del, Phokion G. Kolaitis, and Moshe Y. Vardi. On the decision problem for two-variable first-order logic. Bulletin of Symbolic Logic, 3(1):53\u201369, 1997.\n[18] Eric Gribkoff, Guy Van den Broeck, and Dan Suciu. Understanding the complexity of lifted inference and asymmetric weighted model counting. In UAI, pages 280\u2013289, 2014.\n[19] Johannes Hoffart, Fabian M. Suchanek, Klaus Berberich, and Gerhard Weikum. Yago2: A spatially and temporally enhanced knowledge base from wikipedia. AIJ, 194:28\u201361, 2013.\n[20] Manfred Jaeger. Lower complexity bounds for lifted inference. TPLP, 2012.\n[21] Manfred Jaeger and Guy Van den Broeck. Liftability of probabilistic inference: Upper and lower bounds. In StarAI, 2012.\n[22] Abhay Kumar Jha and Dan Suciu. Probabilistic databases with MarkoViews. VLDB, 5(11):1160\u20131171, 2012.\n[23] Neil Jones and Alan Selman. Turing machines and the spectra of first-order formulas with equality. In STOC, pages 157\u2013167, 1972.\n[24] Kristian Kersting, Babak Ahmadi, and Sriraam Natarajan. Counting belief propagation. In UAI, pages 277\u2013284, 2009.\n[25] Angelika Kimmig, Guy Van den Broeck, and Luc De Raedt. Algebraic model counting. arXiv preprint arXiv:1211.4475, 2012.\n[26] S. Kok, P. Singla, M. Richardson, and P. Domingos. The alchemy system for statistical relational AI, 2005.\n[27] Phokion G. Kolaitis and Moshe Y. Vardi. 0-1 laws for fragments of existential second-order logic: A survey. In MFCS, pages 84\u201398, 2000.\n[28] Leonid Libkin. Elements of Finite Model Theory. Springer, 2004.\n[29] Mathias Niepert. Symmetry-aware marginal density estimation. In AAAI, 2013.\n[30] Feng Niu, Christopher Re\u0301, AnHai Doan, and Jude W. Shavlik. Tuffy: Scaling up statistical inference in Markov logic networks using an RDBMS. VLDB, 4(6):373\u2013384, 2011.\n[31] Hoifung Poon and Pedro Domingos. Sound and efficient inference with probabilistic and deterministic dependencies. In AAAI, pages 458\u2013463, 2006.\n[32] Dan Suciu, Dan Olteanu, Christopher Re\u0301, and Christoph Koch. Probabilistic Databases. Morgan & Claypool Publishers, 2011.\n[33] Leslie G. Valiant. The complexity of computing the permanent. Theor. Comput. Sci., 8:189\u2013201, 1979.\n[34] Leslie G. Valiant. The complexity of enumeration and reliability problems. SIAM J. Comput., 1979.\n[35] Guy Van den Broeck. On the completeness of first-order knowledge compilation for lifted probabilistic inference. In NIPS, pages 1386\u20131394, 2011.\n[36] Guy Van den Broeck and Adnan Darwiche. On the complexity and approximation of binary evidence in lifted inference. In NIPS, 2013.\n[37] Guy Van den Broeck, Wannes Meert, and Adnan Darwiche. Skolemization for weighted first-order model counting. In KR, 2014.\n[38] Guy Van den Broeck, Wannes Meert, and Jesse Davis. Lifted generative parameter learning. In StaRAI, 2013.\n[39] Guy Van den Broeck, Nima Taghipour, Wannes Meert, Jesse Davis, and Luc De Raedt. Lifted probabilistic inference by first-order knowledge compilation. In IJCAI, pages 2178\u20132185. AAAI Press, 2011.\n[40] Moshe Y. Vardi. The complexity of relational query languages (extended abstract). In STOC, pages 137\u2013146, 1982.\n[41] Deepak Venugopal and Vibhav Gogate. Scaling-up importance sampling for markov logic networks. In NIPS, 2014.\n[42] Wei Wei, Jordan Erenrich, and Bart Selman. Towards efficient sampling: Exploiting random walk strategies. In AAAI, pages 670\u2013676, 2004.\n[43] Wentao Wu, Hongsong Li, Haixun Wang, and Kenny Qili Zhu. Probase: a probabilistic taxonomy for text understanding. In SIGMOD, pages 481\u2013492, 2012.\n[44] Ce Zhang and Christopher Re\u0301. Towards high-throughput gibbs sampling at scale: a study across storage managers. In SIGMOD, pages 397\u2013408, 2013."}, {"heading": "APPENDIX", "text": ""}, {"heading": "A. THE THREE LEMMAS", "text": ""}, {"heading": "A.1 Proof of Lemma 3.3: Removing Exists", "text": "Following the proof of [37], we show how to eliminate existential quantifiers from a WFOMC problem (a form of Skolemization). Assume that \u03a6 is in prenex normal form: \u03a6 = Q1x1Q2x2 . . . Qkxk\u03a8, where each Qi is either \u2200 or \u2203, and \u03a8 is quantifier-free. Let i be the first position of an \u2203, and denote \u03d5(x, xi) = Qi+1xi+1 . . . Qkxk\u03a8; note that \u03d5 is a formula with free variables x = (x1, . . . , xi\u22121). We have:\n\u03a6 =\u2200x\u2203xi\u03d5(x, xi) Let A be a fresh relational symbol of arity i. The new formula \u03a6\u2032 is:\n\u03a6\u2032 =\u2200x((\u2203xi\u03d5(x, xi))\u21d2 A(x)) (6) Let w\u2032, w\u0304\u2032 denote the weights of \u03a6\u2019s vocabulary ex-\ntended with w(A) = 1 and w\u0304(A) = \u22121. We claim that WFOMC(\u03a6, n, w, w\u0304) = WFOMC(\u03a6\u2032, n, w\u2032, w\u0304\u2032). Consider a possible world D \u2286 Tup(n) that satisfies \u03a6\u2032. Call D \u201cgood\u201d if it also satisfies \u03a6. In a good world D, for any constants x = a, the sentence \u2203xi\u03d5(a, xi) is true, hence A(a) is also true (because \u03a6\u2032 is true), and therefore the weight of D is the same as the weight of D \u2212 {A}, the world obtained from D by removing all tuples referring to the relational symbol A: W (D,w\u2032, w\u0304\u2032) = W (D\u2212{A}, w, w\u0304). Thus, the sum of the weights of the good worlds (see Eq.(3)) is precisely WFOMC(\u03a6, n, w, w\u0304). We prove that the sum of the weights of the bad worlds is zero. Let D be a bad world: it satisfies \u03a6\u2032 but not \u03a6. Thus, there exists some constants a s.t. the sentence \u2203xi\u03d5(a, xi) is false; choose a to be the first such constants, in some lexicographic order. Let D\u2032 be the world obtained from D by flipping the status of A(a): thus D,D\u2032 are identical, but one sets A(a) to true and the other to false. Both satisfy \u03a6\u2032, and W (D,w\u2032, w\u0304\u2032) = \u2212W (D\u2032, w\u2032, w\u0304\u2032), therefore they cancel out in the sum of Eq.(3). This proves that WFOMC(\u03a6, n, w, w\u0304) = WFOMC(\u03a6\u2032, n, w\u2032, w\u0304\u2032).\nWe note that \u03a6\u2032 can be written equivalently as:\n\u03a6\u2032 =\u2200x\u2200xi(\u00ac\u03d5(x, xi) \u2228A(x)) In other words, we have replaced the first existential quantifier in \u03a6 by a universal quantifier (and may have increased the number of \u2203 on positions i+ 1, i+ 2, . . .). Lemma 3.3 follows by applying this procedure inductively."}, {"heading": "A.2 Proof of Lemma 3.4: Removing Negation", "text": "Let \u00ac\u03c8(x) be a negated subformula of \u03a6, with k free variables x. Let A, B be two new relational symbols of arity k. Let \u03a6p denote the sentence obtained from \u03a6 by replacing the subformula \u00ac\u03c8(x) with A(x). Denote: \u2206 =\u2200x[(\u03c8(x) \u2228A(x)) \u2227 (A(x) \u2228B(x)) \u2227 (\u03c8(x) \u2228B(x))]\n(7)\nExtend the weight functions w, w\u0304 to w\u2032, w\u0304\u2032 by setting w(A) = w\u0304(A) = w(B) = 1, w\u0304(B) = \u22121. Define \u03a6\u2032 = \u03a6p \u2227 \u2206. We claim that WFOMC(\u03a6, n, w, w\u0304) = WFOMC(\u03a6\u2032, n, w\u2032, w\u0304\u2032). To prove this, consider a world\nD \u2286 Tup(n) over the vocabulary of \u03a6\u2032, and assume that D satisfies \u03a6\u2032. Call D \u201cgood\u201d, if the statement \u2200x(\u03c8(x) xor A(x)) holds. It is easy to see that in any good world, \u2200xB(x) holds too, hence the good world has the same weight as the world obtained by stripping it of the additional relations A,B, and, furthermore, their contributions to WFOMC(\u03a6\u2032, n, w\u2032, w\u0304\u2032) is precisely WFOMC(\u03a6, n, w, w\u0304). Consider a bad world: it satisfies \u03a6\u2032, but there exists a such both \u03c8(a) and A(a) are true. In that case B(a) can be set arbitrarily to true or false and still satisfy the formula \u03a6\u2032, hence the contributions of these two pairing worlds cancel out. This proves that WFOMC(\u03a6, n, w, w\u0304) = WFOMC(\u03a6\u2032, n, w\u2032, w\u0304\u2032).\nLemma 3.4 follows by apply this process repeatedly."}, {"heading": "A.3 Proof of Lemma 3.5: Removing Equality", "text": "Let E(x, y) be a new predicate symbol, with weights w(E) = z and w\u0304(E) = 1, where z is a real value to be determined below. Define \u03a6E to be obtained from \u03a6 by replacing every equality predicate x = y with E(x, y), and define:\n\u03a6\u2032 =\u03a6E \u2227 \u2200xE(x, x) Consider the count f(z) = WFOMC(\u03a6\u2032, n, w\u2032, w\u0304\u2032) as a function of z, where w\u2032, w\u0304\u2032 extend w, w\u0304 with w(E) = z, w\u0304(E) = 1. This is a polynomial of degree n2 in z. Since \u03a6\u2032 asserts \u2200xE(x, x), all monomials in f have a degree \u2265 n. Let c \u00b7zn be the monomial of degree n. Then we claim that its coefficient c = WFOMC(\u03a6, n, w, w\u0304). Indeed, every world D where E has exactly n tuples is a world where E is interpreted as the equality predicate. We can compute c using n + 1 calls to an oracle for f(z) as follows. Fix \u03b4 > 0, and denote \u22060f = f , \u2206k+1f(z) = (\u2206kf)(z + \u03b4)\u2212 (\u2206kf)(z). Then \u2206nf(0) = c\u00b7n! = ( n 0 ) f(0)\u2212 ( n 1 ) f(\u03b4)+ ( n 2 ) f(2\u03b4)\u2212\u00b7 \u00b7 \u00b7 (\u22121)n ( n n ) f(n\u03b4).\nB. A #P1-HARD SENTENCE \u03981 We prove here Lemma 3.9: shows how to reduce a linear-time, multi-tape counting TM with a unary input alphabet (such as the #P1-complete TM) to the FOMC problem on a first-order sentence. The sentence that encodes the #P1-complete TM is referred to as \u03981. This proof is based on the standard encoding of a deterministic Turing machine into first-order logic, as used to prove Trakhtenbrot\u2019s theorem [28, p. 167]. We extend this construction in several ways: (1) towards non-deterministic counting Turing machines, (2) with multiple tapes, (3) with a run time of c \u00b7 n for some fixed c, instead of n, (4) to have n symbols 1 on the input tape, followed by symbols 0, and finally (5) to obtain a sentence in FO3.\nAs discussed in Section 3.3, we need to encode run times and space with lengths up to c \u00b7 n, yet we only have a domain size of exactly n available. This is solved by partitioning the run time into c epochs of n steps, and the space into c regions of n cells. Moreover, we assume w.l.o.g. that there are two symbols: {0, 1}."}, {"heading": "B.1 Signature", "text": "The signature of \u03981 consists of the following predicates P/a, where a is the arity of P :\n\u2022 </2, denoting a strict linear order on the domain,\n\u2022 Succ/2, denoting the successor relation w.r.t. the order on the domain,\n\u2022 Min/1 and Max/1, denoting the smallest and largest domain element\n\u2022 state predicates Sqe/1, where Sqe(t) is true precisely when the machine is in state q at time t in epoch e,\n\u2022 head predicates H\u03c4er/2, where H\u03c4er(t, p) is true precisely when at time t in epoch e, the head for tape \u03c4 is at position p in region r, and\n\u2022 tape predicates Ts\u03c4er/2, where Ts\u03c4er(t, p) is true precisely when at time t in epoch e, tape \u03c4 contains symbol s \u2208 {0, 1} at position p in region r, \u2022 movement predicates Left\u03c4er/2 and Right\u03c4er/2, where\nLeft\u03c4er(t, p) is true precisely when the head on tape \u03c4 at time t in epoch e is to the left of p in region r (or when p, r is the first cell on its tape and the head is there), and Right is defined similarly, and\n\u2022 frame predicate Unchanged\u03c4er/2, where we have that Unchanged\u03c4er(t, p) is true precisely when position p in region r of tape \u03c4 did not change going from time t in epoch e to the next time step."}, {"heading": "B.2 Sentences", "text": "To encode the Turing machine, we let \u03981 consist of the following sentences.\n1. < is an arbitrary strict linear order (total, antisymmetric, irreflexive, and transitive):\n\u2200x, \u2200y, \u00ac(x = y)\u21d2 (x < y) \u2228 (y < x) \u2200x, \u2200y, \u00ac(x < y) \u2228 \u00ac(y < x)\n\u2200x, \u2200y,\u2200z, (x < y) \u2227 (y < z)\u21d2 (x < z) 2. Min is the smallest element, and Max is the largest\nelement:\n\u2200x, Min(x)\u21d4 \u00ac\u2203y, (y < x) \u2200x, Max (x)\u21d4 \u00ac\u2203y, (x < y)\n3. Succ is the successor relation:\n\u2200x,\u2200y, Succ(x, y)\u21d4 (x < y) \u2227 \u00ac\u2203z, (x < z) \u2227 (z < y) 4. At any time, the machine is in exactly one state:\u2227\nq,q\u2032,e:q 6=q\u2032 \u2200t, \u00acSqe(t) \u2228 \u00acSq\u2032e(t)\u2227\ne\n\u2200t, \u2228 q Sqe(t)\n5. At any time, the head is in exactly one position per tape:\n(a) The head is in at least one position:\u2227 \u03c4,e \u2200t,\u2203p, \u2228 r H\u03c4er(t, p)\n(b) The head is in at most one region:\u2227 \u03c4,e,r \u2200t, \u2200p, H\u03c4er(t, p)\u21d2 \u2227 r\u2032:r\u2032 6=r \u2200p\u2032,\u00acH\u03c4er\u2032(t, p\u2032)\n(c) The head is in at most one position per region:\u2227 \u03c4,e,r \u2200t, \u2200p, H\u03c4er(t, p)\n\u21d2 \u00ac\u2203p\u2032,\u00ac(p = p\u2032) \u2227H\u03c4er(t, p\u2032)\n6. At any time, each tape position has exactly one symbol:\u2227\n\u03c4,e,r\n\u2200t, \u2200p, T0\u03c4er(t, p)\u21d4 \u00acT1\u03c4er(t, p)\n7. In the initial configuration of the TM (first time step),\n(a) it is in state q1, and its heads are in the first position:\n\u2200x,Min(x)\u21d2 Sq1e1(x) \u2227 \u2227 \u03c4 H\u03c4e1r1(x, x)\n(b) the first (input) tape \u03c41 contains n symbols 1 in the first region, followed by symbol 0 in all other regions (starting with cell n+ 1), and all other tapes \u03c4i contain symbol 0:\n\u2200t,Min(t)\u21d2\u2200p, T1\u03c41e1r1(t, p) \u2227 \u2227 i:i>1 T0\u03c41e1ri(t, p)\n\u2227 \u2227\ni,r:i>1\nT0\u03c4ie1r(t, p)\n8. An encoding of the transition relation \u03b4. For example, that state qa operates on tape \u03c4a, and that \u03b4(qa, 0) = {(qb, 1, L), (qc, 0, R)} is encoded into the following sentences.\n(a) What changed when t is before the end of an epoch (i.e., has a successor in the epoch):\n\u2227 e,r \u2200t, t\u2032,\u2200p,  Sqae(t)\u2227H\u03c4aer(t, p)\u2227T0\u03c4aer(t, p) \u2227Succ(t, t\u2032) \u21d2 [\nSqbe(t \u2032)\n\u2227Left\u03c4aer(t\u2032, p)\u2227T1\u03c4aer(t\u2032, p)\n] \u2228 [\nSqce(t \u2032)\n\u2227Right\u03c4aer(t\u2032, p)\u2227T0\u03c4aer(t\u2032, p)\n]\n(b) What changed when t is at the end of an epoch:\n\u2227 i,r:1\u2264i<c \u2200t, t\u2032,\u2200p,\n Sqaei(t)\n\u2227H\u03c4aeir(t, p) \u2227T0\u03c4aeir(t, p) \u2227Max (t) \u2227Min(t\u2032) \u21d2 [\nSqbei+1(t \u2032)\n\u2227Left\u03c4aei+1r(t\u2032, p) \u2227T1\u03c4aei+1r(t\u2032, p)\n] \u2228 [\nSqcei+1(t \u2032)\n\u2227Right\u03c4aei+1r(t\u2032, p) \u2227T0\u03c4aei+1r(t\u2032, p)\n]\n(c) What does not change on the tapes: other cells in the region of \u03c4a where the head is, regions\nwith no head, and tapes other than \u03c4a.\u2227 e,r \u2200t,\u2200p, [ Sqae(t) \u2227H\u03c4aer(t, p) ] \u21d2 \u2200p\u2032, (p = p\u2032) \u2228Unchanged\u03c4aer(t, p\u2032)\u2227\n\u03c4,e,r\n\u2200t, \u2200p,H\u03c4er(t, p)\n\u21d2 \u2227\nr\u2032:r\u2032 6=r \u2200p,Unchanged\u03c4er\u2032(t, p)\u2227\ne\n\u2200t, Sqae(t) \u21d2 \u2227\n\u03c4,r:\u03c4 6=\u03c4a \u2200p,Unchanged\u03c4er(t, p)\n(d) The positions of the heads on tapes other than \u03c4a do not change:\n\u2227 \u03c4,e,r:\u03c4 6=\u03c4a\n\u2200t, t\u2032,\u2200p, [\nSqae(t) \u2227H\u03c4er(t, p) \u2227Succ(t, t\u2032) ] \u21d2 H\u03c4er(t\u2032, p)\n\u2227 \u03c4,i,r:\u03c4 6=\u03c4a,1\u2264i<c \u2200t, t\u2032,\u2200p,  Sqaei(t)\u2227H\u03c4eir(t, p)\u2227Max (t) \u2227Min(t\u2032)  \u21d2 H\u03c4ei+1r(t\u2032, p)\n9. The movement predicates are defined as\u2227 \u03c4,e,r \u2200t, \u2200p, p\u2032, [ Left\u03c4er(t, p) \u2227Succ(p\u2032, p) ] \u21d4 H\u03c4er(t, p\u2032)\n\u2227 \u03c4,e,i:1\u2264i<c\n\u2200t,\u2200p, p\u2032, [\nLeft\u03c4eri+1(t, p) \u2227Min(p) \u2227Max (p\u2032)\n] \u21d4 H\u03c4eri(t, p\u2032)\n\u2227 \u03c4,e \u2200t,\u2200p, [ Left\u03c4er1(t, p)\u2227Min(p) ] \u21d4 H\u03c4er1(t, p)\n\u2227 \u03c4,e,r \u2200t, \u2200p, p\u2032, [ Right\u03c4er(t, p) \u2227Succ(p, p\u2032) ] \u21d4 H\u03c4er(t, p\u2032)\n\u2227 \u03c4,e,i:1\u2264i<c\n\u2200t, \u2200p, p\u2032, [\nRight\u03c4eri(t, p)\u2227Max (p) \u2227Min(p\u2032)\n] \u21d4 H\u03c4eri+1(t, p\u2032)\n\u2227 \u03c4,e \u2200t,\u2200p, [ Right\u03c4erc(t, p)\u2227Max (p) ] \u21d4 H\u03c4erc(t, p)\n10. The frame predicates are defined as\n\u2227 s,\u03c4,e,r\n\u2200t, t\u2032,\u2200p, [ Ts\u03c4er(t, p) \u2227Unchanged\u03c4er(t, p)\n\u2227Succ(t, t\u2032) ] \u21d4 Ts\u03c4er(t\u2032, p)\n\u2227 s,\u03c4,i,r:1\u2264i<c \u2200t, t\u2032,\u2200p,  Ts\u03c4eir(t, p)\u2227Unchanged\u03c4eir(t, p)\u2227Max (t) \u2227Min(t\u2032)  \u21d4 Ts\u03c4ei+1r(t\u2032, p)\n11. The machine terminates in an accepting state (e.g., q1, q5, q42, etc.) :\n\u2200t,Max (t)\u21d2 Sq1ec(t) \u2228 Sq5ec(t) \u2228 Sq42ec(t) \u2228 . . . It is easy to verify that \u03981 uses at most three logical variables per sentence, and that \u03981 is therefore in FO 3. Note that FO3 permits variables to be reused within the same sentence.\nFor a fixed model of </2, that is, a fixed order on the domain, the models of \u03981 for domain size n correspond one-to-one to the accepting computations of the TM on input n. Since there are exactly (n!) models of < /2, we can compute the number of accepting computations from the FOMC efficiently.\nC. PTIME DATA COMPLEXITY FOR FO2 The proof of the fact that the data complexity for FO2 is in PTIME is spread over two references, [35] and [37]. We include here a brief proof, for completeness.\nGiven an FO2 formula \u03d5 of size s, we start by applying the reduction in [17], which converts \u03d5 into a formula \u03d5\u2217 with the following properties:\n\u2022 Every relational symbol occurring in \u03d5\u2217 has arity at most 2.\n\u2022 Items 1 and 3 of Scott\u2019s reduction hold. (Item 2 becomes: \u03d5\u2217 has size O(s log s). In our case \u03d5 is fixed, so it suffices to note that the size of \u03d5\u2217 is O(1).)\nThe reduction consists of Scott\u2019s reduction described above, plus the following transformation that ensures that all relational symbols have arity \u2264 2. Replace each relational atom of arity > 2 by a new unary or binary symbol, for example, replace the atoms R(x, y, x), R(y, y, y), R(x, x, y) by R1(x, y), R2(x), R3(x, y). Then append to \u03d5\u2217 conjuncts asserting how the new relational symbols relate, for example \u2200x(R1(x, x)\u2194 R2(x)); we refer the reader to [17] for details.\nWe perform one more transformation: remove all existential quantifiers by using Lemma 3.3, thus transforming \u03d5\u2217 into a universally quantified sentences:\n\u03d5\u2217 = \u2200x\u2200y \u03c8(x, y) where \u03c8(x, y) is a quantifier-free formula.\nIf \u03d5\u2217 contains any relational symbol R of arity zero then we perform a Shannon expansion and compute P (\u03d5\u2217) = Pr(\u03d5\u2217[R = false]) \u00b7 (1 \u2212 p(R)) + Pr(\u03d5\u2217[R = true]) \u00b7 p(R). Thus, we can assume w.l.o.g. that all relational symbols in \u03d5\u2217 have arity 1 or 2.\nAssume first that all relational symbols in \u03d5\u2217 have arity 2. Then we write its lineage as:\nF = \u2227\na,b\u2208[n]:a<b \u03c8(a, b) \u2227 \u2227 c\u2208[n] \u03c8(c, c)\nSince all atoms are binary, for any two distinct sets {a, b} 6= {a\u2032, b\u2032}, the formulas \u03c8(a, b) and \u03c8(a\u2032, b\u2032) are\nindependent probabilistic events, because they depend on disjoint sets of ground tuples: one depends on tuples of the form R(a, b) or R(b, a), the other on tuples of the form R(a\u2032, b\u2032) or R(b\u2032, a\u2032), and they are disjoint. (This would fail if \u03c8 contained a unary atom, say U(x), because we may have a = a\u2032, b 6= b\u2032, and in that case both formulas depend on the tuple U(a).) Therefore:\nPr(F ) = \u220f\na,b\u2208[n]:a<b Pr(\u03c8(a, b)) \u00b7 \u220f c\u2208[n] Pr(\u03c8(c, c))\nBecause the probabilities are symmetric, the quantity p1 = Pr(\u03c8(a, b)) is independent of a, b, while p2 = Pr(\u03c8(c, c)) is independent of c, and both can be computed in time O(1). Therefore, Pr(\u03d5) = Pr(\u03d5\u2217) = p(F ) = p n(n\u22121)/2 1 p n 2 . For a simple illustration, consider \u03d5\u2217 = \u2200x\u2200y(R(x, y)\u2228T (x, y))\u2227(R(x, y)\u2228T (y, x)). Then:\nF = \u2227\na,b\u2208[n]:a<b (R(a, b) \u2228 T (a, b)) \u2227 (R(a, b) \u2228 T (b, a)) \u2227 (R(b, a) \u2228 T (b, a)) \u2227 (R(b, a) \u2228 T (a, b)) \u2227 \u2227 c\u2208[n] (R(c, c) \u2228 T (c, c))\nand the probability is given by p n(n\u22121)/2 1 p n 2 where p1 = Pr((R(a, b) \u2228 T (a, b)) \u2227 (R(a, b) \u2228 T (b, a)) \u2227 (R(b, a) \u2228 T (b, a)) \u2227 (R(b, a) \u2228 T (a, b))) and p2 = Pr(R(c, c) \u2228 T (c, c)), both quantities that can be computed using brute force.\nNext consider the case when \u03d5\u2217 has both unary and binary relational symbols. Let R1, . . . , Rm be all unary symbols. Consider the 2m cells defined by conjunctions of these atoms or their negation, denote them C1, . . . , C2m ; that is C1(x) \u2261 \u00acR1(x)\u2227\u00b7 \u00b7 \u00b7\u2227\u00acRm(x), . . ., C2m(x) \u2261 R1(x)\u2227 \u00b7 \u00b7 \u00b7 \u2227Rm(x). Let P denote any partition of [n] into 2m disjoint sets, i.e. P = (S1, . . . , S2m) such that S1 \u222a \u00b7 \u00b7 \u00b7 \u222aS2m = [n]. Denote (C1, . . . , C2m) = P the event that the 2m cells define precisely the partition P . Then, summing over all partitions P gives us:\nPr(\u03d5\u2217) = \u2211 P Pr(\u03d5\u2217 \u2227 (C1, \u00b7 \u00b7 \u00b7 , C2m) = P ) (8)\nNext, we split \u03d5\u2217 into a conjunction of several formulas, each x ranging over some cell Si and y over some cell Sj :\n\u03d5\u2217 = \u2227\ni,j\u2208[2m]:i<j \u2200x : Si,\u2200y : Sj , (\u03c8(x, y) \u2227 \u03c8(y, x))\n\u2227 \u2227\n`\u2208[2m] \u2200x : S`,\u2200y : S`, \u03c8(x, y)\nWhen x ranges over Si, then every unary predicate R(x) containing the variable x is either true or false. Similarly, when y ranges over Sj , a predicate R(y) is either true or false. Let \u03c8ij(x, y) (or \u03c8`(x, y)) denote the formula \u03c8(x, y) \u2227 \u03c8(y, x) (or \u03c8(x, y)) where all the unary predicates have been replaced by true or false, accord-\ning to the cells Si, Sj (or S` respectively). Therefore: \u03d5\u2217 = \u2227\ni,j\u2208[2m]:i<j \u2200x : Si,\u2200y : Sj , \u03c8ij(x, y)\n\u2227 \u2227\n`\u2208[2m] \u2200x : S`,\u2200y : S`, \u03c8`(x, y)\nNotice that \u03c8ij and \u03c8` have only binary predicates. All conjuncts in the expression above are independent probabilistic events: if {i1, j1} 6= {i2, j2} then \u2200x : Si1 ,\u2200y : Sj1 , \u03c8i1j1(x, y) and \u2200x : Si2 ,\u2200y : Sj2 , \u03c8i2j2(x, y) are independent. Therefore, denoting ni = |Si| for i = 1, 2m, we have: Pr(\u03d5\u2217 \u2227 (C1, \u00b7 \u00b7 \u00b7 , C2m) = P ) =\u220f i,j\u2208[2m]:i<j qij \u00b7 \u220f `\u2208[2m r`, where:\nqij = Pr(\u2200x : Si,\u2200y : Sj , \u03c8ij(x, y)) = \u220f a\u2208Si,b\u2208Sj Pr(\u03c8ij(a, b)) = r ninj ij\nr` = Pr(\u2200x : S`,\u2200y : S`, \u03c8`(x, y)) = \u220f a,b\u2208S`:a<b Pr(\u03c8`(a, b) \u2227 \u03c8`(b, a)) \u00b7 \u220f c\u2208S` Pr(\u03c8`(c, c))\n=s n`\u2217(n`\u22121)/2 ` \u00b7 tn``\nwhere rij = Pr(\u03c8ij(a, b)), s` = Pr(\u03c8`(a, b) \u2227 \u03c8`(b, a)), and t` = Pr(\u03c8`(c, c)) are independent of the choices of a, b, c respectively, and can be computed by brute force in time O(1). Finally, we use the fact that the probabilities are symmetric, which implies that the expression in Eq. (8) depends only on the cell cardinalities n1, . . . , n2m , and not on the actual cells S1, . . . , S2m . Therefore:\nPr(\u03d5\u2217) = \u2211\nn1,...,n2m :n1+\u00b7\u00b7\u00b7+n2m=1\nn!\nn1! \u00b7 \u00b7 \u00b7n2m !\n\u00b7 rninjij s n`\u2217(n`\u22121)/2 ` \u00b7 tn``\nFor a simple illustration, consider \u03d5\u2217 = \u2200x\u2200y(R(x) \u2228 U(x, y)\u2228T (y))\u2227 (\u00acR(x)\u2228\u00acU(x, y)\u2228\u00acT (y)). Denoting the four cells \u00acR \u2227 \u00acT , \u00acR \u2227 T , R \u2227 \u00acT , R \u2227 T by C1, . . . C4 respectively, we split \u03d5 into a conjunct of 6 + 4 expressions, such that in each expression x and y are restricted to the domains Ci and Cj respectively, for i \u2264 j. Denoting n1, . . . , n4 the sizes of these cells, we have:\nPr(\u03d5\u2217) = \u2211\nn1+\u00b7\u00b7\u00b7+n4=n\nn!\nn1!n2!n3!n4! r ninj ij s n`\u2217(n`\u22121)/2 ` \u00b7 tn``\nwhere r12 = Pr(U(a, b)) (because \u2200x : S1,\u2200y : S2, (R(x)\u2228 U(x, y) \u2228 T (y)) \u2227 (\u00acR(x) \u2228 \u00acU(x, y) \u2228 \u00acT (y)) \u2261 \u2200x : S1,\u2200y : S2, T (x, y)), and similarly for the others."}], "references": [{"title": "On ranking 1-way finitely ambiguous NL languages and #P1-complete census functions", "author": ["Alberto Bertoni", "Massimiliano Goldwurm"], "venue": "ITA, 27(2):135\u2013148,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1993}, {"title": "Toward an architecture for never-ending language learning", "author": ["Andrew Carlson", "Justin Betteridge", "Bryan Kisiel", "Burr Settles", "Estevam R. Hruschka Jr.", "Tom M. Mitchell"], "venue": "In AAAI,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2010}, {"title": "The computational complexity of asymptotic problems", "author": ["Kevin J. Compton"], "venue": "i: Partial orders. Inf. Comput.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1988}, {"title": "Efficient query evaluation on probabilistic databases", "author": ["Nilesh N. Dalvi", "Dan Suciu"], "venue": "VLDB J.,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2007}, {"title": "The dichotomy of probabilistic inference for unions of conjunctive queries", "author": ["Nilesh N. Dalvi", "Dan Suciu"], "venue": "J. ACM,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Markov Logic: An Interface Layer for Artificial Intelligence", "author": ["Pedro Domingos", "Daniel Lowd"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Knowledge vault: A web-scale approach to probabilistic knowledge fusion", "author": ["X. Dong", "E. Gabrilovich", "G. Heitz", "W. Horn", "N. Lao", "K. Murphy", "T. Strohmann", "S. Sun", "W. Zhang"], "venue": "In KDD,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "Fifty years of the spectrum problem: survey and new results", "author": ["Arnaud Durand", "Neil D. Jones", "Johann A. Makowsky", "Malika More"], "venue": "Bulletin of Symbolic Logic,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "Some characterizations of \u03b3 and \u03b2-acyclicity of hypergraphs", "author": ["David Duris"], "venue": "Information Processing Letters,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Identifying relations for open information extraction", "author": ["Anthony Fader", "Stephen Soderland", "Oren Etzioni"], "venue": "In EMNLP,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "Generalized first-order spectra and polynomial-time recognizable sets", "author": ["Ronald Fagin"], "venue": "In SIAM-AMS Proceedings", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1974}, {"title": "Probabilities on finite models", "author": ["Ronald Fagin"], "venue": "J. Symb. Log.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1976}, {"title": "Degrees of acyclicity for hypergraphs and relational database schemes", "author": ["Ronald Fagin"], "venue": "J. ACM,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1983}, {"title": "Probabilistic theorem proving", "author": ["Vibhav Gogate", "Pedro Domingos"], "venue": "In UAI, pages 256\u2013265,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "From sampling to model counting", "author": ["Carla P Gomes", "Joerg Hoffmann", "Ashish Sabharwal", "Bart Selman"], "venue": "In IJCAI,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "On the decision problem for two-variable first-order logic", "author": ["Erich Gr\u00e4del", "Phokion G. Kolaitis", "Moshe Y. Vardi"], "venue": "Bulletin of Symbolic Logic,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1997}, {"title": "Understanding the complexity of lifted inference and asymmetric weighted model counting", "author": ["Eric Gribkoff", "Guy Van den Broeck", "Dan Suciu"], "venue": "In UAI,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2014}, {"title": "Yago2: A spatially and temporally enhanced knowledge base from wikipedia", "author": ["Johannes Hoffart", "Fabian M. Suchanek", "Klaus Berberich", "Gerhard Weikum"], "venue": "AIJ, 194:28\u201361,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2013}, {"title": "Lower complexity bounds for lifted inference", "author": ["Manfred Jaeger"], "venue": "TPLP,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2012}, {"title": "Liftability of probabilistic inference: Upper and lower bounds", "author": ["Manfred Jaeger", "Guy Van den Broeck"], "venue": "In StarAI,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "Probabilistic databases with MarkoViews", "author": ["Abhay Kumar Jha", "Dan Suciu"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2012}, {"title": "Turing machines and the spectra of first-order formulas with equality", "author": ["Neil Jones", "Alan Selman"], "venue": "In STOC,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1972}, {"title": "Counting belief propagation", "author": ["Kristian Kersting", "Babak Ahmadi", "Sriraam Natarajan"], "venue": "In UAI, pages 277\u2013284,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2009}, {"title": "Algebraic model counting", "author": ["Angelika Kimmig", "Guy Van den Broeck", "Luc De Raedt"], "venue": "arXiv preprint arXiv:1211.4475,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2012}, {"title": "The alchemy system for statistical relational AI", "author": ["S. Kok", "P. Singla", "M. Richardson", "P. Domingos"], "venue": null, "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2005}, {"title": "0-1 laws for fragments of existential second-order logic: A survey", "author": ["Phokion G. Kolaitis", "Moshe Y. Vardi"], "venue": "In MFCS,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2000}, {"title": "Symmetry-aware marginal density estimation", "author": ["Mathias Niepert"], "venue": "In AAAI,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2013}, {"title": "Tuffy: Scaling up statistical inference in Markov logic networks using an RDBMS", "author": ["Feng Niu", "Christopher R\u00e9", "AnHai Doan", "Jude W. Shavlik"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2011}, {"title": "Sound and efficient inference with probabilistic and deterministic dependencies", "author": ["Hoifung Poon", "Pedro Domingos"], "venue": "In AAAI,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2006}, {"title": "The complexity of computing the permanent", "author": ["Leslie G. Valiant"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1979}, {"title": "The complexity of enumeration and reliability problems", "author": ["Leslie G. Valiant"], "venue": "SIAM J. Comput.,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1979}, {"title": "On the completeness of first-order knowledge compilation for lifted probabilistic inference", "author": ["Guy Van den Broeck"], "venue": "In NIPS,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2011}, {"title": "On the complexity and approximation of binary evidence in lifted inference", "author": ["Guy Van den Broeck", "Adnan Darwiche"], "venue": "In NIPS,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2013}, {"title": "Skolemization for weighted first-order model counting", "author": ["Guy Van den Broeck", "Wannes Meert", "Adnan Darwiche"], "venue": "In KR,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2014}, {"title": "Lifted generative parameter learning", "author": ["Guy Van den Broeck", "Wannes Meert", "Jesse Davis"], "venue": "In StaRAI,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2013}, {"title": "Lifted probabilistic inference by first-order knowledge compilation", "author": ["Guy Van den Broeck", "Nima Taghipour", "Wannes Meert", "Jesse Davis", "Luc De Raedt"], "venue": "In IJCAI,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2011}, {"title": "The complexity of relational query languages (extended abstract)", "author": ["Moshe Y. Vardi"], "venue": "In STOC,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 1982}, {"title": "Scaling-up importance sampling for markov logic networks", "author": ["Deepak Venugopal", "Vibhav Gogate"], "venue": "In NIPS,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2014}, {"title": "Towards efficient sampling: Exploiting random walk strategies", "author": ["Wei Wei", "Jordan Erenrich", "Bart Selman"], "venue": "In AAAI,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2004}, {"title": "Probase: a probabilistic taxonomy for text understanding", "author": ["Wentao Wu", "Hongsong Li", "Haixun Wang", "Kenny Qili Zhu"], "venue": "In SIGMOD,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2012}], "referenceMentions": [{"referenceID": 17, "context": "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft\u2019s Probase [43] or Google\u2019s Knowledge Vault [8], have millions to billions of uncertain tuples.", "startOffset": 36, "endOffset": 40}, {"referenceID": 1, "context": "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft\u2019s Probase [43] or Google\u2019s Knowledge Vault [8], have millions to billions of uncertain tuples.", "startOffset": 47, "endOffset": 50}, {"referenceID": 9, "context": "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft\u2019s Probase [43] or Google\u2019s Knowledge Vault [8], have millions to billions of uncertain tuples.", "startOffset": 73, "endOffset": 77}, {"referenceID": 39, "context": "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft\u2019s Probase [43] or Google\u2019s Knowledge Vault [8], have millions to billions of uncertain tuples.", "startOffset": 99, "endOffset": 103}, {"referenceID": 6, "context": "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft\u2019s Probase [43] or Google\u2019s Knowledge Vault [8], have millions to billions of uncertain tuples.", "startOffset": 132, "endOffset": 135}, {"referenceID": 6, "context": "For an illustration, Google\u2019s Knowledge Vault [8] contains 1.", "startOffset": 46, "endOffset": 49}, {"referenceID": 6, "context": "6B triples of the form (subject, predicate, object), for example, </m/02mjmr, /people/person/place_of_birth /m/02hrh0_> where /m/02mjmr is the Freebase id for Barack Obama, and /m/02hrh0_ is the id for Honolulu [8].", "startOffset": 211, "endOffset": 214}, {"referenceID": 5, "context": "A Markov Logic Network (MLN) [7] is a finite set of soft or hard constraints.", "startOffset": 29, "endOffset": 32}, {"referenceID": 24, "context": "Today\u2019s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference.", "startOffset": 29, "endOffset": 33}, {"referenceID": 27, "context": "Today\u2019s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference.", "startOffset": 41, "endOffset": 49}, {"referenceID": 28, "context": "Today\u2019s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference.", "startOffset": 87, "endOffset": 91}, {"referenceID": 38, "context": "In practice, MC-SAT implementations rely on SampleSAT [42], which provides no guarantees on the uniformity of solutions.", "startOffset": 54, "endOffset": 58}, {"referenceID": 14, "context": "Several complex examples are known in the literature where model counting based on SampleSAT leads to highly inaccurate estimates [16].", "startOffset": 130, "endOffset": 134}, {"referenceID": 35, "context": "A totally different approach to computing PrMLN (\u03a6) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.", "startOffset": 89, "endOffset": 105}, {"referenceID": 13, "context": "A totally different approach to computing PrMLN (\u03a6) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.", "startOffset": 89, "endOffset": 105}, {"referenceID": 33, "context": "A totally different approach to computing PrMLN (\u03a6) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.", "startOffset": 89, "endOffset": 105}, {"referenceID": 20, "context": "A totally different approach to computing PrMLN (\u03a6) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.", "startOffset": 89, "endOffset": 105}, {"referenceID": 20, "context": "We review here briefly one such reduction, adapting from [22, 37].", "startOffset": 57, "endOffset": 65}, {"referenceID": 33, "context": "We review here briefly one such reduction, adapting from [22, 37].", "startOffset": 57, "endOffset": 65}, {"referenceID": 22, "context": "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].", "startOffset": 194, "endOffset": 210}, {"referenceID": 35, "context": "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].", "startOffset": 194, "endOffset": 210}, {"referenceID": 26, "context": "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].", "startOffset": 194, "endOffset": 210}, {"referenceID": 37, "context": "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].", "startOffset": 194, "endOffset": 210}, {"referenceID": 34, "context": "Some tasks on MLNs, such as parameter learning [38], naturally exhibit symmetries.", "startOffset": 47, "endOffset": 51}, {"referenceID": 32, "context": "For others, such as computing conditional probabilities given a large \u201cevidence\u201d database, the symmetric WFOMC model is applicable when the database has bounded Boolean rank [36].", "startOffset": 174, "endOffset": 178}, {"referenceID": 30, "context": "It is immediate that this problem belongs to the class #P1, which is the set of #P problems over a unary input alphabet [34].", "startOffset": 120, "endOffset": 124}, {"referenceID": 33, "context": "In a surprising result [37] has proven that for FO the data complexity of symmetric WFOMC is in PTIME (reviewed in Appendix C).", "startOffset": 23, "endOffset": 27}, {"referenceID": 19, "context": "This begs the question: could it be the case that every FO formula is in PTIME? The answer was shown to be negative by Jaeger and Van den Broeck [21, 20], using the following argument.", "startOffset": 145, "endOffset": 153}, {"referenceID": 18, "context": "This begs the question: could it be the case that every FO formula is in PTIME? The answer was shown to be negative by Jaeger and Van den Broeck [21, 20], using the following argument.", "startOffset": 145, "endOffset": 153}, {"referenceID": 7, "context": "Recall that the spectrum, Spec(\u03a6), of a formula \u03a6 is the set of numbers n for which \u03a6 has a model over a domain of size n [9].", "startOffset": 122, "endOffset": 125}, {"referenceID": 31, "context": "PTIME data complexity for symmetric WFOMC is called domain-liftability in the AI and lifted inference literature [35].", "startOffset": 113, "endOffset": 117}, {"referenceID": 31, "context": "Tractability of \u03a6 was noted before in, for example [32, 35].", "startOffset": 51, "endOffset": 59}, {"referenceID": 21, "context": "Then, using a result in [23], if ETIME 6= NETIME, then there exists a formula \u03a6 for which computing WFOMC is not in polynomial time.", "startOffset": 24, "endOffset": 28}, {"referenceID": 30, "context": "Valiant already observed in [34] that such problems are probably not candidates for being #P-complete.", "startOffset": 28, "endOffset": 32}, {"referenceID": 0, "context": "Very few hardness results are known for this class: we are aware only of a graph matching problem that was proven by Valiant, and of a language-theoretic problem by Bertoni and Goldwurm [1].", "startOffset": 186, "endOffset": 189}, {"referenceID": 33, "context": "Second, we prove that every \u03b3-acyclic conjunctive query without self-joins is in polynomial time, extending the result in [37] from FO to \u03b3-acyclic conjunctive queries.", "startOffset": 122, "endOffset": 126}, {"referenceID": 33, "context": "The tractability for FO [37] raises a natural question: do other restrictions of FO, like FO for k \u2265 3, also have polynomial data complexity? By carefully analyzing the details of the construction of \u03981 we prove that it is actually in FO.", "startOffset": 24, "endOffset": 28}, {"referenceID": 25, "context": "Recall that, if C is a class of finite structures and P is a property over these structures, then \u03bcn(P ) denotes the fraction of labeled structures in C over a domain of size n that satisfy the property P [27].", "startOffset": 205, "endOffset": 209}, {"referenceID": 11, "context": "Fagin [13] proved a 0-1 law for First-Order logic and all structures, by using an elegant transfer theorem: there exists a unique, countable structure R, which is characterized by an infinite set of extension axioms, \u03c4 .", "startOffset": 6, "endOffset": 10}, {"referenceID": 2, "context": "Compton [3] proved 0-1 laws for several classes of structures C.", "startOffset": 8, "endOffset": 11}, {"referenceID": 21, "context": "The data complexity variant is, of course, the spectrum membership problem, which has been completely solved by Jones and Selman [23], by proving that the class of spectra coincides with NETIME, that is, {Spec(\u03a6) | \u03a6 \u2208 FO} = NETIME.", "startOffset": 129, "endOffset": 133}, {"referenceID": 15, "context": "Gr\u00e4del, Kolaitis and Vardi [17] have proven the following two", "startOffset": 27, "endOffset": 31}, {"referenceID": 0, "context": "In the probability computation problem, each variable Xi is set to true with some known probability p(Xi) \u2208 [0, 1], and", "startOffset": 108, "endOffset": 114}, {"referenceID": 0, "context": "While in practical applications the weights are positive real numbers, and the probabilities are numbers in [0, 1], in this paper we impose no restrictions on the values of the weights and probabilities.", "startOffset": 108, "endOffset": 114}, {"referenceID": 23, "context": "The definition (2) of WMC(F,w) applies equally well to negative weights, and, in fact, to any semiring structure for the weights [25].", "startOffset": 129, "endOffset": 133}, {"referenceID": 20, "context": "There is, in fact, at least one application of negative probabilities [22], namely the particular reduction from MLNs to WFOMC described in Example 1.", "startOffset": 70, "endOffset": 74}, {"referenceID": 3, "context": "depend on i, j #P-hard for \u03a6 [4]", "startOffset": 29, "endOffset": 32}, {"referenceID": 33, "context": "[37] have shown that the Symmetric WFOMC problem for every FO formula has polynomial time data complexity (the proof is reviewed in Appendix C); Theorem 3.", "startOffset": 0, "endOffset": 4}, {"referenceID": 33, "context": "This lemma was proven by [37], and says that all existential quantifiers can be eliminated.", "startOffset": 25, "endOffset": 29}, {"referenceID": 33, "context": "The next lemma, also following the proof in [37], says that all negations can be eliminated.", "startOffset": 44, "endOffset": 48}, {"referenceID": 12, "context": "Fagin\u2019s definition of \u03b3-acyclic hypergraphs [14] is reviewed in the proof of Theorem 3.", "startOffset": 44, "endOffset": 48}, {"referenceID": 12, "context": "This boundary does not lie at \u03b3-acyclicity: the query c\u03b3 = R(x, z), S(x, y, z), T (y, z) is \u03b3-cyclic (with cycle RxSyTzR; see Fagin [14]), yet it still has PTIME data complexity.", "startOffset": 132, "endOffset": 136}, {"referenceID": 4, "context": "The key observation is that \u03b3-cycles allow the last variable z to appear in all predicates, turning it into a separator variable [5], hence Pr(Q) = \u220f a\u2208[n] Pr(Q[a/z]), which is [Pr(Q[a/z])] n by symme-", "startOffset": 129, "endOffset": 132}, {"referenceID": 8, "context": "A weaker notion of acyclicity, called jtdb (for join tree with disjoint branches), can be found in [10].", "startOffset": 99, "endOffset": 103}, {"referenceID": 12, "context": "Fagin [14] defines two increasingly weaker notions of acyclicity: \u03b2- and \u03b1-acyclic.", "startOffset": 6, "endOffset": 10}, {"referenceID": 12, "context": "By definition, a \u03b2-cyclic query Q contains a weak \u03b2-cycle [14] of the form R1x1R2x2 .", "startOffset": 58, "endOffset": 62}, {"referenceID": 16, "context": "Finally, we discuss a peculiar sentence, whose complexity we left open in [18]:", "startOffset": 74, "endOffset": 78}, {"referenceID": 16, "context": "QS4 =\u2200x1\u2200x2\u2200y1\u2200y2(S(x1, y1)\u2228 \u00acS(x2, y1) \u2228 S(x2, y2) \u2228 \u00acS(x1, y2)) In [18] we showed that QS4 is in PTIME under the modified semantics, where S is a bipartite graph.", "startOffset": 69, "endOffset": 73}, {"referenceID": 29, "context": "We briefly recall the basic notions from Valiant\u2019s original papers [33, 34].", "startOffset": 67, "endOffset": 75}, {"referenceID": 30, "context": "We briefly recall the basic notions from Valiant\u2019s original papers [33, 34].", "startOffset": 67, "endOffset": 75}, {"referenceID": 30, "context": "A similar construction in [34] is sketched too briefly to see how the particular pairing function can work; we use a different pairing function and give full details.", "startOffset": 26, "endOffset": 30}, {"referenceID": 21, "context": "By allowing runtimes O(n) with a > 1, the lemma implies: #P1 = {f | \u2203\u03a6 \u2208 FO ,\u2200n : f(n) = bFOMC(\u03a6, n)/n!c}; this is an extension of the classic result by Jones and Selman [23], which, restated for the tally notation says NP1 = {Spec(\u03a6) | \u03a6 \u2208 FO} (see [12], [9, Sec.", "startOffset": 170, "endOffset": 174}, {"referenceID": 10, "context": "By allowing runtimes O(n) with a > 1, the lemma implies: #P1 = {f | \u2203\u03a6 \u2208 FO ,\u2200n : f(n) = bFOMC(\u03a6, n)/n!c}; this is an extension of the classic result by Jones and Selman [23], which, restated for the tally notation says NP1 = {Spec(\u03a6) | \u03a6 \u2208 FO} (see [12], [9, Sec.", "startOffset": 250, "endOffset": 254}, {"referenceID": 12, "context": "To prove the theorem, we use an equivalent definition of \u03b3-acyclicity given by Fagin [14], which we give here together with our algorithm for computing Pr(Q).", "startOffset": 85, "endOffset": 89}, {"referenceID": 36, "context": "Vardi [40] proved that the model checking problem, \u201cgiven \u03a6 and a structure D, is \u03a6 true in D?\u201d is PSPACE-complete.", "startOffset": 6, "endOffset": 10}, {"referenceID": 29, "context": "This problem is #P-hard [33].", "startOffset": 24, "endOffset": 28}], "year": 2015, "abstractText": "The FO Model Counting problem (FOMC) is the following: given a sentence \u03a6 in FO and a number n, compute the number of models of \u03a6 over a domain of size n; the Weighted variant (WFOMC) generalizes the problem by associating a weight to each tuple and defining the weight of a model to be the product of weights of its tuples. In this paper we study the complexity of the symmetric WFOMC, where all tuples of a given relation have the same weight. Our motivation comes from an important application, inference in Knowledge Bases with soft constraints, like Markov Logic Networks, but the problem is also of independent theoretical interest. We study both the data complexity, and the combined complexity of FOMC and WFOMC. For the data complexity we prove the existence of an FO formula for which FOMC is #P1complete, and the existence of a Conjunctive Query for which WFOMC is #P1-complete. We also prove that all \u03b3acyclic queries have polynomial time data complexity. For the combined complexity, we prove that, for every fragment FO, k \u2265 2, the combined complexity of FOMC (or WFOMC) is", "creator": "LaTeX with hyperref package"}}}