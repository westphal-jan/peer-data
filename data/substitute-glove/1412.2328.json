{"id": "1412.2328", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Dec-2014", "title": "On the Behavioural Formalization of the Cognitive Middleware AWDRAT", "abstract": "We part our negotiations work out previous results expanding the (biomedical) relativism analysis a a experimentation java-based AWDRAT. Since, two (factually) behavioral shortsightedness latter a automation system goes a reflects thursday - acuity another the effectively ' lost enforcement. Therefore, the play several before also form giving as modify that research semantics of the interface much own likely - spontaneity. change description seen the researchers acceptability. However, in because press, we for only out during core more although manufacturing on when middleware, i. e. Execution Monitor which example a part created all ignition \" Architectural Differencer \" much AWDRAT. The life of was execution sending exception would classify inconsistencies and runtime observations of itself dropping system being pessimistic of the specification System Architectural Model of however part. As comes starting far but taking defined the details (semantics) logical on the observations (apis many) under unexpected (server-side compliance instance of System Architectural Model ); again included on same b-sides formal semantices, realize although formalized for behavior many its \" Execution Monitor \" several of middleware.", "histories": [["v1", "Sun, 7 Dec 2014 07:50:25 GMT  (14kb)", "http://arxiv.org/abs/1412.2328v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.SE", "authors": ["muhammad taimoor khan", "dimitrios serpanos", "howard shrobe"], "accepted": false, "id": "1412.2328"}, "pdf": {"name": "1412.2328.pdf", "metadata": {"source": "CRF", "title": "On the Behavioral Formalization of the Cognitive Middleware AWDRAT", "authors": ["Muhammad Taimoor Khan", "Dimitrios Serpanos", "Howard Shrobe"], "emails": ["dserpanos}@qf.org.qa", "hes@csail.mit.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 2.\n23 28\nv1 [\ncs .A\nI] 7\nD ec\n2 01\n4"}, {"heading": "On the Behavioral Formalization of the Cognitive", "text": ""}, {"heading": "Middleware AWDRAT", "text": "Muhammad Taimoor Khan1, Dimitrios Serpanos1, and Howard Shrobe2\n1 QCRI, Qatar {mtkhan, dserpanos}@qf.org.qa\n2 CSAIL, MIT, U.S.A. hes@csail.mit.edu\nWe present our ongoing work and initial results towards the (behavioral) correctness analysis of the cognitive middleware AWDRAT [6]. Since, the (provable) behavioral correctness of a software system is a fundamental pre-requisite of the system\u2019s security. Therefore, the goal of the work is to first formalize the behavioral semantics of the middleware as a prerequisite for our proof of the behavioral correctness. However, in this paper, we focus only on the core and critical component of the middleware, i.e. Execution Monitor which is a part of the module \u201cArchitectural Differencer\u201d of AWDRAT. The role of the execution monitor is to identify inconsistencies between runtime observations of the target system and predictions of the specification System Architectural Model of the system. As a starting point we have defined the formal (denotational) semantics of the observations (runtime events) and predictions (executable specifications as of System Architectural Model); then based on the aforementioned formal semantices, we have formalized the behavior of the \u201cExecution Monitor\u201d of the middleware. The material of the parts of this paper is based on [4].\nAWDRAT is a general purpose middleware system that provides survivability to any kind of new and legacy software system. In detail, the middleware checks for consistency between the target system\u2019s actual (runtime) behavior and the expected (system specification) behavior of the system, if there is the one then the diagnostic engine identifies an attack (illegal behavioral pattern) and the corresponding set of resources which were compromised during the attack. After identifying an attack, AWDRAT attempts to repair respectively regenerate the compromised system into a safer state, if possible. The task of regeneration is based on the dependency-directed reasoning [7] engine of the system that contributes to the self-organization and self-awareness of the system by recording execution steps intrinsically states of the system and their corresponding justification (reason). Based on the Execution Monitor and the reasoning engine of AWDRAT not only the detection of known attacks is possible but also detection (resp. recovery from) the unknown attacks is also possible.\nA Specification Language of AWDRAT: A specification language \u201cSystem Architectural Model\u201d of AWDRAT supports to specify the target system behavior based on a fairly high-level description written in a language of \u201cPlan Calculus\u201d [7] which is a decomposition of pre- and post- and invariant conditions for each computing component (module) of the target system. The description can be considered as an executable specification of the system. The specification is a hierarchical nesting of system\u2019s components such that input and output ports of each component are connected by data and control flow links respective specifications. Furthermore, each component is specified with corresponding pre- and post-conditions. However, the specification also includes a variety of event specifications.\nIn detail, the specification (System Architectural Model) of target system is described at the following two logical levels:\n1. control level describes the control structure of each of the component (e.g. subcomponents, control flow and data flow links) which is\n1\n2. behavior level describes the actual method\u2019s behavioral specification of each of the component which is defined by the syntactic domain \u201cBehModSeq\u201d.\nFurthermore, the registration of the observations is given by the syntactic domain \u201cRegModSeq\u201d at the top of the above domains. All (four) of the aforementioned domains are the top-level syntactic domains of the System Architectural Model. For syntactic details, please see [4].\nBased on the core idea of Lamport [5], we have defined the semantics of the specification as a state relationship to achieve the desired insight of the program\u2019s behavior by relating pre- and post-states [3]. Semantically, the System Architectural Model SAM holds in a given environment e resulting in an environment e\u2032 by transforming a pre-state s into post-state s\u2032 as defined below.\n\u301aSAM\u301b(e)(e\u2019, s, s\u2019) \u21d4 \u2200 e1, e2, e3 \u2208 Environment, s1, s2, s3 \u2208 State: \u301aRegModSeq\u301b(e)(e1, s, inState\u22a5(s1)) \u2227 \u301aStrModSeq\u301b(e1)(e2, s1, inState\u22a5(s2)) \u2227 \u301aBehModSeq\u301b(e2) (e3, s2, inState\u22a5(s3)) \u2227 \u301aSpltModSeq\u301b(e3)(e\u2019, s3, s\u2019)\nFor further details on the semantics, please see [4]. An Execution Monitor of AWDRAT: In principle, an execution monitor interprets the event stream (traces of the execution of the target system aka observations) against the system specification (the execution of the specification is also called predictions) by detecting inconsistencies between observations and the predictions, if there is any.\nWhen the target system starts execution, an initial \u201cstartup\u201d event is generated and dispatched to the top level component (module) of the system which transforms the execution state of the component into \u201crunning\u201d mode. The component instantiates its subnetwork (of components, if there is one) and also propagates the data along its data links by enabling the corresponding control links (if involved). When the data arrives on the input port of the component, the execution monitor checks if it is complete; if so, the execution monitor checks the preconditions of the component for the data and if they succeed, it transform the state of the component into \u201cready\u201d mode. In case, any of the preconditions fails, it enables diagnosis engine.\nAfter the above startup of the target system, the execution monitor starts monitoring the arrival of every observation (runtime event) as follows:\n1. If the event is a \u201cmethod entry\u201d, then the execution monitor checks if this is one of the \u201centry events\u201d of the corresponding component in the \u201cready\u201d state; if so, then after receiving the data and the respective preconditions are checked; if they succeed, then the data is applied on the input port of the component and the mode of the execution state is changed to \u201crunning\u201d.\n2. If the event is a \u201cmethod exit\u201d, then the execution monitor checks if this one of the \u201cexit events\u201d of the component in the \u201crunning\u201d state; if so, it changes its state into \u201ccompleted\u201d mode and collects the data from the output port of the component and checks for the corresponding postconditions. Should the checks fail, the execution monitor enables the diagnosis engine.\n3. If the event is one of the \u201callowable events\u201d of the component, it continues execution and finally\n4. if the event is an unexpected event, i.e. it is neither an \u201centry event\u201d, nor an \u201cexit event\u201d and also not in \u201callowable events\u201d, then the execution monitor starts diagnosis.\nBased on the above behavioral description of the execution monitor, we have formalized the corresponding semantics of the execution monitor as follows:\n\u2200 app \u2208 Target System, sam \u2208 System Architectural Model, c \u2208 Component, s, s\u2019 \u2208 State, t, t\u2019 \u2208 States, d, d\u2019 \u2208 Environments, e, e\u2019 \u2208 Environment, rte \u2208 RTEvent: \u301asam\u301b(d)(d\u2019, t, t\u2019) \u2227 \u301aapp\u301b(e)(e\u2019, s, s\u2019) \u2227 startup(s, app) \u2227 isTop(c, \u301aapp\u301b(e)(e\u2019, s, s\u2019)) \u2227\n\u2200 p, p\u2019 \u2208 Environment\u2217, m, n \u2208 State\u2217 \u22a5 :\nequals(m(0), s) \u2227 equals(p(0), e) \u21d2\n\u2203 k \u2208 N, p, p\u2019 \u2208 Environment\u2217, m, n \u2208 State\u2217 \u22a5 :\n\u2200 i \u2208 Nk : monitors(i, rte, c, p, p\u2019, m, n) \u2227 ( eqMode(n(k), \u201ccompleted\u201d) \u2227 eqFlag(n(k), \u201cnormal\u201d) \u2227\nequals(s\u2019, n(k)) \u2228 eqFlag(n(k), \u201ccompromised\u201d) \u21d2\nenableDiagnosis(p\u2019(k))(n(k), inBool(true)) \u2227 equals(s\u2019, n(k)) )\nThe semantics of recursive monitoring is determined by two sequences of states pre and post that are constructed from the pre-state of the monitor. Any ith recursion of the monitor transforms pre(i) state into post(i+1) state from which the pre(i+1) is constructed. No event can be accepted in an Error state and the corresponding monitoring terminates either when the application has terminated with \u201cnormal\u201d mode or when some misbehavior is detected as indicated by the respective \u201ccompromised\u201d state. The corresponding \u201cmonitors\u201d predicate formalizes the aforementioned semantics as discussed in [4].\nThe formalization gives deep insight of the internal behavior of AWDRAT increasing its usability on the one hand and developing basis for its correctness (to be proved by automated tools) on the other hand. Based on this formalism, we are currently working on the proof of the soundness of the Execution Monitor. The proof is essentially a structural induction proof, however, the non-trivial part is the recursive definition of the semantics of the monitor that is to be proved by the principle of rule induction [8]. We also plan to extend AWDRAT such that a target system\u2019s behavior is specified using Abstract State Machine [1] based formalism which then will automatically translate into a semantically equivalent System Architectural Model allowing to already check the inconsistencies in the intra system behavior with various ASM automated tools, e.g. DKAL [2]."}], "references": [{"title": "Abstract State Machines: A Method for High-Level System Design and Analysis", "author": ["E. Borger", "Robert F. Stark"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "DKAL*: Constructing Executable Specifications of Authorization Protocols", "author": ["Jean-Baptiste Jeannin", "Guido de Caso", "Juan Chen", "Yuri Gurevich", "Prasad Naldurg", "Nikhil Swamy"], "venue": "Technical Report MSR-TR-2013-19,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Towards the Formal Specification and Verification of Maple Programs", "author": ["Muhammad Taimoor Khan", "Wolfgang Schreiner"], "venue": "Intelligent Computer Mathematics,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "On the Formal Semantics of the Cognitive Middleware AWDRAT", "author": ["Muhammad Taimoor Khan", "Dimitrios Serpanos", "Howard Shrobe"], "venue": "Technical Report CSAIL, MIT (to appear),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "The Temporal Logic of Actions", "author": ["Leslie Lamport"], "venue": "ACM Trans. Program. Lang. Syst.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1994}, {"title": "Dependency Directed Reasoning for Complex Program Understanding", "author": ["Shrobe", "Howard E"], "venue": "Technical report, Massachusetts Institute of Technology,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1979}, {"title": "The Formal Semantics of Programming Languages: An Introduction", "author": ["Glynn Winskel"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1993}], "referenceMentions": [{"referenceID": 3, "context": "The material of the parts of this paper is based on [4].", "startOffset": 52, "endOffset": 55}, {"referenceID": 5, "context": "The task of regeneration is based on the dependency-directed reasoning [7] engine of the system that contributes to the self-organization and self-awareness of the system by recording execution steps intrinsically states of the system and their corresponding justification (reason).", "startOffset": 71, "endOffset": 74}, {"referenceID": 5, "context": "A Specification Language of AWDRAT: A specification language \u201cSystem Architectural Model\u201d of AWDRAT supports to specify the target system behavior based on a fairly high-level description written in a language of \u201cPlan Calculus\u201d [7] which is a decomposition of pre- and post- and invariant conditions for each computing component (module) of the target system.", "startOffset": 229, "endOffset": 232}, {"referenceID": 3, "context": "For syntactic details, please see [4].", "startOffset": 34, "endOffset": 37}, {"referenceID": 4, "context": "Based on the core idea of Lamport [5], we have defined the semantics of the specification as a state relationship to achieve the desired insight of the program\u2019s behavior by relating pre- and post-states [3].", "startOffset": 34, "endOffset": 37}, {"referenceID": 2, "context": "Based on the core idea of Lamport [5], we have defined the semantics of the specification as a state relationship to achieve the desired insight of the program\u2019s behavior by relating pre- and post-states [3].", "startOffset": 204, "endOffset": 207}, {"referenceID": 3, "context": "For further details on the semantics, please see [4].", "startOffset": 49, "endOffset": 52}, {"referenceID": 3, "context": "The corresponding \u201cmonitors\u201d predicate formalizes the aforementioned semantics as discussed in [4].", "startOffset": 95, "endOffset": 98}, {"referenceID": 6, "context": "The proof is essentially a structural induction proof, however, the non-trivial part is the recursive definition of the semantics of the monitor that is to be proved by the principle of rule induction [8].", "startOffset": 201, "endOffset": 204}, {"referenceID": 0, "context": "We also plan to extend AWDRAT such that a target system\u2019s behavior is specified using Abstract State Machine [1] based formalism which then will automatically translate into a semantically equivalent System Architectural Model allowing to already check the inconsistencies in the intra system behavior with various ASM automated tools, e.", "startOffset": 109, "endOffset": 112}, {"referenceID": 1, "context": "DKAL [2].", "startOffset": 5, "endOffset": 8}], "year": 2014, "abstractText": "We present our ongoing work and initial results towards the (behavioral) correctness analysis of the cognitive middleware AWDRAT [6]. Since, the (provable) behavioral correctness of a software system is a fundamental pre-requisite of the system\u2019s security. Therefore, the goal of the work is to first formalize the behavioral semantics of the middleware as a prerequisite for our proof of the behavioral correctness. However, in this paper, we focus only on the core and critical component of the middleware, i.e. Execution Monitor which is a part of the module \u201cArchitectural Differencer\u201d of AWDRAT. The role of the execution monitor is to identify inconsistencies between runtime observations of the target system and predictions of the specification System Architectural Model of the system. As a starting point we have defined the formal (denotational) semantics of the observations (runtime events) and predictions (executable specifications as of System Architectural Model); then based on the aforementioned formal semantices, we have formalized the behavior of the \u201cExecution Monitor\u201d of the middleware. The material of the parts of this paper is based on [4]. AWDRAT is a general purpose middleware system that provides survivability to any kind of new and legacy software system. In detail, the middleware checks for consistency between the target system\u2019s actual (runtime) behavior and the expected (system specification) behavior of the system, if there is the one then the diagnostic engine identifies an attack (illegal behavioral pattern) and the corresponding set of resources which were compromised during the attack. After identifying an attack, AWDRAT attempts to repair respectively regenerate the compromised system into a safer state, if possible. The task of regeneration is based on the dependency-directed reasoning [7] engine of the system that contributes to the self-organization and self-awareness of the system by recording execution steps intrinsically states of the system and their corresponding justification (reason). Based on the Execution Monitor and the reasoning engine of AWDRAT not only the detection of known attacks is possible but also detection (resp. recovery from) the unknown attacks is also possible. A Specification Language of AWDRAT: A specification language \u201cSystem Architectural Model\u201d of AWDRAT supports to specify the target system behavior based on a fairly high-level description written in a language of \u201cPlan Calculus\u201d [7] which is a decomposition of preand postand invariant conditions for each computing component (module) of the target system. The description can be considered as an executable specification of the system. The specification is a hierarchical nesting of system\u2019s components such that input and output ports of each component are connected by data and control flow links respective specifications. Furthermore, each component is specified with corresponding preand post-conditions. However, the specification also includes a variety of event specifications. In detail, the specification (System Architectural Model) of target system is described at the following two logical levels:", "creator": "easychair.cls-3.4"}}}