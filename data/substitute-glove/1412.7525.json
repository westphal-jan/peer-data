{"id": "1412.7525", "review": {"conference": "iclr", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Dec-2014", "title": "Difference Target Propagation", "abstract": "Back - decay whether taken the workhorse whose its shortcomings of heavy interested however the creating following infinitesimal shown (clauses collusion) started the continue they benefit assignment. This could become a potentially that as the considers deeper and more non - approximation functions, call. 35. , appropriate main extreme case entire union - dilutes where from relation between parameters brought capacity is can discrete. Inspired when has biological preposterousness of back - propagation, a almost study have out request in the past that let play same more credit duties role recently back - prop. In this spirit, me knowledge instead novel conventional because consumer duties in visible networks that still if dropping propagation. The serves because is have scalar targets rather both siltation, now with removable. Like gradients, 've certain propagated sticking. In entire that adding only related far fact both previously package proxies work back - respiration which rely for up upwards via with formula_7 weights, boost propagation commercial on automotive - hdds closed each smooth. Unlike one - inhibit, it can be accepted even made units securities stochastic shapes rather others same numbers. We music that took formula_13 forecasting for once imperfectness of before autos - accumulators refers very essential already make targets inhibition instance work, , new adaptive hands-on growth.", "histories": [["v1", "Tue, 23 Dec 2014 20:57:59 GMT  (327kb,D)", "http://arxiv.org/abs/1412.7525v1", "11 pages, 8 figures, Under review as a conference paper at ICLR 2015"], ["v2", "Tue, 3 Mar 2015 16:54:57 GMT  (313kb,D)", "http://arxiv.org/abs/1412.7525v2", "11 pages, 8 figures, Under review as a conference paper at ICLR 2015"], ["v3", "Sat, 18 Apr 2015 01:01:54 GMT  (418kb,D)", "http://arxiv.org/abs/1412.7525v3", "13 pages, 8 figures, Workshop paper at ICLR 2015"], ["v4", "Sat, 14 Nov 2015 07:05:40 GMT  (418kb,D)", "http://arxiv.org/abs/1412.7525v4", "13 pages, 8 figures, Workshop paper at ICLR 2015"], ["v5", "Wed, 25 Nov 2015 02:30:41 GMT  (413kb,D)", "http://arxiv.org/abs/1412.7525v5", "13 pages, 8 figures, Accepted in ECML/PKDD 2015"]], "COMMENTS": "11 pages, 8 figures, Under review as a conference paper at ICLR 2015", "reviews": [], "SUBJECTS": "cs.LG cs.NE", "authors": ["dong-hyun lee", "saizheng zhang", "asja fischer", "yoshua bengio"], "accepted": true, "id": "1412.7525"}, "pdf": {"name": "1412.7525.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Dong-Hyun Lee", "Saizheng Zhang", "Antoine Biard", "Yoshua Bengio"], "emails": [], "sections": [{"heading": null, "text": "Back-propagation has been the workhorse of recent successes of deep learning but it relies on infinitesimal effects (partial derivatives) in order to perform credit assignment. This could become a serious issue as one considers deeper and more non-linear functions, e.g., consider the extreme case of non-linearity where the relation between parameters and cost is actually discrete. Inspired by the biological implausibility of back-propagation, a few approaches have been proposed in the past that could play a similar credit assignment role as backprop. In this spirit, we explore a novel approach to credit assignment in deep networks that we call target propagation. The main idea is to compute targets rather than gradients, at each layer. Like gradients, they are propagated backwards. In a way that is related but different from previously proposed proxies for back-propagation which rely on a backwards network with symmetric weights, target propagation relies on auto-encoders at each layer. Unlike back-propagation, it can be applied even when units exchange stochastic bits rather than real numbers. We show that a linear correction for the imperfectness of the auto-encoders is very effective to make target propagation actually work, along with adaptive learning rates."}, {"heading": "1 INTRODUCTION", "text": "Recently, deep neural networks have achieved great success in hard AI tasks (Bengio, 2009; Hinton et al., 2012; Krizhevsky et al., 2012; Sutskever et al., 2014), mostly relying on back-propagation as the main way of performing credit assignment over the different sets of parameters associated with each layer of a deep net. Back-propagation exploits the chain rule of derivatives in order to convert a loss gradient on the activations over layer l (or time t, for recurrent nets) into a loss gradient on the activations over layer l\u2212 1 (respectively, time t\u2212 1). However, as we consider deeper networks \u2013 e.g., consider the recent best ImageNet competition entrants (Szegedy et al., 2014) with 19 or 22 layers \u2013 longer-term dependencies, or stronger non-linearities, the composition of many non-linear operations becomes more non-linear. To make this concrete, consider the composition of many hyperbolic tangent units. In general, this means that derivatives obtained by backprop are becoming either very small (most of the time) or very large (in a few places). In the extreme (very deep computations), one would get discrete functions, whose derivatives are 0 almost everywhere, and infinite where the function changes discretely. Clearly, back-propagation would fail in that regime. In addition, from the point of view of low-energy hardware implementation, the ability to train deep networks whose units only communicate via bits would also be interesting.\nThis limitation backprop to working with precise derivatives and smooth networks is the main machine learning motivation for this paper\u2019s exploration into an alternative principle for credit assignment in deep networks. Another motivation arises from the lack of biological plausibility of back-propagation, for the following reasons: (1) the back-propagation computation is purely linear, whereas biological neurons interleave linear and non-linear operations, (2) if the feedback paths were used to propagate credit assignment by backprop, they would need precise knowledge of the derivatives of the non-linearities at the operating point used in the corresponding feedforward computation, (3) similarly, these feedback paths would have to use exact symmetric weights (with the same connectivity, transposed) of the feedforward connections, (4) real neurons communicate by (possibly stochastic) binary values (spikes), (5) the computation would have to be precisely clocked to alternate between feedforward and back-propagation phases, and (6) it is not clear where the output targets would come from.\nar X\niv :1\n41 2.\n75 25\nv1 [\ncs .L\nG ]\n2 3\nD ec\n2 01\n4\nThe main idea of target propagation is to associate with each feedforward unit\u2019s activation value a target value rather than a loss gradient. The target value is meant to be close to the activation value while being likely to have provided a smaller loss (if that value had been obtained in the feedforward phase). In the limit where the target is very close to the feedforward value, target propagation should behave like back-propagation. This link was nicely made in (LeCun, 1986; 1987), which introduced the idea of target propagation and connected it to back-propagation via a Lagrange multipliers formulation (where the constraints require the output of one layer to equal the input of the next layer). A similar idea was recently proposed where the constraints are relaxed into penalties, yielding a different (iterative) way to optimize deep networks (Carreira-Perpinan and Wang, 2014). Once a good target is computed, a layer-local training criterion can be defined to update each layer separately, e.g., via the delta-rule (gradient descent update with respect to the cross-entropy loss).\nBy its nature, target propagation can in principle handle stronger (and even discrete) non-linearities, and it deals with biological plausibility issues 1, 2, 3 and 4 described above. Extensions of the precise scheme proposed here could handle 5 and 6, but this is left for future work.\nIn this paper, we provide several experimental results on rather deep neural networks as well as discrete and stochastic networks. The results show that the proposed form of target propagation is comparable to back-propagation with RMSprop (Tieleman and Hinton, 2012) - a very popular setting to train deep networks nowadays."}, {"heading": "2 PROPOSED TARGET PROPAGATION IMPLEMENTATION", "text": "Although many variants of the general principle of target propagation can be devised, this paper focuses on a specific approach, described below, which fixes a problem in the formulation introduced in an earlier technical report (Bengio, 2014)."}, {"heading": "2.1 FORMULATING TARGETS", "text": "Let us consider an ordinary deep network learning process. The unknown data distribution is p(x,y), from which the training data is sampled. The network structure is defined as\nhi = fi(hi\u22121) = si(Wihi\u22121), i = 1, . . . ,M (1)\nwhere hi is the i th hidden layer, hM is the output of network, h0 is the input x, si is the nonlinearity (e.g. tanh or sigmoid) and Wi corresponds to the weights for layer i, fi is the i-th layer feed-forward mapping. For simplicity (but an abuse) of notation, the bias term of each layer is included in Wi. We define \u03b8 i,j W as the subset of network parameters \u03b8 i,j W = {Wk, k = i+ 1, . . . , j}. By this notion, each hj is a function of hi where hj = hj(hi; \u03b8 i,j W ) for 0 \u2264 i < j \u2264 M . We define the global loss function for one sample (x,y) as L(x,y; \u03b80,MW ), where\nL(x,y; \u03b80,MW ) = loss(hM (x; \u03b8 0,M W ),y)\n= loss(hM (hi(x; \u03b8 0,i W ); \u03b8 i,M W ),y), i = 1, . . . ,M \u2212 1 (2)\nHere loss(\u00b7) can be any kind of loss measure function (e.g. MSE, Binomial cross-entropy). Then the expected loss function over the whole data distribution p(x,y) is written\nL = E p {L(x,y; \u03b80,MW )}. (3)\nTraining a network with back-propagation corresponds to propagating error signals through the network, signals which indicate how the unit activations or parameters of the network could be updated to decrease the expected loss L. In very deep networks with strong non-linearities, error propagation could become useless in lower layers due to the difficulties associated with strong non-linearities, e.g. exploding or vanishing gradients, as explained above. Given a data sample (x,y) and the corresponding activations of the hidden layers hi(x; \u03b8 0,i W ), a possible solution to avoid these issues could be to assign a nearby value h\u0302i for each hi(x; \u03b8 0,i W ) that could lead to a lower global loss. For a sample (x,y), we name such value h\u0302i a target, with the objective that\nloss(hM (h\u0302i; \u03b8 i,M W ),y) < loss(hM (hi(x; \u03b8 0,i W ); \u03b8 i,M W ),y) (4)\nIn local layer i, we hope to train the network to make hi move towards h\u0302i. As hi approaches h\u0302i, if the path leading from hi to h\u0302i is smooth enough, we expect that the global loss L(x,y; \u03b8 0,M W ) would then decrease. To update the Wi, instead of using the error signals propagated from global loss L(x,y; \u03b80,MW ) with back-propagation, we define a layer-local target loss Li. For example, using a MSE loss gives :\nLi(h\u0302i,hi) = ||h\u0302i \u2212 hi(x; \u03b80,iW )|| 2 2. (5)\nIn such a case, Wi is updated locally within its layer via stochastic gradient descent, where h\u0302i is considered as a constant with respect to Wi\nW (t+1) i = W (t) i \u2212 \u03b7fi\n\u2202Li(h\u0302i,hi)\n\u2202Wi = W\n(t) i \u2212 \u03b7fi\n\u2202Li(h\u0302i,hi)\n\u2202hi\n\u2202hi(x; \u03b8 0,i W )\n\u2202Wi . (6)\nIn this context, derivatives can be used within a local layer because they typically correspond to computation performed inside each neuron. The severe non-linearity that may originate from the chain rule arises mostly when it is applied through many layers. This motivates target propagation methods to serve as alternative credit assignment in the context of a composition of many nonlinearities. What a target propagation method requires is a way to compute the target h\u0302i\u22121 from the higher-level target h\u0302i and from hi, such that it is likely to respect the constraint defined by Eq.4 and at least satisfies weaker assumptions, like for example :\nLi(h\u0302i, fi(h\u0302i\u22121)) < Li(h\u0302i, fi(hi\u22121)) (7)"}, {"heading": "2.2 HOW TO ASSIGN A PROPER TARGET TO EACH LAYER", "text": "The problem of credit assignment is the following: how should each unit change its output so as to increase the likelihood of reducing the global loss?\nWith the back-propagation algorithm, we compute the gradient of the loss with respect to the output of each layer, and we can interpret that gradient as an error signal. That error signal is propagated recursively from the top layer to the bottom layer using the chain rule.\n\u03b4hi\u22121 = \u2202L\n\u2202hi\u22121 =\n\u2202L\n\u2202hi \u2202hi \u2202hi\u22121 = \u03b4hi \u2202hi \u2202hi\u22121\n(8)\nIn the target-prop setting, the signal that gives the direction for the update is the difference h\u0302 \u2212 h. So we can rewrite the first and the last terms of the previous equation and we get :\nh\u0302i\u22121 \u2212 hi\u22121 = (h\u0302i \u2212 hi) \u2202hi \u2202hi\u22121 = \u22121 2 \u2202||h\u0302i \u2212 hi||22 \u2202hi\u22121\n(9)\nStill in the target-prop framework, the parameter update at a specific layer is obtain by a stochastic gradient descent (sgd) step to minimize the layer wise cost and can be written :\nW (t+1) i = W (t) i \u2212 \u03b7 \u2202||h\u0302i \u2212 hi||22 \u2202Wi\n(10)\nWith back-propagation to compute the gradients at each layer, we can consider that the target of a lower layer is computed from the target of an upper layer as if gradient descent had been applied (non-parametrically) to the layer\u2019s activations, such that Li(h\u0302i, fi(h\u0302i\u22121)) < Li(h\u0302i, fi(hi\u22121)). This could be called \u201ctarget propagation through optimization\u201d and reminiscent of (CarreiraPerpinan and Wang, 2014).\nHowever, in order to avoid the chain of derivatives through many layers, another option, introduced in (Bengio, 2014), is to take advantage of an \u201capproximate inverse\u201d. For example, suppose that we have a function gi such that fi(gi(h\u0302i)) \u2248 h\u0302i, (11) then choosing h\u0302i\u22121 = gi(h\u0302i) would have the consequence that the level i loss Li (to make the output match the target at level i) would be minimized. This is the vanilla target propagation introduced in (Bengio, 2014):\nh\u0302i\u22121 = gi(h\u0302i) (12)\nNote that gi does not need to invert fi everywhere, only in the vicinity of the targets. If the feedback mappings were the perfect inverses of the feed-forward mappings (gi = f\u22121i ), we would get directly\nLi(h\u0302i, fi(h\u0302i\u22121)) = Li(h\u0302i, fi(gi(h\u0302i))) = Li(h\u0302i, h\u0302i) = 0. (13)\nThis would be ideal for target propagation. In fact, we have the following proposition for the case of a perfect inverse:\nProposition 1. Assume that gi is a perfect inverse of fi, where gi = f\u22121i , i = 1, ...,M \u2212 1 and fi satisfies: 1. fi is a linear mapping or, 2. hi = fi(hi\u22121) = Wisi(hi\u22121), which is another way to obtain a non-linear deep network structure (here si can be any differentiable monotonically increasing element-wise function). Consider one update for both target propagation and back-propagation, with the target propagation update (with perfect inverse) in ith layer being \u03b4W tpi , and the backpropagation update being \u03b4W bpi . Then the angle \u03b1i between \u03b4W tp i and \u03b4W bp i is bounded by\n0 \u2264 \u03b1i \u2264 cos\u22121( \u03bbmin \u03bbmax ) (14)\nHere \u03bbmax and \u03bbmin are the largest and smallest singular values of (JfM\u22121 . . . Jfi+1) T , where Jfk is the Jacobian matrix of fk.\nSee proof in Appendix A1. Proposition 1 says that if fi has the assumed structures, the descent direction of target propagation with perfect inverse at least partly matches with the gradient descent direction, which makes the global loss always decrease. But a perfect inverse may be impractical for computational reasons and unstable (there is no guarantee that f\u22121i applied to a target would yield a value that is in the domain of fi\u22121). So here we prefer to learn an approximate inverse gi, making the fi / gi pair look like an auto-encoder. This suggests parametrizing gi as follows:\nh\u0302i\u22121 = gi(h\u0302i) = si(Vihi), i = 0, ...,M (15)\nwhere si is a non-linearity associated with the decoder and Vi the matrix of feedback weights for layer i. With such a parametrization, it is unlikely that the auto-encoder will achieve zero reconstruction error. The decoder could be trained via an additional auto-encoder-like loss at each layer:\nLinvi = ||fi(gi(h\u0302i))\u2212 h\u0302i||22 (16)\nThis makes fi(h\u0302i\u22121) closer to h\u0302i, thus making Li(h\u0302i, fi(h\u0302i\u22121)) closer to zero. But we should get inverse mapping around the targets. This could help to compute targets which have never been seen before. For this, we can modify inverse loss using noise injection.\nLinvi = ||fi(gi(h\u0302i + ))\u2212 (h\u0302i + )||22, \u223c N(0, \u03c3) (17)\nHowever, the imperfection of the inverse yields severe optimization problems which has brought us to propose the following linearly corrected formula for the target propagation:\nh\u0302i\u22121 \u2212 hi\u22121 = gi(h\u0302i)\u2212 gi(hi) (18)\nWe call this variant \u201cdifference target propagation\u201d and we found in the experiments described below that it can significantly reduce the optimization problems associated with Eq. 12. Note that if gi was an inverse of fi, then difference target propagation would be equivalent to the vanilla target propagation of Eq. 12. For the \u201cdifference target propagation\u201d, we have following proposition:\nProposition 2. During the t + 1 th update in difference target propagation, we use Linvi (h\u0302 (t) i +\n;Vi,W (t) i ) to update V (t+1) i and we define L\u0304 inv i (Vi,W (t) i ) as the expected local auto-encoder-like\nloss function over all possible h\u0302(t)i + with W (t) i fixed,\nL\u0304invi (Vi,W (t) i ) = E\nh\u0302 (t) i ,\n{Linvi (h\u0302 (t) i + ;Vi,W (t) i )} (19)\n1In the arXiv version of this paper.\nIf 1.L\u0304invi (Vi,W (t) i ) has only one minimum with optimal V \u2217 i (W (t) i ); 2. proper learning rates for Vi and Wi are given; 3. All the Jacobian and Hessian like matrices are bounded during learning; 4. \u2207ViL\u0304invi (Vi,W (t) i ) always points towards optimal V \u2217 i (W (t) i ); 5. E{V \u2217i (W (t+1) i ) \u2212 V \u2217i (W (t) i ) | W (t) i } = 0. Then V (t) i \u2212 V \u2217i (W (t) i ) will almost surely converge to 0 at t th update when t goes to infinity. Condition 1, 2, 4 follow the settings of stochastic gradient descent convergence similar to (Bottou, 1998).\nSee proof in Appendix2. Proposition 2 says that in difference target propagation, gi can learn a good approximation of fi\u2019s inverse, which will quickly minimize the auto-encoder-like error of each layer.\nThe top layer does not have a layer above it and it has its own loss function which is also the global loss function. In our experiments we chose to set the first target of the target-prop chain such that L(h\u0302M\u22121) < L(hM\u22121). This can be achieved for classification loss as follows:\nh\u0302M\u22121 = hM\u22121 \u2212 \u03b70 \u2202L\n\u2202hM\u22121 (20)\nwhere \u03b70 is a \u201ctarget-prop\u201d learning rate for making the first target \u2013 i.e. one of the hyper-parameters. Making the first target at layer M \u22121 with the specific output and loss function instead of the output layer can reduce algorithm\u2019s dependence on specific type of output and loss function. So we can apply consistent formulation to compute target in lower layers. And then, once we have a method to assign proper targets to each layer, we only have to optimize layer-local target losses to decrease global loss function."}, {"heading": "2.3 THE ADVANTAGE OF DIFFERENCE TARGET PROPAGATION", "text": "In order to make optimization stable in target propagation, hi\u22121 should approach to h\u0302i\u22121 as hi approaches to h\u0302i . If not, even though optimization is finished in upper layers, the weights in lower layers would continue to be updated. As a result, the target losses in upper layers as well as the global loss can increase even after we reach the optimum situation. So we found the following condition to greatly improve the stability of the optimization.\nhi = h\u0302i \u2192 hi\u22121 = h\u0302i\u22121 (21) If we have the perfect inverse gi = f\u22121i , it holds with vanilla target propagation because\nhi\u22121 = f \u22121 i (hi) = gi(h\u0302i) = h\u0302i\u22121. (22)\nAlthough it is not guaranteed with an imperfect inverse mapping gi 6= f\u22121i in vanilla target propagation, with difference target propagation, it naturally holds by construction.\nh\u0302i\u22121 \u2212 hi\u22121 = gi(h\u0302i)\u2212 gi(hi) (23)\nMore precisely, we can show that the when the input of a layer become the target of lower layer computed by difference target propagation, the output of the layer moves toward the side of its target\nfi(h\u0302i\u22121) = fi(hi\u22121 + gi(h\u0302i)\u2212 gi(hi)) \u223c hi + f \u2032i(hi\u22121)g\u2032i(hi)(h\u0302i \u2212 hi) (24)\n(h\u0302i \u2212 hi)T (fi(h\u0302i\u22121)\u2212 hi) \u223c (h\u0302i \u2212 hi)T f \u2032i(hi\u22121)g\u2032i(hi)(h\u0302i \u2212 hi)) > 0 (25) if h\u0302i \u223c hi and f \u2032i(hi\u22121)g\u2032i(hi) = (fi(gi(hi)))\u2032 is positive definite. It is far more flexible condition than the perfect inverseness. Even when gi is a random mapping, this condition can be satisfied. Actually, if fi and gi are linear mappings and gi has a random matrix, difference target propagation is equivalent to feedback alignment (Lillicrap et al., 2014) which works well on many datasets. As a target framework, we also can show that the output of the layer get closer to its target\n||h\u0302i \u2212 fi(h\u0302i\u22121)||22 < ||h\u0302i \u2212 hi||22 (26) if h\u0302i \u223c hi and the maximum eigenvalue of (I \u2212 f \u2032i(hi\u22121)g\u2032i(hi))T (I \u2212 f \u2032i(hi\u22121)g\u2032i(hi)) is less than 1 because h\u0302i \u2212 fi(h\u0302i\u22121) \u223c [I \u2212 f \u2032i(hi\u22121)g\u2032i(hi)](h\u0302i \u2212 hi) . Moreover, as gi approaches to f \u22121 i , this approaches to vanilla target propagation formula in (Bengio, 2014). gi(hi) \u223c hi\u22121 \u2192 h\u0302i\u22121 = hi\u22121 \u2212 gi(hi) + gi(h\u0302i) \u223c gi(h\u0302i) (27)\n2In the arXiv version of this paper."}, {"heading": "3 EXPERIMENTS", "text": ""}, {"heading": "3.1 VERY DEEP NETWORKS", "text": "As a primary objective, we investigated whether one can train ordinary deep networks on the MNIST dataset. The network has 7 hidden layers and the number of hidden units is 240. The activation function is the hyperbolic tangent (tanh). we use RMSprop as a adaptive learning rate algorithm because we do not have a global loss to optimize. Instead, we have the local layer-wise target losses that might need their learning rates to be on different scales (this is actually what we find when we do hyper-parameter optimization over the separate learning rates for each layer). To get this result, we chose the optimal hyper-parameters for the best training cost using random search. And the weights are initialized with orthogonal random matrices.\nTo improve optimization results, layers are updated one at a time from the bottom layer to the top layer, thus avoiding issues with the current input of each layer being invalid if we update all layers at once.\nAs a baseline, back-propagation with RMSprop is used. The same weight initialization and adaptive learning rate and hyper-parameter searching method are used as with target-prop. We report our results in figure 1. We got test error 1.92% in target propagation, 1.88% in back propagation. And we got negative log-likelihood 3.38\u00d7 10\u22126 in target propagation, 1.81\u00d7 10\u22125 in back propagation. These results are averaged over 5 trials using chosen hyper-parameters."}, {"heading": "3.2 NETWORKS WITH DISCRETIZED TRANSMISSION BETWEEN UNITS", "text": "As an example of extremely non-linear networks, we investigated whether one can train even discrete networks on the MNIST dataset. The network architecture is 784-500-500-10 and only the 1st hidden layer is discretized. Instead of just using the step activation function, we have normal neural layers with tanh, and signals are discretized when transporting between layer 1 and layer 2, based on biological considerations and the objective of reducing the communication cost between neurons.\nh1 = f1(x) = tanh(W1x) (28)\nh2 = f2(h1) = tanh(W2sign(h1)) (29)\np(y|x) = f3(h2) = softmax(W3h2) (30) where sign(x) = 1 if x > 0, 0 if x \u2264 0. We also use feedback mapping with inverse loss. But in this case, we cannot optimize full auto-encoding loss because it is not differentiable. Instead, we can use only reconstruction loss given the input and the output of feed-forward mapping.\ng2(h2) = tanh(V2sign(h2)) (31)\nLinv2 = ||g2(f2(h1 + ))\u2212 (h1 + )||22, \u223c N(0, \u03c3) (32)\nIf only feed-forward mapping is discrete, we can train the network using back-propagation with biased gradient estimator as if we train continuous networks with tanh. However, if training signals also should be discrete, it is very hard to train using back-propagation. So we compare our result to two backprop baselines. One baseline is to train the discrete networks directly so we cannot trainW1 using backprop. It still can make training error be zero but we cannot learn any meaningful representation on h1, so test error is poor in Figure 3 (left). Another baseline is to train continuous-activation networks with tanh and to test with the discrete networks (that is, indirect training). Though the estimated gradient is biased so training error does not converge to zero, generalization performance is fairly good, as seen in Figure 2 (right), 3 (left).\nHowever, with target propagation, because we can learn an inverse mapping with a discrete layer and we do not use derivatives through layers, we can successfully train discrete networks directly. Though training convergence is slower, training error approaches zero, unlike the biased gradient estimator with backprop and continuous networks. The remarkable thing is that test error is comparable to biased gradient estimator with backprop and continuous networks. We can train W1 properly, that is, training signals can go across the discrete region successfully. Of course, as shown on the figure, the generalization performance is much better than the vanilla backprop baseline."}, {"heading": "3.3 STOCHASTIC NETWORKS", "text": "Another interesting learning problem which backprop cannot deal with well is stochastic networks with discrete units. Recently such networks have attracted attention (Bengio, 2013; Tang and Salakhutdinov, 2013; Bengio et al., 2013) because a stochastic network can learn a multi-modal conditional distribution P (Y |X), which is important for structured output predictions. Training networks of stochastic binary units is also motivated from biology, i.e., they resemble networks of spiking neurons. Here, we investigate whether one can train networks of stochastic binary units on MNIST for classification using target propagation. Following Raiko et al. (2014), the network architecture is 784-200-200-10 and the hidden units are stochastic binary units with the probability of turning on given by a sigmoid activation.\nhpi = \u03c3(Wihi\u22121), hi = sample(h p i ) (33)\nwhere sample(p) is a binary random variable which is 1 with probability p.\nAs a baseline, we consider a biased gradient estimator in which we do back-propagation as if it were just continuous sigmoid networks. This baseline showed the best performance in Raiko et al. (2014).\n\u03b4hpi\u22121 = \u03b4h p i \u2202hpi \u2202hpi\u22121 \u223c \u03c3\u2032(Wihi\u22121)WTi \u03b4h p i (34)\nIn target propagation, we can train this network directly.\nh\u0302p2 = h p 2 \u2212 \u03b7\n\u2202L\n\u2202h2 , h\u0302p1 = h p 1 + g2(h\u0302 p 2)\u2212 g2(h p 2) (35)\ngi(h p i ) = tanh(Vih p i ), L inv i = ||gi(fi(hi\u22121 + ))\u2212 (hi\u22121 + )||22, \u223c N(0, \u03c3) (36)\nUsing layer-local target losses Li = ||h\u0302pi \u2212 h p i ||22, we can update all the weights.\nWe obtained a test error of 1.51% using target propagation and 1.71% using the baseline method. In the evalution, we averaged the output probabilities of an example over 100 noise samples, and then classify the example accordingly, following Raiko et al. (2014) This suggests that target propagation can directly deal with networks of binary stochastic units."}, {"heading": "3.4 BACKPROP-FREE AUTO-ENCODER", "text": "Auto-encoders are interesting building blocks for learning representations, especially deep ones (Erhan et al., 2010). In addition, as we have seen, training an auto-encoder is also part of what is\nrequired for target propagation according to the approach presented here, in order to train the feedback paths that propagate the targets. We show here how a regularized auto-encoder can be trained using difference target propagation, without backprop.\nLike in the work on denoising auto-encoders (Vincent et al., 2010) and Generative Stochastic Networks (Bengio et al., 2014), we consider the denoising auto-encoder like a stochastic network with noise injected in input and hidden units, trained to minimize a reconstruction loss.\nh = f(x) = sigm(Wx + b) (37)\nz = g(h) = sigm(WT (h + ) + c), \u223c N(0, \u03c3) (38)\nL = ||z\u2212 x||22 + ||f(x + )\u2212 h||22, \u223c N(0, \u03c3) (39)\nwhere we also use regularization to obtain contractive mappings. In order to train this network without backprop (that is, chain rule), we can use difference target propagation. At first, the target of z is just x, so we can train reconstruction mapping g with Lg = ||g(h) \u2212 x||22 in which h is considered as a constant. And then, we compute the target h\u0302 of hidden units following difference target propagation.\nh\u0302 = h + f(z\u0302)\u2212 f(z) = 2h\u2212 f(z) (40)\nwhere f is used as a inverse mapping of g without additional functions, and f(z\u0302) = f(x) = h. As a target loss for the hidden layer, we can use Lf = ||f(x + ) \u2212 h\u0302||22 in which regularization for contractive mapping is also incorporated and h\u0302 is considered as a constant. Using layer-local target losses Lf and Lg , we train on MNIST a denoising auto-encoder whose architecture is 784- 1000-784. Stroke-like filters can be obtained (See Figure 4) and after supervised fine-tuning (using backprop), we get 1.35% test error. That is, our auto-encoder can train a good initial representation as good as the one obtained by regularized auto-encoders trained by backprop on the reconstruction error."}, {"heading": "ACKNOWLEDGMENTS", "text": "We would like to thank Junyoung Chung for providing RMSprop code, Caglar Gulcehre for general discussion and feedback, Jyri Kivinen for discussion of backprop-free auto-encoder, Mathias Berglund for explanation of his stochastic networks. We thank the developers of Theano (Bergstra et al., 2010; Bastien et al., 2012), a Python library which allowed us to easily develop a fast and optimized code for GPU. We also thank the developers of Pylearn2 (Goodfellow et al., 2013), a Python library built on the top of Theano which allowed us to easily interface the data sets with our Theano code. We are also grateful for funding from NSERC, the Canada Research Chairs, Compute Canada, and CIFAR."}, {"heading": "A PROOF OF PROPOSITION 1", "text": "Proof. During one update, the training sample is (x,y), with assumed fi we have:\nhi = fi(hi\u22121) = Wisi(hi\u22121), i = 1, . . . ,M (A-1)\nHere si is identity element-wise function if fi is linear mapping. According to the loss function in section 2.1, the back-propagation update \u03b4W bpi is then\n\u03b4W bpi = \u2212\u03b7bp \u2202L(x,y; \u03b80,MW )\n\u2202Wi\n= \u2212\u03b7bp( \u2202hi+1 \u2202hi )T . . . ( \u2202hM\u22121 \u2202hM\u22122 )T \u2202loss(hM , y) \u2202hM\u22121 (si(hi\u22121)) T\n= \u2212\u03b7bpJTfi+1 . . . J T fM\u22121\n\u2202loss(hM , y)\n\u2202hM\u22121 (si(hi\u22121))\nT (A-2)\nwhere Jfk =\n\u2202hk \u2202hk\u22121 = Wi \u00b7 S\u2032i(hk\u22121), k = i+ 1, . . . ,M \u2212 1 (A-3)\nS\u2032i(hk\u22121) is a diagonal matrix with each diagonal element being corresponding element-wise derivatives and Jfk is the Jocobian matirx of fk(hk\u22121) with respect to hi\u22121.\nTarget propagation update is more complicated. For layer M \u22121, as mentioned in the end of section 2.2, target h\u0302M\u22121 of hM\u22121 is assigned by\nh\u0302M\u22121 = hM\u22121 \u2212 \u03b70 \u2202loss(hM , y)\n\u2202hM\u22121 (A-4)\nIf all hks are allocated in smooth areas and \u03b70 is sufficiently small, then the target h\u0302i in layer i is achieved by perfect inverse gk = f\u22121k , k = i+ 1, . . . ,M \u2212 1 that\nh\u0302i = gi+1(. . . gM\u22121(h\u0302M\u22121) . . . )\n= gi+1(. . . gM\u22121(hM\u22121) . . . )\u2212 \u03b70Jgi+1 . . . JgM\u22121 \u2202loss(hM , y)\n\u2202hM\u22121 + o(\u03b720)\n' hi \u2212 \u03b70J\u22121fi+1 . . . J \u22121 fM\u22121\n\u2202loss(hM , y)\n\u2202hM\u22121 (A-5)\nNow for target propagation update \u03b4W tpi we have\n\u03b4W bpi = \u2212\u03b7tp \u2202||hi(hi\u22121;Wi)\u2212 h\u0302i||22\n\u2202Wi\n= \u2212\u03b7tp(hi \u2212 (hi \u2212 \u03b70J\u22121fi+1 . . . J \u22121 fM\u22121\n\u2202loss(hM , y)\n\u2202hM\u22121 ))(si(hi\u22121))\nT\n= \u2212\u03b7\u0303tpJ\u22121fi+1 . . . J \u22121 fM\u22121\n\u2202loss(hM , y)\n\u2202hM\u22121 (si(hi\u22121))\nT (A-6)\nhere \u03b7\u0303tp = \u03b7tp \u00b7 \u03b70 and we write \u2202loss(hM ,y)\u2202hM\u22121 as l and si(hi\u22121) as v for short. Since \u03b4W bp i and \u03b4W tp i are in matrix form, the inner production of their vector forms vec(\u03b4W bpi ) and vec(\u03b4W tp i ) is\n\u3008vec(\u03b4W bpi ), vec(\u03b4W tp i )\u3009 = tr((\u2212\u03b7bpJ T fi+1 . . . J T fM\u22121 lv T )T (\u2212\u03b7\u0303tpJ\u22121fi+1 . . . J \u22121 fM\u22121 lvT ))\n= \u03b7bp\u03b7\u0303tptr(vlTJfM\u22121 . . . Jfi+1J \u22121 fi+1 . . . J\u22121fM\u22121 lv T )\n= \u03b7bp\u03b7\u0303tptr(vlT lvT ) = \u03b7bp\u03b7\u0303tp||v||22 \u00b7 ||l||22 (A-7)\nAlso for ||vec(\u03b4W bpi )||22 and ||vec(\u03b4W tp i )||22 we have\n||vec(\u03b4W bpi )|| 2 2 = tr((\u2212\u03b7bpJTfi+1 . . . J T fM\u22121 lv T )T (\u2212\u03b7bpJTfi+1 . . . J T fM\u22121 lv T ))\n= \u03b72bptr(v((JfM\u22121 . . . Jfi+1) T l)T ((JfM\u22121 . . . Jfi+1) T l)vT )\n= \u03b72bp||v||22 \u00b7 ||(JfM\u22121 . . . Jfi+1)T l||22 \u2264 \u03b72bp||v||22 \u00b7 ||(JfM\u22121 . . . Jfi+1)T ||22 \u00b7 ||l||22 (A-8)\nand similarly,\n||vec(\u03b4W tpi )|| 2 2 \u2264 \u03b7\u03032tp||v||22 \u00b7 ||(JfM\u22121 . . . Jfi+1)\u22121||22 \u00b7 ||l||22 (A-9)\nhere ||(JfM\u22121 . . . Jfi+1)T ||2 and ||(JfM\u22121 . . . Jfi+1)\u22121||2 are Euclidian norms, i.e. the largest singular value of (JfM\u22121 . . . Jfi+1) T , \u03bbmax, and the largest singular value of (JfM\u22121 . . . Jfi+1) \u22121, 1\u03bbmin (\u03bbmin is the smallest singular value of (JfM\u22121 . . . Jfi+1) T , because fk is invertable, so all the smallest singular values of Jacobians are larger than 0). Finally, the angle \u03b1i between vec(\u03b4W bp i ) and vec(\u03b4W tpi ) satisfies:\ncos(\u03b1i) = \u3008vec(\u03b4W bpi ), vec(\u03b4W tp i )\u3009\n||vec(\u03b4W bpi )||2 \u00b7 ||vec(\u03b4W tp i )||2\n\u2265 \u03b7bp\u03b7\u0303tp||v|| 2 2 \u00b7 ||l||22\u221a \u03b72bp||v||22 \u00b7 \u03bb2max \u00b7 ||l||22 \u221a \u03b7\u03032bp||v||22 \u00b7 (\n1 \u03bb2min ) \u00b7 ||l||22\n= \u03bbmin \u03bbmax\n(A-10)\nwe have 0 \u2264 \u03b1i \u2264 cos\u22121( \u03bbmin\u03bbmax ), where \u03b1i \u2265 0 is trivial."}, {"heading": "B PROOF OF PROPOSITION 2", "text": "Proof. Let us first give detail explanation for condition 2, 3, 4. For condition 2, proper learning rates \u03b7v and \u03b7w satisfy\n\u221e\u2211 t=1 \u03b7(t)v (\u03b7 (t) w ) = +\u221e, \u221e\u2211 t=1 (\u03b7(t)v ) 2((\u03b7(t)w ) 2) < +\u221e (A-11)\nNote that the the beginning learning rate \u03b7(1)v (\u03b7 (1) w ) can be assigned as 1n0 to be sufficiently small to satisfy locally smooth condition if needed. Condition 3 basically says that the norm of first order terms like\u2207ViLinvi (h\u0302i+ ;Vi,Wi) and\u2207WiLi(Wi) which are special cases of Jacobians, and eigenvalues of second order terms like \u2202 2Linvi (h\u0302i+ ;Vi,Wi)\n\u2202V 2i , \u2202 2Linvi (h\u0302i+ ;Vi,Wi) \u2202Vi\u2202Wi\nare bounded. Codition 4 is equavilent to the following\n\u2200\u03b5 > 0, inf ||Vi\u2212V \u2217i (W (t) i )||2>\u03b5 (Vi \u2212 V \u2217i (W (t) i )) T\u2207ViL\u0304invi (Vi,W (t) i ) > 0 (A-12)\nabove condition basically says that oppoite of the gradient \u2212\u2207ViL\u0304invi (Vi,W (t) i ) always at least partly points towards its minimum with optimal V \u2217i (W (t) i ).\nNote that in the following proof, all Vis and Wis are in vector form. V (t) i and W (t) i follow their update rules like\nV (t+1) i = V (t) i \u2212 \u03b7 (t) v \u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i ) (A-13)\nW (t+1) i = W (t) i \u2212 \u03b7 (t) w \u03b4W (t) i (A-14)\n\u03b4W (t) i respects to\u2207WiLi(Wi) in difference target propagation. We define \u03b3t that\n\u03b3t = ||V (t)i \u2212 V \u2217 i (W (t) i )|| 2 2 (A-15)\nThe \u03b3t measures how far the current V (t) i is from the optimum. During the learning process, the randomness is only introduced by every update\u2019s sample (x,y) and the used in updating Vi. We care about whether \u03b3t converges and we check the following conditional expcation\nE{\u03b3t+1 \u2212 \u03b3t | V (t)i ,W (t) i }\n= E{||V (t)i \u2212 \u03b7 (t) v \u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )\u2212 V \u2217 i (W (t+1) i )|| 2 2\n\u2212||V (t)i \u2212 V \u2217 i (W (t) i )|| 2 2 | V (t) i ,W (t) i }\n= \u22122\u03b7(t)v (V (t) i \u2212 V \u2217 i (W (t) i )) T E h\u0302\n(t) i ,\n{\u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )}\n+(\u03b7(t)v ) 2 E h\u0302\n(t) i ,\n{||\u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )|| 2 2}\n+2(V (t) i \u2212 V \u2217 i (W (t) i )) TE{V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i ) |W (t) i } (A-16)\n\u22122\u03b7(t)v E h\u0302\n(t) i ,\n{(\u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )) T (V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i ) |W (t) i }\n+E{||V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i )|| 2 2 |W (t) i }\n= \u22122\u03b7(t)v (V (t) i \u2212 V \u2217 i (W (t) i )) T\u2207ViL\u0304invi (V (t) i ,W (t) i ) (A-17)\n+(\u03b7(t)v ) 2 E h\u0302\n(t) i ,\n{||\u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )|| 2 2} (A-18)\n\u22122\u03b7(t)v E h\u0302\n(t) i ,\n{(\u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )) T (V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i ) |W (t) i }(A-19)\n+E{||V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i )|| 2 2 |W (t) i } (A-20)\nWe can see that term (A-16) is cancelled by condition 5. In term (A-18), because the norm of \u2207ViLinvi (h\u0302i + ;Vi,Wi) is bounded by some non-negative constant \u03b1v , we have\nE h\u0302i,\n{||\u2207ViLinvi (h\u0302i + ;Vi,W (t) i )|| 2 2} \u2264 \u03b12v (A-21)\nLet us check term (A-19) and term (A-20) where both of them have the term\n\u2206\u2217 = V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i ) (A-22)\nBecause V \u2217i (W (t) i ) is the optimum minimizing L\u0304 inv i (Vi,W (t) i ), we have\n0 = \u2207ViL\u0304invi (V \u2217i (W (t) i ),W (t) i )\n= \u2207ViL\u0304invi (V \u2217i (W (t+1) i ),W (t+1) i )\n= \u2207ViL\u0304invi (V \u2217i (W (t) i )\u2212\u2206 \u2217,W (t) i \u2212 \u03b7 (t) w \u03b4W (t) i ) (A-23)\nIf the learning rate for Vi and Wi is small enough with local smoothness satisfied, we can transform Eq.A-23 like\n0 = \u2212\u2202 2L\u0304invi (Vi,Wi)\n\u2202V 2i \u2206\u2217 \u2212 \u03b7(t)w\n\u22022L\u0304invi (Vi,Wi)\n\u2202Vi\u2202Wi \u03b4W\n(t) i + o(||\u2206 \u2217||22) + o(||\u03b7(t)w \u03b4W (t) i || 2 2) (A-24)\nHere ||o(||\u2206\u2217||22)||2 \u2264 \u03b5\u2206||\u2206\u2217||2 and ||o(||\u03b7 (t) w \u03b4W (t) i ||22)||2 \u2264 \u03b5w||\u03b7 (t) w \u03b4W (t) i ||2 for local smoothness. With the fact that all the second order terms are bounded, based on Eq.A-24 we have\n||\u2206\u2217||2 \u2264 \u03b1\u2206\u03b7(t)w ||\u03b4W (t) i ||2 (A-25)\nHere \u03b1\u2206 is some non-negative constant. Further more, because the first order term of Wi like \u2207WiLi(Wi) is also bounded, we have\n||\u03b4W (t)i ||2 \u2264 \u03b1w (A-26)\nHere \u03b1w is some non-negative constant. Now for term (A-19) we have\n| E h\u0302\n(t) i ,\n{(\u2207ViLinvi (h\u0302 (t) i + ;Vi,W (t) i )) T (V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i ) |W (t) i }| \u2264 \u03b1\u2206\u03b1v\u03b1w\u03b7 (t) w (A-27)\nand the absolute value of the entire term (A-19) is then bounded by\n2\u03b1\u2206\u03b1v\u03b1w\u03b7 (t) w \u03b7 (t) v (A-28)\nBased on Cauthy-Schwarz inequality, \u03b7(t)w \u03b7 (t) v satisfies\n( N\u2211 t=1 \u03b7(t)w \u03b7 (t) v ) 2 \u2264 ( N\u2211 t=1 (\u03b7(t)w ) 2)( N\u2211 t=1 (\u03b7(t)v ) 2) (A-29)\nFrom the learning rates condition, we know that\nlim N\u2192\u221e N\u2211 t=1 (\u03b7(t)w ) 2((\u03b7(t)v ) 2) < +\u221e (A-30)\nBecause \u03b7(t)w and \u03b7 (t) v are positive, then we can easily have\nlim N\u2192\u221e N\u2211 t=1 \u03b7(t)w \u03b7 (t) v < +\u221e (A-31)\nFor term (A-20) we have\nE{||V \u2217i (W (t) i )\u2212 V \u2217 i (W (t+1) i )|| 2 2 |W (t) i } \u2264 \u03b1 2 \u2206\u03b1 2 w(\u03b7 (t) w ) 2 (A-32)\nFinally, E{\u03b3t+1 \u2212 \u03b3t | V (t)i ,W (t) i } satisfies\nE{\u03b3t+1 \u2212 \u03b3t | V (t)i ,W (t) i }\n\u2264 \u22122\u03b7(t)v (V (t) i \u2212 V \u2217 i (W (t) i )) T\u2207ViL\u0304invi (V (t) i ,W (t) i )\n+(\u03b7(t)v ) 2(\u03b1v) 2 + 2\u03b1\u2206\u03b1v\u03b1w\u03b7 (t) w \u03b7 (t) v + \u03b1 2 \u2206\u03b1 2 w(\u03b7 (t) w ) 2\n\u2264 (\u03b7(t)v )2(\u03b1v)2 + 2\u03b1\u2206\u03b1v\u03b1w\u03b7(t)w \u03b7(t)v + \u03b12\u2206\u03b12w(\u03b7(t)w )2 (A-33)\nFrom Eq.A-11 and Eq.A-31, we know that the right side of Eq.A-33 is the summand of a convergent infinite sum. Since process {\u03b3t} always larger than 0, and Eq.A-33 gives the upper bound of positive expected variation of \u03b3t, from Quasi-martingale convergence theorem in section 4.4 of (Bottou, 1998), we have that \u03b3t converges amlost surely. The almost surely convergence of \u03b3t and Eq.A-33 imply that\n\u221e\u2211 t=1 \u03b7(t)v (V (t) i \u2212 V \u2217 i (W (t) i )) T\u2207ViL\u0304invi (V (t) i ,W (t) i ) \u2264 +\u221e, a.s. (A-34)\nHere a.s. means almost surely. With the learning rate \u03b7(t)v satisfies \u221e\u2211 t=1 \u03b7(t)v = +\u221e (A-35)\nand (V (t)i \u2212 V \u2217i (W (t) i )) T\u2207ViL\u0304invi (V (t) i ,W (t) i ) is always positive because of condition 4, we have\nlim t\u2192\u221e\n(V (t) i \u2212 V \u2217 i (W (t) i )) T\u2207ViL\u0304invi (V (t) i ,W (t) i ) = 0, a.s. (A-36)\nAssume that \u03b3t converges to some positive constant rather than 0. It implies that when t is large enough, \u03b3t = ||V (t)i \u2212 V \u2217i (W (t) i )||22 > \u03b5 > 0. This is incompatible with condition 3 and Eq.A-36. Therefore \u03b3t converges to 0 almost surely and we have\nlim t\u2192\u221e\nV (t) i \u2212 V \u2217 i (W (t) i ) = 0, a.s. (A-37)"}], "references": [{"title": "Theano: new features and speed improvements", "author": ["F. Bastien", "P. Lamblin", "R. Pascanu", "J. Bergstra", "I.J. Goodfellow", "A. Bergeron", "N. Bouchard", "Y. Bengio"], "venue": "Deep Learning and Unsupervised Feature Learning NIPS 2012 Workshop.", "citeRegEx": "Bastien et al\\.,? 2012", "shortCiteRegEx": "Bastien et al\\.", "year": 2012}, {"title": "Learning deep architectures for AI", "author": ["Y. Bengio"], "venue": "Now Publishers.", "citeRegEx": "Bengio,? 2009", "shortCiteRegEx": "Bengio", "year": 2009}, {"title": "Estimating or propagating gradients through stochastic neurons", "author": ["Y. Bengio"], "venue": "Technical Report arXiv:1305.2982, Universite de Montreal.", "citeRegEx": "Bengio,? 2013", "shortCiteRegEx": "Bengio", "year": 2013}, {"title": "How auto-encoders could provide credit assignment in deep networks via target propagation", "author": ["Y. Bengio"], "venue": "Technical report, arXiv preprint arXiv:1407.7906.", "citeRegEx": "Bengio,? 2014", "shortCiteRegEx": "Bengio", "year": 2014}, {"title": "Estimating or propagating gradients through stochastic neurons for conditional computation", "author": ["Y. Bengio", "N. L\u00e9onard", "A. Courville"], "venue": "arXiv preprint arXiv:1308.3432.", "citeRegEx": "Bengio et al\\.,? 2013", "shortCiteRegEx": "Bengio et al\\.", "year": 2013}, {"title": "Deep generative stochastic networks trainable by backprop", "author": ["Y. Bengio", "E. Thibodeau-Laufer", "J. Yosinski"], "venue": "ICML\u20192014.", "citeRegEx": "Bengio et al\\.,? 2014", "shortCiteRegEx": "Bengio et al\\.", "year": 2014}, {"title": "Theano: a CPU and GPU math expression compiler", "author": ["J. Bergstra", "O. Breuleux", "F. Bastien", "P. Lamblin", "R. Pascanu", "G. Desjardins", "J. Turian", "D. WardeFarley", "Y. Bengio"], "venue": "Proceedings of the Python for Scientific Computing Conference (SciPy). Oral Presentation.", "citeRegEx": "Bergstra et al\\.,? 2010", "shortCiteRegEx": "Bergstra et al\\.", "year": 2010}, {"title": "Online algorithms and stochastic approximations", "author": ["L. Bottou"], "venue": "Saad, D., editor, Online Learning and Neural Networks. Cambridge University Press, Cambridge, UK. revised, oct 2012.", "citeRegEx": "Bottou,? 1998", "shortCiteRegEx": "Bottou", "year": 1998}, {"title": "Distributed optimization of deeply nested systems", "author": ["M. Carreira-Perpinan", "W. Wang"], "venue": "AISTATS\u20192014, JMLR W&CP, volume 33, pages 10\u201319.", "citeRegEx": "Carreira.Perpinan and Wang,? 2014", "shortCiteRegEx": "Carreira.Perpinan and Wang", "year": 2014}, {"title": "Why does unsupervised pre-training help deep learning? In JMLR W&CP: Proc", "author": ["D. Erhan", "A. Courville", "Y. Bengio", "P. Vincent"], "venue": "AISTATS\u20192010, volume 9, pages 201\u2013208.", "citeRegEx": "Erhan et al\\.,? 2010", "shortCiteRegEx": "Erhan et al\\.", "year": 2010}, {"title": "Pylearn2: a machine learning research library", "author": ["I.J. Goodfellow", "D. Warde-Farley", "P. Lamblin", "V. Dumoulin", "M. Mirza", "R. Pascanu", "J. Bergstra", "F. Bastien", "Y. Bengio"], "venue": "arXiv preprint arXiv:1308.4214.", "citeRegEx": "Goodfellow et al\\.,? 2013", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2013}, {"title": "Deep neural networks for acoustic modeling in speech recognition", "author": ["G. Hinton", "L. Deng", "G.E. Dahl", "A. Mohamed", "N. Jaitly", "A. Senior", "V. Vanhoucke", "P. Nguyen", "T. Sainath", "B. Kingsbury"], "venue": "IEEE Signal Processing Magazine, 29(6):82\u201397.", "citeRegEx": "Hinton et al\\.,? 2012", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "ImageNet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G. Hinton"], "venue": "NIPS\u20192012.", "citeRegEx": "Krizhevsky et al\\.,? 2012", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Learning processes in an asymmetric threshold network", "author": ["Y. LeCun"], "venue": "Fogelman-Souli\u00e9, F., Bienenstock, E., and Weisbuch, G., editors, Disordered Systems and Biological Organization, pages 233\u2013240. Springer-Verlag, Les Houches, France.", "citeRegEx": "LeCun,? 1986", "shortCiteRegEx": "LeCun", "year": 1986}, {"title": "Mod\u00e8les connexionistes de l\u2019apprentissage", "author": ["Y. LeCun"], "venue": "PhD thesis, Universit\u00e9 de Paris VI.", "citeRegEx": "LeCun,? 1987", "shortCiteRegEx": "LeCun", "year": 1987}, {"title": "Random feedback weights support learningin deep neural networks", "author": ["T.P. Lillicrap", "D. Cownden", "D.B. Tweed", "C.J. Akerman"], "venue": "Technical report, arXiv preprint arXiv:1411.0247.", "citeRegEx": "Lillicrap et al\\.,? 2014", "shortCiteRegEx": "Lillicrap et al\\.", "year": 2014}, {"title": "Techniques for learning binary stochastic feedforward neural networks", "author": ["T. Raiko", "M. Berglund", "G. Alain", "L. Dinh"], "venue": "NIPS Deep Learning Workshop 2014.", "citeRegEx": "Raiko et al\\.,? 2014", "shortCiteRegEx": "Raiko et al\\.", "year": 2014}, {"title": "Sequence to sequence learning with neural networks", "author": ["I. Sutskever", "O. Vinyals", "Q.V. Le"], "venue": "Technical report, arXiv preprint arXiv:1409.3215.", "citeRegEx": "Sutskever et al\\.,? 2014", "shortCiteRegEx": "Sutskever et al\\.", "year": 2014}, {"title": "Going deeper with convolutions", "author": ["C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich"], "venue": "Technical report, arXiv preprint arXiv:1409.4842.", "citeRegEx": "Szegedy et al\\.,? 2014", "shortCiteRegEx": "Szegedy et al\\.", "year": 2014}, {"title": "A new learning algorithm for stochastic feedforward neural nets", "author": ["Y. Tang", "R. Salakhutdinov"], "venue": "ICML\u20192013 Workshop on Challenges in Representation Learning.", "citeRegEx": "Tang and Salakhutdinov,? 2013", "shortCiteRegEx": "Tang and Salakhutdinov", "year": 2013}, {"title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude", "author": ["T. Tieleman", "G. Hinton"], "venue": "COURSERA: Neural Networks for Machine Learning,", "citeRegEx": "Tieleman and Hinton,? \\Q2012\\E", "shortCiteRegEx": "Tieleman and Hinton", "year": 2012}, {"title": "Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion", "author": ["P. Vincent", "H. Larochelle", "I. Lajoie", "Y. Bengio", "Manzagol", "P.-A."], "venue": "J. Machine Learning Res., 11.", "citeRegEx": "Vincent et al\\.,? 2010", "shortCiteRegEx": "Vincent et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 1, "context": "Recently, deep neural networks have achieved great success in hard AI tasks (Bengio, 2009; Hinton et al., 2012; Krizhevsky et al., 2012; Sutskever et al., 2014), mostly relying on back-propagation as the main way of performing credit assignment over the different sets of parameters associated with each layer of a deep net.", "startOffset": 76, "endOffset": 160}, {"referenceID": 11, "context": "Recently, deep neural networks have achieved great success in hard AI tasks (Bengio, 2009; Hinton et al., 2012; Krizhevsky et al., 2012; Sutskever et al., 2014), mostly relying on back-propagation as the main way of performing credit assignment over the different sets of parameters associated with each layer of a deep net.", "startOffset": 76, "endOffset": 160}, {"referenceID": 12, "context": "Recently, deep neural networks have achieved great success in hard AI tasks (Bengio, 2009; Hinton et al., 2012; Krizhevsky et al., 2012; Sutskever et al., 2014), mostly relying on back-propagation as the main way of performing credit assignment over the different sets of parameters associated with each layer of a deep net.", "startOffset": 76, "endOffset": 160}, {"referenceID": 17, "context": "Recently, deep neural networks have achieved great success in hard AI tasks (Bengio, 2009; Hinton et al., 2012; Krizhevsky et al., 2012; Sutskever et al., 2014), mostly relying on back-propagation as the main way of performing credit assignment over the different sets of parameters associated with each layer of a deep net.", "startOffset": 76, "endOffset": 160}, {"referenceID": 18, "context": ", consider the recent best ImageNet competition entrants (Szegedy et al., 2014) with 19 or 22 layers \u2013 longer-term dependencies, or stronger non-linearities, the composition of many non-linear operations becomes more non-linear.", "startOffset": 57, "endOffset": 79}, {"referenceID": 13, "context": "This link was nicely made in (LeCun, 1986; 1987), which introduced the idea of target propagation and connected it to back-propagation via a Lagrange multipliers formulation (where the constraints require the output of one layer to equal the input of the next layer).", "startOffset": 29, "endOffset": 48}, {"referenceID": 8, "context": "A similar idea was recently proposed where the constraints are relaxed into penalties, yielding a different (iterative) way to optimize deep networks (Carreira-Perpinan and Wang, 2014).", "startOffset": 150, "endOffset": 184}, {"referenceID": 20, "context": "The results show that the proposed form of target propagation is comparable to back-propagation with RMSprop (Tieleman and Hinton, 2012) - a very popular setting to train deep networks nowadays.", "startOffset": 109, "endOffset": 136}, {"referenceID": 3, "context": "Although many variants of the general principle of target propagation can be devised, this paper focuses on a specific approach, described below, which fixes a problem in the formulation introduced in an earlier technical report (Bengio, 2014).", "startOffset": 229, "endOffset": 243}, {"referenceID": 3, "context": "However, in order to avoid the chain of derivatives through many layers, another option, introduced in (Bengio, 2014), is to take advantage of an \u201capproximate inverse\u201d.", "startOffset": 103, "endOffset": 117}, {"referenceID": 3, "context": "This is the vanilla target propagation introduced in (Bengio, 2014): \u0125i\u22121 = gi(\u0125i) (12)", "startOffset": 53, "endOffset": 67}, {"referenceID": 7, "context": "Condition 1, 2, 4 follow the settings of stochastic gradient descent convergence similar to (Bottou, 1998).", "startOffset": 92, "endOffset": 106}, {"referenceID": 15, "context": "Actually, if fi and gi are linear mappings and gi has a random matrix, difference target propagation is equivalent to feedback alignment (Lillicrap et al., 2014) which works well on many datasets.", "startOffset": 137, "endOffset": 161}, {"referenceID": 3, "context": "Moreover, as gi approaches to f \u22121 i , this approaches to vanilla target propagation formula in (Bengio, 2014).", "startOffset": 96, "endOffset": 110}, {"referenceID": 2, "context": "Recently such networks have attracted attention (Bengio, 2013; Tang and Salakhutdinov, 2013; Bengio et al., 2013) because a stochastic network can learn a multi-modal conditional distribution P (Y |X), which is important for structured output predictions.", "startOffset": 48, "endOffset": 113}, {"referenceID": 19, "context": "Recently such networks have attracted attention (Bengio, 2013; Tang and Salakhutdinov, 2013; Bengio et al., 2013) because a stochastic network can learn a multi-modal conditional distribution P (Y |X), which is important for structured output predictions.", "startOffset": 48, "endOffset": 113}, {"referenceID": 4, "context": "Recently such networks have attracted attention (Bengio, 2013; Tang and Salakhutdinov, 2013; Bengio et al., 2013) because a stochastic network can learn a multi-modal conditional distribution P (Y |X), which is important for structured output predictions.", "startOffset": 48, "endOffset": 113}, {"referenceID": 1, "context": "Recently such networks have attracted attention (Bengio, 2013; Tang and Salakhutdinov, 2013; Bengio et al., 2013) because a stochastic network can learn a multi-modal conditional distribution P (Y |X), which is important for structured output predictions. Training networks of stochastic binary units is also motivated from biology, i.e., they resemble networks of spiking neurons. Here, we investigate whether one can train networks of stochastic binary units on MNIST for classification using target propagation. Following Raiko et al. (2014), the network architecture is 784-200-200-10 and the hidden units are stochastic binary units with the probability of turning on given by a sigmoid activation.", "startOffset": 49, "endOffset": 545}, {"referenceID": 1, "context": "Recently such networks have attracted attention (Bengio, 2013; Tang and Salakhutdinov, 2013; Bengio et al., 2013) because a stochastic network can learn a multi-modal conditional distribution P (Y |X), which is important for structured output predictions. Training networks of stochastic binary units is also motivated from biology, i.e., they resemble networks of spiking neurons. Here, we investigate whether one can train networks of stochastic binary units on MNIST for classification using target propagation. Following Raiko et al. (2014), the network architecture is 784-200-200-10 and the hidden units are stochastic binary units with the probability of turning on given by a sigmoid activation. hpi = \u03c3(Wihi\u22121), hi = sample(h p i ) (33) where sample(p) is a binary random variable which is 1 with probability p. As a baseline, we consider a biased gradient estimator in which we do back-propagation as if it were just continuous sigmoid networks. This baseline showed the best performance in Raiko et al. (2014). \u03b4hpi\u22121 = \u03b4h p i \u2202hpi \u2202hpi\u22121 \u223c \u03c3(Wihi\u22121)W i \u03b4h p i (34)", "startOffset": 49, "endOffset": 1021}, {"referenceID": 16, "context": "In the evalution, we averaged the output probabilities of an example over 100 noise samples, and then classify the example accordingly, following Raiko et al. (2014) This suggests that target propagation can directly deal with networks of binary stochastic units.", "startOffset": 146, "endOffset": 166}, {"referenceID": 16, "context": "The second row shows the results from (Raiko et al., 2014).", "startOffset": 38, "endOffset": 58}, {"referenceID": 16, "context": "In our experiment, we used RMS-prop and maximum epochs is 1000 different from (Raiko et al., 2014).", "startOffset": 78, "endOffset": 98}, {"referenceID": 9, "context": "Auto-encoders are interesting building blocks for learning representations, especially deep ones (Erhan et al., 2010).", "startOffset": 97, "endOffset": 117}, {"referenceID": 21, "context": "Like in the work on denoising auto-encoders (Vincent et al., 2010) and Generative Stochastic Networks (Bengio et al.", "startOffset": 44, "endOffset": 66}, {"referenceID": 5, "context": ", 2010) and Generative Stochastic Networks (Bengio et al., 2014), we consider the denoising auto-encoder like a stochastic network with noise injected in input and hidden units, trained to minimize a reconstruction loss.", "startOffset": 43, "endOffset": 64}], "year": 2017, "abstractText": "Back-propagation has been the workhorse of recent successes of deep learning but it relies on infinitesimal effects (partial derivatives) in order to perform credit assignment. This could become a serious issue as one considers deeper and more non-linear functions, e.g., consider the extreme case of non-linearity where the relation between parameters and cost is actually discrete. Inspired by the biological implausibility of back-propagation, a few approaches have been proposed in the past that could play a similar credit assignment role as backprop. In this spirit, we explore a novel approach to credit assignment in deep networks that we call target propagation. The main idea is to compute targets rather than gradients, at each layer. Like gradients, they are propagated backwards. In a way that is related but different from previously proposed proxies for back-propagation which rely on a backwards network with symmetric weights, target propagation relies on auto-encoders at each layer. Unlike back-propagation, it can be applied even when units exchange stochastic bits rather than real numbers. We show that a linear correction for the imperfectness of the auto-encoders is very effective to make target propagation actually work, along with adaptive learning rates.", "creator": "LaTeX with hyperref package"}}}