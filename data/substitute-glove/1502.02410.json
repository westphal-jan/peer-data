{"id": "1502.02410", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2015", "title": "Out-of-sample generalizations for supervised manifold learning for classification", "abstract": "Supervised separable life purely each user synonym historical technology analyze 238 during a high - constructs ambient space whether though high - geometry domain which only structure - preserving if, while enhancing created separation between different classes in several but embedding. Most numerical internationally subspace learning such compute the embedding of the singularities perhaps saw the since etc. special 6, while the generalization of place homomorphism to romantic climbed, . as it way - of - collected extension instance into symmetric studies, really quite any a classification used. In another work, we propose a quarterfinals - requested computation set building an riccati characteristic that unique provided out - of - sample permit for general demobilization manifold learning visualization theology he following viewpoint of classification. The proposed optimization computes rather radial issue function (RBF) interpolator instead mitigates leading evaluation depending composed from itself 700 microliths error of unlabeled speed testing, probability as their distance may from embeddings followed only differentiable over our own instance, as other recently he diophantine term that controls which subtlety brought the interpolation matrix 20 a direction - remain rather. The class copies of failed embedded to however interpolation formula_8 geometry are estimated jointly long a society procedures. Experimental doubt on face making object photo demonstrate through potential of itself approved out - of - sample full diophantine to during classification of manifold - modeled data..", "histories": [["v1", "Mon, 9 Feb 2015 09:56:57 GMT  (713kb,D)", "http://arxiv.org/abs/1502.02410v1", null]], "reviews": [], "SUBJECTS": "cs.CV cs.LG", "authors": ["elif vural", "christine guillemot"], "accepted": false, "id": "1502.02410"}, "pdf": {"name": "1502.02410.pdf", "metadata": {"source": "CRF", "title": "Out-of-sample generalizations for supervised manifold learning for classification", "authors": ["Elif Vural", "Christine Guillemot"], "emails": ["(elif.vural@inria.fr,", "tine.guillemot@inria.fr)."], "sections": [{"heading": null, "text": "Index Terms\u2014Manifold learning, dimensionality reduction, supervised learning, out-of-sample extensions, pattern classification.\nI. INTRODUCTION\nTHE recovery of low-dimensional structures in data setsnot only allows understanding the data but also provides useful representations for their treatment in several problems. Data classification is among the applications that benefit from the identification of low-dimensional structures in data. Unlike unsupervised manifold learning methods such as [1], [2], [3], which only take the geometric structure of data samples into account when learning a low-dimensional embedding, many recent supervised manifold learning methods seek a representation that not only preserves the manifold structure in each class, but also enhances the separation between different class-representative manifolds in the learned embedding. Meanwhile, an important problem in data classification with supervised manifold learning is the generalization of the learned embedding to novel data samples. In this work, we address the problem of constructing a continuous mapping between the high-dimensional original data space and the low-dimensional space of embedding for data classification applications.\nElif Vural and Christine Guillemot are with Centre de recherche INRIA Rennes - Bretagne Atlantique, France (elif.vural@inria.fr, christine.guillemot@inria.fr).\nSupervised manifold learning methods can be categorized into two groups as linear and nonlinear algorithms. Linear methods such as [4], [5], [6], [7], and [8] learn a linear projection that maps data into a lower-dimensional space such that the proximity of neighboring samples from the same class is preserved, while the distance between samples from different classes is increased. Nonlinear methods such as [9] have a similar classification-driven objective, while the new coordinates of data samples in the low-dimensional space are computed with a nonlinear learning process based on a graph representation of data. As linear dimensionality reduction methods compute a linear projection, they have the advantage that the generalization of the embedding for initially unavailable data samples is immediate and given by the learned linear operator. However, with linear methods samples from different classes are not linearly separable in the learned embedding, unless they are already linearly separable in the original highdimensional space, which is rarely the case. The separation between different classes is an important factor that influences the performance of classification. Nonlinear dimensionality reduction methods achieve a better separation as a result of their relative flexibility in learning the coordinates. In fact, nonlinear methods such as [9], or nonlinear adaptations of the above linear methods, typically learn data representations where different classes become even linearly separable. However, one difficulty of using nonlinear methods is that they compute an embedding only in a pointwise manner, i.e., data coordinates in the low-dimensional domain are computed only for the initially available training data and are not generalizable to the test data in a straightforward way. Hence, an important issue that needs to be addressed in order to benefit from nonlinear manifold learning methods in classification is the generalization of the embedding to novel data samples.\nThe generalization of the learned embedding to new samples is referred to as the out-of-sample extension problem in manifold learning. Several previous works have addressed the outof-sample problem. The study in [10] focuses on the extension of manifold learning methods that compute data coordinates in the form of the eigenvectors of a data kernel matrix. It is shown that in such a setting the Nystro\u0308m method can be used to compute eigenfunctions that coincide with the eigenvectors on the training samples and generalize them to the continuous domain. In fact, the out-of-sample extension with the Nystro\u0308m formula as proposed in [10] can also be derived from the kernel ridge regression framework, by removing the regularization term and imposing the constraint that the data coordinates of training samples be given by the eigenvectors of the data kernel matrix [11]. Next, several out-of-sample extension algorithms rely on the construction of an interpolation function between\nar X\niv :1\n50 2.\n02 41\n0v 1\n[ cs\n.C V\n] 9\nF eb\n2 01\n5\n2 the high- and low-dimensional domains. Some families of interpolation functions used in manifold learning extensions are polynomials [12], sparse linear combinations of functions in a reproducing kernel Hilbert space (RKHS) [11], and sparse grid functions [13]. In [14], the out-of-sample extension of general manifold learning methods is achieved by computing a local projection of the high-dimensional space to the lowdimensional domain with a similarity transformation of the local PCA bases. There are also some extension methods designed for particular manifold learning algorithms. The study in [15] proposes an out-of-sample generalization of the multidimensional scaling (MDS) method, which is based on an interpretation of MDS as a least squares problem. Similarly, the method proposed in [16] presents a generalization for maximum variance unfolding [17].\nMeanwhile, all of the above methods address the out-ofsample extension problem in an unsupervised setting, i.e., no class label information of input data samples is used. In a classification problem, on the other hand, different classes are often assumed to lie on different manifolds, e.g., in a face recognition problem, the face images of each individual form a different manifold, and supervised manifold learning methods map these class-representative manifolds to different manifolds in the low-dimensional domain. Therefore, class labels of data samples and the fact that different classes are concentrated around different low-dimensional structures should be taken into account when constructing an out-of-sample extension for classification applications. Besides this, many of the above unsupervised extension methods are even not applicable in the supervised setting. For instance, the popular Nystro\u0308m extension [10] considers embeddings given by the eigenvectors of a symmetric kernel matrix. Then, in order to embed a novel point, the kernel is evaluated between the novel point and each training point. Meanwhile, in supervised manifold learning, the value of the kernel depends not only on data sample pairs but also on the class labels of the samples. The kernel usually takes positive values for sample pairs from the same class and negative values for those from different classes, e.g., as in [9]. Hence, the Nystro\u0308m method does not have a straightforward generalization for supervised manifold learning.\nIn this paper, we propose a method for constructing outof-sample generalizations of supervised manifold learning algorithms for classification. In order to extend the embedding (learned with any supervised algorithm) to novel points, we compute a radial basis function (RBF) interpolation function from the high-dimensional space to the low-dimensional one. We optimize the parameters of the interpolation function such that it maps initially unavailable test points as close as possible to the embeddings of the manifolds of their own class in the low-dimensional domain. This is achieved with a progressive estimation of the class labels of test points while gradually updating the parameters of the interpolation function at the same time. As the proposed method makes use of test points in the construction of the interpolation function, it can be considered as a semi-supervised solution for obtaining an out-of-sample extension. Another criterion that is taken into account in the optimization of the parameters of the interpolation function is the regularity of the interpolation function. We find that\nthe regularity of the interpolation function can be adjusted by optimizing its scale parameters to minimize a regularization objective, which controls the magnitude of the interpolation function gradient, while allowing sharp directional derivatives to occur only along the class separation boundaries in order to attain an effective separation between different classes. Experimentation on several image data sets shows that the proposed method can be effectively used in the classification of data of intrinsic low dimension. The proposed out-of-sample extension method is general and can be coupled with any supervised manifold learning algorithm.\nThe rest of the paper is organized as follows. In Section II we briefly overview some supervised manifold learning methods and formulate the out-of-sample extension problem. In Section III we describe the proposed method for classification-driven out-of-sample extensions for supervised manifold learning. In Section IV we discuss some aspects of the proposed algorithm, where we analyze its complexity and interpret it within the context of regression. In Section V we present some experimental results and in Section VI we conclude."}, {"heading": "II. OVERVIEW OF MANIFOLD LEARNING", "text": ""}, {"heading": "A. Manifold learning for classification", "text": "Given a set of data samples {xi}Ni=1 \u2282 Rn that reside in a high-dimensional space Rn, manifold learning computes a new representation yi \u2208 Rd in a lower-dimensional domain Rd for each data sample xi. Manifold learning methods generally assume that the samples {xi} come from a model of low intrinsic dimension and search for an embedding that significantly reduces the dimension of the data (d n) while preserving certain geometric properties. Different methods target different objectives in computing the embedding. The ISOMAP method computes an embedding such that Euclidean distances in the low-dimensional domain are proportional to the geodesic distances in the original domain [1], while LLE looks for an embedding that preserves local reconstruction weights of data samples in the original domain [2]. The Laplacian eigenmaps algorithm [3] first constructs a graph from the data samples where nearest neighbors are typically connected with an edge. The graph Laplacian matrix is given by L = D\u2212W , where W is the N\u00d7N weight matrix whose entries are usually computed based on a kernel Wij = K(xi, xj), and D is a diagonal degree matrix given by Dii = \u2211 jWij . The embedding with Laplacian eigenmaps is then learned by solving\nmin Y \u2208RN\u00d7d\ntr(Y TLY ) s.t. Y TDY = I\nwhere I is the identity matrix. The solution to this problem is given by the d eigenvectors corresponding to the smallest nonzero eigenvalues of the generalized eigenvalue problem Lz = \u03bbDz, where the coordinate vector yi for each data sample xi is given by the i-th row of Y . Intuitively, such an embedding seeks data coordinates that have a slow variation on the data graph, i.e., two neighboring points on the graph are mapped to nearby coordinates. There exist linear versions of the Laplacian eigenmaps method as well. The above problem is solved under the constraint that Y be given by a linear\n3 projection of X onto Rd in [18], which is applied to face recognitions problems in [19] and [20].\nRecently, many extensions have been proposed for manifold learning for classification. Most of these methods are supervised adaptations of the Laplacian eigenmaps algorithm. In order to achieve a good separation between the classes, an embedding is sought where data coordinates vary slowly between neighboring samples of the same class and change rapidly between neighboring samples of different classes. The algorithm proposed in [9] formalizes this idea by defining two graphs that respectively capture the within-class and betweenclass neighborhoods. Denoting the weight matrices of these two graphs by Ww and Wb, and the corresponding Laplacians by Lw and Lb, the method seeks an embedding that solves\nmin Y \u2208RN\u00d7d tr(Y TLwY )\u2212 \u00b5 tr(Y TLbY ) s.t. Y TDwY = I (1) where \u00b5 > 0. The method proposed in [21] employs an alternative Fisher-like formulation for the supervised manifold learning problem where the embedding is obtained by solving\nmax z\nzTLbz zTLwz . (2)\nHowever, the problem is solved under the constraint zT = vTX in order to obtain a linear embedding, where X = [x1 . . . xN ] is the n \u00d7 N data matrix and v \u2208 Rn\u00d71 defines a projection. Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22]."}, {"heading": "B. Out-of-sample extensions", "text": "While most manifold learning methods learn the coordinates of only initially available data samples, in many applications including classification, the generalization of the learned embedding to the whole data space is an important problem. Given a set of data samples {xi}Ni=1 \u2282 Rn in the highdimensional ambient space and their corresponding coordinates {yi}Ni=1 \u2282 Rd in a low-dimensional space, the out-ofsample extension problem consists of constructing a mapping f : Rn \u2192 Rd such that f gives the learned embedding f(xi) = yi on the available data samples while generalizing the embedding to all points in Rn.\nA popular out-of-sample generalization algorithm is presented in [10], based on the Nystro\u0308m formula. This method proposes a generalization for manifold learning algorithms that compute the coordinates based on an eigenvalue problem Myk = \u03bbk y\nk, where the symmetric matrix M is given by a data-dependent kernel Mij = M\u0303(xi, xj) and yk is the kth eigenvector of M , which defines the kth dimension of the data coordinates. The exact expression of the kernel matrix M as a function of the weight matrix W depends on the manifold learning algorithm to be generalized, as different algorithms target different objectives. The out-ofsample extension proposed in [10] is then given by the function f(x) = [f1(x) . . . fd(x)], where\nfk(x) = 1\n\u03bbk N\u2211 i=1 yki M\u0303(x, xi) (3)\nand yi = [y1i . . . y d i ] are the coordinates of the embedding of xi in Rd. This defines a continuous function that coincides with the embedding at the initially available points f(xi) = yi. While this popular method provides straightforward generalizations of many manifold learning algorithms such as ISOMAP, LLE, and Laplacian eigenmaps, it cannot be used with most supervised manifold learning methods. The reason is that, although the data kernel matrix M is assumed to be a general symmetric matrix (not necessarily positive semi-definite) in [10], the entries of this matrix in supervised methods are not only dependent on the data samples xi, but also on their class labels. For instance, in (1), the kernel matrix M is a normalized version of the matrix Lw \u2212 \u00b5Lb, which is determined with respect to data class labels. In this case, the Nystro\u0308m formula (3) cannot be applied as M\u0303(x, xi) is not priorly known for a test sample of unknown class.\nSeveral out-of-sample extension methods such as those based on fitting a particular type of interpolation function as in [11], [12], and [13] can be applied for generalizing supervised embeddings by fitting a function f to the priorly learned (xi, yi) pairs. However, as this gives a generalized embedding based only on an approximation objective that does not take into account the class information of data, its classification performance is likely to be suboptimal.\nIn this paper, we propose to learn an interpolation function in an application-aware manner. The proposed method not only makes use of the initially available training samples (xi, yi), but also exploits the test samples of unknown class in the learning, by jointly estimating the interpolation function parameters and the class labels of test samples. We describe this method in Section III."}, {"heading": "III. OUT-OF-SAMPLE EXTENSIONS FOR CLASSIFICATION", "text": ""}, {"heading": "A. Formulation of the out-of-sample problem", "text": "We begin with a formalization of the classification-based out-of-sample extension problem. Let M1,M2, . . .MM \u2282 Rn be M compact manifolds representing M different classes in the original ambient space Rn. Let E be an embedding of the manifolds {Mm} in a lower-dimensional space Rd\nE : \u22c3 m Mm \u2192 Rd\nsuch that each manifold Mm \u2282 Rn is mapped to E(Mm) \u2282 Rd. The restriction of E to each manifold is assumed to be continuous and the embeddings of different manifolds are assumed to be disjoint. We consider that the data samples are drawn from a probability measure \u03bd on Rn such that the samples of each class m are concentrated around the manifold Mm. Let \u03bdm denote the probability measure of class m having a support region Sm in Rn, where Mm \u2282 Sm. We denote by PMm(x) a projection of the point x onto the manifold Mm, which is a point on Mm of minimal distance to x\n\u2016x\u2212 PMm(x)\u2016 = min x\u2032\u2208Mm\n\u2016x\u2212 x\u2032\u2016.\nHere \u2016 \u00b7 \u2016 denotes the usual `2-norm in the Euclidean space. As for the solution set of interpolation functions, we consider a compact set H of differentiable functions from Rn\n4 to R, where f : Rn \u2192 Rd belongs to Hd given by the ddimensional Cartesian product of H. An interpolation function that is suitable for classification should map points x from class m as close as possible to the set E(Mm), so that they can be correctly classified with respect to their representation in Rd. We thus define the embedding error of f with respect to its deviation from the embedding of the projection of a point onto the manifold of its own class. The total embedding error of a function f over all classes is then given by\nE(f) := \u2211 m \u222b Sm \u2016f(x)\u2212 E (PMm(x)) \u20162 d\u03bdm(x). (4) The distributions \u03bdm are usually not explicitly known in practice. In order to avoid overfitting to training data, it is useful to enforce some regularity properties for the interpolation function f . A smoothness constraint can be imposed by controlling the total gradient magnitude. Meanwhile, nonlinear supervised manifold learning methods, whose extensions are targeted in this paper, typically learn a representation where different classes are likely to become linearly separable in the learned embedding. The coordinates defining the embedding are orthogonal when given by the eigenvectors of a symmetric kernel, or \u201cnearly orthogonal\u201d when given by the generalized eigenvalue problem (1). Different groups of classes are then expected to become separable along different dimensions of the learned embedding, which is also easy to confirm experimentally (see, e.g., Figure 3(a)). Thus, when learning an interpolation function f , in order to enhance the separation between different classes, it is desirable to have sufficiently strong derivatives along the directions defining the boundaries of the distributions of different classes in the ambient space, especially for the components fk of f for which the considered classes are separable at dimension k of Rd. This is illustrated in Figure 1. Given a dimension k \u2208 {1, . . . , d}, let\nIk = {(m, p) : max Ek(Mm) < min Ek(Mp) or max Ek(Mp) < min Ek(Mm)}\ndenote the set of indices of manifold pairs whose embeddings are separable at dimension k, where Ek(Mm) denotes the kth dimension of the embedding E(Mm). Let \u2207vfk denote the directional derivative of fk along the direction v. For a point x from class m, let up(x) := (x \u2212 PMp(x))/\u2016x \u2212 PMp(x)\u2016 denote the unit vector corresponding to the direction of projection of x onto the manifold Mp of class p, where p 6= m. Then, we would like to learn an interpolation function f such that the directions along which fk has the strongest derivatives coincide with the directions of the projections of points onto the manifolds of other classes. The total derivative magnitude along the directions of projection onto other classes, normalized by the average derivative magnitude is given by\nD(fk) := \u2211\n(m,p)\u2208Ik\n\u222b Sm \u2225\u2225\u2207up(x) fk(x)\u2225\u2225 Ev\u2016\u2207v fk(x)\u2016 d\u03bdm(x) (5)\nwhere fk is assumed to have nowhere vanishing gradient and Ev\u2016\u2207v fk(x)\u2016 denotes the mean directional derivative magnitude, induced from the overall distribution of data over\nx u v f(x)\nM 1\nM 2\nE (M 1) E (M 2) f 1\nf 2\nFig. 1. Illustration of supervised manifold learning and out-of-sample interpolation. Manifolds M1 and M2 representing two different classes are embedded in a lower-dimensional domain such that they are separable along dimension k = 2, but not along dimension k = 1. The second component f2(x) of the interpolation function f(x) = [f1(x) f2(x) . . . fk(x)] should then have a sufficiently strong directional derivative \u2207uf2(x) along direction u at x, in order to reinforce the separation achieved by the supervised embedding, while it should vary smoothy along direction v. Meanwhile, the first component f1(x) of the interpolation function should have a slow variation along both directions u and v as the embeddings E(M1) and E(M2) are not separable along dimension k = 1.\nall classes.1 The normalization of the directional derivative by the average derivative aims to measure the derivative magnitude along separation boundaries relatively to the mean derivative magnitude.\nWhile the presence of sufficiently strong directional derivatives along separation boundaries is expected to enhance the separation between classes with the learned function, it is useful to control the smoothness of the interpolation function by preventing it from attaining arbitrarily high gradient magnitudes. We thus define the total gradient magnitude\nG(fk) := \u2211 m \u222b Sm \u2016\u2207fk(x)\u2016 Ev\u2016\u2207v fk(x)\u2016 d\u03bdm(x) (6)\nwhich is also normalized by the average directional derivative so that it is comparable to the term in (5).\nFrom (5) and (6), one can define an overall regularization objective R that increases with the total gradient magnitude G and decreases with the directional derivative magnitude along separation boundaries D. One way to define the regularization objective R is as\nR(f) = d\u2211 k=1 ( G(fk)\u2212 \u03bbD(fk) ) where \u03bb > 0.\nFinally, combining the embedding error in (4) and the above regularization term, we formulate the search of the interpolation function f as the optimization of the following\n1 The mean directional derivative can be formally defined as follows. Let p\u03bd denote the probability density function corresponding to the probability measure \u03bd, and let St(x) \u2282 Rn denote the (n \u2212 1)-dimensional sphere of radius t centered at x. The expected value of the directional derivative of fk at x is then given by\nEv\u2016\u2207v fk(x)\u2016 = lim t\u21920\n\u222b St(x)\np\u03bd(x+ tv) \u2016\u2207v fk(x)\u2016dS\u222b St(x) p\u03bd(x+ tv) dS\nwhere v denotes the unit surface normal in the direction of the surface element dS.\n5 problem\nf = arg min h\u2208Hk (\u2211 m \u222b Sm \u2016h(x)\u2212 E (PMm(x)) \u20162 d\u03bdm(x)\n+ \u03b1R(h) )\nwhere \u03b1 > 0. A solution to the above problem exists as Hk is compact and the objective function is continuous.\nIn a real setting, the distributions \u03bdm of data are often not explicitly known and one has access to a set of samples X = {xi}Qi=1 drawn from these distributions. Let Ci \u2208 {1, . . . ,M} denote the class label of the data sample xi, and N (xi) be the set of nearest neighbors of xi in X (which can be chosen for instance as the K-nearest neighbors of xi with respect to the Euclidean distance in Rn). Let\nn(xi) = { xi \u2212 xj \u2016xi \u2212 xj\u2016 : xj \u2208 N (xi) }\ndenote the set of unit vectors that indicate the directions of the neighbors of xi, and\nnp(xi) = { xi \u2212 xj \u2016xi \u2212 xj\u2016 : xj \u2208 N (xi), Cj = p }\ndenote the set of unit directions given by the nearest neighbors of xi within class p. We can then define the empirical embedding error E\u0302(f) as\nE\u0302(f) = \u2211 m \u2211 i:Ci=m \u2016f(xi)\u2212 E (PMm(xi)) \u20162\nand the empirical counterpart R\u0302(f) of the regularization term R(f) as\nR\u0302(f) = d\u2211 k=1 ( G\u0302(fk)\u2212 \u03bbD\u0302(fk) ) (7)\nwhere G\u0302(fk) := \u2211 i \u2016\u2207fk(xi)\u2016 |n(xi)|\u22121 \u2211 v\u2208n(xi) \u2016\u2207v f k(xi)\u2016 (8)\nD\u0302(fk) := \u2211\n(m,p)\u2208Ik \u2211 i:Ci=m\n1\n|np(xi)|\u2211 u\u2208np(xi) \u2225\u2225\u2207u fk(xi)\u2225\u2225 |n(xi)|\u22121 \u2211 v\u2208n(xi) \u2016\u2207v f k(xi)\u2016 . (9)\nIn the above expressions, | \u00b7 | denotes the cardinality of a set, and the mean directional derivative Ev\u2016\u2207v fk(xi)\u2016 is approximated by the average derivative of fk(xi) along the directions of the neighbors n(xi) of xi. In the definition of D\u0302(fk), we approximate the derivative \u2207up(xi) fk(xi) along the direction of the projection of xi ontoMp with the average derivative along the directions of the nearest neighbors of xi within class p, where np(xi) is assumed to be non-empty for all xi and p.\nNow, having defined the objective function in the empirical setting, we come back to the actual manifold learning problem. In practice, the manifolds Mm are usually not explicitly known, and manifold learning methods compute an embedding for only the initially available training samples. Let us denote by XT = {xi}Ni=1 \u2282 X the set of training samples with\nknown class labels (where N \u2264 Q), for which an embedding YT = {yi}Ni=1 is priorly computed with a supervised manifold learning algorithm. We assume that there exist embeddings E(Mm) of the manifolds Mm such that the embeddings {yi} of the samples of each class m are concentrated around E(Mm). Although the training samples available in practice are not guaranteed to lie exactly on a manifold in general (due to noise, imprecise measurements, or several sources of deviation from the assumed model), we make the following approximations for a sample xi \u2208 XT of class m for the simplicity of computations:\nPMm(xi) \u2248 xi, E(PMm(xi)) \u2248 yi.\nThe embedding error E\u0302(f) can then be decomposed as E\u0302(f) = E\u0302T (f) + E\u0302O(f) where\nE\u0302T (f) = N\u2211 i=1 \u2016f(xi)\u2212 yi\u20162\nis the embedding error of the training samples XT and\nE\u0302O(f) = Q\u2211 i=N+1 \u2016f(xi)\u2212 E (PMm(xi)) \u20162\n= \u2211 m Q\u2211 i=N+1 Ci=m \u2016f(xi)\u2212 E (PMm(xi)) \u20162\nis the embedding error of the other samples than the training samples (test samples in X \\ XT ).\nIn the generalization of an embedding, one may wish to strictly preserve the learned coordinates of the training data f(xi) = yi. We can thus formulate the out-of-sample extension problem for supervised manifold learning as follows:\nf = arg min h\u2208Hk E\u0302O(h) + \u03b1R\u0302(h) s.t. E\u0302T (h) = 0. (10)\nIn the above problem, if there are observations in X with unknown class labels, one needs to estimate the class labels Ci for N < i \u2264 Q. In the rest the paper, we focus on this general case. In Section III-B, we describe an algorithm that computes an interpolation function with a joint and progressive estimation of the function parameters and the class labels of data."}, {"heading": "B. Construction of the interpolation function", "text": "In this study, we select the set H of interpolation functions for the out-of-sample extension problem as the radial basis functions (RBFs)\nH = { g : g(x) =\nL\u2211 l=1 cl \u03c6 ( \u2016x\u2212 al\u2016 \u03c3l )} where \u03c6 : R\u2192 R+ is a differentiable kernel. The coefficients cl, the kernel centers al, and the scale parameters \u03c3l are assumed to lie in some compact domains in R, Rn and R+, respectively. The Gaussian function \u03c6(t) = e\u2212t 2\nis a common choice for the RBF kernel due to its desirable properties such as its smoothness and rapid decay, which we also adopt in this work.\n6 In our problem, we look for a function f = [f1(x) . . . fd(x)] : Rn \u2192 Rd such that each dimension fk of f is given by\nfk(x) = L\u2211 l=1 ckl \u03c6 ( \u2016x\u2212 akl \u2016 \u03c3kl ) . (11)\nThe construction of the interpolation function f is thus equivalent to the determination of the parameters ckl , a k l , \u03c3 k l , and the number of terms L. In the optimization problem in (10), the evaluation of E\u0302O(h) requires the knowledge of the class labels Ci of xi for i = N + 1, . . . , Q, which are unavailable in the beginning. We propose to solve this problem with an iterative algorithm that progressively estimates the class labels and constructs a sequence of interpolation functions f1, . . . , fr, . . . fR in an alternating scheme as described below.\nIn iteration r of the algorithm, we construct a function fr with Lr terms. When fitting an RBF interpolation function to data, it is common practice to assign kernel centers as data points. In iteration r, we select the kernel centers akl = xrl as a subset of data samples {xrl} Lr l=1 \u2282 X , where the index sequence {rl}Lrl=1 depends on the iteration r and denotes the indices of the data samples {xi} chosen as kernel centers. Throughout the iterations, the number of terms Lr is increased gradually such that N = L1 < L2 < ... < LR = Q. Once the kernel centers akl are fixed, the interpolation function fr in iteration r, characterized by the coefficients {ckl } and the scale parameters {\u03c3kl }, l = 1, . . . , Lr, k = 1, . . . , d, is obtained by solving the problem\nmin {ckl }\u2282B, {\u03c3 k l }\u2282\u039b\nE\u0302rO(f) + \u03b1R\u0302(f) s.t. E\u0302T (f) = 0 (12)\nwhere B \u2282 R and \u039b \u2282 R+ are compact parameter domains (sufficiently large so that the constraint E\u0302T (f) = 0 can be satisfied) and\nE\u0302rO(f) = \u2211 m Lr\u2211 l=N+1 Crl=m \u2016f(xrl)\u2212 E (PMm(xrl)) \u20162. (13)\nThe problem (12) has a solution as a continuous function over a compact domain attains its minimum.\nBefore discussing the solution of (12), we first give an overview of the method. In iteration r, once the interpolation function fr is computed by solving (12), we estimate the class label of each point xi for N + 1 \u2264 i \u2264 Q by assigning it the class label of the training point xj such that fr(xj) is the closest to fr(xi) in the low-dimensional domain Rd:\nCi = Cj : j = arg min q \u2016fr(xq)\u2212 fr(xi)\u2016, 1 \u2264 q \u2264 N.\n(14) At the same time, a confidence score \u00b5i is assigned to each estimate Ci by comparing the distance of xi to its nearest neighbor xj within all classes and to its nearest neighbor xj\u2032 among the classes other than Cj :\n\u00b5i = \u2016f(xj\u2032)\u2212 f(xi)\u2016 \u2016f(xj)\u2212 f(xi)\u2016 : j\u2032 = arg min q \u2016fr(xq)\u2212 fr(xi)\u2016, 1 \u2264 q \u2264 N,Cn 6= Cj .\n(15)\nThe confidence score \u00b5i thus decreases with the \u201cambiguity\u201d in assigning xi the class label Ci with respect to the nearestneighbor decision rule in Rd via fr.\nThe confidence scores \u00b5i obtained in an iteration are then used in the next iteration for the selection of the kernel centers. In iteration r, the kernel centers are determined based on the confidence scores computed in the previous iteration r \u2212 1 as follows. The first N kernel centers {akl }Nl=1 = {xrl}Nl=1 consist of the training set XT , i.e., rl = l for l = 1, . . . , N . The remaining kernel centers {akl } Lr l=N+1 are then set as the first Lr \u2212 N points in X \\ XT of highest confidence scores. The alternating stages of computing fr and estimating the class labels Ci and obtaining the confidence scores \u00b5i are repeated until the last iteration R, where all data samples are included in the set of kernel centers {akl } Q l=1 = X . The interpolation function f is then given by fR, and the class labels of the points in X are obtained by estimating them with the final interpolation function with respect to (14).\nWe now discuss the solution of the problem (12). First, observe that for any Lr input data pairs (xi, yi) \u2208 Rn \u00d7 Rd and any choice of the scale parameters \u03c3kl , one can find interpolation functions fk of L = Lr terms that satisfy f(xi) = yi as follows. Setting akl = xl for l = 1, . . . , Lr, the constraints fk(xi) = yki yield the linear system\n\u03a6kck = yk (16)\nwhere ck = [ck1 . . . c k Lr ]T is the coefficient vector, yk = [yk1 . . . y k Lr ]T consists of the kth dimensions of {yi}, and\n\u03a6kil = \u03c6\n( \u2016xi \u2212 xl\u2016\n\u03c3kl\n) (17)\nis the matrix of RBFs evaluated at data points xi. The square matrix \u03a6k is invertible if the points xi are distinct and \u03c6 is chosen as the Gaussian kernel [23]. The system (16) then has a unique solution ck = (\u03a6k)\u22121yk, which satisfies fk(xi) = yki .\nIn iteration r = 1, we have L1 = N and all kernel centers are training points. In this case the embedding error in (13) is E\u03021O(f) = 0, and the optimization problem is reduced to\nmin {ckl }\u2282B, {\u03c3 k l }\u2282\u039b R\u0302(f) s.t. E\u0302T (f) = 0.\nDue to the above discussion, the constraint E\u0302T (f) = 0 can be satisfied for any choice of scale parameters \u03c3kl by setting the coefficients as ck = (\u03a6k)\u22121yk. This reduces the problem to the minimization of the regularization term R\u0302(f) by optimizing the scale parameters {\u03c3kl } under the constraint ck = (\u03a6k)\u22121yk\nmin {\u03c3kl }\u2282\u039b\nck=(\u03a6k)\u22121yk\nR\u0302(f) (18)\nwhere the summations in the terms (8) and (9) of R\u0302(f) run over the set of training samples XT . The regularization term is a non-convex function of the scale parameters {\u03c3kl } with numerous extrema. Meanwhile, we have experimentally observed that the variation of R\u0302(f) with \u03c3k is quite regular when all scale parameters \u03c3kl , l = 1, . . . , L1, in each dimension k are set to a common value \u03c3k. Moreover, setting all scale parameters to the same value across each dimension also simplifies the\n7 optimization problem, as it reduces the number of optimization variables from L1k to k. We thus propose to solve the problem (18) under the constraint \u03c3kl = \u03c3\nk for l = 1, . . . , L1. Since the form of R\u0302(f) in (7) is decomposable into its components in different dimensions, the scale parameter of dimension k is given by\nmin \u03c3k\u2208\u039b\nck=(\u03a6k)\u22121yk\n( G\u0302(fk)\u2212 \u03bbD\u0302(fk) ) .\nIt is difficult to analyze the above function theoretically. Meanwhile, in practice we have observed that G\u0302(fk) increases with \u03c3k monotonically. Moreover, if the underlying embedding obtained with supervised manifold learning provides a \u201cbalanced\u201d distribution of the classes across different dimensions while ensuring a sufficient separation, the total directional derivative along class separation boundaries D\u0302(fk) first increases at a fast rate with \u03c3k at small scale values, and then it stagnates or the rate of increase is highly reduced. This is due to the fact that, when the scale parameters are too small, the interpolation function is too localized around kernel centers and its support does not cover well the whole space. Then, it does not have sufficiently strong derivatives along class separation boundaries. As \u03c3k increases, there typically exists a range for \u03c3k where the directional derivatives along class separation boundaries are relatively stronger than those along other directions, thanks to the underlying learned embedding that separates different classes and guides the interpolation function via the condition fk(xi) = yki imposed on training samples. This range for the scale parameters coincides in general with the interval of scale parameters where a good classification performance is attained. If the scale parameters are increased beyond this range, the gradient of the function fk increases too much, resulting in an overfitting of the interpolation function, where the advantage of having sufficiently strong directional derivatives along class separation boundaries is lost as strong derivatives appear in other directions as well due to overfitting. This is illustrated with a simple example in Figure 2. Figure 2(a) shows two manifolds M1,M2 \u2282 R2 representing two different classes, and four training samples selected from the distribution concentrated around each manifold. Let us consider a one-dimensional embedding of the manifold samples in R such that samples from M1 and M2 are mapped respectively to 1 and \u22121. An ideal interpolation function f(x) : R2 \u2192 R separating the two classes well in R should have gradients in the directions shown in red in Figure 2(a), which are orthogonal to the class separation boundary. In Figures 2(b)-2(d), an RBF interpolation function f with Gaussian kernel is fitted to the training data, and f(x) is plotted over the displayed region of R2, where white and black colors correspond respectively to 1 and \u22121. The scale parameter is chosen as \u03c3 = 0.5, \u03c3 = 2, and \u03c3 = 6 respectively in Figures 2(b)- 2(d). The scale parameter is observed to be too small in Figure 2(b) as the support of f does not cover the manifolds sufficiently. The scale parameter in Figure 2(c) yields an accurate interpolation function that separates the two classes well, where the directions along which f has strong derivatives are close to the directions shown in Figure 2(a). Meanwhile, the selection of a too large value for\n!=0.01\nM1\nM2\n(a)\n\u03c3=0.5 \u03c3=2 \u03c3=6\n(b)\n\u03c3=0.5 \u03c3=2 \u03c3=6\n(c)\n\u03c3=0.5 \u03c3=2 \u03c3=6\n(d)\nFig. 2. Illustration of the effect of the scale parameter on the accuracy of the interpolation function. (a) Manifolds M1,M2 \u2282 R2 representing two different classes and samples chosen from each class. An ideal interpolation function f separating the two classes well in R should have gradients in the directions shown in red. (b) Function f constructed with \u03c3 = 0.5. The scale parameter is observed to be too small as the support of the function does not cover the manifolds well. (c) Choosing the scale as \u03c3 = 2 yields a good interpolation function. (d) Choosing a too large scale parameter \u03c3 = 6 results in an overfitting of the interpolation function, with large derivatives in the indicated directions. the scale parameter in Figure 2(d) results in an overfitting of the interpolation function. In particular, strong directional derivatives are observable in directions other than the class separation boundary directions as well due to overfitting, e.g., the directions shown in red in Figure 2(d).\nIn optimizing \u03c3k, we look for an interval where D\u0302(fk) is large enough while G\u0302(fk) is not too high. We set the weight parameter \u03bb to a value where the effects of both of these terms are visible, often yielding a nonmonotonic variation of the overall regularization term G\u0302(fk)\u2212 \u03bbD\u0302(fk), which first decreases with \u03c3k due to the sharp increase in D\u0302(fk) and then increases with \u03c3k due to the stagnation of D(fk) and the continuing increase in the first term G\u0302(fk). The optimal value of \u03c3k can then be found easily with a simple descent or line search algorithm by minimizing the one-dimensional regularization term G\u0302(fk) \u2212 \u03bbD\u0302(fk). We finally note that other configurations of these two terms D\u0302(fk) and G\u0302(fk) in a regularization objective R\u0302(f) (rather than a linear combination) may also be possible, depending on the underlying embedding. This will be discussed in more detail in Section V, as well as the links between the regularization objective R\u0302(f) and the classification performance.\nHaving examined the computation of the scale parameters and the coefficients of f1 in iteration 1, we now discuss the solution of the problem (12) in a general iteration r. Due to the iterative estimation of the class labels and the calculation of the function parameters, the class labels Crl of the points xrl contributing to the embedding error (13) are already estimated in the previous iteration. The manifolds Mm and the embedding E are not explicitly known in the term E (PMm(xrl)). However, relying on a locally linear approximation of the manifolds, one can estimate the projection of a point x onto Mm as a convex combination of its nearest neighbors, which can then be used to compute E (PMm(xrl)).2 Denoting the indices of the K nearest neighbors of x within the training samples of class m as {ai}Ki=1, and the set of nearest neighbors\n2Note that, although the interpolation function of the previous iteration gives an estimate of the embedding of a point x as fr\u22121(x), it is more reliable to update the embedding by projecting x onto the manifold Mm. This is because the embedding fr\u22121(x) employs no priors on the class label of x and is indeed used to estimate the class label of x, while the recomputation of the embedding as E (PMm (x)) uses the estimated class label of x. In fact, E (PMm (x)) coincides with the value of the updated interpolation function fr(x) of iteration r for x = xrl as discussed below.\n8 as Nm(x) = {xai}Ki=1, the projection is approximated as\nPMm(x) \u2248 K\u2211 i=1 wi xai\nwhere w = [w1 . . . wK ]T is the vector of weights given by\nw = arg min v \u2016x\u2212 K\u2211 i=1 vi xai\u20162 s.t. vi \u2265 0, \u2211 i=1 vi = 1\n(19) which can be solved with quadratic programming. From the continuity assumption of the embeddings, the embedding E (PMm(x)) of PMm(x) is then estimated as\nE (PMm(x)) \u2248 K\u2211 i=1 wi yai (20)\nwhere yai are the coordinates of xai in the learned embedding in Rd. Letting yrl = E ( PMCrl (xrl) )\n, the total embedding error is given by\nE\u0302r(f) = E\u0302rO(f) + E\u0302T (f) = \u2211 m Lr\u2211 l=1\nCrl=m\n\u2016f(xrl)\u2212 yrl\u20162.\nSince in iteration r an interpolation function of Lr terms is constructed, for any choice of the scale parameters {\u03c3kl }, fitting the coefficients to the observations as ck = (\u03a6k)\u22121yk yields E\u0302r(f) = 0, which immediately satisfies the constraint E\u0302T (f) = 0 on training samples. It then remains to minimize the regularization term by optimizing the scale parameters as in (18).3 This concludes the description of the proposed method. As the proposed algorithm employs unlabeled test samples in learning an out-of-sample extension, we call it Semi-supervised Out-of-Sample Interpolation (SOSI). The method is summarized in Algorithm 1."}, {"heading": "IV. DISCUSSION", "text": ""}, {"heading": "A. Complexity analysis", "text": "We now derive the complexity of the proposed method, which is essentially determined by the complexity of steps 11- 13 in the main loop of the algorithm. In step 11, the determination of the nearest neighbors in XT for each test image is of complexity O(nN), and the solution of the quadratic program in (19) has a polynomial-time complexity O(poly(K)) in the number of neighbors K [24]. The complexity dK of (20) can be neglected as d is small. Since the embedding of the projection of each point in X \\ XT is computed only once throughout the algorithm, we get the overall complexity of step 11 as O(Q (poly(K) + nN)) \u2248 O(nQN).\nNext, step 12 requires the evaluation of the regularization term R\u0302(f) at several \u03c3k values and the corresponding coefficients ck = (\u03a6k)\u22121yk. The computation of the coefficients\n3In practice the optimization of scale parameters can be omitted for r > 1 and the scale parameters can be set to the \u03c3k values obtained in iteration r = 1 in order to speed up the algorithm without much change in the performance, as the reoptimization of the scale parameters results in \u03c3k values in the vicinity of those obtained at iteration r = 1 in general.\nAlgorithm 1 Semi-supervised Out-of-Sample Interpolation (SOSI)\n1: Input: X = {xi}Qi=1 \u2282 R\nn: Set of labeled and unlabeled data samples {Ci}Ni=1: Class labels of training data XT = {xi}Ni=1 \u2282 X , where N < Q. 2: Initialization: Assign number of iterations R and number of RBF terms {Lr}Rr=1 in each iteration such that L1 = N , LR = Q (possibly with equispaced intervals between N and Q) 3: for r = 1 do 4: Set kernel centers akl = xl for l = 1, . . . , N , k = 1, . . . , d 5: Optimize scale parameters \u03c3kl of f1 by minimizing R\u0302(f) subject to\nthe constraints \u03c3kl = \u03c3 k , ck = (\u03a6k)\u22121yk\n6: Estimate class labels Ci and compute confidence scores \u00b5i for i = 1, . . . , Q by NN classification with f1 in Rd 7: end for 8: for r = 2, . . . , R do 9: Determine {xrl} Lr l=1 such that {xrl} N l=1 = XT and {xrl} Lr l=N+1\nare the points in X \\ XT with highest confidence scores 10: Set kernel centers as akl = xrl for l = 1, . . . , Lr , k = 1, . . . , d 11: Compute the embeddings of the projections of xrl on the manifolds\nas in (20) and set yrl = E ( PMCrl (xrl ) )\n12: Optimize scale parameters \u03c3kl of fr by minimizing R\u0302(f) subject to the constraints \u03c3kl = \u03c3\nk , ck = (\u03a6k)\u22121yk 13: Update class labels Ci and confidence scores \u00b5i for i = 1, . . . , Q with NN classification with fr in Rd 14: end for 15: Output:\nOut-of-sample interpolation function f = fR : Rn \u2192 Rd given by fk(x) = \u2211Q l=1 c k l \u03c6 ( \u2016x\u2212akl \u2016 \u03c3k l ) {Ci}Qi=N+1: Class labels of initially unlabeled data samples\nck requires the solution of an Lr \u00d7 Lr linear system, whose complexity is between O(Lr2) and O(Lr3). Then, for a given \u03c3k and the corresponding ck, we analyze the evaluation of D\u0302(fk). The computation of the gradient \u2207fk(xi) is of complexity O(nLr). Assuming that each training point xi has around K nearest neighbors in each one of the M classes, the computation of the directional derivative \u2207ufk(xi) for all neighbors of a point xi is of complexity O(n(Lr + KM)). Since this is repeated for all N training points xi, the complexity of computing D\u0302(fk) is of O(nN(Lr +KM)). Since the complexity of G\u0302(fk) is dominated by that of D\u0302(fk), the optimization of \u03c3k is of O(Lr2 + nN(Lr + KM)). Performing this optimization for all d dimensions, upper bounding Lr by Q, and repeating this for all R iterations gives the complexity of step 12 throughout the algorithm as O(dR(Q2 +nN(Q+KM))) \u2248 O(dnRN(Q+KM)). If one omits the reoptimization of \u03c3k for r > 1, the complexity of step 12 is reduced to the optimization of scale parameters at the first iteration r = 1 and the update of the coefficients ck at every iteration, which is of O(dnN(N +KM) + dRQ2).\nStep 13 requires the evaluation of f(xi) for all xi \u2208 X \\XT , which is of O(dnQLr), and the comparison of the function values to those of the training points, which is of O(dQN). The complexity of repeating step 13 throughout R iterations is then of O(R(dnQ2 + dQN)) = O(dnRQ2). Finally, combining the complexities of steps 11-13, we get the complexity of the overall algorithm as O(dnRQ2).\n9"}, {"heading": "B. Relation to kernel ridge regression", "text": "In this section, we discuss how out-of-sample extensions of supervised manifold learning methods with RBF interpolation can be interpreted within the context of kernel ridge regression. Ridge regression is a well-known statistical method that learns a linear function to model the dependency between a set of input training points {xi}Ni=1 \u2282 Rn and the associated outputs {yi}Ni=1 \u2282 Rd. For each dimension yki of the outputs yi = [y1i . . . y d i ], the algorithm looks for a linear model f\nk(x) = wTx that minimizes\nG(w) = a\u2016w\u20162 + N\u2211 i=1 (yki \u2212 wTxi)2\nwhich is a slightly modified version of the least squares method by adding a regularization term representing the squared norm of the fitted linear model. Here a > 0 is a parameter adjusting the weight of the regularization term. An alternative formulation of ridge regression is proposed in [25] that is based on a dual version of the above problem. The solution of the dual problem yields the following prediction fk(x) of the output value for a new input sample x:\nfk(x) = (yk)T (K + aI)\u22121v. (21)\nHere, yk = [yk1 . . . y k N ] T is the vector of output values for training samples, K \u2208 RN\u00d7N is the matrix of inner products of input samples whose entries are given by Kij = \u3008xi, xj\u3009, I is the identity matrix, and v \u2208 RN\u00d71 is the vector of inner products of x with xi, whose ith entry is given by vi = \u3008x, xi\u3009.\nSince this formulation only involves the inner products between the samples x and {xi} rather than the samples themselves as vectors, it permits a kernel extension of the regression problem, where the samples are mapped to a highdimensional feature space F via a kernel \u03c8 : Rn \u2192 F . The inner products in K and v are then evaluated in the feature space as Kij = \u3008\u03c8(xi), \u03c8(xj)\u3009 and vi = \u3008\u03c8(x), \u03c8(xi)\u3009. Translationinvariant kernels are a widely-used family of kernel functions, where the inner product \u3008\u03c8(xi), \u03c8(xj)\u3009 in the feature space depends only on the difference \u2016xi\u2212xj\u2016 between the samples in the original space.\nOut-of-sample extensions with RBF kernels as in the proposed method are linked to kernel ridge regression in the following way. If the regularization term (a = 0) is omitted in (21), the kth dimension of the output vector for the input sample x is given by\nfk(x) = (yk)TK\u22121v. (22)\nIf the kernel Kij is set as \u3008\u03c8(xi), \u03c8(xj)\u3009 = \u03c6(\u2016xi \u2212 xj\u2016/\u03c3) with the RBF kernel used in interpolation, one can observe from (17) that the kernel matrix K coincides with the matrix \u03a6k when a constant scale parameter \u03c3 is chosen for dimension k of the interpolation function. Defining v similarly with the RBF kernel \u03c6, the interpolation function in (11) can be written as fk(x) = (ck)T v. The coefficients ck of the interpolation function being given by ck = (\u03a6k)\u22121yk, we obtain\nfk(x) = (ck)T v = (yk)T (\u03a6k)\u22121v\nwhich is the same as the result obtained with kernel ridge regression in (22).\nWe thus observe that fitting an RBF interpolation function for manifold embeddings is the equivalent of learning a kernel ridge regression model (with no regularization) such that the output values yki are the coordinates of data samples in the computed embedding. Therefore, the studied out-of-sample extension setting can be regarded as a kernel ridge regression adapted particularly to manifold-structured data. Indeed, in the general and traditional regression setting for classification, no assumption is made about the structure of data, and the output vectors yi are taken as the class labels. Taking yi\u2019s simply as the class labels of data transmits only the class information to the regression algorithm and conveys no information about the geometric properties of data. Meanwhile, first computing an embedding with a supervised manifold learning algorithm and then learning the regression model on the coordinates yki of data in Rd (instead of taking yi\u2019s directly as class labels) allows the classifier to be guided by the special geometric structure of data samples concentrated around classrepresentative manifolds. Coordinates learned with supervised manifold learning algorithms reinforce the class information of data by enhancing the separability between the classes, while the manifold structure of data is also preserved in each class."}, {"heading": "V. EXPERIMENTAL RESULTS", "text": "In this section, we evaluate the performance of the proposed method in classification experiments. We apply the presented out-of-sample extension algorithm on two different supervised manifold learning methods. First, we consider the supervised Laplacian eigenmaps algorithm presented in [9], which computes an embedding by solving (1). Next, we evaluate our algorithm on embeddings obtained with the Fisher-like objective function in (2), which is used by methods such as [5], [6], [7], and [21]. However, we compute a nonlinear embedding by removing the linear projection constraint zT = vTX , so that the out-of-sample extension problem is of interest.\nWe compare the following methods in the experiments, the first four of which provide out-of-sample extension solutions for manifold embeddings. When testing the out-of-sample extension methods, class labels of test images are assigned with nearest-neighbor classification in the low-dimensional domain of embedding. \u2022 Proposed semi-supervised out-of-sample interpolation\nmethod (SOSI) \u2022 RBF fitting: An RBF interpolation function is fitted only\nto the training samples, which is the equivalent of the interpolation function f1 computed at the end of iteration r = 1 in Algorithm 1. Test images x are then mapped to Rd via the function f1(x). \u2022 Locally linear embedding (LLE): Test points in Rn are mapped to Rd with an adaptation of the LLE algorithm [2] to the out-of-sample problem. Given a test point x \u2208 Rn, first its approximation is computed as a linear combination of its nearest neighbors in XT with weights adding up to 1 as in LLE. The point x is then mapped to y \u2208 Rd as the linear combination of the embeddings of the same neighbors with the same weights.\n10\n\u2022 Nystro\u0308m: The original Nystro\u0308m formula is not applicable since the data-dependent kernel depends on the class labels as discussed in Section II-B. We thus use a modified version of the Nystro\u0308m method, where fk(x) is taken as a linear combination of the embedding coordinates yki weighted by the kernel as in (3). The kernel M\u0303 in the formula is taken as the same type of kernel (Gaussian kernel) used in the construction of the within-class and between-class weight matrices Ww and Wb, and it is normalized for each test sample so that the kernel values M\u0303(x, xi) sum up to 1. \u2022 Nearest neighbor classification in the original data space Rn \u2022 SVM in the original data space Rn \u2022 Semi-supervised learning (SSL) using Gaussian fields:\nSince the proposed out-of-sample extension method can be regarded as a building block of a semi-supervised classifier, we also compare our results with those of a semisupervised classification method. We test the performance of SSL with the algorithm proposed in [26], which is a state-of-the-art semi-supervised classifier based on the computation of a smooth function on the data graph that coincides with the class labels when evaluated at data samples of known class labels.\nWe first evaluate the proposed method on a data set consisting of the face images of 12 individuals from the extended Yale face database [27], which includes 58 images of each individual taken under different poses and illumination conditions. The images are normalized, converted to grayscale and downsampled to a resolution of 17\u00d7 20 pixels. A sample image of each subject in the data set is shown in Figure 4(a). The supervised Laplacian eigenmaps and the Fisher-based embedding algorithms are used to map the data (17\u00d720-pixel images) to R20. The weight parameter is set as \u00b5 = 0.01 in the supervised Laplacian eigenmaps method. Figure 3 shows the embeddings of a subset of the data set containing 10 labeled images of each individual, computed with the supervised Laplacian and the Fisher-based embedding algorithms. Only the first three dimensions of the coordinates are plotted for illustration. It can be observed that both methods compute representations with an enhanced separation between different classes. The supervised Laplacian eigenmaps method yields an even distribution of different classes across different di-\nmensions. Since each dimension of the embedding renders several pairs of classes separable, sufficiently many class pairs contribute to the total directional derivative D\u0302(fk) in (9) for each dimension k. This causes the variations of D\u0302(fk) and G\u0302(fk) with the scale parameter to be as discussed in Section III-B, such that G\u0302(fk) increases at a faster rate than D\u0302(fk) at large scales due to overfitting. Thus, for the embeddings obtained with supervised Laplacian eigenmaps, we optimize the scale parameters by minimizing the regularization term R\u0302(f) as in (7).4 Meanwhile, the embedding computed with the Fisher-based objective yields a more \u201cpolarized\u201d representation, where each dimension of the embedding is observed to separate out only one class from the others. When there are not sufficiently many separable class pairs in D\u0302(fk), the estimation of the variation of this term with the scale parameter may become unreliable or biased by a particular class in each dimension. We have observed that, when the embedding is computed with the Fisher-based objective, the variation of D\u0302(fk) with the scale parameter is closer to that of G\u0302(fk) (in comparison with supervised Laplacian eigenmaps). The choice of the regularization term R\u0302(f) as a linear combination of these two terms may then lose its reliability, as it may become a monotonic function of the scale parameter, for instance. Therefore, for the Fisher-based embedding, we apply a slightly modified procedure for optimizing the scale parameters, where we choose a sufficiently large value for the scale parameter in each dimension, which ensures, however, that the D\u0302(fk)/G\u0302(fk) ratio stays above a certain threshold value. The scale parameters of the RBF fitting method are set as equal to those of the proposed SOSI algorithm. Figure 5 shows the classification errors obtained with all methods for the supervised Laplacian and the Fisher-based embeddings. Each curve displays the misclassification rate (in percentage)\n4Occasionally, the scale parameter \u03c3k of one dimension or a few dimensions k may diverge from the scale parameters of the rest of the dimensions, which may cause instabilities. In order to avoid this, we bound the final values of the scale parameters to an interval of two standard deviations around their mean value averaged over all dimensions.\n11\nof unlabeled images, obtained by varying the ratio between the number of labeled and unlabeled images in the data set. The results are the average of 5 repetitions of the experiment by randomly choosing the labeled samples. An early stopping rule is applied in the SOSI algorithm for the leftmost point of the curve (the labeled/unlabeled ratio of 0.11) due to the relatively high error, where the interpolation function construction is terminated when around 80% of the unlabeled points are added as RBF kernel centers. It is observed that the proposed method outperforms the other out-of-sample extension methods in comparison, as well as the SVM classifier and the semisupervised graph-based classifier.\nWe then repeat the same experiment on two different databases of object images captured under varying viewpoints. The first experiment is conducted on the images of 8 objects from the ETH-80 database [28], where 41 images are available for each object (in particular, the images of the first object in each object category are used so that the images in each class belong to the same manifold). A sample image of each object is shown in Figure 4(b). The images are normalized, converted to grayscale, and downsampled to a resolution of 20 \u00d7 20 pixels. An embedding of dimension d = 15 is computed with the supervised Laplacian eigenmaps and the Fisher-based manifold learning algorithms. The second experiment is done on the images of 20 objects from the COIL-20 database [29] with 71 images for each object, which are normalized, converted to grayscale, and downsampled to a resolution of 32 \u00d7 32 pixels. Figure 4(c) shows a sample image for each object. The images are embedded in a space of dimension d = 25. In both experiments, the optimization of the scale parameters is done as in the previous experiment. The results obtained with the two object data sets are presented in Figures\n6 and 7. The misclassification rates of unlabeled samples are plotted with respect to the ratio between the number of labeled and unlabeled samples. The results are the average of 5 random partitionings of the data set. As the classification error of the ETH-80 database is relatively high, an early stopping rule is applied for this data set by terminating the interpolation function construction when around 70% of the unlabeled samples with the highest confidence scores are added as RBF kernel centers. The results show that the proposed method often yields the smallest classification error in the experiment of Figure 6, while it is outperformed only by the semisupervised learning method in Figure 7. This graph-based semi-supervised learning algorithm performs particularly well on the COIL-20 data set, due to the dense sampling and the regular structure of the object image manifolds.\nThe overall consideration of these experiments shows that the proposed out-of-sample extension method for supervised manifold learning provides a better performance than the reference out-of-sample extension strategies in comparison, while it can provide an alternative solution for semi-supervised learning when coupled with a supervised dimensionality reduction method and thus regarded as one building block of a semi-supervised classifier. In particular, one can observe in Figures 5-7 that SVM and graph-based SSL may perform very differently in different settings. SVM is based purely on the representation of the data samples in the original ambient space Rn, while graph-based SSL only uses the information of the similarities between neighboring data samples instead of interpreting them as vectors in the high-dimensional space Rn. Meanwhile, the proposed method is expected to find a compromise between these two approaches, as the interpolation function depends both on the coordinates of the data samples in Rn and the coordinates of the embedding in Rd learned with a supervised manifold learning algorithm that relies on the graph representation of data. The experimental results seem to confirm this expectation, as the proposed classification solution attains a reasonably good performance in situations where SVM or graph-based SSL may fail (as in Figures 6 and 5 respectively).\nIn the experiments of Figures 5-7, the interpolation functions of the out-of-sample methods other than SOSI are constructed using only the training data. The information present in the unlabeled data samples is not exploited in the construction of these interpolation functions, whereas SOSI uses these points to gradually add them as kernel centers of\n12\nthe learned interpolation function. In order to assess the performance of the proposed method in the progressive integration of the unlabeled data samples in the learning process, we do an additional experiment. The proposed SOSI algorithm is used to classify unlabeled test images in an iterative way as described in Algorithm 1. Then, in order to compare SOSI with the other out-of-sample extension methods, for each one of these methods, we carry out an iterative classification procedure as follows. In each iteration, all test images are assigned class labels with nearest-neighbor classification in the low-dimensional domain via the out-of-sample generalization strategies in comparison, and a confidence score is obtained for each test image as in (15). Then in the next iteration, the test images with the highest confidence scores are added to the training set with their estimated class labels and a completely new embedding of this extended training set is computed with the supervised Laplacian eigenmaps and the Fisher-based embedding algorithms (thus new coordinates are assigned to the original training images as well). The out-ofsample extension of this new embedding is then recomputed with the tested strategies in comparison, which are used to reclassify the test images. In each iteration r, the compared methods use the same number Lr of extended training images in X (same as the number of terms in the interpolation function of SOSI), while the choice of the extended training set varies between the compared methods as a result of the different confidence scores they assign to the test images. This progressive procedure is continued until all test images are included in the extended training set. The results obtained on the face images from the Yale database are presented in Figures 8(a) and 8(b), respectively for the supervised Laplacian eigenmaps and the Fisher-based embedding algorithms. The image set of each subject contains 10 labeled and 48 unlabeled samples in this experiment. The misclassification rates obtained throughout the iterations are plotted with respect to the ratio Lr/N between the size of the extended training set (number of RBF terms for SOSI) and the size of the original training set. The results indicate that the best classification accuracy is achieved by the proposed algorithm most of the time. The misclassification error obtained with the proposed method decreases regularly throughout the iterations as the number of terms in the interpolation function increases, while the evolution of the misclassification error with the other strategies is less regular\nand the error may even increase throughout the iterations. This is due to the fact that the strategies other than SOSI compute a new embedding of the extended training set from scratch in each iteration. The mislabeled data samples in the extended training set may then significantly influence the computed embedding and consequently the class label assignments of the next iteration, since the embedding given by the eigenvectors of a class-dependent kernel matrix may change dramatically even with small errors in the kernel matrix. The proposed method does not suffer from this problem, since it preserves the original embedding and refines only the interpolation function throughout the iterations, which has a regularizing effect that better tolerates inaccurate assignments of the class labels of test images. We finally note that, among the strategies compared in this experiment, the proposed SOSI algorithm is the only one that provides an out-of-sample solution for manifold learning when Lr > N .\nFinally, we study the influence of the scale parameters of the interpolation function on the classification performance. As discussed in Section III-B, the proposed method selects the scale parameters by optimizing the regularization term R\u0302(f). In order to evaluate the effect of this regularization approach on the classification accuracy, we compare the variations of the regularization term R\u0302(f) and the classification error with the scale parameter. We compute an embedding of the training images with the supervised Laplacian eigenmaps algorithm and then construct an RBF interpolation function, where all scale parameters \u03c3kl are set to a common \u03c3 value and the coefficients ckl are computed to fit the training images and the learned embedding for this choice of the scale parameter (as in the RBF fitting method or the first iteration of SOSI). A sequence of interpolation functions are computed by varying the scale parameter \u03c3, and for each interpolation function, the regularization objective R\u0302(f) is computed as well as the misclassification rate of the test images. The variations of the regularization cost and the misclassification rate with the scale parameter \u03c3 are presented in Figure 9 for all three data sets used in the experiments. The results suggest that the regularization objective R\u0302(f) has a rather smooth and nonmonotonic variation with the scale parameter, which resembles that of the classification error. Moreover, the interval of scale parameters \u03c3 minimizing the regularization objective R\u0302(f) coincides with the range of \u03c3 values where the misclassification rate takes small values. This shows that the proposed regularization objective permits the algorithm to capture the influence of the scale parameters on the performance of learning and can be used for optimizing the scale parameters."}, {"heading": "VI. CONCLUSIONS", "text": "We have proposed a method for the out-of-sample extensions of supervised manifold learning algorithms that embed a set of class-representative manifolds residing in a highdimensional ambient space to a set of manifolds in a lowerdimensional domain. The proposed out-of-sample generalization method is based on the construction of an RBF interpolation function, where the parameters of the interpolation function are optimized to minimize the embedding error over\n13\na set of initially unlabeled data samples, whose class labels are estimated progressively along with the parameters of the interpolation function. We have shown that the regularity of the interpolation function can be controlled by optimizing the RBF scale parameters to minimize a regularization objective that controls the total gradient of the interpolation function while encouraging sufficiently strong derivatives along the directions of class separation boundaries in order to ensure an effective separation between different classes. The proposed out-ofsample generalization method outperforms baseline interpolation solutions in classification applications. Experimental results suggest that the proposed algorithm achieves stateof-the-art performance in semi-supervised learning and can be effectively used along with supervised manifold learning methods in the classification of low-dimensional data sets consisting of labeled and unlabeled data samples."}, {"heading": "VII. ACKNOWLEDGMENT", "text": "The authors would like to thank Pascal Frossard and Alhussein Fawzi for the helpful discussions that contributed to this study."}], "references": [{"title": "A global geometric framework for nonlinear dimensionality reduction.", "author": ["J.B. Tenenbaum", "V. de Silva", "J.C. Langford"], "venue": "Science, vol. 290,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "Nonlinear dimensionality reduction by locally linear embedding", "author": ["S.T. Roweis", "L.K. Saul"], "venue": "Science, vol. 290, pp. 2323\u20132326, 2000.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2000}, {"title": "Laplacian eigenmaps for dimensionality reduction and data representation", "author": ["M. Belkin", "P. Niyogi"], "venue": "Neural Computation, vol. 15, no. 6, pp. 1373\u20131396, Jun. 2003.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "Graph embedding and extensions: A general framework for dimensionality reduction", "author": ["S. Yan", "D. Xu", "B. Zhang", "H.J. Zhang", "Q. Yang", "S. Lin"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., vol. 29, no. 1, pp. 40\u201351, 2007.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "Local similarity and diversity preserving discriminant projection for face and handwriting digits recognition.", "author": ["Q. Hua", "L. Bai", "X.Z. Wang", "Y. Liu"], "venue": "Neurocomputing, vol", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "A multi-manifold discriminant analysis method for image feature extraction", "author": ["W. Yang", "C. Sun", "L. Zhang"], "venue": "Pattern Recognition, vol. 44, no. 8, pp. 1649\u20131657, 2011.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Marginal semi-supervised submanifold projections with informative constraints for dimensionality reduction and recognition", "author": ["Z. Zhang", "M. Zhao", "T. Chow"], "venue": "Neural Networks, vol. 36, pp. 97\u2013111, 2012.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Stable orthogonal local discriminant embedding for linear dimensionality reduction.", "author": ["Q. Gao", "J. Ma", "H. Zhang", "X. Gao", "Y. Liu"], "venue": "IEEE Transactions on Image Processing,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "A supervised non-linear dimensionality reduction approach for manifold learning", "author": ["B. Raducanu", "F. Dornaika"], "venue": "Pattern Recognition, vol. 45, no. 6, pp. 2432\u20132444, 2012.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Out-of-sample extensions for LLE, ISOMAP, MDS, Eigenmaps, and Spectral Clustering", "author": ["Y. Bengio", "J.F. Paiement", "P. Vincent", "O. Delalleau", "N. Le Roux", "M. Ouimet"], "venue": "Adv. Neural Inf. Process. Syst. MIT Press, 2004, pp. 177\u2013184.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2004}, {"title": "Sparse projections of medical images onto manifolds", "author": ["G.H. Chen", "C. Wachinger", "P. Golland"], "venue": "Proc. Information Processing in Medical Imaging - 23rd International Conference, 2013, pp. 292\u2013303.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "An explicit nonlinear mapping for manifold learning", "author": ["H. Qiao", "P. Zhang", "D. Wang", "B. Zhang"], "venue": "IEEE T. Cybernetics, vol. 43, no. 1, pp. 51\u201363, 2013.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "A sparse-grid-based out-of-sample extension for dimensionality reduction and clustering with laplacian eigenmaps", "author": ["B. Peherstorfer", "D. Pfl\u00fcger", "H.J. Bungartz"], "venue": "AI 2011: Proc. Advances in Artificial Intelligence - 24th Australasian Joint Conference, 2011, pp. 112\u2013121.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2011}, {"title": "A generalised solution to the out-ofsample extension problem in manifold learning", "author": ["H. Strange", "R. Zwiggelaar"], "venue": "Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence, 2011.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "The out-of-sample problem for classical multidimensional scaling", "author": ["M.W. Trosset", "C.E. Priebe"], "venue": "Computational Statistics & Data Analysis, vol. 52, no. 10, pp. 4635\u20134642, 2008.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "Out-of-sample extrapolation of learned manifolds", "author": ["T.J. Chin", "D. Suter"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., vol. 30, no. 9, pp. 1547\u20131556, 2008.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2008}, {"title": "Unsupervised learning of image manifolds by semidefinite programming", "author": ["K.Q. Weinberger", "L.K. Saul"], "venue": "International Journal of Computer Vision, vol. 70, no. 1, pp. 77\u201390, 2006.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Locality Preserving Projections", "author": ["X. He", "P. Niyogi"], "venue": "Advances in Neural Information Processing Systems 16. Cambridge, MA: MIT Press, 2004.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2004}, {"title": "Face recognition using Laplacianfaces", "author": ["X. He", "S. Yan", "Y. Hu", "P. Niyogi", "H. Zhang"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., vol. 27, no. 3, pp. 328\u2013340, 2005.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2005}, {"title": "Orthogonal Laplacianfaces for face recognition", "author": ["D. Cai", "X. He", "J. Han", "H. Zhang"], "venue": "IEEE Transactions on Image Processing, vol. 15, no. 11, pp. 3608\u20133614, 2006.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "Manifold discriminant analysis", "author": ["R. Wang", "X. Chen"], "venue": "CVPR, 2009, pp. 429\u2013436.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2009}, {"title": "Marginal fisher analysis and its variants for human gait recognition and content- based image retrieval", "author": ["D. Xu", "S. Yan", "D. Tao", "S. Lin", "H. Zhang"], "venue": "IEEE Transactions on Image Processing, vol. 16, no. 11, pp. 2811\u20132821, 2007.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2007}, {"title": "Radial Basis Functions", "author": ["M.D. Buhmann"], "venue": null, "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "The polynomial solvability of convex quadratic programming", "author": ["M.K. Kozlov", "S.P. Tarasov", "L. Khachiyan"], "venue": "USSR Computational Mathematics and Mathematical Physics, vol. 20, no. 5, pp. 223 \u2013 228, 1980.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1980}, {"title": "Ridge regression learning algorithm in dual variables", "author": ["C. Saunders", "A. Gammerman", "V. Vovk"], "venue": "Proceedings of the Fifteenth International Conference on Machine Learning, 1998, pp. 515\u2013521.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1998}, {"title": "Semi-supervised learning using gaussian fields and harmonic functions", "author": ["X. Zhu", "Z. Ghahramani", "J.D. Lafferty"], "venue": "Machine Learning, Proceedings of the Twentieth International Conference, 2003, pp. 912\u2013 919.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2003}, {"title": "From few to many: Illumination cone models for face recognition under variable lighting and pose", "author": ["A.S. Georghiades", "P.N. Belhumeur", "D.J. Kriegman"], "venue": "IEEE Trans. Pattern Anal. Mach. Intelligence, vol. 23, no. 6, pp. 643\u2013660, 2001.", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2001}, {"title": "Analyzing appearance and contour based methods for object categorization", "author": ["B. Leibe", "B. Schiele"], "venue": "2003 IEEE Computer Society 14 Conference on Computer Vision and Pattern Recognition (CVPR 2003), 2003, pp. 409\u2013415.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2003}, {"title": "Columbia Object Image Library (COIL-20)", "author": ["S.A. Nene", "S.K. Nayar", "H. Murase"], "venue": "Tech. Rep., Feb 1996.", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1996}], "referenceMentions": [{"referenceID": 0, "context": "unsupervised manifold learning methods such as [1], [2], [3], which only take the geometric structure of data samples into account when learning a low-dimensional embedding, many recent supervised manifold learning methods seek a representation that not only preserves the manifold structure in each class, but also enhances the separation between differ-", "startOffset": 47, "endOffset": 50}, {"referenceID": 1, "context": "unsupervised manifold learning methods such as [1], [2], [3], which only take the geometric structure of data samples into account when learning a low-dimensional embedding, many recent supervised manifold learning methods seek a representation that not only preserves the manifold structure in each class, but also enhances the separation between differ-", "startOffset": 52, "endOffset": 55}, {"referenceID": 2, "context": "unsupervised manifold learning methods such as [1], [2], [3], which only take the geometric structure of data samples into account when learning a low-dimensional embedding, many recent supervised manifold learning methods seek a representation that not only preserves the manifold structure in each class, but also enhances the separation between differ-", "startOffset": 57, "endOffset": 60}, {"referenceID": 3, "context": "Linear methods such as [4], [5], [6], [7], and [8] learn a linear projection that maps data into a lower-dimensional space such that the proximity of neighboring samples from the same class is preserved, while the distance between samples from different classes is increased.", "startOffset": 23, "endOffset": 26}, {"referenceID": 4, "context": "Linear methods such as [4], [5], [6], [7], and [8] learn a linear projection that maps data into a lower-dimensional space such that the proximity of neighboring samples from the same class is preserved, while the distance between samples from different classes is increased.", "startOffset": 28, "endOffset": 31}, {"referenceID": 5, "context": "Linear methods such as [4], [5], [6], [7], and [8] learn a linear projection that maps data into a lower-dimensional space such that the proximity of neighboring samples from the same class is preserved, while the distance between samples from different classes is increased.", "startOffset": 33, "endOffset": 36}, {"referenceID": 6, "context": "Linear methods such as [4], [5], [6], [7], and [8] learn a linear projection that maps data into a lower-dimensional space such that the proximity of neighboring samples from the same class is preserved, while the distance between samples from different classes is increased.", "startOffset": 38, "endOffset": 41}, {"referenceID": 7, "context": "Linear methods such as [4], [5], [6], [7], and [8] learn a linear projection that maps data into a lower-dimensional space such that the proximity of neighboring samples from the same class is preserved, while the distance between samples from different classes is increased.", "startOffset": 47, "endOffset": 50}, {"referenceID": 8, "context": "Nonlinear methods such as [9] have a similar classification-driven objective, while the new coordinates of data samples in the low-dimensional space are computed with a nonlinear learning process based on a graph representation of data.", "startOffset": 26, "endOffset": 29}, {"referenceID": 8, "context": "In fact, nonlinear methods such as [9], or nonlinear adaptations of the above linear methods, typically learn data representations where different classes become even linearly separable.", "startOffset": 35, "endOffset": 38}, {"referenceID": 9, "context": "The study in [10] focuses on the extension", "startOffset": 13, "endOffset": 17}, {"referenceID": 9, "context": "formula as proposed in [10] can also be derived from the kernel ridge regression framework, by removing the regularization term and imposing the constraint that the data coordinates of training samples be given by the eigenvectors of the data kernel matrix [11].", "startOffset": 23, "endOffset": 27}, {"referenceID": 10, "context": "formula as proposed in [10] can also be derived from the kernel ridge regression framework, by removing the regularization term and imposing the constraint that the data coordinates of training samples be given by the eigenvectors of the data kernel matrix [11].", "startOffset": 257, "endOffset": 261}, {"referenceID": 11, "context": "interpolation functions used in manifold learning extensions are polynomials [12], sparse linear combinations of functions in a reproducing kernel Hilbert space (RKHS) [11], and sparse grid functions [13].", "startOffset": 77, "endOffset": 81}, {"referenceID": 10, "context": "interpolation functions used in manifold learning extensions are polynomials [12], sparse linear combinations of functions in a reproducing kernel Hilbert space (RKHS) [11], and sparse grid functions [13].", "startOffset": 168, "endOffset": 172}, {"referenceID": 12, "context": "interpolation functions used in manifold learning extensions are polynomials [12], sparse linear combinations of functions in a reproducing kernel Hilbert space (RKHS) [11], and sparse grid functions [13].", "startOffset": 200, "endOffset": 204}, {"referenceID": 13, "context": "In [14], the out-of-sample extension of general manifold learning methods is achieved by computing a local projection of the high-dimensional space to the lowdimensional domain with a similarity transformation of the local PCA bases.", "startOffset": 3, "endOffset": 7}, {"referenceID": 14, "context": "The study in [15] proposes an out-of-sample generalization of the multidimensional scaling (MDS) method, which is based on an interpretation of MDS as a least squares problem.", "startOffset": 13, "endOffset": 17}, {"referenceID": 15, "context": "Similarly, the method proposed in [16] presents a generalization for maximum variance unfolding [17].", "startOffset": 34, "endOffset": 38}, {"referenceID": 16, "context": "Similarly, the method proposed in [16] presents a generalization for maximum variance unfolding [17].", "startOffset": 96, "endOffset": 100}, {"referenceID": 9, "context": "For instance, the popular Nystr\u00f6m extension [10] considers embeddings given by the eigenvectors of a symmetric kernel matrix.", "startOffset": 44, "endOffset": 48}, {"referenceID": 8, "context": ", as in [9].", "startOffset": 8, "endOffset": 11}, {"referenceID": 0, "context": "The ISOMAP method computes an embedding such that Euclidean distances in the low-dimensional domain are proportional to the geodesic distances in the original domain [1], while LLE looks for an embedding that preserves local reconstruction weights of data samples in the original domain [2].", "startOffset": 166, "endOffset": 169}, {"referenceID": 1, "context": "The ISOMAP method computes an embedding such that Euclidean distances in the low-dimensional domain are proportional to the geodesic distances in the original domain [1], while LLE looks for an embedding that preserves local reconstruction weights of data samples in the original domain [2].", "startOffset": 287, "endOffset": 290}, {"referenceID": 2, "context": "The Laplacian eigenmaps algorithm [3] first constructs a graph from the data samples where nearest neighbors are typically connected with an edge.", "startOffset": 34, "endOffset": 37}, {"referenceID": 17, "context": "projection of X onto R in [18], which is applied to face", "startOffset": 26, "endOffset": 30}, {"referenceID": 18, "context": "recognitions problems in [19] and [20].", "startOffset": 25, "endOffset": 29}, {"referenceID": 19, "context": "recognitions problems in [19] and [20].", "startOffset": 34, "endOffset": 38}, {"referenceID": 8, "context": "The algorithm proposed in [9] formalizes this idea by defining two graphs that respectively capture the within-class and betweenclass neighborhoods.", "startOffset": 26, "endOffset": 29}, {"referenceID": 20, "context": "The method proposed in [21] employs an alternative Fisher-like formulation for the supervised manifold learning problem where the embedding is obtained by solving", "startOffset": 23, "endOffset": 27}, {"referenceID": 3, "context": "Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22].", "startOffset": 77, "endOffset": 80}, {"referenceID": 4, "context": "Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22].", "startOffset": 82, "endOffset": 85}, {"referenceID": 5, "context": "Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22].", "startOffset": 87, "endOffset": 90}, {"referenceID": 6, "context": "Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22].", "startOffset": 92, "endOffset": 95}, {"referenceID": 7, "context": "Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22].", "startOffset": 97, "endOffset": 100}, {"referenceID": 21, "context": "Variations over this formulation can be found in several other works such as [4], [5], [6], [7], [8] and [22].", "startOffset": 105, "endOffset": 109}, {"referenceID": 9, "context": "A popular out-of-sample generalization algorithm is presented in [10], based on the Nystr\u00f6m formula.", "startOffset": 65, "endOffset": 69}, {"referenceID": 9, "context": "The out-ofsample extension proposed in [10] is then given by the function f(x) = [f(x) .", "startOffset": 39, "endOffset": 43}, {"referenceID": 9, "context": "The reason is that, although the data kernel matrix M is assumed to be a general symmetric matrix (not necessarily positive semi-definite) in [10], the entries of this matrix in supervised methods are not only dependent on the data samples xi, but also on their class labels.", "startOffset": 142, "endOffset": 146}, {"referenceID": 10, "context": "Several out-of-sample extension methods such as those based on fitting a particular type of interpolation function as in [11], [12], and [13] can be applied for generalizing supervised embeddings by fitting a function f to the priorly learned (xi, yi) pairs.", "startOffset": 121, "endOffset": 125}, {"referenceID": 11, "context": "Several out-of-sample extension methods such as those based on fitting a particular type of interpolation function as in [11], [12], and [13] can be applied for generalizing supervised embeddings by fitting a function f to the priorly learned (xi, yi) pairs.", "startOffset": 127, "endOffset": 131}, {"referenceID": 12, "context": "Several out-of-sample extension methods such as those based on fitting a particular type of interpolation function as in [11], [12], and [13] can be applied for generalizing supervised embeddings by fitting a function f to the priorly learned (xi, yi) pairs.", "startOffset": 137, "endOffset": 141}, {"referenceID": 22, "context": "The square matrix \u03a6 is invertible if the points xi are distinct and \u03c6 is chosen as the Gaussian kernel [23].", "startOffset": 103, "endOffset": 107}, {"referenceID": 23, "context": "nation of the nearest neighbors in XT for each test image is of complexity O(nN), and the solution of the quadratic program in (19) has a polynomial-time complexity O(poly(K)) in the number of neighbors K [24].", "startOffset": 205, "endOffset": 209}, {"referenceID": 24, "context": "An alternative formulation of ridge regression is proposed in [25] that is based on a dual version of the above problem.", "startOffset": 62, "endOffset": 66}, {"referenceID": 8, "context": "First, we consider the supervised Laplacian eigenmaps algorithm presented in [9], which computes an embedding by solving (1).", "startOffset": 77, "endOffset": 80}, {"referenceID": 4, "context": "Next, we evaluate our algorithm on embeddings obtained with the Fisher-like objective function in (2), which is used by methods such as [5], [6], [7], and [21].", "startOffset": 136, "endOffset": 139}, {"referenceID": 5, "context": "Next, we evaluate our algorithm on embeddings obtained with the Fisher-like objective function in (2), which is used by methods such as [5], [6], [7], and [21].", "startOffset": 141, "endOffset": 144}, {"referenceID": 6, "context": "Next, we evaluate our algorithm on embeddings obtained with the Fisher-like objective function in (2), which is used by methods such as [5], [6], [7], and [21].", "startOffset": 146, "endOffset": 149}, {"referenceID": 20, "context": "Next, we evaluate our algorithm on embeddings obtained with the Fisher-like objective function in (2), which is used by methods such as [5], [6], [7], and [21].", "startOffset": 155, "endOffset": 159}, {"referenceID": 1, "context": "\u2022 Locally linear embedding (LLE): Test points in R are mapped to R with an adaptation of the LLE algorithm [2] to the out-of-sample problem.", "startOffset": 107, "endOffset": 110}, {"referenceID": 25, "context": "We test the performance of SSL with the algorithm proposed in [26], which is a state-of-the-art semi-supervised classifier based on the computation of a smooth function on the data graph that coincides with the class labels when evaluated at data samples of known class labels.", "startOffset": 62, "endOffset": 66}, {"referenceID": 26, "context": "We first evaluate the proposed method on a data set consisting of the face images of 12 individuals from the extended Yale face database [27], which includes 58 images", "startOffset": 137, "endOffset": 141}, {"referenceID": 27, "context": "The first experiment is conducted on the images of 8 objects from the ETH-80 database [28], where 41 images are available for each object (in particular, the images of the first object in each object category are used so that the images in each class belong to the same manifold).", "startOffset": 86, "endOffset": 90}, {"referenceID": 28, "context": "The second experiment is done on the images of 20 objects from the COIL-20 database [29] with 71 images for each object, which are normalized, converted to grayscale, and downsampled to a resolution of 32 \u00d7 32 pixels.", "startOffset": 84, "endOffset": 88}], "year": 2015, "abstractText": "Supervised manifold learning methods for data classification map data samples residing in a high-dimensional ambient space to a lower-dimensional domain in a structurepreserving way, while enhancing the separation between different classes in the learned embedding. Most nonlinear supervised manifold learning methods compute the embedding of the manifolds only at the initially available training points, while the generalization of the embedding to novel points, known as the out-of-sample extension problem in manifold learning, becomes especially important in classification applications. In this work, we propose a semi-supervised method for building an interpolation function that provides an out-of-sample extension for general supervised manifold learning algorithms studied in the context of classification. The proposed algorithm computes a radial basis function (RBF) interpolator that minimizes an objective function consisting of the total embedding error of unlabeled test samples, defined as their distance to the embeddings of the manifolds of their own class, as well as a regularization term that controls the smoothness of the interpolation function in a direction-dependent way. The class labels of test data and the interpolation function parameters are estimated jointly with a progressive procedure. Experimental results on face and object images demonstrate the potential of the proposed out-of-sample extension algorithm for the classification of manifold-modeled data sets.", "creator": "LaTeX with hyperref package"}}}