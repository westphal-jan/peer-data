{"id": "1502.03509", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Feb-2015", "title": "MADE: Masked Autoencoder for Distribution Estimation", "abstract": "There has leaving in gotten of recent interest in designers physiological network larger come estimate 's distribution moved taking set of examples. We application a simple methods than autoencoder excitability stations that 10-year become implements types. Our method spray the autoencoder ' s mechanisms any achieve autoregressive criteria: regular input is chancel that was subsequent efficiently 20 with any retaliation. Constrained done way, the autoencoder coding you fully interpreted well old coming the conditional probabilities, and. industry, all full announced probability. We can besides ferries little band outlet that can lipids time joint probability in multiple and orderings. Our simple mechanism anything fact rules to multiple microcontroller, including deep ones. Vectorized debugging, that as on GPUs, several simple when fast. Experiments intentions made kind conventional is concentrating on independent - and - be - style campier distribution least-squares. At cricket takes, the required as significantly easily and clusters need which other cormet 2,034.", "histories": [["v1", "Thu, 12 Feb 2015 02:06:07 GMT  (104kb,D)", "https://arxiv.org/abs/1502.03509v1", "9 pages and 1 page of supplementary material"], ["v2", "Fri, 5 Jun 2015 14:37:32 GMT  (112kb,D)", "http://arxiv.org/abs/1502.03509v2", "9 pages and 1 page of supplementary material. Updated to match published version"]], "COMMENTS": "9 pages and 1 page of supplementary material", "reviews": [], "SUBJECTS": "cs.LG cs.NE stat.ML", "authors": ["mathieu germain", "karol gregor", "iain murray", "hugo larochelle"], "accepted": true, "id": "1502.03509"}, "pdf": {"name": "1502.03509.pdf", "metadata": {"source": "META", "title": "MADE: Masked Autoencoder for Distribution Estimation", "authors": ["Mathieu Germain", "Karol Gregor", "Iain Murray"], "emails": ["MATHIEU.GERMAIN2@USHERBROOKE.CA", "KAROL.GREGOR@GMAIL.COM", "I.MURRAY@ED.AC.UK", "HUGO.LAROCHELLE@USHERBROOKE.CA"], "sections": [{"heading": "1. Introduction", "text": "Distribution estimation is the task of estimating a joint distribution p(x) from a set of examples {x(t)}Tt=1, which is by definition a general problem. Many tasks in machine learning can be formulated as learning only specific properties of a joint distribution. Thus a good distribution estimator can be used in many scenarios, including classification (Schmah\nProceedings of the 32nd International Conference on Machine Learning, Lille, France, 2015. JMLR: W&CP volume 37. Copyright 2015 by the author(s).\net al., 2009), denoising or missing input imputation (Poon & Domingos, 2011; Dinh et al., 2014), data (e.g. speech) synthesis (Uria et al., 2015) and many others. The very nature of distribution estimation also makes it a particular challenge for machine learning. In essence, the curse of dimensionality has a distinct impact because, as the number of dimensions of the input space of x grows, the volume of space in which the model must provide a good answer for p(x) exponentially increases.\nFortunately, recent research has made substantial progress on this task. Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014). These algorithms are showing great potential in scaling to high-dimensional distribution estimation problems. In this work, we focus our attention on autoregressive models (Section 3). Computing p(x) exactly for a test example x is tractable with these models. However, the computational cost of this operation is still larger than typical neural network predictions for a D-dimensional input. For previous deep autoregressive models, evaluating p(x) costs O(D) times more than a simple neural network point predictor.\nThis paper\u2019s contribution is to describe and explore a simple way of adapting autoencoder neural networks that makes them competitive tractable distribution estimators that are faster than existing alternatives. We show how to mask the weighted connections of a standard autoencoder to convert it into a distribution estimator. The key is to use masks that are designed in such a way that the output is autoregressive for a given ordering of the inputs, i.e. that each input dimension is reconstructed solely from the dimensions preceding it in the\nar X\niv :1\n50 2.\n03 50\n9v 2\n[ cs\n.L G\n] 5\nordering. The resulting Masked Autoencoder Distribution Estimator (MADE) preserves the efficiency of a single pass through a regular autoencoder. Implementation on a GPU is straightforward, making the method scalable.\nThe single hidden layer version of MADE corresponds to the previously proposed autoregressive neural network of Bengio & Bengio (2000). Here, we go further by exploring deep variants of the model. We also explore training MADE to work simultaneously with multiple orderings of the input observations and hidden layer connectivity structures. We test these extensions across a range of binary datasets with hundreds of dimensions, and compare its statistical performance and scaling to comparable methods."}, {"heading": "2. Autoencoders", "text": "A brief description of the basic autoencoder, on which this work builds upon, is required to clearly grasp what follows. In this paper, we assume that we are given a training set of examples {x(t)}Tt=1. We concentrate on the case of binary observations, where for every D-dimensional input x, each input dimension xd belongs in {0, 1}. The motivation is to learn hidden representations of the inputs that reveal the statistical structure of the distribution that generated them.\nAn autoencoder attempts to learn a feed-forward, hidden representation h(x) of its input x such that, from it, we can obtain a reconstruction x\u0302 which is as close as possible to x. Specifically, we have\nh(x) = g(b + Wx) (1) x\u0302 = sigm(c + Vh(x)) , (2)\nwhere W and V are matrices, b and c are vectors, g is a nonlinear activation function and sigm(a) = 1/(1 + exp(\u2212a)). Thus, W represents the connections from the input to the hidden layer, and V represents the connections from the hidden to the output layer.\nTo train the autoencoder, we must first specify a training loss function. For binary observations, a natural choice is the cross-entropy loss:\n`(x) =\nD\u2211\nd=1\n\u2212xd log x\u0302d \u2212 (1\u2212xd) log(1\u2212x\u0302d) . (3)\nBy treating x\u0302d as the model\u2019s probability that xd is 1, the cross-entropy can be understood as taking the form of a negative log-likelihood function. Training the autoencoder corresponds to optimizing the parameters {W,V,b, c} to reduce the average loss on the training examples, usually with (mini-batch) stochastic gradient descent.\nOne advantage of the autoencoder paradigm is its flexibility. In particular, it is straightforward to obtain a deep autoencoder by inserting more hidden layers between the input\nand output layers. Its main disadvantage is that the representation it learns can be trivial. For instance, if the hidden layer is at least as large as the input, hidden units can each learn to \u201ccopy\u201d a single input dimension, so as to reconstruct all inputs perfectly at the output layer. One obvious consequence of this observation is that the loss function of Equation 3 isn\u2019t in fact a proper log-likelihood function. Indeed, since perfect reconstruction could be achieved, the implied data \u2018distribution\u2019 q(x)= \u220f d x\u0302 xd d (1\u2212x\u0302d)1\u2212xd could be learned to be 1 for any x and thus not be properly normalized ( \u2211 x q(x) 6=1)."}, {"heading": "3. Distribution Estimation as Autoregression", "text": "An interesting question is what property we could impose on the autoencoder, such that its output can be used to obtain valid probabilities. Specifically, we\u2019d like to be able to write p(x) in such a way that it could be computed based on the output of a properly corrected autoencoder.\nFirst, we can use the fact that, for any distribution, the probability product rule implies that we can always decompose it into the product of its nested conditionals\np(x) =\nD\u220f\nd=1\np(xd |x<d), (4)\nwhere x<d = [x1, . . . , xd\u22121]>.\nBy defining p(xd = 1 |x<d) = x\u0302d, and thus p(xd = 0 |x<d) = 1\u2212x\u0302d, the loss of Equation 3 becomes a valid negative log-likelihood:\n\u2212 log p(x) = D\u2211\nd=1\n\u2212 log p(xd |x<d)\n=\nD\u2211\nd=1\n\u2212xd log p(xd =1 |x<d)\n\u2212 (1\u2212xd) log p(xd =0 |x<d) = `(x) .\n(5)\nThis connection provides a way to define autoencoders that can be used for distribution estimation. Each output x\u0302d = p(xd |x<d) must be a function taking as input x<d only and outputting the probability of observing value xd at the dth dimension. In particular, the autoencoder forms a proper distribution if each output unit x\u0302d only depends on the previous input units x<d, and not the other units x\u2265d = [xd, . . . , xD] >.\nWe refer to this property as the autoregressive property, because computing the negative log-likelihood (5) is equivalent to sequentially predicting (regressing) each dimension of input x."}, {"heading": "4. Masked Autoencoders", "text": "The question now is how to modify the autoencoder so as to satisfy the autoregressive property. Since output x\u0302d must depend only on the preceding inputs x<d, it means that there must be no computational path between output unit x\u0302d and any of the input units xd, . . . , xD. In other words, for each of these paths, at least one connection (in matrix W or V) must be 0.\nA convenient way of zeroing connections is to elementwisemultiply each matrix by a binary mask matrix, whose entries that are set to 0 correspond to the connections we wish to remove. For a single hidden layer autoencoder, we write\nh(x) = g(b + (W MW)x) (6) x\u0302 = sigm(c + (V MV)h(x)) (7)\nwhere MW and MV are the masks for W and V respectively. It is thus left to the masks MW and MV to satisfy the autoregressive property.\nTo impose the autoregressive property we first assign each unit in the hidden layer an integer m between 1 and D\u22121 inclusively. The kth hidden unit\u2019s number m(k) gives the maximum number of input units to which it can be connected. We disallow m(k)=D since this hidden unit would depend on all inputs and could not be used in modelling any of the conditionals p(xd |x<d). Similarly, we exclude m(k)=0, as it would create constant hidden units.\nThe constraints on the maximum number of inputs to each hidden unit are encoded in the matrix masking the connections between the input and hidden units:\nMWk,d = 1m(k)\u2265d = { 1 if m(k) \u2265 d 0 otherwise, (8)\nfor d\u2208{1, . . . , D} and k \u2208{1, . . . ,K}. Overall, we need to encode the constraint that the dth output unit is only connected to x<d (and thus not to x\u2265d). Therefore the output weights can only connect the dth output to hidden units with m(k)<d, i.e. units that are connected to at most d\u22121 input units. These constraints are encoded in the output mask matrix:\nMVd,k = 1d>m(k) = { 1 if d > m(k) 0 otherwise, (9)\nagain for d \u2208 {1, . . . , D} and k \u2208 {1, . . . ,K}. Notice that, from this rule, no hidden units will be connected to the first output unit x\u03021, as desired.\nFrom these mask constructions, we can easily demonstrate that the corresponding masked autoencoder satisfies the autoregressive property. First, we note that, since the masks MV and MW represent the network\u2019s connectivity, their matrix product MV,W = MVMW represents the connectivity between the input and the output layer. Specifically,\nMV,Wd\u2032,d is the number of network paths between output unit x\u0302d\u2032 and input unit xd. Thus, to demonstrate the autoregressive property, we need to show that MV,W is strictly lower diagonal, i.e. MV,Wd\u2032,d is 0 if d\n\u2032 \u2264 d. By definition of the matrix product, we have:\nMV,Wd\u2032,d =\nK\u2211\nk=1\nMVd\u2032,kM W k,d =\nK\u2211\nk=1\n1d\u2032>m(k)1m(k)\u2265d. (10)\nIf d\u2032\u2264 d, then there are no values for m(k) such that it is both strictly less than d\u2032 and greater or equal to d. Thus MV,Wd\u2032,d is indeed 0.\nConstructing the masks MV and MW only requires an assignment of the m(k) values to each hidden unit. One could imagine trying to assign an (approximately) equal number of units to each legal value of m(k). In our experiments, we instead set m(k) by sampling from a uniform discrete distribution defined on integers from 1 to D\u22121, independently for each of the K hidden units.\nPrevious work on autoregressive neural networks have also found it advantageous to use direct connections between the input and output layers (Bengio & Bengio, 2000). In this context, the reconstruction becomes:\nx\u0302 = sigm(c + (V MV)h(x) + (A MA)x) , (11)\nwhere A is the parameter connection matrix and MA is its mask matrix. To satisfy the autoregressive property, MA simply needs to be a strictly lower diagonal matrix, filled otherwise with ones. We used such direct connections in our experiments as well."}, {"heading": "4.1. Deep MADE", "text": "One advantage of the masked autoencoder framework described in the previous section is that it naturally generalizes to deep architectures. Indeed, as we\u2019ll see, by assigning a maximum number of connected inputs to all units across the deep network, masks can be similarly constructed so as to satisfy the autoregressive property.\nFor networks with L>1 hidden layers, we use superscripts to index the layers. The first hidden layer matrix (previously W) will be denoted W1, the second hidden layer matrix will be W2, and so on. The number of hidden units (previously K) in each hidden layer will be similarly indexed as Kl, where l is the hidden layer index. We will also generalize the notation for the maximum number of connected inputs of the kth unit in the lth layer to ml(k).\nWe\u2019ve already discussed how to define the first layer\u2019s mask matrix such that it ensures that its kth unit is connected to at most m(k) (now m1(k)) inputs. To impose the same property on the second hidden layer, we must simply make sure that each unit k\u2032 is only connected to first layer units\nconnected to at most m2(k\u2032) inputs, i.e. the first layer units such that m1(k) \u2264 m2(k\u2032). One can generalize this rule to any layer l, as follows:\nMW l\nk\u2032,k = 1ml(k\u2032)\u2265ml\u22121(k) = { 1 if ml(k\u2032) \u2265 ml\u22121(k) 0 otherwise.\n(12) Also, taking l = 0 to mean the input layer and defining m0(d) = d (which is intuitive, since the dth input unit indeed takes its values from the d first inputs), this definition also applies for the first hidden layer weights. As for the output mask, we simply need to adapt its definition by using the connectivity constraints of the last hidden layer mL(k) instead of the first:\nMVd,k = 1d>mL(k) = { 1 if d > mL(k) 0 otherwise. (13)\nLike for the single hidden layer case, the values for ml(k) for each hidden layer l \u2208 {1, . . . , L} are sampled uniformly. To avoid unconnected units, the value for ml(k) is sampled\nto be greater than or equal to the minimum connectivity at the previous layer, i.e. mink\u2032 ml\u22121(k\u2032)."}, {"heading": "4.2. Order-agnostic training", "text": "So far, we\u2019ve assumed that the conditionals modelled by MADE were consistent with the natural ordering of the dimensions of x. However, we might be interested in modelling the conditionals associated with an arbitrary ordering of the input\u2019s dimensions.\nSpecifically, Uria et al. (2014) have shown that training an autoregressive model on all orderings can be beneficial. We refer to this approach as order-agnostic training. It can be achieved by sampling an ordering before each stochastic/minibatch gradient update of the model. There are two advantages of this approach. Firstly, missing values in partially observed input vectors can be imputed efficiently: we invoke an ordering where observed dimensions are all before unobserved ones, making inference straightforward. Secondly, an ensemble of autoregressive models can be constructed on the fly, by exploiting the fact that the conditionals for two different orderings are not guaranteed to be exactly consistent (and thus technically correspond to slightly different models). An ensemble is then easily obtained by sampling a set of orderings, computing the probability of x under each ordering and averaging.\nConveniently, in MADE, the ordering is simply represented by the vector m0 = [m0(1), . . . ,m0(D)]. Specifically, m0(d) corresponds to the position of the original dth dimension of x in the product of conditionals. Thus, a random ordering can be obtained by randomly permuting the ordered vector [1, . . . , D]. From these values of each m0, the first hidden layer mask matrix can then be created. During order-agnostic training, randomly permuting the last value of m0 again is sufficient to obtain a new random ordering."}, {"heading": "4.3. Connectivity-agnostic training", "text": "One advantage of order-agnostic training is that it effectively allows us to train as many models as there are orderings, using a common set of parameters. This can be exploited by creating ensembles of models at test time.\nIn MADE, in addition to choosing an ordering, we also have to choose each hidden unit\u2019s connectivity constraint ml(k). Thus, we could imaging training MADE to also be agnostic of the connectivity pattern generated by these constraints. To achieve this, instead of sampling the values of ml(k) for all units and layers once and for all before training, we actually resample them for each training example or minibatch. This is still practical, since the operation of creating the masks is easy to parallelize. Denoting ml = [ml(1), . . . ,ml(Kl)], and assuming an element-wise and parallel implementation of the operation 1a\u2265b for vectors, such that 1a\u2265b is a matrix\nAlgorithm 1 Computation of p(x) and learning gradients for MADE with order and connectivity sampling. D is the size of the input, L the number of hidden layers and K the number of hidden units.\nInput: training observation vector x Output: p(x) and gradients of \u2212 log p(x) on parameters\n# Sampling ml vectors m0 \u2190 shuffle([1, . . . , D]) for l from 1 to L do\nfor k from 1 to Kl do ml(k)\u2190 Uniform([mink\u2032 ml\u22121(k\u2032), . . . , D\u22121])\nend for end for\n# Constructing masks for each layer for l from 1 to L do MW\nl \u2190 1ml\u2265ml\u22121 end for MV \u2190 1m0>mL\n# Computing p(x) h0(x)\u2190 x for l from 1 to L do hl(x)\u2190 g(bl + (Wl MWl)hl\u22121(x)) end for x\u0302\u2190 sigm(c + (V MV)hL(x)) p(x)\u2190 exp (\u2211D d=1 xd log x\u0302d + (1\u2212xd) log(1\u2212x\u0302d) )\n# Computing gradients of \u2212 log p(x) tmp\u2190 x\u0302\u2212 x \u03b4c\u2190 tmp \u03b4V\u2190 ( tmp hL(x)> ) MV tmp\u2190 (tmp>(V MV))> for l from L to 1 do\ntmp\u2190 tmp g\u2032(bl + (Wl MWl)hl\u22121(x)) \u03b4bl \u2190 tmp \u03b4Wl \u2190 ( tmp hl\u22121(x)> ) MWl\ntmp\u2190 (tmp>(Wl MWl))> end for return p(x), \u03b4b1, . . . , \u03b4bL, \u03b4W1, . . . , \u03b4WL, \u03b4c, \u03b4V\nwhose i, j element is 1ai\u2265bj , then the hidden layer masks are simply MW l\n= 1ml\u2265ml\u22121 .\nBy resampling the connectivity of hidden units for every update, each hidden unit will have a constantly changing number of incoming inputs during training. However, the absence of a connection is indistinguishable from an instantiated connection to a zero-valued unit, which could confuse the neural network during training. In a similar situation, Uria et al. (2014) informed each hidden unit which units\nwere providing input with binary indicator variables, connected with additional learnable weights. We considered applying a similar strategy, using companion weight matrices Ul, that are also masked by MW l\nbut connected to a constant one-valued vector:\nhl(x) = g(bl + (Wl MWl)hl\u22121(x) + (Ul MWl)1) (14) An analogous parametrization of the output layer was also employed. These connectivity conditioning weights were only sometimes useful. In our experiments, we treated the choice of using them as a hyperparameter.\nMoreover, we\u2019ve found in our experiments that sampling masks for every example could sometimes over-regularize MADE and provoke underfitting. To fix this issue, we also considered sampling from only a finite list of masks. During training, MADE cycles through this list, using one for every update. At test time, we then average probabilities obtained for all masks in the list.\nAlgorithm 1 details how p(x) is computed by MADE, as well as how to obtain the gradient of `(x) for stochastic gradient descent training. For simplicity, the pseudocode assumes order-agnostic and connectivity-agnostic training, doesn\u2019t assume the use of conditioning weight matrices or of direct input/output connections. Figure 1 also illustrates an example of such a two-layer MADE network, along with its ml(k) values and its masks."}, {"heading": "5. Related Work", "text": "There has been a lot of recent work on exploring the use of feed-forward, autoencoder-like neural networks as probabilistic generative models. Part of the motivation behind this research is to test the common assumption that the use of models with probabilistic latent variables and intractable partition functions (such as the restricted Boltzmann machine (Salakhutdinov & Murray, 2008)), is a necessary evil in designing powerful generative models for high-dimensional data.\nThe work on the neural autoregressive distribution estimator or NADE (Larochelle & Murray, 2011) has illustrated that feed-forward architectures can in fact be used to form stateof-the-art and even tractable distribution estimators.\nRecently, a deep extension of NADE was proposed, improving even further the state-of-the-art in distribution estimation (Uria et al., 2014). This work introduced a randomized training procedure, which (like MADE) has nearly the same cost per iteration as a standard autoencoder. Unfortunately, deep NADE models still require D feed-forward passes through the network to evaluate the probability p(x) of a D-dimensional test vector. The computation of the first hidden layer\u2019s activations can be shared across these passes,\nalthough is slower in practice than evaluating a single pass in a standard autoencoder. In deep networks with K hidden units per layer, it costs O(DK2) to evaluate a test vector.\nDeep AutoRegressive Networks (DARN, Gregor et al., 2014), also provide probabilistic models with roughly the same training costs as standard autoencoders. DARN\u2019s latent representation consist of binary, stochastic hidden units. While simulating from these models is fast, evaluation of exact test probabilities requires summing over all configurations of the latent representation, which is exponential in computation. Monte Carlo approximation is thus recommended.\nThe main advantage of MADE is that evaluating probabilities retains the efficiency of autoencoders, with minor additional cost for simple masking operations. Table 1 lists the computational complexity for exact computation of probabilities for various models. DARN and RBMs are exponential in dimensionality of the hiddens or data, whereas NADE and MADE are polynomial. MADE only requires one pass through the autoencoder rather than the D passes required by NADE. In practice, we also observe that the single-layer MADE is an order of magnitude faster than a one-layer NADE, for the same hidden layer size, despite NADE sharing computation to get the same asymptotic scaling. NADE\u2019s computations cannot be vectorized as efficiently. The deep versions of MADE also have better scaling than NADE at test time. The training costs for MADE, DARN, and deep NADE will all be similar.\nBefore the work on NADE, Bengio & Bengio (2000) proposed a neural network architecture that corresponds to the special case of a single hidden layer MADE model, without randomization of input ordering and connectivity. A contribution of our work is to go beyond this special case, exploring deep variants and order/connectivity-agnostic training.\nAn interesting interpretation of the autoregressive mask sampling is as a structured form of dropout regularization (Srivastava et al., 2014). Specifically, it bears similarity with the masking in dropconnect networks (Wan et al., 2013). The exception is that the masks generated here must guaranty the autoregressive property of the autoencoder, while in Wan et al. (2013), each element in the mask is generated independently."}, {"heading": "6. Experiments", "text": "To test the performance of our model we considered two different benchmarks: a suite of UCI binary datasets, and the binarized MNIST dataset. The code to reproduce the experiments of this paper is available at https://github.com/mgermain/MADE/releases/tag/ICML2015. The results reported here are the average negative loglikelihood on the test set of each respective dataset. All experiments were made using stochastic gradient descent (SGD) with mini-batches of size 100 and a lookahead of 30 for early stopping."}, {"heading": "6.1. UCI evaluation suite", "text": "We use the binary UCI evaluation suite that was first put together in Larochelle & Murray (2011). It\u2019s a collection of 7 relatively small datasets from the University of California, Irvine machine learning repository and the OCR-letters dataset from the Stanford AI Lab. Table 2 gives an overview of the scale of those datasets and the way they were split.\nThe experiments were run with networks of 500 units per hidden layer, using the adadelta learning update (Zeiler, 2012) with a decay of 0.95. The other hyperparameters were varied as Table 3 indicates. We note as # of masks the number of different masks through which MADE cycles during training. In the no limit case, masks are sampled on the fly and never explicitly reused unless re-sampled by chance. In this situation, at validation and test time, 300 and 1000 sampled masks are used for averaging probabilities.\nThe results are reported in Table 4. We see that MADE is among the best performing models on half of the datasets and is competitive otherwise. To reduce clutter, we have not reported standard deviations, which were fairly small and consistent across models. However, for completeness we report standard deviations in a separate table in the supplementary materials.\nAn analysis of the hyperparameters selected for each dataset reveals no clear winner. However, we do see from Table 4 that when the mask sampling helps, it helps quite a bit and when it does not, the impact is negligible on all but OCRletters. Another interesting note is that the conditioning weights had almost no influence except on NIPS-0-12 where it helped."}, {"heading": "6.2. Binarized MNIST evaluation", "text": "The version of MNIST we used is the one binarized by Salakhutdinov & Murray (2008). MNIST is a set of 70,000 hand written digits of 28\u00d728 pixels. We use the same split as in Larochelle & Murray (2011), consisting of 50,000 for the training set, 10,000 for the validation set and 10,000 for the test set.\nExperiments were run using the adagrad learning update (Duchi et al., 2010), with an epsilon of 10\u22126. Since MADE is much more efficient than NADE, we considered varying the hidden layer size from 500 to 8000 units. Seeing that increasing the number of units tended to always help, we used 8000. Even with such a large hidden layer, our GPU implementation of MADE was quite efficient. Using a single mask, one training epoch requires about 14 and 44 seconds, for one hidden layer and two hidden layer MADE respectively. Using 32 sampled masks, training time increases to 33 and 100 respectively. These timings are all less than our GPU implementation of the 500 hidden units NADE model, which requires about 130 seconds per epoch. These timings were obtained on a K20 NVIDIA GPU.\nBuilding on what we learned on the UCI experiments, we set the activation function to be ReLU and the conditioning weights were not used. The hyperparameters that were varied are in Table 5.\nThe results are reported in Table 6, alongside other results\nTable 5. Binarized MNIST Grid Search\nHyperparameter Values tried\n# Hidden Layer 1, 2 Learning Rate 0.1, 0.05, 0.01, 0.005 # of masks 1, 2, 4, 8, 16, 32, 64\n0 10 20 30 40 50 60 70 # Masks used during training\n93.0\n93.5\n94.0\n94.5\n95.0\n95.5\n96.0\n96.5\n97.0\nN LL\nTest error\nFigure 2. Impact of the number of masks used with a single hidden layer, 500 hidden units network, on binarized MNIST.\ntaken from the literature. Again, despite its tractability, MADE is competitive with other models. Of note is the fact that the best MADE model outperforms the single layer NADE network, which was otherwise the best model among those requiring only a single feed-forward pass to compute log probabilities.\nIn these experiments, we clearly observed the overregularization phenomenon from using too many masks. When more than four orderings were used, the deeper variant of MADE always yielded better results. For the two layer model, adding masks during training helped up to 64, at which point the negative log-likelihood started to increase. We observed a similar pattern for the single layer model, but in this case the dip was around 8 masks. Figure 2 illustrates this behaviour more precisely for a single layer MADE with 500 hidden units, trained by only varying the number of masks used and the size of the mini-batches (83, 100, 128).\nWe randomly sampled 100 digits from our best performing model from Table 6 and compared them with their nearest neighbor in the training set (Figure 3), to ensure that the generated samples are not simple memorization. Each row of digits uses a different mask that was seen at training time by the network."}, {"heading": "7. Conclusion", "text": "We proposed MADE, a simple modification of autoencoders allowing them to be used as distribution estimators. MADE demonstrates that it is possible to get direct, cheap estimates of high-dimensional joint probabilities, from a single pass through an autoencoder. Like standard autoencoders, our extension is easy to vectorize and implement on GPUs. MADE can evaluate high-dimensional probably distributions with better scaling than before, while maintaining state-of-the-art statistical performance."}, {"heading": "Acknowledgments", "text": "We thank Marc-Alexandre Co\u0302te\u0301 for helping to implement NADE in Theano and the whole Theano (Bastien et al., 2012; Bergstra et al., 2010) team of contributors. We also thank NSERC, Calcul Que\u0301bec and Compute Canada."}], "references": [{"title": "Theano: new features and speed improvements", "author": ["Bastien", "Fr\u00e9d\u00e9ric", "Lamblin", "Pascal", "Pascanu", "Razvan", "Bergstra", "James", "Goodfellow", "Ian J", "Bergeron", "Arnaud", "Bouchard", "Nicolas", "Bengio", "Yoshua"], "venue": "Deep Learning and Unsupervised Feature Learning NIPS 2012 Workshop,", "citeRegEx": "Bastien et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bastien et al\\.", "year": 2012}, {"title": "Modeling highdimensional discrete data with multi-layer neural networks", "author": ["Bengio", "Yoshua", "Samy"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Bengio et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 1999}, {"title": "Deep generative stochastic networks trainable by backprop", "author": ["Bengio", "Yoshua", "Laufer", "Eric", "Alain", "Guillaume", "Yosinski", "Jason"], "venue": "In Proceedings of the 31th Annual International Conference on Machine Learning (ICML", "citeRegEx": "Bengio et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 2014}, {"title": "NICE: non-linear independent components estimation", "author": ["Dinh", "Laurent", "Krueger", "David", "Bengio", "Yoshua"], "venue": null, "citeRegEx": "Dinh et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Dinh et al\\.", "year": 2014}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["Duchi", "John", "Hazan", "Elad", "Singer", "Yoram"], "venue": "Technical report,", "citeRegEx": "Duchi et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2010}, {"title": "Generative adversarial nets", "author": ["Goodfellow", "Ian", "Pouget-Abadie", "Jean", "Mirza", "Mehdi", "Xu", "Bing", "Warde-Farley", "David", "Ozair", "Sherjil", "Courville", "Aaron", "Bengio", "Yoshua"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Goodfellow et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2014}, {"title": "Learning representations by maximizing compression", "author": ["Gregor", "Karol", "LeCun", "Yann"], "venue": null, "citeRegEx": "Gregor et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Gregor et al\\.", "year": 2011}, {"title": "Deep AutoRegressive Networks", "author": ["Gregor", "Karol", "Danihelka", "Ivo", "Mnih", "Andriy", "Blundell", "Charles", "Wierstra", "Daan"], "venue": "In Proceedings of the 31th Annual International Conference on Machine Learning (ICML", "citeRegEx": "Gregor et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Gregor et al\\.", "year": 2014}, {"title": "Auto-encoding variational bayes", "author": ["Kingma", "Diederik P", "Welling", "Max"], "venue": "In Proceedings of the 2nd International Conference on Learning Representations (ICLR", "citeRegEx": "Kingma et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kingma et al\\.", "year": 2014}, {"title": "The neural autoregressive distribution estimator", "author": ["Larochelle", "Hugo", "Murray", "Iain"], "venue": "In Proceedings of the 14th International Conference on Artificial Intelligence and Statistics (AISTATS 2011),", "citeRegEx": "Larochelle et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Larochelle et al\\.", "year": 2011}, {"title": "Sum-product networks: A new deep architecture", "author": ["Poon", "Hoifung", "Domingos", "Pedro"], "venue": "In Proceedings of the 20th Conference on Uncertainty in Artificial Intelligence (UAI", "citeRegEx": "Poon et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Poon et al\\.", "year": 2011}, {"title": "Stochastic backpropagation and approximate inference in deep generative models", "author": ["Rezende", "Danilo Jimenez", "Mohamed", "Shakir", "Wierstra", "Daan"], "venue": "In Proceedings of the 31th International Conference on Machine Learning (ICML", "citeRegEx": "Rezende et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Rezende et al\\.", "year": 2014}, {"title": "On the quantitative analysis of deep belief networks", "author": ["Salakhutdinov", "Ruslan", "Murray", "Iain"], "venue": "In Proceedings of the 25th Annual International Conference on Machine Learning (ICML", "citeRegEx": "Salakhutdinov et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Salakhutdinov et al\\.", "year": 2008}, {"title": "Generative versus discriminative training of RBMs for classification of fMRI images", "author": ["Schmah", "Tanya", "Hinton", "Geoffrey E", "Zemel", "Richard S", "Small", "Steven L", "Strother", "Stephen C"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Schmah et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Schmah et al\\.", "year": 2008}, {"title": "Dropout: A simple way to prevent neural networks from overfitting", "author": ["Srivastava", "Nitish", "Hinton", "Geoffrey", "Krizhevsky", "Alex", "Sutskever", "Ilya", "Salakhutdinov", "Ruslan"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Srivastava et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Srivastava et al\\.", "year": 2014}, {"title": "RNADE: The real-valued neural autoregressive densityestimator", "author": ["Uria", "Benigno", "Murray", "Iain", "Larochelle", "Hugo"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Uria et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Uria et al\\.", "year": 2013}, {"title": "A deep and tractable density estimator", "author": ["Uria", "Benigno", "Murray", "Iain", "Larochelle", "Hugo"], "venue": "In Proceedings of the 31th International Conference on Machine Learning,", "citeRegEx": "Uria et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Uria et al\\.", "year": 2014}, {"title": "Regularization of neural networks using dropconnect", "author": ["Wan", "Li", "Zeiler", "Matthew D", "Zhang", "Sixin", "LeCun", "Yann", "Fergus", "Rob"], "venue": "In Proceedings of the 30th International Conference on Machine Learning,", "citeRegEx": "Wan et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Wan et al\\.", "year": 2013}, {"title": "ADADELTA: an adaptive learning rate", "author": ["Zeiler", "Matthew D"], "venue": null, "citeRegEx": "Zeiler and D.,? \\Q2012\\E", "shortCiteRegEx": "Zeiler and D.", "year": 2012}], "referenceMentions": [{"referenceID": 3, "context": ", 2009), denoising or missing input imputation (Poon & Domingos, 2011; Dinh et al., 2014), data (e.", "startOffset": 47, "endOffset": 89}, {"referenceID": 15, "context": "Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014).", "startOffset": 92, "endOffset": 321}, {"referenceID": 11, "context": "Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014).", "startOffset": 92, "endOffset": 321}, {"referenceID": 2, "context": "Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014).", "startOffset": 92, "endOffset": 321}, {"referenceID": 7, "context": "Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014).", "startOffset": 92, "endOffset": 321}, {"referenceID": 5, "context": "Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014).", "startOffset": 92, "endOffset": 321}, {"referenceID": 3, "context": "Specifically, learning algorithms for a variety of neural network models have been proposed (Bengio & Bengio, 2000; Larochelle & Murray, 2011; Gregor & LeCun, 2011; Uria et al., 2013; 2014; Kingma & Welling, 2014; Rezende et al., 2014; Bengio et al., 2014; Gregor et al., 2014; Goodfellow et al., 2014; Dinh et al., 2014).", "startOffset": 92, "endOffset": 321}, {"referenceID": 15, "context": "Specifically, Uria et al. (2014) have shown that training an autoregressive model on all orderings can be beneficial.", "startOffset": 14, "endOffset": 33}, {"referenceID": 15, "context": "In a similar situation, Uria et al. (2014) informed each hidden unit which units were providing input with binary indicator variables, connected with additional learnable weights.", "startOffset": 24, "endOffset": 43}, {"referenceID": 16, "context": "Recently, a deep extension of NADE was proposed, improving even further the state-of-the-art in distribution estimation (Uria et al., 2014).", "startOffset": 120, "endOffset": 139}, {"referenceID": 14, "context": "An interesting interpretation of the autoregressive mask sampling is as a structured form of dropout regularization (Srivastava et al., 2014).", "startOffset": 116, "endOffset": 141}, {"referenceID": 17, "context": "Specifically, it bears similarity with the masking in dropconnect networks (Wan et al., 2013).", "startOffset": 75, "endOffset": 93}, {"referenceID": 14, "context": "An interesting interpretation of the autoregressive mask sampling is as a structured form of dropout regularization (Srivastava et al., 2014). Specifically, it bears similarity with the masking in dropconnect networks (Wan et al., 2013). The exception is that the masks generated here must guaranty the autoregressive property of the autoencoder, while in Wan et al. (2013), each element in the mask is generated independently.", "startOffset": 117, "endOffset": 374}, {"referenceID": 4, "context": "Experiments were run using the adagrad learning update (Duchi et al., 2010), with an epsilon of 10\u22126.", "startOffset": 55, "endOffset": 75}, {"referenceID": 0, "context": "We thank Marc-Alexandre C\u00f4t\u00e9 for helping to implement NADE in Theano and the whole Theano (Bastien et al., 2012; Bergstra et al., 2010) team of contributors.", "startOffset": 90, "endOffset": 135}], "year": 2015, "abstractText": "There has been a lot of recent interest in designing neural network models to estimate a distribution from a set of examples. We introduce a simple modification for autoencoder neural networks that yields powerful generative models. Our method masks the autoencoder\u2019s parameters to respect autoregressive constraints: each input is reconstructed only from previous inputs in a given ordering. Constrained this way, the autoencoder outputs can be interpreted as a set of conditional probabilities, and their product, the full joint probability. We can also train a single network that can decompose the joint probability in multiple different orderings. Our simple framework can be applied to multiple architectures, including deep ones. Vectorized implementations, such as on GPUs, are simple and fast. Experiments demonstrate that this approach is competitive with stateof-the-art tractable distribution estimators. At test time, the method is significantly faster and scales better than other autoregressive estimators.", "creator": "LaTeX with hyperref package"}}}