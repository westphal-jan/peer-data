{"id": "1506.02162", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jun-2015", "title": "Learning from Rational Behavior: Predicting Solutions to Unknown Linear Programs", "abstract": "We values to instance the no addition predicting the desired hold an linear program, though only resulting planning actually the purpose making constraints. This generalizes soon problem of learning rest might to purchasing behavior of first rational steroids who seen long unknown objective furthermore, which much leaving studied for during probably \" Learning from Revealed Preferences \". We without error to learning algorithms 2001 two settings: in itself first, the achieving of the linear program it known one the comprehension, one there only an arbitrary, equivalent set common constraint which certain discovered. Each example given set the learner being changing addition but requested, has constraint, and into equaliser there from problem-based is leave trends when correlation steps from the linear program supposed however split has present addition although location limitations. This models, among other things, the way of predicting the irrational of gave simplest agent young thanks similar became, but given efficiency these alive. In on later giving, the careful of the generalized learning and unknown, and how 2004 taken controlled out. The limitation of the coupling program may making change least evening, hard are originated. An can is instance by a set of increasing and date provided they to reasonable, own all task of as pgce kind began coming predict the adequate solving of next partially known linear an.", "histories": [["v1", "Sat, 6 Jun 2015 15:10:25 GMT  (351kb,D)", "https://arxiv.org/abs/1506.02162v1", null], ["v2", "Sun, 8 May 2016 20:07:43 GMT  (865kb,D)", "http://arxiv.org/abs/1506.02162v2", null], ["v3", "Wed, 26 Oct 2016 16:41:01 GMT  (651kb,D)", "http://arxiv.org/abs/1506.02162v3", "The short version of this paper appears in the proceedings of NIPS-16"]], "reviews": [], "SUBJECTS": "cs.DS cs.GT cs.LG", "authors": ["shahin jabbari", "ryan m rogers", "aaron roth", "steven z wu"], "accepted": true, "id": "1506.02162"}, "pdf": {"name": "1506.02162.pdf", "metadata": {"source": "CRF", "title": "Learning from Rational Behavior: Predicting Solutions to Unknown Linear Programs", "authors": ["Shahin Jabbari", "Ryan Rogers", "Aaron Roth", "Zhiwei Steven Wu"], "emails": ["{jabbari@cis,", "ryrogers@sas,", "aaroth@cis,", "wuzhiwei@cis}.upenn.edu"], "sections": [{"heading": "1 Introduction", "text": "We initiate the systematic study of a general class of multi-dimensional prediction problems, where the learner wishes to predict the solution to an unknown linear program (LP), given some partial information about either the set of constraints or the objective. In the special case in which there is a single known constraint that is changing and the objective that is unknown and fixed, this problem has been studied under the name learning from revealed preferences [1, 2, 3, 16] and captures the following scenario: a buyer, with an unknown linear utility function over d goods u : Rd \u2192 R defined as u(x) = c \u00b7 x faces a purchasing decision every day. On day t, she observes a set of prices pt \u2208 Rd\u22650 and buys the bundle of goods that maximizes her unknown utility, subject to a budget b:\nx(t) = argmax x c \u00b7 x such that pt \u00b7 x \u2264 b\nIn this problem, the goal of the learner is to predict the bundle that the buyer will buy, given the prices that she faces. Each example at day t is specified by the vector pt \u2208 Rd\u22650 (which fixes the constraint), and the goal is to accurately predict the purchased bundle x(t) \u2208 [0, 1]d that is the result of optimizing the unknown linear objective.\nIt is also natural to consider the class of problems in which the goal is to predict the outcome to a LP broadly e.g. suppose the objective c \u00b7 x is known but there is an unknown set of constraints Ax \u2264 b. An instance is again specified by a changing known constraint (pt, bt) and the goal is to predict:\nx(t) = argmax x c \u00b7 x such that Ax \u2264 b and pt \u00b7 x \u2264 bt. (1)\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n50 6.\n02 16\n2v 3\n[ cs\n.D S]\n2 6\nO ct\n2 01\nThis models the problem of predicting the behavior of an agent whose goals are known, but whose resource constraints are unknown.\nAnother natural generalization is the problem in which the objective is unknown, and may vary in a specified way across examples, and in which there may also be multiple arbitrary known constraints which vary across examples. Specifically, suppose that there are n distinct, unknown linear objective functions v1, . . . ,vn. An instance on day t is specified by a subset of the unknown objective functions, St \u2286 [n] := {1, . . . , n} and a convex feasible region Pt, and the goal is to predict:\nx(t) = argmax x \u2211 i\u2208St vi \u00b7 x such that x \u2208 Pt. (2)\nWhen the changing feasible regions Pt correspond simply to varying prices as in the revealed preferences problem, this models a setting in which at different times, purchasing decisions are made by different members of an organization, with heterogeneous preferences \u2014 but are still bound by an organization-wide budget. The learner\u2019s problem is, given the subset of decision makers and the prices at day t, to predict which bundle they will purchase. This generalizes some of the preference learning problems recently studied by Blum et al [6]. Of course, in this generality, we may also consider a richer set of changing constraints which represent things beyond prices and budgets.\nIn all of the settings we study, the problem can be viewed as the task of predicting the behavior of a rational decision maker, who always chooses the action that maximizes her objective function subject to a set of constraints. Some part of her optimization problem is unknown, and the goal is to learn, through observing her behavior, that unknown part of her optimization problem sufficiently so that we may reliably predict her future actions."}, {"heading": "1.1 Our Results", "text": "We study both variants of the problem (see below) in the strong mistake bound model of learning [13]. In this model, the learner encounters an arbitrary adversarially chosen sequence of examples online and must make a prediction for the optimal solution in each example before seeing future examples. Whenever the learner\u2019s prediction is incorrect, the learner encounters a mistake, and the goal is to prove an upper bound on the number of mistakes the learner can make, in the worst case over the sequence of examples. Mistake bound learnability is stronger than (and implies) PAC learnability [15].\nKnown Objective and Unknown Constraints We first study this problem under the assumption that there is a uniform upper bound on the number of bits of precision used to specify the constraint defining each example. In this case, we show that there is a learning algorithm with both running time and mistake bound linear in the number of edges of the polytope formed by the unknown constraint matrix Ax \u2264 b. We note that this is always polynomial in the dimension d when the number of unknown constraints is at most d + O(1). (In Appendix A, we show that by allowing the learner to run in time exponential in d, we can give a mistake bound that is always linear in the dimension and the number of rows of A, but we leave as an open question whether or not this mistake bound can be achieved by an efficient algorithm.) We then show that our bounded precision assumption is necessary \u2014 i.e. we show that when the precision to which constraints are specified need not be uniformly upper bounded, then no algorithm for this problem in dimension d \u2265 3 can have a finite mistake bound.\nThis lower bound motivates us to study a PAC style variant of the problem, where the examples are not chosen in an adversarial manner, but instead are drawn independently at random from an arbitrary unknown distribution. In this setting, we show that even if the constraints can be specified to arbitrary (even infinite) precision, there is a learner that requires sample complexity only linear in the number of edges of the unknown constraint polytope. This learner can be implemented efficiently when the constraints are specified with finite precision.\nKnown Constraints and Unknown Objective For the variant of the problem in which the objective is unknown and changing and the constraints are known but changing, we give an algorithm that has a mistake bound and running time polynomial in the dimension d. Our algorithm uses the Ellipsoid algorithm to learn the coefficients of the unknown objective by implementing a separation oracle that generates separating hyperplanes given examples on which our algorithm made a mistake.\nWe leave the study of either of our problems under natural relaxations (e.g. under a less demanding loss function) and whether it is possible to substantially improve our results in these relaxations as an interesting open problem."}, {"heading": "1.2 Related Work", "text": "Beigman and Vohra [3] were the first to study revealed preference problems (RPP) as a learning problems and to relate them to multi-dimensional classification. They derived sample complexity bounds for such problems by computing the fat shattering dimension of the class of target utility functions, and showed that the set of Lipschitz-continuous valuation functions had finite fat-shattering dimension. Zadimoghaddam and Roth [16] gave efficient algorithms with polynomial sample complexity for PAC learning of the RPP over the class of linear (and piecewise linear) utility functions. Balcan et al. [2] showed a connection between RPP and the structured prediction problem of learning d-dimensional linear classes [7, 8, 12], and use an efficient variant of the compression techniques given by Daniely and Shalev-Shwartz [9] to give efficient PAC algorithms with optimal sample complexity for various classes of economically meaningful utility functions. Amin et al. [1] study the RPP for linear valuation functions in the mistake bound model, and in the query model in which the learner gets to set prices and wishes to maximize profit. Roth et al. [14] also study the query model of learning and give results for strongly concave objective functions, leveraging an algorithm of Belloni et al. [4] for bandit convex optimization with adversarial noise.\nAll of the works above focus on the setting of predicting the optimizer of a fixed unknown objective function, together with a single known, changing constraint representing prices. This is the primary point of departure for our work \u2014 we give algorithms for the more general settings of predicting the optimizer of a LP when there may be many unknown constraints, or when the unknown objective function is changing. Finally, the literature on preference learning (see e.g. [10]) has similar goals, but is technically quite distinct: the canonical problem in preference learning is to learn a ranking on distinct elements. In contrast, the problem we consider here is to predict the outcome of a continuous optimization problem as a function of varying constraints."}, {"heading": "2 Model and Preliminaries", "text": "We first formally define the geometric notions used throughout this paper. A hyperplane and a halfspace in Rd are the set of points satisfying the linear equation a1x1 + . . . adxd = b and the linear inequality a1x1 + . . .+ adxd \u2264 b for a set of ais respectively, assuming that not all ai\u2019s are simultaneously zero. A set of hyperplanes are linearly independent if the normal vectors to the hyperplanes are linearly independent. A polytope (denoted by P \u2286 Rd) is the bounded intersection of finitely many halfspaces, written as P = {x | Ax \u2264 b}. An edge-space e of a polytope P is a one dimensional subspace that is the intersection of d\u2212 1 linearly independent hyperplanes of P , and an edge is the intersection between an edge-space e and the polytope P .We denote the set of edges of polytope P by EP . A vertex of P is a point where d linearly independent hyperplanes of P intersect. Equivalently, P can be written as the convex hull of its vertices V denoted by Conv(V ). Finally, we define a set of points to be collinear if there exists a line that contains all the points in the set.\nWe study an online prediction problem with the goal of predicting the optimal solution of a changing LP whose parameters are only partially known. Formally, in each day t = 1, 2, . . . an adversary chooses a LP specified by a polytope P(t) (a set of linear inequalities) and coefficients c(t) \u2208 Rd of the linear objective function. The learner\u2019s goal is to predict the solution x(t) where x(t) = argmaxx\u2208P(t) c\n(t) \u00b7 x. After making the prediction x\u0302(t), the learner observes the optimal x(t) and learns whether she has made a mistake (x\u0302(t) 6= x(t)). The mistake bound is defined as follows. Definition 1. Given a LP with feasible polytope P and objective function c, let \u03c3(t) denote the parameters of the LP that are revealed to the learner on day t. A learning algorithm A takes as input the sequence {\u03c3(t)}t, the known parameters of an adaptively chosen sequence {(P(t), c(t))}t of LPs and outputs a sequence of predictions {x\u0302(t)}t. We say that A has mistake bound M if max{(P(t),c(t))}t { \u03a3\u221et=11 [ x\u0302(t) 6= x(t) ]} \u2264M, where x(t) = argmaxx\u2208P(t) c(t) \u00b7 x on day t.\nWe consider two different instances of the problem described above. First, in Section 3, we study the problem given in (1) in which c(t) = c is fixed and known to the learner but the polytope P(t) =\nP \u2229N (t) consists of an unknown fixed polytope P and a new constraintN (t) = {x | p(t) \u00b7x \u2264 b(t)} which is revealed to the learner on day t i.e. \u03c3(t) = (N (t), c). We refer to this as the Known Objective problem. Then, in Section 4, we study the problem in which the polytope P(t) is changing and known but the objective function c(t) = \u2211 i\u2208S(t) v\ni is unknown and changing as in (2) where the set S(t) is known i.e. \u03c3(t) = (P(t), S(t)). We refer to this as the Known Constraints problem. In order for our prediction problem to be well defined, we make Assumption 1 about the observed solution x(t) in each day. Assumption 1 guarantees that each solution is on a vertex of P(t). Assumption 1. The optimal solution to the LP: maxx\u2208P(t) c(t) \u00b7 x is unique for all t."}, {"heading": "3 The Known Objective Problem", "text": "In this section, we focus on the Known Objective Problem where the coefficients of the objective function c are fixed and known to the learner but the feasible region P(t) on day t is unknown and changing. In particular, P(t) is the intersection of a fixed and unknown polytope P = {x | Ax \u2264 b, A \u2286 Rm\u00d7d} and a known halfspace N (t) = {x | p(t) \u00b7 x \u2264 b(t)} i.e. P(t) = P \u2229N (t). Throughout this section we make the following assumptions. First, we assume w.l.o.g. (up to scaling) that the points in P have `\u221e-norm bounded by 1. Assumption 2. The unknown polytope P lies inside the unit `\u221e-ball i.e. P \u2286 {x | ||x||\u221e \u2264 1}.\nWe also assume that the coordinates of the vertices in P can be written with finite precision (this is implied if the halfspaces defining P can be described with finite precision). 1\nAssumption 3. The coordinates of each vertex of P can be written with N bits of precision.\nWe show in Section 3.3 that Assumption 3 is necessary \u2014 without any upper bound on precision, there is no algorithm with a finite mistake bound. Next, we make some non-degeneracy assumptions on polytopes P and P(t), respectively. We require these assumptions to hold on each day. Assumption 4. Any subset of d\u2212 1 rows of A have rank d\u2212 1 where A is the constraint matrix in P = {x | Ax \u2264 b}. Assumption 5. Each vertex of P(t) is the intersection of exactly d-hyperplanes of P(t).\nThe rest of this section is organized as follows. We present LearnEdge for the Known Objective Problem and analyze its mistake bound in Sections 3.1 and 3.2, respectively. Then in Section 3.3, we prove the necessity of Assumption 3 to get a finite mistake bound. Finally in Section 3.4, we present the LearnHull in a PAC style setting where the new constraint each day is drawn i.i.d. from an unknown distribution, rather than selected adversarially.\n3.1 LearnEdge Algorithm\nIn this section we introduce LearnEdge and show in Theorem 1 that the number of mistakes of LearnEdge depends linearly on the number of edges EP and the precision parameter N and only logarithmically on the dimension d. We defer all the proofs of this section to Appendix B.\nTheorem 1. The number of mistakes and per day running time of LearnEdge in the Known Objective Problem are O(|EP |N log(d)) and poly(m, d, |EP |) respectively when A \u2286 Rm\u00d7d.\nAt a high level, LearnEdge maintains a set of prediction information I(t) about the prediction history up to day t, and makes prediction in each day based on I(t) and a set of prediction rules (P.1\u2212 P.4). After making a mistake, LearnEdge updates the information with a set of update rules (U.1\u2212 U.4). The framework of LearnEdge is presented in Algorithm 1. We will now present the details of each component.\n1Lemma 6.2.4 from Grotschel et al. [11] states that if each constraint in P \u2286 Rd has encoding length at most N then each vertex of P has encoding length at most 4d2N . Typically the finite precision assumption is made on the constraints of the LP. However, since this assumption implies that the vertices can be described with finite precision, for simplicity, we make our assumption directly on the vertices.\nAlgorithm 1 Learning in Known Objective Problem (LearnEdge) procedure LearnEdge({N (t),x(t)}t) . Against adaptive adversary\nInitialize I(1) to be empty. . Initialize for t = 1, 2, \u00b7 \u00b7 \u00b7 do\nPredict x\u0302(t) according to one of P.1 - P.4 based on N (t) and I(t). . Predict if x\u0302(t) 6= x(t) then\nX(t+1) \u2190 X(t) \u222a {x(t)}. Update I(t+1) with U.1 - U.4 based on x(t). . Update\nend procedure\nPrediction Information It is natural to ask \u201cWhat information is useful for prediction?\" Lemma 2 establishes the importance of the set of edges EP by showing that all the observed solutions will be on an element of EP .\nLemma 2. On any day t, the observed solution x(t) lies on an edge in EP .\nIn the proof of Lemma 2 we also show that when x(t) does not bind the new constraint N (t), then x(t) is the solution for the underlying LP: argmaxx\u2208P c \u00b7 x. Corollary 1. If x(t) \u2208 {x | p(t)x < b(t)} then x(t) = x\u2217 \u2261 argmaxx\u2208P c \u00b7 x.\nWe then show how an edge-space e of P can be recovered after seeing 3 collinear observed solutions. Lemma 3. Let x,y, z be 3 distinct collinear points on edges of P . Then they are all on the same edge of P and the 1-dimensional subspace containing them is an edge-space of P .\nGiven the relation between observed solutions and edges, the information I(t) is stored as follows:\nFeQe 0\nMe 0\nYe 0 Ye 1\nMe 1\nQe 1\n}} }}}\nWe add the superscript (t) to show the dependence of these quantities on days. Furthermore, we eliminate the subscript e when taking the union over all elements in E(t), e.g. F (t) = \u22c3 e\u2208E(t) F (t) e .\nSo the information I(t) can be written as follows: I(t) = ( X(t), E(t), F (t), Y (t), Q(t),M (t) ) .\nPrediction Rules We now focus on the prediction rules of LearnEdge. On day t, let N\u0303 (t) = {x | p(t) \u00b7 x = b(t)} be the hyperplane specified by the additional constraint N (t). If x(t) /\u2208 N\u0303 (t), then x(t) = x\u2217 by Corollary 1. So whenever the algorithm observes x\u2217, it will store x\u2217 and predict it in the future days when x\u2217 \u2208 N (t). This is case P.1. So in the remaining cases we know x\u2217 /\u2208 N (t).\nThe analysis of Lemma 2 shows that x(t) must be in the intersection between N\u0303 (t) and the edges EP , so x(t) = argmaxx\u2208N\u0303 (t)\u2229EP c \u00b7 x. Hence, LearnEdge can restrict its prediction to the following candidate set: Cand(t) = {(E(t) \u222aX(t)) \\ E\u0304(t)} \u2229 N\u0303 (t) where E\u0304(t) = {e \u2208 E(t) | e \u2286 N\u0303 (t)}. As we show in Lemma 4, x(t) will not be in E\u0304(t), so it is safe to remove E\u0304(t) from Cand(t).\nLemma 4. Let e be an edge-space of P such that e \u2286 N\u0303 (t), then x(t) 6\u2208 e.\nHowever, Cand(t) can be empty or only contain points in the infeasible regions of the edge-spaces. If so, then there is simply not enough information to predict a feasible point in P . Hence, LearnEdge predicts an arbitrary point outside of Cand(t). This is case P.2.\nOtherwise Cand(t) contains points from the feasible and questionable regions of the edge-spaces. LearnEdge predicts from a subset of Cand(t) called the extended feasible region Ext(t) instead of directly predicting from Cand(t). Ext(t) contains the whole feasible region and only parts of the questionable region on all the edge-spaces in E(t) \\ E\u0304(t). We will show later that this guarantees LearnEdge makes progress in learning the true feasible region on some edge-space upon making a mistake. More formally, Ext(t) is the intersection of N\u0303 (t) with the union of intervals between the two mid-points (M0e ) (t) and (M1e ) (t) on every edge-space e \u2208 E(t) \\ E\u0304(t) and all points in X(t):\nExt(t) = { X(t) \u222a { \u222ae\u2208E(t)\\E\u0304(t)Conv ( (M0e ) (t), (M1e ) (t) )}} \u2229 N\u0303 (t).\nIn P.3, if Ext(t) 6= \u2205 then LearnEdge predicts the point with the highest objective value in Ext(t).\nFinally, if Ext(t) = \u2205, then we know N\u0303 (t) only intersects within the questionable regions of the learned edge-spaces. In this case, LearnEdge predicts the intersection point with the lowest objective value, which corresponds to P.4. Although it might seem counter-intuitive to predict the point with the lowest objective value, this guarantees that LearnEdge makes progress in learning the true feasible region on some edge-space upon making a mistake. The prediction rules are summarized as follows:\nP.1 First, if x\u2217 is observed and x\u2217 \u2208 N (t), then predict x\u0302(t) \u2190 x\u2217;\nP.2 Else if Cand = \u2205 or Cand(t) \u2286 \u22c3 e\u2208E(t) Y (t) e , then predict any point outside Cand(t);\nP.3 Else if Ext(t) 6= \u2205, then predict x\u0302(t) = argmaxx\u2208Ext(t) c \u00b7 x;\nP.4 Else, predict x\u0302(t) = argminx\u2208Cand(t) c \u00b7 x.\nUpdate Rules Next we describe how LearnEdge updates its information. Upon making a mistake, LearnEdge adds x(t) to the set of previously observed solutions X(t) i.e. X(t+1) \u2190 X(t) \u222a {x(t)}. Then it performs one of the following four mutually exclusive update rules (U.1-U.4) in order.\nU.1 If x(t) /\u2208 N\u0303 (t), then LearnEdge records x(t) as the unconstrained optimal solution x\u2217.\nU.2 Then if x(t) is not on any learned edge-space in E(t), LearnEdge will try to learn a new edge-space by checking the collinearity of x(t) and any couple of points in X(t). So after this update LearnEdge might recover a new edge-space of the polytope.\nIf the previous updates were not invoked, then x(t) was on some learned edge-space e. LearnEdge then compares the objective values of x\u0302(t) and x(t) (we know c \u00b7 x\u0302(t) 6= c \u00b7 x(t) by Assumption 1):\nU.3 If c \u00b7 x\u0302(t) > c \u00b7 x(t), then x\u0302(t) must be infeasible and LearnEdge then updates the questionable and infeasible regions for e.\nU.4 If c \u00b7 x\u0302(t) < c \u00b7 x(t) then x(t) was outside of the extended feasible region of e. LearnEdge then updates the questionable region and feasible interval on e.\nIn both of U.3 and U.4, LearnEdge will shrink some questionable interval substantially till the interval has length less than 2\u2212N in which case Assumption 3 implies that the interval contains no points. So LearnEdge can update the adjacent feasible region and infeasible interval accordingly.\n3.2 Analysis of LearnEdge\nWhenever LearnEdge makes a mistake, one of the update rules U.1 - U.4 is invoked. So the number of mistakes of LearnEdge is bounded by the number of times each update rule is invoked. The mistake bound of LearnEdge in Theorem 1 is hence the sum of mistakes bounds in Lemmas 5-7. Lemma 5. Update U.1 is invoked at most 1 time. Lemma 6. Update U.2 is invoked at most 3|EP | times. 2\nLemma 7. Updates U.3 and U.4 are invoked at most O(|EP |N log(d)) times."}, {"heading": "3.3 Necessity of the Precision Bound", "text": "We show the necessity of Assumption 3 by showing that the dependence on the precision parameter N in our mistake bound is tight. We show that subject to Assumption 3, there exist a polytope and a sequence of additional constraints such that any learning algorithm will make \u2126(N) mistakes. This implies that without any upper bound on precision, it is impossible to learn with finite mistakes. Theorem 8. For any learning algorithm A in the Known Objective Problem and any d \u2265 3, there exists a polytopeP and a sequence of additional constraints {N (t)}t such that the number of mistakes made by A is at least \u2126(N). 3"}, {"heading": "3.4 Stochastic Setting", "text": "Given the lower bound in Theorem 8, we ask \u201cIn what settings we can still learn without an upper bound on the precision to which constraints are specified?\u201d The lower bound implies we must abandon the adversarial setting so we consider a PAC style variant. In this variant, the additional constraint at each day t is drawn i.i.d. from some fixed but unknown distribution D over Rd\u00d7R such that each point (p, b) drawn from D corresponds to the halfspace N = {x | p \u00b7 x \u2264 b}. We make no assumption on the form of D and require our bounds to hold in the worst case over all choices of D. We describe LearnHull an algorithm based on the following high level idea: LearnHull keeps track of the convex hull C(t\u22121) of all the solutions observed up to day t. LearnHull then behaves as if this convex hull is the entire feasible region. So at day t, given the constraintN (t) = {x | p(t) \u00b7x \u2264 b(t)}, LearnHull predicts x\u0302(t) where\nx\u0302(t) = argmaxx\u2208C(t\u22121)\u2229N (t) c \u00b7 x. (3)\nLearnHull\u2019s hypothetical feasible region is therefore always a subset of the true feasible region \u2013 i.e. it can never make a mistake because its prediction was infeasible, but only because its prediction was sub-optimal. Hence, whenever LearnHull makes a mistake, it must have observed a point that expands the convex hull. Hence, whenever it fails to predict x(t), LearnHull will enlarge its feasible region by adding the point x(t) to the convex hull:\nC(t) \u2190 Conv(C(t\u22121) \u222a {x(t)}), (4)\notherwise it will simply set C(t) \u2190 C(t\u22121) for the next day. LearnHull is described formally in Algorithm 2.\nWe show that the expected number of mistakes of LearnHull over T days is linear in the number of edges of P and only logarithmic in T . 4\n2The dependency on |EP | can be improved by replacing it with the set of edges of P on which an optimal solution is observed. This applies to all the dependencies on |EP | in our bounds.\n3 We point out that the condition d \u2265 3 is necessary in the statement of Theorem 8 since there exists learning algorithms for d = 1 and d = 2 with finite mistake bounds independent of N . See Appendix C.\n4LearnHull can be implemented efficiently in time poly(T,N, d) if all of the coefficients in the unknown constraints in P are represented in N bits. Note that given the observed solutions so far and a new point, a separation oracle can be implemented in time poly(T,N, d) using a LP solver.\nAlgorithm 2 Stochastic Procedure (LearnHull) procedure LearnHull(D) C(0) \u2190 \u2205. . Initialize Observe N (t) \u223c D and set x\u0302(t) as in (3). . Predict Observers x(t) = argmaxx\u2208P\u2229N (t) c \u00b7 x and update C(t) as in (4). . Update\nend procedure\nTheorem 9. For any T > 0 and any constraint distribution D, the expected number of mistakes of LearnHull after T days is bounded by O (|EP | log(T )).\nTo prove Theorem 9, first in Lemma 10 we bound the probability that the solution observed at day t falls outside of the convex hull of the previously observed solutions. This is the only event that can cause LearnHull to make a mistake. In Lemma 10, we abstract away the fact that the point observed at each day is the solution to some optimization problem. Lemma 10. LetP be a polytope andD a distribution over points onEP . LetX = {x1, . . . , xt\u22121} be t\u22121 i.i.d. draws fromD and xt an additional independent draw fromD. Then Pr[xt 6\u2208 Conv(X)] \u2264 2|EP |/t where the probability is taken over the draws of points x1, . . . , xt from D.\nFinally in Theorem 11 we convert the bound on the expected number of mistakes of LearnHull in Theorem 9 to a high probability bound. 5\nTheorem 11. There exists a deterministic procedure such that after T = O (|EP | log (1/\u03b4)) days, the probability (over the randomness of the additional constraint) that the procedure makes a mistake on day T + 1 is at most \u03b4 for any \u03b4 \u2208 (0, 1/2)."}, {"heading": "4 The Known Constraints Problem", "text": "We now consider the Known Constraints Problem in which the learner observes the changing constraint polytope P(t) at each day, but does not know the changing objective function which we assume to be written as c(t) = \u2211 i\u2208S(t) v\ni, where {vi}i\u2208[n] are fixed but unknown. Given P(t) and the subset S(t) \u2286 [n], the learner must make a prediction x\u0302(t) on each day. Inspired by Bhaskar et al. [5], we use the Ellipsoid algorithm to learn the coefficients {vi}i\u2208[n], and show that the mistake bound of the resulting algorithm is bounded by the (polynomial) running time of the Ellipsoid. We use V \u2208 Rd\u00d7n to denote the matrix whose columns are vi and make the following assumption on V . Assumption 6. Each entry in V can be written with N bits of precision. Also w.l.o.g. ||V ||F \u2264 1.\nSimilar to Section 3 we assume the coordinates of P(t)\u2019s vertices can be written with finite precision.6\nAssumption 7. The coordinates of each vertex of P(t) can be written with N bits of precision.\nWe first observe that the coefficients of the objective function represent a point that is guaranteed to lie in a region F (described below) which may be written as the intersection of possibly infinitely many halfspaces. Given a subset S \u2286 [n] and a polytope P , let xS,P denote the optimal solution to the instance defined by S and P . Informally, the halfspaces defining F ensure that for any problem instance defined by arbitrary choices of S and P , the objective value of the optimal solution xS,P must be at least as high as the objective value of any feasible point in P . Since the convergence rate of the Ellipsoid algorithm depends on the precision to which constraints are specified, we do not in fact consider a hyperplane for every feasible solution but only for those solutions that are vertices of the feasible polytope P . This is not a relaxation, since LPs always have vertex-optimal solutions. We denote the set of all vertices of polytope P by vert(P), and the set of polytopes P satisfying Assumption 7 by \u03a6. We then define F as follows:\nF = { W = (w1, . . . ,wn) \u2208 Rn\u00d7d | \u2200S \u2286 [n],\u2200P \u2208 \u03a6,\n\u2211 i\u2208S wi \u00b7 ( xS,P \u2212 x ) \u2265 0,\u2200x \u2208 vert(P) } (5)\n5LearnEdge fails to give any non-trivial mistake bound in the adversarial setting. 6We again point out that this is implied if the halfspaces defining the polytope are described with finite\nprecision [11].\nThe idea behind our LearnEllipsoid algorithm is that we will run a copy of the Ellipsoid algorithm with variables w \u2208 Rd\u00d7n, as if we were solving the feasibility LP defined by the constraints defining F . We will always predict according to the centroid of the ellipsoid maintained by the Ellipsoid algorithm (i.e. its candidate solution). Whenever a mistake occurs, we are able to find one of the constraints that define F such that our prediction violates the constraint \u2013 exactly what is needed to take a step in solving the feasibility LP. Since we know F is non-empty (at least the true objective function V lies within it) we know that the LP we are solving is feasible. Given the polynomial convergence time of the Ellipsoid algorithm, this gives a polynomial mistake bound for our algorithm.\nThe Ellipsoid algorithm will generate a sequence of ellipsoids with decreasing volume such that each one contains feasible region F . Given the ellipsoid E(t) at day t, LearnEllipsoid uses the centroid of E(t) as its hypothesis for the objective function W (t) = ( (w1)(t), . . . , (wn)(t) ) . Given the subset\nS(t) and polytope P(t), LearnEllipsoid predicts\nx\u0302(t) \u2208 argmax x\u2208P(t) { \u2211 i\u2208S(t) (wi)(t) \u00b7 x}. (6)\nWhen a mistake occurs, LearnEllipsoid finds the hyperplane\nH(t) = W = (w1, . . . ,wn) \u2208 Rn\u00d7d : \u2211 i\u2208S(t) wi \u00b7 (x(t) \u2212 x\u0302(t)) > 0  (7) that separates the centroid of the current ellipsoid (the current candidate objective) from F .\nAfter the update, we use the Ellipsoid algorithm to compute the minimum-volume ellipsoid E(t+1) that containsH(t) \u2229 E(t). On day t+ 1, LearnEllipsoid sets W (t+1) to be the centroid of E(t+1). The above procedure is formalized in Algorithm 3.\nAlgorithm 3 Learning with Known Constraints (LearnEllipsoid) procedure LearnEllipsoid(A) . Against adversary A\nI(1) \u2190 ( E(1) = {z \u2208 Rn\u00d7d : ||z||F \u2264 2},W (1) = CENTROID(E(1)) ) . Initialize for t = 1 . . . do Given S(t),P(t), set x\u0302(t) as in (6). . Predict if x(t) 6= x\u0302(t) then\nsetH(t) as in (7). . Update E(t+1) \u2190 ELLIPSOID(H(t), E(t)),W (t+1) = CENTROID(E(t+1)). I(t+1) = ( E(t+1),W (t+1) ) .\nelse I(t+1) \u2190 I(t).\nend procedure\nWe left the procedure used to solve the LP in the prediction rule of LearnEllipsoid unspecified. To simplify our analysis, we use a specific LP solver to obtain a prediction x\u0302(t) which is a vertex of P(t). We defer all the proofs of this section to Appendix D. Theorem 12 (Theorem 6.4.12 and Remark 6.5.2 [11]). There exists a LP solver that runs in time polynomial in the length of its input and returns an exact solution that is a vertex of P(t).\nIn Theorem 13, we show that the number of mistakes made by LearnEllipsoid is at most the number of updates that the Ellipsoid algorithm makes before it finds a point in F and the number of updates of the Ellipsoid algorithm can be bounded by well-known results from the literature on LP. Theorem 13. The total number of mistakes and the running time of LearnEllipsoid in the Known Constraints Problem is at most poly(n, d,N)."}, {"heading": "A Polynomial Mistake Bound with Exponential Running Time", "text": "In this section we give a simple randomized algorithm for the unknown constraints problem, that in expectation makes a number of mistakes that is only linear in the dimension d, the number of rows in the unknown constraint matrix A (denoted by m), and the bit precision N , but which requires exponential running time. When the number of rows is large, this can represent an exponential improvement over the mistake bound of LearnEdge, which is linear in the number of edges on the polytope P defined by A. This algorithm which we describe shortly is a randomized variant of the well known halving algorithm [13]. We leave it as an open problem whether the mistake bound achieved by this algorithm can also be achieved by a computationally efficient algorithm.\nLet K be the hypothesis class of all polytopes formed by m constraints in d dimensions, such that each entry of each constraint can be written as a multiple of 1/2N (and without loss of generality, up to scaling, has absolute value at most 1). We then have\n|K| = 2O(dmN).\nWe write K(t) to denote the polytopes that are consistent with the examples and solutions we have seen up to and including day t. Note that |K(t)| \u2265 1 for every t because there is some polytope (specifically the true unknown polytope P) that is consistent with all the optimal solutions. On each day t we keep track of consistent polytopes and more specifically update the set of consistent polytopes by\nK(t+1) = { P \u2208 K(t) | x(t) \u2208 argmax\nx\u2208P\u2229N (t) c \u00b7 x\n} , (8)\nwhere N (t) is the new constraint on day t. The formal description of the algorithm, FCP, is presented in Algorithm 4. To predict at each day, FCP selects a polytope P\u0302(t) from K(t) uniformly at random and guesses x\u0302(t) that solves the following LP: maxx\u2208P\u0302(t)\u2229N (t) c \u00b7 x.\nAlgorithm 4 Find Consistent Polytope FCP procedure FCP K(1) = K. . Initialize for t = 1 . . . do\nChoose P\u0302(t) \u2208 K(t) uniformly at random. Guess x\u0302(t) \u2208 argmaxx\u2208P\u0302(t)\u2229N (t) c \u00b7 x. . Predict Observe x(t) and set K(t+1) as in (8).\nend procedure\nWe now bound the expected number of mistakes that FCP makes. Theorem 14. The expected number of mistakes that FCP makes is at most log(|K|) = O(dmN), where the expectation is over the randomness of FCP and possible randomness of the adversary.\nProof. First note that the probability that FCP does not make a mistake at day t can be expressed as |K(t+1)|/|K(t)|. This is because if FCP makes a mistake at day t, it must have selected a polytope that will be eliminated at the next day (also note that FCP selects its polytope from among the consistent set uniformly at random). Now consider the product of these probabilities over all days t = 1 . . . T .\nT\u220f t=1 (1\u2212 P [Mistake at day t]) = T\u220f t=1 |K(t+1)| |K(t)| = |K(T+1)| |K(1)| .\nFinally, note that the expected number of mistakes is the sum of probabilities of making mistakes over all days. Using the inequality (1\u2212 x) \u2264 e\u2212x for every x \u2208 [0, 1] and rearranging terms we get\nT\u2211 t=1 P [Mistake at day t] \u2264 log ( |K(1)| |K(T+1)| ) \u2264 O(dmN),\nsince |K(1)| = 2O(dmN) and |K(T+1)| \u2265 1.\nFinally, we remark that the randomized halving technique above will also result in a polynomial mistake bound in the more demanding variant where not only the underlying constraint matrix but also the linear objective function is unknown. This is because the coefficients of the objective function can be written in dN bits if they are also represented with finite precision. However, the issue about the exponential running time still exists in the new setting."}, {"heading": "B Missing Proofs from Section 3", "text": "B.1 Section 3.1\nProof of Lemma 2. Let x\u2217 be the optimal solution of the linear program solved over the unknown polytope P , without the added constraint i.e. x\u2217 \u2261 argmaxx\u2208P c \u00b7 x.\n1. Suppose that x\u2217 \u2208 N (t), then clearly x(t) = x\u2217. By Assumption 1, x\u2217 lies on a vertex of P and therefore x(t) lies on one of the edges of P .\n2. Suppose that x\u2217 /\u2208 N (t) i.e. p(t) \u00b7 x\u2217 > b(t). Then we claim that the optimal solution x(t) satisfies p(t) \u00b7 x(t) = b(t). Suppose to the contrary that p(t) \u00b7 x(t) < b(t). Since c \u00b7 x\u2217 \u2265 c \u00b7 x(t), then for any point y \u2208 Conv(x(t),x\u2217),\nc \u00b7 y = c \u00b7 (\u03b1x(t) + (1\u2212 \u03b1)x\u2217) = \u03b1(c \u00b7 x(t)) + (1\u2212 \u03b1)(c \u00b7 x\u2217) \u2265 c \u00b7 x(t) \u2200\u03b1 \u2208 [0, 1].\nSince x(t) strictly satisfies the new constraint, there exists some point y\u2217 \u2208 Conv(x(t),x\u2217) where y\u2217 6= x(t) such that y\u2217 \u2208 P(t) (i.e. y\u2217 is also feasible). It follows that c \u00b7 y\u2217 \u2265 c \u00b7x(t), which contradicts Assumption 1. Therefore, x(t) must bind the additional constraint. Furthermore, by non-degeneracy Assumption 5, x(t) binds exactly (d\u2212 1) constraints in P , i.e. x(t) lies at the intersection of d\u2212 1 hyperplanes of P which are linearly independent by Assumption 4. Therefore, x(t) must be on an edge of P .\nProof of Lemma 3. Without loss of generality, let us assume y can be written as convex combination of x and z i.e. y = \u03b1x + (1 \u2212 \u03b1)z for some \u03b1 \u2208 (0, 1). Let By = {j | Ajy = bj} be the set of binding constraints for y. We know that |By| \u2265 d\u22121 by Assumption 5. For any j in By , we consider the following two cases.\n1. At least one of x and z belongs to the hyperplane {w | Ajw = bj}. Then we claim that all three points bind the same constraint. Assume that Ajx = bj , then we must have\nAjz = Aj(y \u2212 \u03b1x)\n(1\u2212 \u03b1) = bj \u2212 \u03b1bj (1\u2212 \u03b1) = bj .\nSimilarly, if we assume Ajz = bj , we will also have Ajx = bj .\n2. None of x and z belongs to the hyperplane {w | Ajw = bj} i.e. Ajx < bj and Ajz < bj both hold. Then we can write\nbj = Ajy = \u03b1Ajx + (1\u2212 \u03b1)Ajz < \u03b1bj + (1\u2212 \u03b1)bj = bj ,\nwhich is a contradiction.\nIt follows that for any j \u2208 By, we have Ajx = Ajy = Ajz = bj . Since |By| \u2265 d \u2212 1, we know by Assumption 4 that the set of points that bind any set of d \u2212 1 constraints in By will form an edge-space and further this edge-space will include x,y, and z.\nProof of Lemma 4. First, note that the observed solution x(t) is a vertex in the polytope P(t) = P \u2229 N\u0303 (t), that is an intersection of exactly d constraints by Assumption 1 and Assumption 5. Second, note that all points in e bind at least d\u2212 1 constraints in P and since e \u2286 N\u0303 (t), then all points in e bind at least d constraints in P(t). It follows that any vertex of P(t) on e must bind at least (d+ 1) constraints, which rules out the possibility of x(t) being on e.\nB.2 Section 3.2\nProof of Lemma 5. As soon as LearnEdge invokes update rule U.1, it records the solution x\u2217 \u2261 argmaxx\u2208P c \u00b7x. Then, the prediction rule specified by P.1 prevents further updates of this type. This is because x\u2217 continues to remain optimal if it feasible in the more constrained problem (optimizing over the polytope P(t)).\nProof of Lemma 6. Rule U.2 is invoked only when x(t) /\u2208 X(t) and x(t) /\u2208 e for any of e \u2208 E(t). So after each invokation, a new point on the edge of P is observed. Whenever 3 points are observed on the same edge of P , the edge-space is learned by Lemma 3 (since the points are necessarily collinear). Hence, the total number of times rule U.2 can be invoked is at most 3|EP |. We now introduce Lemmas 16 and 17 that will be used in the proof of Lemma 18 which itself will be useful in the proof of Lemma 7. But first, for completeness, in Lemma 15 we show that we are guaranteed the existence of an edge-space if the update implemented is U.3 or U.4. Lemma 15.\n(1) If update rule U.3 is used, then there exists edge-space e\u0302 \u2208 E(t) such that x\u0302(t) \u2208 e\u0302.\n(2) If update rule U.4 is used, then there exists edge-space e \u2208 E(t) such that x(t) \u2208 e.\nProof. We prove this by contradiction. First consider the case in which c \u00b7 x\u0302(t) > c \u00b7x(t) and suppose x\u0302(t) \u2208 {x \u2208 X(t) | \u2200e \u2208 E(t),x /\u2208 e}. When this is the case we know that x\u0302(t) is feasible at day t and this contradicts x(t) being optimal at that day because c \u00b7 x\u0302(t) > c \u00b7 x(t).\nNext consider the case in which c \u00b7 x\u0302(t) < c \u00b7x(t) and suppose x(t) \u2208 {x \u2208 X(t) | \u2200e \u2208 E(t),x 6\u2208 e}. We would have used P.3 to make a prediction because N\u0303 (t)\u2229Ext(t) is non-empty and includes at least the point x(t). Note that by P.3, we have x\u0302(t) = argmaxN\u0303 (t)\u2229Ext(t) c \u00b7x. Since x\n(t) \u2208 N\u0303 (t)\u2229Ext(t), we must also have c \u00b7 x\u0302(t) \u2265 c \u00b7 x(t), which is again a contradiction.\nLemma 16. If U.3 is implemented at day t, then x\u0302(t) /\u2208 P and x\u0302(t) \u2208 (Qie\u0302)(t) \u2229 Ext(t) for some i = 0 or 1 where e\u0302 is given in U.3.\nProof. Each time the algorithm makes update U.3 we know that the algorithm\u2019s prediction x\u0302(t) was on some edge-space e\u0302 \u2208 E(t) by Lemma 15. Therefore, LearnEdge did not use P.1 or P.2 to predict x\u0302(t). So we only need to check P.3 and P.4.\n\u2022 If P.3 was used, we know that x\u0302(t) \u2208 N\u0303 (t) but x\u0302(t) must violate a constraint of P , due to x(t) being the observed solution and having lower objective value. This implies that x\u0302(t) is in some questionable region, say (Qie\u0302)\n(t) for i = 0 or 1 but also in the extended feasible on e\u0302, i.e. x\u0302(t) \u2208 Ext(t) \u2229 (Qie\u0302)(t).\n\u2022 If P.4 was used, then Ext(t) = \u2205. However LearnEdge selected x\u0302(t) from Cand(t) 6= \u2205 with the lowest objective value. Finally, when updating with U.3 (i) x(t) \u2208 Cand(t) and (ii) c \u00b7 x(t) < c \u00b7 x\u0302(t). So we could not have used P.4 to predict x\u0302(t).\nLemma 17. If U.4 is implemented at day t, then x(t) \u2208 (Qie)(t)\\Ext(t) for some i = 0 or 1 where e is given in U.4.\nProof. As in Lemma 16, LearnEdge did not use P.1 or P.2 to predict x\u0302(t) (again by application of Lemma 15). So we only need to check P.3 and P.4.\n\u2022 If P.3 was used, then LearnEdge did not guess x(t) which had the higher objective because it was outside of Ext(t) along edge-space e. Since x(t) is feasible, it must have been on some questionable region on e, say (Qie) (t) for some i = 0 or 1. Hence, x(t) \u2208 (Qie)(t)\\Ext(t).\n\u2022 If P.4 was used, then Ext(t) = \u2205 and thus x(t) was a candidate solution but outside of the extended feasible interval along edge-space e. Further, because x(t) \u2208 P we know that x(t) must be in some questionable interval along e, say (Qie)\n(t) for some i = 0 or 1. Therefore, x(t) \u2208 (Qie)(t)\\Ext(t).\nLemma 18. Each time U.3 or U.4 is used, there is a questionable interval on some edge-space whose length is decreased by at least a factor of two.\nProof. From Lemma 16 we know that if U.3 is used then x\u0302(t) \u2208 e\u0302, is infeasible but outside of the known infeasible interval (Y ie\u0302 )\n(t) and inside of the extended feasible interval along e\u0302. Note that if a point x is infeasible along edge space e\u0302 in the questionable interval (Qie\u0302)\n(t), then the constraint it violates is also violated by all points in Y ie . Hence the interval Conv(x, (Y i e )\n(t)) contains only infeasible points. By the definition of (M ie)\n(t) and the fact that x\u0302(t) is in the extended feasible region on e\u0302, we know that\n|(Qie)(t+1)| = \u2223\u2223\u2223(Qie)(t)\\Conv (x\u0302(t), (Y ie )(t))\u2223\u2223\u2223 \u2264 \u2223\u2223\u2223(Qie)(t)\\Conv ((M ie)(t), (Y ie )(t))\u2223\u2223\u2223 = |(Qie)(t)|2 .\nFurther, from convexity we know that if x(t) is feasible on edge-space e at day t, then the interval Conv(x(t), F (t) e ) only contains feasible points on e. We know that x(t) is feasible and in a questionable interval (Qie) (t) along edge space e but outside its extended feasible region, by Lemma 17. Thus, by definition of the midpoint (M ie) (t) we have\n|(Qie)(t+1)| = \u2223\u2223\u2223(Qie)(t)\\Conv (x\u0302(t), (Fe)(t))\u2223\u2223\u2223 \u2264 \u2223\u2223\u2223(Qie)(t)\\Conv ((M ie)(t), F (t)e )\u2223\u2223\u2223 = |(Qie)(t)|2 .\nProof of Lemma 7. Let Qie be the updated questionable interval. We know initially Qie has length at most than 2 \u221a d by Assumption 2. In Lemma 18 we showed that each time an update U.3 or U.4 is invoked, the length of Qie is decreases by at least a half. Then after at most O(N log(d)) updates, the interval will have length less than 2\u2212N after which the interval will be updated at most once because there is at most one point up to precision N in it.\nTherefore, the total number of updates on Qie is bounded by O(N log(d)). Since there are at most 2|EP | questionable intervals, the total number of updates U.3 and U.4 is bounded by O(|EP |N log(d)).\nB.3 Section 3.3\nWe prove the lower bound in Theorem 8 initially for d = 3.\nTheorem 19. If Assumptions 1 and 3 hold, then the number of mistakes of any learning algorithm in the known objective problem is at least \u2126(N) for d = 3.\nProof. The high level idea of the proof is as follows. In each day the adversary can pick two points on the two bold edges in Figure 2 as the optimal points and no matter what the learner predicts, the adversary can return a point that is different than the guess of the learner as the optimal point. If the adversary picks the midpoint of the questionable region in each day, then the size of the questionable region in both of the lines will shrink in half. So this process can be repeated N times where each entry of every vertex can be written with as a multiple of 1/2N , by Assumption 3. Finally, we show that at the end of this process, the adversary can return a simple polytope which is consistent with all the observed optimal points so far.\nWe formalize this high level in procedure ADVERSARY that takes as input any learning algorithm L and interacts with L for N days. Each day the adversary presents a constraint. Then no matter what L predicts, the adversary ensures that L\u2019s prediction is incorrect. After N interactions, the adversary outputs a feasible polytope that is consistent with all of the previous actions of the adversary.\nIn procedure ADVERSARY, subroutines NAC and AD-2 are used to pick a constraint and return an optimal point that causesL to make a mistake, respectively. We use the notation mid(R) in subroutines NAC and AD-2 to denote the middle point of a real interval R, top(R) to be the largest point in R, and bot(R) to be the smallest value in R. Finally, we assume the known objective function is c = (0, 0, 1).\nAlgorithm 5 Adversary Updates (ADVERSARY) Input: Any learning algorithm L and bit precision N Output: Polytope P that is consistent with L making a mistake each day.\nprocedure ADVERSARY(L, N ) Set R(0)1 = [0, 1], R (0) 2 = [1, 2]. . Initialize\nfor t = 1, \u00b7 \u00b7 \u00b7 , N do(( p(t), q(t) ) , r\n(t) 1 , r (t) 2 ) \u2190 NAC(R(t\u22121)1 , R (t\u22121) 2 ).\nShow constraint p(t) \u00b7 x \u2264 q(t) to L. . Constraint Get prediction x\u0302(t) from L.( x(t), R\n(t) 1 , R (t) 2\n) \u2190 AD-2 ( R\n(t\u22121) 1 , R (t\u22121) 2 , r (t) 1 , r (t) 2 , x\u0302\n(t) )\n. . Update\nReveal the optimal x(t) 6= x\u0302(t) and update the regions R(t)1 and R (t) 2 .\nA,b\u2190 MATRIX(RN1 , RN2 ) . Constraint matrix consistent with {x(t) | t \u2208 [N ]} return A,b end procedure\nThe procedure NAC takes as input two real valued intervals and then outputs two points r1 and r2 as well as the new constraint denoted by the pair (p, q). The two points will be used as input in AD-2 along with the learner\u2019s prediction. In procedure AD-2 the adversary makes sure that the learner suffers a mistake. On each day, one of the points say r2 produced by NAC has a higher objective than the other one. If the learner chooses r2 then the adversary will simply choose a polytope that makes r2 infeasible so that r1 is actually the optimal point that day. If the learner chooses r1 then the adversary picks r2 as the optimal solution. Note that the three points r1, r2, and r3 computed in NAC all bind the constraint and are not collinear, and thus uniquely define the hyperplane {x : p \u00b7 x = q}. Finally, in AD-2 the adversary updates the new feasible region for her use in the next days.\nADVERSARY finishes by actually outputting the polytope that was consistent with the constraints and the optimal solutions he showed at each day. This polytope is defined by constraint matrix A and vector b using the subroutine MATRIX as well as the nonnegativity constraint x \u2265 0. To prove that the procedure given in ADVERSARY does in fact make every learner L make a mistake at every day, we need to show that (i) there exists a simple unknown polytope that is consistent with what the adversary has presented in the previous days. Furthermore, we need to show that (ii) the optimal point returned by the adversary on each day is indeed the optimal point corresponding to the LP with objective c and unknown constraints subject to the additional constraint added on each day.\nAlgorithm 6 New Adversarial Constraint (NAC) procedure NAC(R1, R2)\nSet \u2190 0.01. Set r1 \u2190 (0, 1,mid(R1))\nr2 \u2190 (1,mid(R2), 1 + \u00b7mid(R2)) r3 \u2190 (1,mid(R2), 0).\nSet p = (1\u2212mid(R2), 1, 0) and q = 1 . The constraint is p \u00b7 x \u2264 1 and binds at r1, r2, r3 return (p, q) and r1, r2.\nend procedure\nAlgorithm 7 Adaptive Adversary (AD-2) procedure AD-2(R1, R2, r1, r2, x\u0302)\nif x\u0302 == r2 then . r1 and r2 as in Algorithm 6 x\u2190 r1. R2 \u2190 [bot(R2),mid(R2)] . else x = r2. R2 \u2190 [mid(R2), top(R2)] . R1 \u2190 [mid(R1), top(R1)] . return x, R1, R2\nend procedure\nTo show (i) note that point r(t)1 = (0, 1,mid(R (t\u22121) 1 )) is always a feasible point for t \u2208 [N ] in the polytope given by A and b and the new constraint added each day will allow r(t)1 to remain feasible.\nTo show (ii) first note that the new constraint added is always a binding constraint. So by Assumption 5, it is sufficient to check the intersection of the edges of the polytope output by MATRIX and the newly added hyperplane and return the (feasible) point with the highest objective as the optimal point. Second, the following equations define the edges of the polytope which are one dimensional subspaces ei,j according to Assumption 4 with A and b being the output of MATRIX.\nei,j = {x \u2208 R3 | Aix = bi and Ajx = bj} i, j \u2208 {1, 2, 3, 4}, i 6= j, where Ai is the ith row of A. Since the first two constraints define two parallel hyperplanes, we only need to consider 5 edges. Let\nr (t) 1 = ( 0, 1,mid(R(t\u22121)1 ) ) ,\nand r\n(t) 2 = ( 1,mid(R(t\u22121)2 ), 1 + \u00b7mid(R (t\u22121) 2 ) ) .\nWe show that the new constraint either intersects the edges of the polytope at r(t)1 or r (t) 2 or do not intersect with them at all. This will prove that the optimal points shown by the adversary each day is consistent with the unknown polytope.\n1. e1,4 = (0, 0, f1) \u00b7 s+ (0, 1, 0) that intersects with the new hyperplane at r(t)1 .\nAlgorithm 8 Matrix consistent with adversary (MATRIX) procedure MATRIX(R1, R2)\nSet f1 = (top(R1) + bot(R1)) /2 and f2 = (top(R2) + bot(R2)) /2 and > 0\nA\u2190  \u22121 0 01 0 0(f1 \u2212 1\u2212 ) \u2212 1 \u2212(f2 \u2212 1) \u00b7 f1 f1 0  and b\u2190  01f1 \u2212 f1  . return A and b end procedure\n2. e2,3 = (0, f2, \u00b7 f2) \u00b7 s+ (1, 0, 1) that intersects with the new hyperplane at r(t)2 .\n3. e2,4 = (0, 0, 1 + \u00b7 f2) \u00b7 s + (1, f2, 0) that does not intersect the new hyperplane unless mid(R2) = f2 (which does not happen).\n4. e3,4 = (1, f2 \u2212 1, 1 + \u00b7 f2 \u2212 f1) \u00b7 s+ (0, 1, f1) that does not intersect the new hyperplane unless mid(R2) = f2 (which does not happen).\n5. e1,3 = (0,\u22121, f1) \u00b7 s+ (0, 1, f1) never intersects the hyperplane.\nAnd this concludes the proof.\nWe now prove Theorem 8 even for d > 3. Proof of Theorem 8. We modify the proof of Theorem 19 to d > 3 by adding dummy variables. These dummy variables are denoted by x4:d. Furthermore, we add dummy constraints xi \u2265 0 for all the dummy variables. We modify the objective function in the proof of Theorem 19 to be c = (0, 0, 1,\u22121, . . . ,\u22121). This will cause all the newly added variables to have no effect on the optimization (they should be set to 0 in the optimal solution) and, hence, the result from Theorem 19 extends to the case when d > 3.\nB.4 Section 3.4\nProof of Lemma 10. First, since all of the points x1, . . . , xt are drawn i.i.d. from D, we observe by symmetry that the event we are interested in is distributed identically to the following event: draw a set of t points X \u2032 = {x1, . . . , xt} i.i.d. from D and select an index i \u2208 {1, . . . , t} uniformly at random and compute the probability that xi 6\u2208 Conv(X \u2032 \\ {xi}). In other words\nPr x1,...,xt\u223cD [xt 6\u2208 Conv(X)] = Pr x1,...,xt\u223cD,i\u223c{1,...,t} [xi 6\u2208 Conv(X \u2032 \\ {xi})] . (9)\nWe analyze the quantity on the right hand side of (9) instead, fixing the choices of x1, . . . , xt, and analyzing the probability only over the randomness of the choice of index i. For each edge e \u2208 EP , let X \u2032e = X \u2032 \u2229 e. Since each edge lies on a one dimensional subspace, there are at most two extreme points xe1, x e 2 \u2208 X \u2032e that lie outside of the convex hull of other points i.e. such that xe1 6\u2208 Conv(X \u2032 \\ {xe1}) and xe2 6\u2208 Conv(X \u2032 \\ {xe2}). We note that when we choose an index i uniformly at random, the probability that we select a point x \u2208 X \u2032e is exactly |X \u2032e|/t, and conditioned on selecting a point x \u2208 X \u2032e, the probability that x is an extreme point (i.e. x \u2208 {xe1, xe2}) is at most 2/|X \u2032e|. Hence, we can calculate\nPr [xi 6\u2208 Conv(X \u2032 \\ {xi})] = \u2211 e\u2208EP Pr[xi \u2208 X \u2032e] \u00b7 Pr[xi /\u2208 Conv(X \u2032e \\ {xi}) | xi \u2208 X \u2032e]\n\u2264 \u2211 e\u2208EP |X \u2032e| t \u00b7 2 |X \u2032e| = \u2211 e\u2208EP 2 t = 2|EP | t .\nProof of Theorem 9. First, we show that LearnHull makes a mistake only if the true optimal point x(t) lies outside of the convex hull C(t\u22121) formed by the previous observed optimal points {x(1), . . . ,x(t\u22121)}. Suppose that at day t, the algorithm predicts the point x\u0302(t) instead of the optimal point x(t). Since each point in C(t\u22121) is feasible and x\u0302(t) is the point with the highest objective value among the points in {x \u2208 C(t\u22121) | p\u2032 \u00b7 x \u2264 b\u2032}, then it must be that x(t) 6\u2208 C(t\u22121) because otherwise c \u00b7 x(t) > c \u00b7 x\u0302(t). By Lemma 10, we also know that the probability that x(t) lies outside of C(t\u22121) is no more than 2|EP |/t in expectation, which also upper bounds the probability of LearnHull making a mistake at day t. Therefore, the expected number of mistakes made by LearnHull over T days is bounded by the sum of probabilities of making a mistake in each day which is \u2211T t=1 2|EP |/t = O(|EP | log(T )).\nProof of Theorem 11. The deterministic procedure runs d18 log(1/\u03b4)e independent instances of the LearnHull each using independently drawn examples. The independent instances are aggregated into a single prediction rule by predicting using the modal prediction (if one exists), and otherwise\npredicting arbitrarily. Hence, the aggregate prediction is correct whenever at least half of the instances of LearnHull are correct.\nWe show that if each instance of the LearnHull is run for 8|EP | days, then the probability that more than half of the instances of LearnHull make a mistake on a newly drawn constraint at day T + 1 is at most \u03b4. The result is that with probability at least 1\u2212 \u03b4 the majority of instances of LearnHull predict the correct optimal point, and hence the aggregate prediction is also correct.\nLet Zi be the random variable that denotes the probability that the ith instance of the LearnHull algorithm makes a mistake on a fresh example, after it has been trained for 8|EP | days. By Theorem 9, we know E[Zi] \u2264 1/4 for all i. Now by Markov\u2019s inequality,\nPr [ Zi \u2265 3\n4\n] = Pr [ Zi \u2265 3 \u00b7 E[Zi] ] \u2264 1/3,\nfor all i. Hence, the expected number of instances that make a mistake is at most 1/3. Finally, since each instance is trained on independent examples, a Chernoff bound implies that the probability that at least half of the instances of LearnHull make a mistake is bounded by \u03b4."}, {"heading": "C Circumventing the Lower Bound when d \u2264 2", "text": "In Theorem 8 (in Section 3.3), we proved the necessity of Assumption 3 by showing that the dependence on the precision parameter N in our mistake bound is tight. However, Theorem 8 requires the dimension d to be at least 3.\nWe now show that this condition on the dimension is indeed necessary\u2014even without the finite precision assumption (Assumption 3), we can have (computationally efficient) algorithms with small mistake bounds when the dimension d \u2264 2. In d = 1, at most two constraints are sufficient to determine any constraint matrix A because the constraint matrix A defines a feasible interval on the real line. So we will guess the value that maximizes the objective subject to the single known constraint. Once we have made a mistake, we must have learned the true optimal to the underlying problem because our guess was infeasible. After this single mistake, we either guess the true optimal that we have already seen or if it is not feasible with the new constraint then we guess the point that maximizes the objective subject to the new constraint. Thus after one mistake, the learner will not make any more mistakes.\nLemma 3 tells us that the line between any three collinear points must give us an edge-space of the underlying polytope. When d = 2, the corresponding edge-space is then just one of the original constraints of the underlying polytope. Since each solution must be on an edge of the underlying polytope each day, we can make at most 3m mistakes without seeing the true objective. Hence, all together, we can make at most 3m+1 mistakes before we recover all the constraints of the underlying polytope, or all the rows of the constraint matrix A, and see the true optimal solution.\nThis phenomenon does not continue to hold for d > 2 (as we show in our lower bound in Theorem 8)."}, {"heading": "D Missing Proofs from Section 4", "text": "First we state Theorem 20 from Grotschel et al. [11] about the running time of the Ellipsoid algorithm. Theorem 20. Let P \u2282 Rd be a polytope given as the intersection of linear constraints, each specified with N bits of precision. Given access to a separation oracle which can return, for each candidate solution p /\u2208 P a hyperplane with N bits of precision that separates p from P , the Ellipsoid algorithm outputs a point p\u2032 \u2208 P or outputs P is empty at most poly(d,N) iterations.\nWe are now ready to bound the number of mistakes that LearnEllipsoid makes. Proof of Theorem 13. Whenever LearnEllipsoid makes a mistake, there exists a separating hyperplane\nH(t) = W = (w1, . . . ,wn) \u2208 Rn\u00d7d | \u2211 i\u2208S(t) wi \u00b7 (x(t) \u2212 x\u0302(t)) > 0 \nthat cause the Ellipsoid algorithm to run for another iteration. When LearnEllipsoid reducesF to a set that contains a single point up toN bits of precision then predicting via the above equation forH(t) will ensure we never make a mistake again. Hence, the number of mistakes that LearnEllipsoid can commit against an adversary is bounded by the maximum number of iterations for which the Ellipsoid algorithm can be made to run, in the worst case.\nWe know that x(t) each day is on a vertex of the polytope P(t) which is guaranteed to have coordinates specified with at most N bits of precision by Assumption 7. Theorem 12 guarantees that the solution x\u0302(t) that LearnEllipsoid produces using the following equation\nx\u0302(t) \u2208 argmax x\u2208P(t)  \u2211 i\u2208S(t) (wi)(t) \u00b7 x  is a vertex solution of P(t). So x\u0302(t) can also be written with N bits of precision by Assumption 7. Thus, every constraint in F and hence each separating hyperplane can be written with d \u00b7N bits of precision. By Assumption 6 and Theorem 20, we know that the Ellipsoid algorithm will find a point in the feasible region F after at most poly(n, d,N) many iterations which is the same as the number of mistakes of LearnEllipsoid."}], "references": [{"title": "Online learning and profit maximization from revealed preferences", "author": ["K. AMIN", "R. CUMMINGS", "L. DWORKIN", "M. KEARNS", "A. ROTH"], "venue": "In Proceedings of the 29th AAAI Conference on Artificial Intelligence", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2015}, {"title": "Learning economic parameters from revealed preferences", "author": ["M. BALCAN", "A. DANIELY", "R. MEHTA", "R. URNER", "V. VAZIRANI"], "venue": "In Proceeding of the 10th International Conference on Web and Internet Economics", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Learning from revealed preference", "author": ["E. BEIGMAN", "R. VOHRA"], "venue": "In Proceedings of the 7th ACM Conference on Electronic Commerce", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "Escaping the local minima via simulated annealing: Optimization of approximately convex functions", "author": ["A. BELLONI", "T. LIANG", "H. NARAYANAN", "A. RAKHLIN"], "venue": "In Proceeding of the 28th Conference on Learning Theory", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Achieving target equilibria in network routing games without knowing the latency functions", "author": ["U. BHASKAR", "K. LIGETT", "L. SCHULMAN", "C. SWAMY"], "venue": "In Proceeding of the 55th IEEE Annual Symposium on Foundations of Computer Science", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Learning what\u2019s going on: Reconstructing preferences and priorities from opaque transactions", "author": ["A. BLUM", "Y. MANSOUR", "J. MORGENSTERN"], "venue": "In Proceedings of the 16th ACM Conference on Economics and Computation", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2015}, {"title": "Discriminative reranking for natural language parsing", "author": ["M. COLLINS"], "venue": "In Proceedings of the 17th International Conference on Machine Learning", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2000}, {"title": "Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms", "author": ["M. COLLINS"], "venue": "In Proceedings of the ACL-02 Conference on Empirical Methods in Natural Language Processing", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2002}, {"title": "Optimal learners for multiclass problems", "author": ["A. DANIELY", "S. SHALEV-SHWARTZ"], "venue": "In Proceedings of the 27th Conference on Learning Theory", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2014}, {"title": "Geometric Algorithms and Combinatorial Optimization, second corrected ed., vol. 2 of Algorithms and Combinatorics", "author": ["M. GR\u00d6TSCHEL", "L. LOV\u00c1SZ", "A. SCHRIJVER"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1993}, {"title": "Conditional random fields: Probabilistic models for segmenting and labeling sequence data", "author": ["J. LAFFERTY", "A. MCCALLUM", "F. PEREIRA"], "venue": "In Proceedings of the 18th International Conference on Machine Learning", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2001}, {"title": "Learning quickly when irrelevant attributes abound: A new linear-threshold algorithm", "author": ["N. LITTLESTONE"], "venue": "Machine Learning 2,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1988}, {"title": "Watch and learn: Optimizing from revealed preferences feedback", "author": ["A. ROTH", "J. ULLMAN", "WU"], "venue": "In Proceedings of the 48th Annual ACMSymposium on Theory of Computing", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2016}, {"title": "A theory of the learnable", "author": ["L. VALIANT"], "venue": "Communications of the ACM 27,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1984}], "referenceMentions": [{"referenceID": 0, "context": "In the special case in which there is a single known constraint that is changing and the objective that is unknown and fixed, this problem has been studied under the name learning from revealed preferences [1, 2, 3, 16] and captures the following scenario: a buyer, with an unknown linear utility function over d goods u : R \u2192 R defined as u(x) = c \u00b7 x faces a purchasing decision every day.", "startOffset": 206, "endOffset": 219}, {"referenceID": 1, "context": "In the special case in which there is a single known constraint that is changing and the objective that is unknown and fixed, this problem has been studied under the name learning from revealed preferences [1, 2, 3, 16] and captures the following scenario: a buyer, with an unknown linear utility function over d goods u : R \u2192 R defined as u(x) = c \u00b7 x faces a purchasing decision every day.", "startOffset": 206, "endOffset": 219}, {"referenceID": 2, "context": "In the special case in which there is a single known constraint that is changing and the objective that is unknown and fixed, this problem has been studied under the name learning from revealed preferences [1, 2, 3, 16] and captures the following scenario: a buyer, with an unknown linear utility function over d goods u : R \u2192 R defined as u(x) = c \u00b7 x faces a purchasing decision every day.", "startOffset": 206, "endOffset": 219}, {"referenceID": 0, "context": "Each example at day t is specified by the vector p \u2208 R\u22650 (which fixes the constraint), and the goal is to accurately predict the purchased bundle x \u2208 [0, 1] that is the result of optimizing the unknown linear objective.", "startOffset": 150, "endOffset": 156}, {"referenceID": 5, "context": "This generalizes some of the preference learning problems recently studied by Blum et al [6].", "startOffset": 89, "endOffset": 92}, {"referenceID": 11, "context": "We study both variants of the problem (see below) in the strong mistake bound model of learning [13].", "startOffset": 96, "endOffset": 100}, {"referenceID": 13, "context": "Mistake bound learnability is stronger than (and implies) PAC learnability [15].", "startOffset": 75, "endOffset": 79}, {"referenceID": 2, "context": "Beigman and Vohra [3] were the first to study revealed preference problems (RPP) as a learning problems and to relate them to multi-dimensional classification.", "startOffset": 18, "endOffset": 21}, {"referenceID": 1, "context": "[2] showed a connection between RPP and the structured prediction problem of learning d-dimensional linear classes [7, 8, 12], and use an efficient variant of the compression techniques given by Daniely and Shalev-Shwartz [9] to give efficient PAC algorithms with optimal sample complexity for various classes of economically meaningful utility functions.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[2] showed a connection between RPP and the structured prediction problem of learning d-dimensional linear classes [7, 8, 12], and use an efficient variant of the compression techniques given by Daniely and Shalev-Shwartz [9] to give efficient PAC algorithms with optimal sample complexity for various classes of economically meaningful utility functions.", "startOffset": 115, "endOffset": 125}, {"referenceID": 7, "context": "[2] showed a connection between RPP and the structured prediction problem of learning d-dimensional linear classes [7, 8, 12], and use an efficient variant of the compression techniques given by Daniely and Shalev-Shwartz [9] to give efficient PAC algorithms with optimal sample complexity for various classes of economically meaningful utility functions.", "startOffset": 115, "endOffset": 125}, {"referenceID": 10, "context": "[2] showed a connection between RPP and the structured prediction problem of learning d-dimensional linear classes [7, 8, 12], and use an efficient variant of the compression techniques given by Daniely and Shalev-Shwartz [9] to give efficient PAC algorithms with optimal sample complexity for various classes of economically meaningful utility functions.", "startOffset": 115, "endOffset": 125}, {"referenceID": 8, "context": "[2] showed a connection between RPP and the structured prediction problem of learning d-dimensional linear classes [7, 8, 12], and use an efficient variant of the compression techniques given by Daniely and Shalev-Shwartz [9] to give efficient PAC algorithms with optimal sample complexity for various classes of economically meaningful utility functions.", "startOffset": 222, "endOffset": 225}, {"referenceID": 0, "context": "[1] study the RPP for linear valuation functions in the mistake bound model, and in the query model in which the learner gets to set prices and wishes to maximize profit.", "startOffset": 0, "endOffset": 3}, {"referenceID": 12, "context": "[14] also study the query model of learning and give results for strongly concave objective functions, leveraging an algorithm of Belloni et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[4] for bandit convex optimization with adversarial noise.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[11] states that if each constraint in P \u2286 R has encoding length at most N then each vertex of P has encoding length at most 4dN .", "startOffset": 0, "endOffset": 4}, {"referenceID": 4, "context": "[5], we use the Ellipsoid algorithm to learn the coefficients {v}i\u2208[n], and show that the mistake bound of the resulting algorithm is bounded by the (polynomial) running time of the Ellipsoid.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "We again point out that this is implied if the halfspaces defining the polytope are described with finite precision [11].", "startOffset": 116, "endOffset": 120}, {"referenceID": 9, "context": "2 [11]).", "startOffset": 2, "endOffset": 6}], "year": 2016, "abstractText": "We define and study the problem of predicting the solution to a linear program (LP) given only partial information about its objective and constraints. This generalizes the problem of learning to predict the purchasing behavior of a rational agent who has an unknown objective function, that has been studied under the name \u201cLearning from Revealed Preferences\". We give mistake bound learning algorithms in two settings: in the first, the objective of the LP is known to the learner but there is an arbitrary, fixed set of constraints which are unknown. Each example is defined by an additional known constraint and the goal of the learner is to predict the optimal solution of the LP given the union of the known and unknown constraints. This models the problem of predicting the behavior of a rational agent whose goals are known, but whose resources are unknown. In the second setting, the objective of the LP is unknown, and changing in a controlled way. The constraints of the LP may also change every day, but are known. An example is given by a set of constraints and partial information about the objective, and the task of the learner is again to predict the optimal solution of the partially known LP.", "creator": "LaTeX with hyperref package"}}}