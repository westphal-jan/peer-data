{"id": "1507.00257", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Jul-2015", "title": "From Causes for Database Queries to Repairs and Model-Based Diagnosis and Back", "abstract": "In see meant we extend making prosecution such between related another snippet answers taken electronically, database undergo wrt. implicit obstacles, and elasticity - co checkup. The both two rarely areas first related districts in databases, in along third one gives similar established similar also aspects representation. We show how keep grants database repairs before confusion, and the other putting there. Causality stress are radically new diagnosis breakdown, where still diagnoses need causes and their operational. The extensive body means research then xml repairs better be practice to the larger explain of web-based extent causes for typing facts and their vested. These systems, which were wonders per cada, allow united, february a transition - inspired 's physicality - consortium genetic - to mapping problems month shots end and vertex created from aligners, to obtain however new algorithmic different logical results time identification causality.", "histories": [["v1", "Wed, 1 Jul 2015 15:20:29 GMT  (64kb)", "https://arxiv.org/abs/1507.00257v1", "Journal submission. Extended version of ICDT 2015 paperarXiv:1412.4311"], ["v2", "Mon, 3 Oct 2016 17:52:10 GMT  (69kb)", "http://arxiv.org/abs/1507.00257v2", "Revised Journal submission after reviews. Extended version of ICDT 2015 paperarXiv:1412.4311"], ["v3", "Sun, 23 Oct 2016 17:37:58 GMT  (69kb)", "http://arxiv.org/abs/1507.00257v3", "To appear in Theory of Computing Systems. By invitation to special issue with extended papers from ICDT 2015 (paperarXiv:1412.4311)"]], "COMMENTS": "Journal submission. Extended version of ICDT 2015 paperarXiv:1412.4311", "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["leopoldo bertossi", "babak salimi"], "accepted": false, "id": "1507.00257"}, "pdf": {"name": "1507.00257.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Leopoldo Bertossi", "Babak Salimi"], "emails": ["bertossi@scs.carleton.ca", "bsalimi@cs.washington.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 7.\n00 25\n7v 3\n[ cs\n.D B\n] 2\n3 O\nct 2\n01 6\nKeywords causality \u00b7 diagnosis \u00b7 repairs \u00b7 consistent query answering \u00b7 integrity constraints"}, {"heading": "1 Introduction", "text": "When querying a database, a user may not always obtain the expected results, and the system could provide some explanations. They could be useful to further understand the data or check if the query is the intended one. Actually,\nL. Bertossi Carleton University School of Computer Science Ottawa, Canada. E-mail: bertossi@scs.carleton.ca\nB. Salimi University of Washington Computer Science and Engineering Seattle, USA. E-mail: bsalimi@cs.washington.edu\nthe notion of explanation for a query result was introduced in [47], on the basis of the deeper concept of actual causation.1\nA tuple t is an actual cause for an answer a\u0304 to a conjunctive query Q from a relational database instance D if there is a contingent set of tuples \u0393 , such that, after removing \u0393 from D, a\u0304 is still an answer, but after further removing t from D r \u0393 , a\u0304 is not an answer anymore (cf. Section 2.1 for a precise definition). Here, \u0393 is a set of tuples that has to accompany t so that the latter becomes a counterfactual cause for answer a\u0304. Actual causes and contingent tuples are restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to exogenous tuples, which may also be present in the database. In rest of this paper, whenever we simply say \u201ccause\u201d, we mean \u201cactual cause\u201d.\nIn applications involving large data sets, it is crucial to rank potential causes by their responsibilities [48,47], which reflect the relative (quantitative) degrees of their causality for a query result. The responsibility measure for a cause is based on its contingency sets: the smallest (one of) its contingency sets, the strongest it is as a cause.\nActual causation, as used in [47], can be traced back to [32,33], which provides a model-based account of causation on the basis of counterfactual dependence. Causal responsibility was introduced in [19], to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.\nApart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61]. A close connection between causality and provenance has been established in [47]. However, causality is a more refined notion that identifies causes for query results on the basis of user-defined criteria, and ranks causes according to their responsibilities [48].\nConsistency-based diagnosis [53], a form of model-based diagnosis [60, sec. 10.3], is an area of knowledge representation. The problem here is, given the specification of a system in some logical formalism and a usually unexpected observation about the system, to obtain explanations for the observation, in the form of a diagnosis for the unintended behavior (cf. Section 2.3 for a precise definition).\nIn a different direction, a database instance, D, that is expected to satisfy certain integrity constraints may fail to do so. In this case, a repair of D is a database D\u2032 that does satisfy the integrity constraints and minimally departs from D. Different forms of minimality can be applied and investigated. A consistent answer to a query from D and with respect to the integrity constraints is a query answer that is obtained from all possible repairs, i.e.\n1 In contrast with general causal claims, such as \u201csmoking causes cancer\u201d, which refer some sort of related events, actual causation specifies a particular instantiation of a causal relationship, e.g., \u201cJoe\u2019s smoking is a cause for his cancer\u201d.\nis invariant or certain under the class of repairs (cf. Section 2.2 for a precise definition). These notions were introduced in [2] (see [7,9] for surveys).2\nThese three forms of reasoning, namely inferring causes from databases, consistency-based diagnosis, and consistent query answering (and repairs) are all non-monotonic [55]. For example, a (most responsible) cause for a query result may not be such anymore after the database is updated. Furthermore, they all reflect some sort of uncertainty about the information at hand. In this work we establish natural, precise, useful, and deeper connections between these three reasoning tasks.\nMore precisely, we unveil a strong connection between computing causes and their responsibilities for conjunctive query answers, on one hand, and computing repairs in databases with respect to denial constraints, on the other. These computational problems can be reduced to each other. In order to obtain repairs with respect to a set of denial constraints from causes, we investigate causes for queries that are unions of conjunctive queries, and develop algorithms to compute causes and responsibilities.\nWe show that inferring and computing actual causes and their responsibilities in a database setting become diagnosis reasoning problems and tasks. Actually, a causality-based explanation for a conjunctive query answer can be viewed as a diagnosis, where in essence the first-order logical reconstruction of the relational database provides the system description [54], and the observation is the query answer. We obtain causes and their responsibilities -and as a side result, also database repairs- from diagnosis.\nBeing the causality problems the main focus of this work, we take advantage of algorithms and complexity results both for consistency-based diagnosis on one side; and database repairs and consistent query answering [9], on another. In this way, we obtain new complexity results for the main problems of causality, namely computing actual causes, determining their responsibilities, and obtaining most responsible causes; and also for their decision versions. In particular, we obtain fixed-parameter polynomial-time algorithms for some of them. More precisely, our main results are as follows: (the complexity results are all in data complexity)\n1. We characterize actual causes and most responsible actual causes for a boolean conjunctive query in terms of subset- and cardinality-repairs of the instance with respect to the denial constraint associated to the query (the query being the violation view of the constraint). In this way we can compute causes from repairs.\nIn the other direction, we obtain repairs of databases with respect to sets of denial constraints from causes for query results. For this, we extend the treatment of causality to unions of conjunctive queries (to represent multiple denial constraints). We characterize an actual cause\u2019s responsibility in terms of cardinality-repairs. Along the way we provide PTIME algorithms to compute causes and their (minimal) contingency sets for unions of conjunctive queries.\n2 Although not in the context of repairs, consistency-based diagnosis has been applied to consistency restoration of a database with respect to integrity constraints [30].\n2. We reduce causes for a boolean conjunctive query to consistency-based diagnosis for the query being unexpectedly true according to a system description. In particular, we show how to compute actual causes, their contingency sets, and responsibilities using the diagnosis characterization. As a side result, we obtain database repairs from diagnosis.\nHitting-set-based algorithmic approaches to diagnosis [53] inspire our algorithmic/complexity approaches to causality. In particular, we reformulate the causality problems as hitting-set problems and vertex cover problems on hypergraphs, which allows us to apply results and techniques for the latter to causality.\n3. We obtain several new computational complexity results:\n(a) Checking minimal contingency sets can be done in PTIME. (b) The responsibility decision problem for conjunctive queries, which is about\ndeciding if a tuple\u2019s responsibility is greater that a bound v (that is part of the input) is NP-complete. However, this problem becomes fixedparameter tractable, with the parameter being 1\nv .\n(c) The problem of computing responsibilities of causes is FPNP(log(n))-complete. Deciding most responsible causes is PNP(log(n))-complete. (d) The structure of the resulting hitting-set problem allows us to obtain efficient parameterized algorithms and good approximation algorithms for computing causes and minimal contingency sets. (e) From the repair connection we obtain that, for consistency based-diagnosis with specifications given by positive implications with disjunctive consequents, the problems of computing minimum-cardinality diagnoses and computing minimum-cardinality diagnoses that contain a given atom are both FPNP(log(n))-hard in the size of their underlying Herbrand structure.\n4. We define notions of preferred causes; in particular one based on prioritized repairs [59]. We also propose an approach to causality based on interventions that are repair actions that replace attribute values by null values.\nThe paper is structured as follows. Section 2 introduces technical preliminaries for relational databases, causality in databases, database repairs and consistent query answering, consistency-based diagnosis, and relevant complexity classes. Section 3 characterizes actual causes and responsibilities in terms of database repairs. Section 4 characterizes repairs and consistent query answers in terms of causes and contingency sets for queries that are unions of conjunctive queries, and presents an algorithm for computing both of the latter. Section 5 formulates causality and repair problems as consistency-based diagnosis problems. Section 6 shows complexity and algorithmic results; in particular a fixed-parameter tractability result for causes\u2019 responsibilities, and also about consistency based-diagnosis. Section 7 deals with preferred causes. Section 8 discusses several relevant issues, connections and open problems around causality in databases. It also draws some final conclusions. We provide proofs for all the results except for those that are rather straightforward. This is an extended version of [58]. It contains proofs, many improvements in the pre-\nsentation, and also new developments and results, mainly in Sections 6.2 and 7."}, {"heading": "2 Preliminaries", "text": "We consider relational database schemas of the form S = (U,P), where U is the possibly infinite database domain of constants and P is a finite set of database predicates3 of fixed arities. A database instance D compatible with S can be seen as a finite set of ground atomic formulas (in databases aka. atoms or tuples), of the form P (c1, ..., cn), where P \u2208 P has arity n, and c1, . . . , cn \u2208 U .\nA conjunctive query (CQ) is a formula Q(x\u0304) of the first-order (FO) logic language, L(S), associated to S of the form \u2203y\u0304(P1(s\u03041)\u2227 \u00b7 \u00b7 \u00b7 \u2227Pm(s\u0304m)), where the Pi(s\u0304i) are atomic formulas, i.e. Pi \u2208 P , and the s\u0304i are sequences of terms, i.e. variables or constants.4 The x\u0304 in Q(x\u0304) shows all the free variables in the formula, i.e. those not appearing in y\u0304. If x\u0304 is non-empty, the query is open. If x\u0304 is empty, the query is boolean (a BCQ), i.e. the query is a sentence, in which case, it is true or false in a database, denoted by D |= Q and D 6|= Q, respectively. A sequence c\u0304 of constants is an answer to an open query Q(x\u0304) if D |= Q[c\u0304], i.e. the query becomes true in D when the free variables are replaced by the corresponding constants in c\u0304.\nAn integrity constraint is a sentence of language L(S), and then, may be true or false in an instance for schema S. Given a set IC of integrity constraints for schema S, a database instance D is consistent with S if D |= IC ; otherwise it is said to be inconsistent. In this work we assume that sets of integrity constraints are always finite and logically consistent.\nA particular class of integrity constraints is formed by denial constraints (DCs), which are sentences \u03ba of the form: \u2200s\u0304\u00ac(A1(s\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 An(s\u0304n), where s\u0304 = \u22c3 s\u0304i and each Ai(s\u0304i) is a database atom, i.e. predicate Ai \u2208 P. So as with conjunctive queries, the atoms may contain constants. Denial constraints are exactly the negations of BCQs. Sometimes we use the common representation of DCs as \u201cnegative rules\u201d of the form: \u2190 A1(s\u03041), . . . , An(s\u0304n). We will also consider functional dependencies (FDs) as DCs. They are represented by negative rules of the form: \u2190 A(x\u03041, x\u03042, y), A(x\u03041, x\u03043, z), y 6= z, saying that the last attribute of relation A functionally depends upon the attributes holding variables x\u03041. They do not contain constants, and correspond to BCQs with inequality.\n3 As opposed to built-in predicates (e.g. 6=) that we assume do not appear, unless explicitly stated otherwise.\n4 In this work, we will assume, unless otherwise explicitly said, that CQs may contain inequality atoms (equality atoms are not an issue, because they can always be eliminated).\n2.1 Causality and responsibility\nAssume that the database instance is split in two, i.e. D = Dn \u222a Dx, where Dn and Dx denote the disjoint sets of endogenous and exogenous tuples, respectively.\nActual causes and contingent tuples are usually restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to the exogenous tuples. Actually, the latter provide the context or the background for the problem, and are considered as external factors that are not of interest to the current problem statement or beyond our control. Since no intervention (or update, in database parlance) is conceivable on exogenous tuples, they can not be included in any contingency set or be an actual cause. They are assumed to be included in all conceivable hypothetical states of a database.\nThe endogenous/exogenous partition is application-dependent and captures predetermined factors, such as users preferences that may affect QAcausal analysis. For example, certain tuples or full tables might be identified as irrelevant (or exogenous) in relation to a particular query at hand, or decided to be exogenous or endogenous a priori, independently from the query.\nA tuple t \u2208 Dn is called a counterfactual cause for a BCQ Q, if D |= Q and Dr {t} 6|= Q. A tuple t \u2208 Dn is an actual cause for Q if there exists \u0393 \u2286 Dn, called a contingency set, such that t is a counterfactual cause for Q in D r \u0393 [47].\nWe will concentrate mostly on CQs. However, the definitions of actual cause and contingency set can be applied without a change to monotone queries in general [47], in particular to unions of BCQs (UBCQs), with or without builtins.\nThe responsibility of an actual cause t for Q, denoted by \u03c1 D (t), is the numerical value 1|\u0393 |+1 , where |\u0393 | is the size of the smallest contingency set for t. We can extend responsibility to all the other tuples in Dn by setting their value to 0. Those tuples are not actual causes for Q.\nExample 1 Consider D = Dn = {R(a4, a3), R(a2, a1), R(a3, a3), S(a4), S(a2), S(a3)}, and the query Q : \u2203x\u2203y(S(x) \u2227R(x, y) \u2227 S(y)). It holds: D |= Q.\nTuple S(a3) is a counterfactual cause for Q. If S(a3) is removed from D, Q is not true anymore. Therefore, the responsibility of S(a3) is 1. Besides, R(a4, a3) is an actual cause for Q with contingency set {R(a3, a3)}. If R(a3, a3) is removed from D, Q is still true, but further removing R(a4, a3) makes Q false. The responsibility of R(a4, a3) is 1 2 , because its smallest contingency sets have size 1. Likewise, R(a3, a3) and S(a4) are actual causes for Q with responsibility 12 .\nFor the same Q, but with D = {S(a3), S(a4), R(a4, a3)}, and the partition Dn = {S(a4), S(a3)} and Dx = {R(a4, a3)}, it turns out that both S(a3) and S(a4) are counterfactual causes for Q.\nRemark 1 In the rest of this paper, we will assume in the context of causality that database instances D are partitioned as D = Dn \u222a Dx, into a subset\nof endogenous and a set of exogenous tuples, respectively. We will denote with Causes(D,Q) the set of actual causes for the BCQ Q (being true) from instance D.\n2.2 Database repairs\nGiven a set IC of integrity constraints, a subset repair (simply, S-repair) of a possibly inconsistent instance D for schema S is an instance D\u2032 for S that satisfies IC and makes \u2206(D,D\u2032) = (D r D\u2032) \u222a (D\u2032 r D) minimal under set inclusion.5 Srep(D, IC ) denotes the set of S-repairs of D with respect to IC [2]. Similarly, D\u2032 is a cardinality repair (simply C-repair) of D if D\u2032 satisfies IC and minimizes |\u2206(D,D\u2032)|. Crep(D, IC ) denotes the class of C-repairs of D with respect to IC . C-repairs are always S-repairs. For DCs, S-repairs and C-repairs are obtained from the original instance by deleting an S-minimal, resp. C-minimal, set of tuples. In other words, S- and C-repairs under DCs become maximal (under set inclusion), resp. maximum (in cardinality), consistent subsets of the given instance.\nIn more general terms, we say that a set is S-minimal in a class of sets C if it is minimal under set inclusion in C. Similarly, a set is C-minimal (or minimum) if it is minimal in cardinality within C. S-minimality and C-minimality are defined similarly.\nExample 2 (ex. 1 cont.) Consider the denial constraint \u03ba :\u2190 S(x), R(x, y), S(y), whose body corresponds to the CQ in Example 1, and is violated by the given instance D.\nHere, Srep(D,\u03ba) = {D1, D2, D3} withD1 = {R(a4, a3), R(a2, a1), R(a3, a3), S(a4), S(a2)}, D2 = {R(a2, a1), S(a4), S(a2), S(a3)}, D3 = {R(a4, a3), R(a2, a1), S(a2), S(a3)}. The only C-repair is D1, i.e. Crep(D,\u03ba) = {D1}.\nMore generally, different repair semanticsmay be considered to restore consistency with respect to general integrity constraints. They depend on the kind of allowed updates on the database (i.e. tuple insertions/deletions, changes of attribute values), and the minimality conditions on repairs, e.g. subsetminimality, cardinality-minimality, etc.\nGiven D and IC , a repair semantics, S, defines a class RepS(D, IC ) of S-repairs, which are the intended repairs [9, Sec. 2.5]. All the elements of RepS(D, IC ) are instances over the same schema of D, and consistent with respect to IC . If D is already consistent, RepS(D, IC ) contains D as its only member.\nGiven a repair semantics, S, c\u0304 is a S-consistent answer to an open query Q(x\u0304) if D\u2032 |= Q[c\u0304] for every D\u2032 \u2208 RepS(D, IC ). A BCQ is S-consistently true if\n5 In general, in the context of repairs, partitions on instances are not considered. However, in Section 7.3 we will bring them into the repair scene.\nit is true in everyD\u2032 \u2208 RepS(D, IC ). In particular, if c\u0304 is a consistent answer to Q(x\u0304) with respect to S-repairs, we say it is an S-consistent answer. Similarly for C-consistent answers. Consistent query answering for DCs under S-repairs was investigated in detail [18]. C-repairs and consistent query answering under them were investigated in detail in [43]. (Cf. [9] for more references.)\n2.3 Consistency-based diagnosis\nConsistency-based diagnosis, a form of model-based diagnosis [60, Sec. 10.4], considers problems M = (SD ,COMPS , OBS), where SD is the description in logic of the intended properties of a system under the explicit assumption that all the components in COMPS are working normally. OBS is a FO sentence that represents the observations. If the system does not behave as expected (as shown by the observations), then the logical theory obtained from SD \u222aOBS plus the explicit assumption, say \u2227 c\u2208COMPS \u00acAb(c), that the components are indeed behaving normally, becomes inconsistent. Ab is an abnormality predicate.6\nThe inconsistency is captured via the minimal conflict sets, i.e. those minimal subsets COMPS \u2032 of COMPS , such that SD\u222aOBS \u222a{ \u2227 c\u2208COMPS \u2032 \u00acAb(c)} is inconsistent. As expected, different notions of minimality can be used at this point.\nA minimal diagnosis for M is a minimal subset \u2206 of COMPS , such that SD\u222aOBS\u222a{\u00acAb(c) | c \u2208 COMPSr\u2206}\u222a{Ab(c) | c \u2208 \u2206} is consistent. That is, consistency is restored by flipping the normality assumption to abnormality for a minimal set of components, and those are the ones considered to be (jointly) faulty. The notion of minimality commonly used is S-minimality, i.e. a diagnosis that does not have a proper subset that is a diagnosis. We will use this kind of minimality in relation to diagnosis. Diagnosis can be obtained from conflict sets [53].\nExample 3 Consider a simple logical gate Or , denoted with o (the only system component in this case), that receives two digits, x, y, as inputs and outputs a digit val(x, y).\nThis simple system can be specified in terms of normal behavior by the logical formula \u03c3 : \u00acAb(o) \u2212\u2192 (val(x, y) = 0 \u2190\u2192 x = y = 0)), saying that, when the gate is not abnormal, the output is 0 iff the inputs are both 0.\nThe logical theory {\u03c3, val (0, 1) = 0} is logically consistent (it can be made true) despite the unexpected observation (namely, output 0 with inputs 0, 1). This is because the system\u2019s model allows for abnormal behaviors. However, this theory together with the extra assumption \u00acAb(o), i.e. that the gate is normal, form the theory {\u03c3, val(0, 1) = 0, \u00acAb(o)} that is inconsistent in the sense that it can not be made true (in technical terms, it has not models).\n6 Here, and as usual, the atom Ab(c) expresses that component c is (behaving) abnormal(ly).\n2.4 Complexity classes\nWe recall some complexity classes [52] used in this paper. FP is the class of functional problems associated to decision problem in the class PTIME, i.e. that are solvable in polynomial time. PNP (or \u2206P2 ) is the class of decision problems solvable in polynomial time by a machine that makes calls to an NP oracle. For PNP(log(n)) the number of calls is logarithmic. It is not known if PNP(log(n)) is strictly contained in PNP. FPNP(log(n)) is similarly defined."}, {"heading": "3 Actual Causes From Database Repairs", "text": "In this section we characterize actual causes for a BCQ Q being true in a database instance D in terms of the repairs of D with respect to a denial constraint whose violation view is Q, i.e. the latter asks if the constraint is violated. In essence, the actual causes will become the tuples outside an Srepair. The complement of the latter contains the cause plus a contingency set for the cause. In order to capture responsibility, C-repairs are considered.\nLet D be an instance for schema S, and Q : \u2203x\u0304(P1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Pm(x\u0304m)) a BCQ.Qmay be unexpectedly true, i.e.D |= Q. Now, \u00acQ is logically equivalent to the DC \u03ba(Q) : \u2200x\u0304\u00ac(P1(x\u03041)\u2227\u00b7 \u00b7 \u00b7\u2227Pm(x\u0304m)). The requirement that \u00acQ holds can be captured by imposing \u03ba(Q) on D. Due to D |= Q, it holds D 6|= \u03ba(Q). So, D is inconsistent with respect to \u03ba(Q), and could be repaired.\nRepairs for (violations of) DCs are obtained by tuple deletions. Intuitively, a tuple that participates in a violation of \u03ba(Q) in D is an actual cause for Q. S-minimal sets of tuples like this are expected to correspond to S-repairs for D with respect to \u03ba(Q).\nMore precisely, given an instance D, a BCQ Q, and a tuple t \u2208 Dn, we consider:\n\u2013 The class containing the sets of differences between D and those S-repairs that do not contain t, and are obtained by removing a subset of Dn:\nDiff s(D,\u03ba(Q), t) = {D rD\u2032 | D\u2032 \u2208 Srep(D,\u03ba(Q)),\nt \u2208 (D rD\u2032) \u2286 Dn}. (1)\n\u2013 The class containing the sets of differences between D and those C-repairs that do not contain t, and are obtained by removing a subset of Dn:\nDiff c(D,\u03ba(Q), t) = {D rD\u2032 | D\u2032 \u2208 Crep(D,\u03ba(Q)),\nt \u2208 (D rD\u2032) \u2286 Dn}. (2)\nIt holds Diff c(D,\u03ba(Q), t) \u2286 Diff s(D,\u03ba(Q), t). Now, any \u039b \u2208 Diff s(D,\u03ba(Q), t) can be written as \u039b = \u039b\u2032 \u222a {t}. From the S-minimality of S-repairs, it follows that D r (\u039b\u2032 \u222a {t}) |= \u03ba(Q), but D r \u039b\u2032 |= \u00ac\u03ba(Q). That is, D r (\u039b\u2032 \u222a {t}) 6|= Q, but D r \u039b\u2032 |= Q. As a consequence, t is an actual cause for Q with contingency set \u039b\u2032. We have obtained the following result.\nProposition 1 Given an instance D and a BCQ Q, t \u2208 Dn is an actual cause for Q iff Diff s(D,\u03ba(Q), t) 6= \u2205. Furthermore, if D rD\u2032 \u2208 Diff s(D,\u03ba(Q), t), then D r (D\u2032 \u222a {t}) is a minimal contingency set for t.\nProposition 2 Given an instance D, a BCQ Q, and t \u2208 Dn:\n(a) If Diff s(D,\u03ba(Q), t) = \u2205, then \u03c1 D (t) = 0. (b) Otherwise, \u03c1 D (t) = 1|\u039b| , where \u039b \u2208 Diff s(D,\u03ba(Q), t) and there is no \u039b\u2032 \u2208\nDiff s(D,\u03ba(Q), t) such that |\u039b\u2032| < |\u039b|.\nCorollary 1 Given an instanceD and a BCQQ: t \u2208 Dn is a most responsible actual cause for Q iff Diff c(D,\u03ba(Q), t) 6= \u2205.\nExample 4 (ex. 1 and 2 cont.) Consider the same instanceD and queryQ. The associated DC is \u03ba(Q) : \u2190 S(x), R(x, y), S(y) that we considered in Example 2, where we obtained Srep(D,\u03ba(Q)) = {D1, D2, D3} and Crep(D,\u03ba(Q)) = {D1}.\nFor tuple R(a4, a3), Diff s(D,\u03ba(Q), R(a4, a3)) = {D rD2} = {{R(a4, a3), R(a3 , a3)}}, which, by Propositions 1 and 2, confirms that R(a4, a3) is an actual cause, with responsibility 12 . The complement of D rD2 contains the actual cause R(a3, a3) plus a contingency set of it, namely that formed by tuple R(a3, a3), which has to be deleted together with the actual cause R(a4, a3) to restore consistency (cf. Example 2).\nFor tuple S(a3), Diff s(D,\u03ba(Q), S(a3)) = {D rD1} = {S(a3)}. So, S(a3)\nis an actual cause with responsibility 1. Similarly,R(a3, a3) is an actual cause with responsibility 1 2 , becauseDiff\ns(D, \u03ba(Q), R(a3, a3)) = {D rD2, D rD3} = {{R(a4, a3), R(a3, a3)}, {R(a3, a3), S(a4)}}.\nIt holds Diff s(D,\u03ba(Q), S(a2)) = Diff s(D,\u03ba(Q), R(a2, a1)) = \u2205, because all repairs contain S(a2), R(a2, a1). This means they do not participate in the violation of \u03ba(Q) or contribute to make Q true. So, they are not actual causes for Q, confirming the result in Example 1.\nDiff c(D,\u03ba(Q), S(a3)) = {S(a3)}. From Corollary 1, S(a3) is the most responsible cause.\nRemark 2 The results in this section can be easily extended to unions of BCQs. This can be done by associating a DC to each disjunct of the query, and considering the corresponding problems for database repairs with respect to several DCs (cf. Section 4.1)."}, {"heading": "4 Database Repairs From Actual Causes", "text": "In this section we characterize repairs for inconsistent databases with respect to a set of DCs in terms of actual causes with their contingency sets. The reduction of repair-related computations to cause-related computations is particularly relevant, because we can take advantage of known complexity results for repairs to obtain new lower-bound complexity results for causality.\nCausality has been investigated so far mainly for single conjunctive queries. However, database repairs appear in the context of sets of constraints. We concentrate on sets of DCs, which requires extending the analysis of causality to unions of conjunctive queries.\nMore concretely, in this section we characterize repairs of a database instance D with respect to a set \u03a3 of DCs in terms of the actual causes (with their contingency sets) for the union of the conjunctive queries naturally associated to the (bodies of the) DCs. In essence, an S-repair D\u2032 is a maximal subset of D that does not contain any actual cause t, and the tuples other than t and outside D\u2032 form a contingency set for t. As expected, C-repairs require the use of most responsible tuples.\nConsider an instance D for schema S, and a set of DCs \u03a3 on S. For each \u03ba \u2208 \u03a3, say \u03ba : \u2190 A1(x\u03041), . . . , An(x\u0304n), consider its associated violation view defined by a BCQ, namely V\u03ba: \u2203x\u0304(A1(x\u03041)\u2227 \u00b7 \u00b7 \u00b7 \u2227An(x\u0304n)). The answer yes to V\u03ba shows that \u03ba is violated (i.e. not satisfied) by D.\nNext, consider the query that is the union of the individual violation views: V\u03a3 := \u2228 \u03ba\u2208\u03a3 V\n\u03ba, a union of BCQs (UBCQs). Clearly, D violates (is inconsistent with respect to) \u03a3 iff D |= V\u03a3.\nIt is easy to verify that D, with Dx = \u2205, is consistent with respect to \u03a3 iff Causes(D, V\u03a3) = \u2205, i.e. there are no actual causes for V\u03a3 when all tuples are endogenous.\nNow, let us collect all S-minimal contingency sets associated with an actual cause t for V\u03a3 :\nDefinition 1 For an instance D and a set \u03a3 of DCs:\nCont(D,V\u03a3 , t) := {\u0393 \u2286 Dn | D r \u0393 |= V\u03a3 , D r (\u0393 \u222a {t}) 6|= V\u03a3 , (3)\nand \u2200\u0393 \u2032 $ \u0393, D r (\u0393 \u2032 \u222a {t}) |= V\u03a3}.\nNotice that for \u0393 \u2208 Cont(D,V\u03a3 , t), it holds t /\u2208 \u0393 . When Dx = \u2205, if t \u2208 Causes(D,V\u03a3) and \u0393 \u2208 Cont(D,V\u03a3 , t), from the definition of actual cause and the S-minimality of \u0393 , it holds that \u0393 \u2032\u2032 = \u0393 \u222a {t} is an S-minimal subset of D with D r \u0393 \u2032\u2032 6|= V\u03a3 . So, D r \u0393 \u2032\u2032 is an S-repair for D. Then, the following holds.\nProposition 3 For an instance D, with Dx = \u2205, and a set DCs \u03a3: D\u2032 \u2286 D is an S-repair forD with respect to \u03a3 iff, for every t \u2208 DrD\u2032: t \u2208 Causes(D,V\u03a3) and D r (D\u2032 \u222a {t}) \u2208 Cont(D,V\u03a3 , t).\nTo establish a connection between most responsible actual causes and Crepairs, assume that Dx = \u2205, and collect the most responsible actual causes for V\u03a3 :\nDefinition 2 For an instance D with Dx = \u2205:\nMRC (D,V\u03a3) := {t \u2208 D | t \u2208 Causes(D,V\u03a3), 6 \u2203t\u2032 \u2208 Causes(D,V\u03a3) (4)\nwith \u03c1 D (t\u2032) > \u03c1 D (t)}.\nProposition 4 For instance D, with Dx = \u2205, and set of DCs \u03a3: D\u2032 \u2286 D is a C-repair for D with respect to \u03a3 iff, for every t \u2208 D rD\u2032: t \u2208 MRC (D,V\u03a3) and D r (D\u2032 \u222a {t}) \u2208 Cont(D,V\u03a3 , t).\nActual causes for V\u03a3 , with their contingency sets, account for the violation of some \u03ba \u2208 \u03a3. Removing those tuples fromD should remove the inconsistency. From Propositions 3 and 4 we obtain:\nCorollary 2 Given an instance D and a set DCs \u03a3, the instance obtained from D by removing an actual cause, resp. a most responsible actual cause, for V\u03a3 together with any of its S-minimal, resp. C-minimal, contingency sets forms an S-repair, resp. a C-repair, for D with respect to \u03a3.\nExample 5 Consider D = {P (a), P (e), Q(a, b), R(a, c)} and \u03a3 = {\u03ba1, \u03ba2}, with \u03ba1 : \u2190 P (x), Q(x, y) and \u03ba2 : \u2190 P (x), R(x, y).\nThe violation views are V \u03ba1 : \u2203xy(P (x) \u2227 Q(x, y)) and V \u03ba2 : \u2203xy(P (x) \u2227 R(x, y)). For V\u03a3 := V \u03ba1 \u2228V \u03ba2 , D |= V\u03a3 and D is inconsistent with respect to \u03a3.\nNow assume all tuples are endogenous. It holds Causes(D,V\u03a3) = {P (a), Q(a, b), R(a, c)}, and its elements are associated with sets of S-minimal contingency sets, as follows: Cont(D,V\u03a3, Q(a, b)) = {{R(a, c)}}, Cont(D,V\u03a3, R(a, c)) = {{Q(a, b)}}, and Cont(D,V\u03a3, P (a)) = {\u2205}.\nFrom Corollary 2, and Cont(D,V\u03a3, R(a, c)) = {{Q(a, b)}}, D1 = D r ({R(a, c)}\u222a{Q(a, b)}) = {P (a), P (e)} is an S-repair. So is D2 = Dr({P (a)}\u222a \u2205) = {P (e), Q(a, b), R(a, c)}. These are the only S-repairs.\nFurthermore, MRC (D,V\u03a3) = {P (a)}. From Corollary 2, D2 is also a Crepair for D.\nRemark 3 An actual cause t with any of its S-minimal contingency sets determines a unique S-repair. The last example shows that, with different combinations of a cause and one of its contingency sets, we may obtain the same repair (e.g. for the first two Cont sets). So, we may have more minimal contingency sets than minimal repairs. However, we may still have exponentially many minimal contingency sets, so as we may have exponentially many minimal repairs of an instance with respect to DCs, as the following example shows.7\nExample 6 ConsiderD = {R(1, 0), R(1, 1), . . . , R(n, 0), R(n, 1), S(1), S(0)} and the DC \u03ba : \u2190 R(x, y), R(x, z), S(y), S(z). D is inconsistent with respect to \u03ba. There are exponentially many S-repairs of D: D\u2032 = D r {S(0)}, D\u2032\u2032 = D r {S(1)}, D1 = Dr{R(1, 0), . . . , R(n, 0)}, ..., D2n = Dr{R(1, 1), . . . , R(n, 1)}. The C-repairs are only D\u2032 and D\u2032\u2032.\nFor the BCQ V \u03ba associated to \u03ba, D |= V \u03ba, and S(1) and S(0) are actual causes for V \u03ba (courterfactual causes with responsibility 1). All tuples in R are actual causes, each with exponentially many S-minimal contingency sets.\n7 Cf. [4] for an example of the latter that uses key constraints, which are DCs with inequalities (with violation views that contain inequality).\nFor example, R(1, 0) has the S-minimal contingency set {R(2, 0), . . . , R(n, 0)}, among exponentially many others (any set built with just one element from each of the pairs {R(2, 0), R(2, 1)}, ..., {R(n, 0), R(n, 1)} is one).\n4.1 Causes for unions of conjunctive queries\nIf we want to compute repairs with respect to sets of DCs from causes for UBCQs using, say Corollary 2, we first need an algorithm for computing the actual causes and their (minimal) contingency sets for UBCQs. These algorithms could be used as a first stage of the computation of S-repairs and C-repairs with respect to sets of DCs. However, these algorithms (developed in Section 4.2), are also interesting and useful per se.\nThe PTIME algorithm for computing actual causes in [47] is for single conjunctive queries, but does not compute the actual causes\u2019 contingency sets. Actually, doing the latter increases the complexity, because deciding responsibility8 of actual causes is NP -hard [47] (which would be tractable if we could efficiently compute all (minimal) contingency sets).9 In principle, an algorithm for responsibilities can be used to compute C-minimal contingency sets, by iterating over all candidates, but Example 6 shows that there can be exponentially many of them.\nWe first concentrate on the problem of computing actual causes for UBCQs, without their contingency sets, which requires some notation.\nDefinition 3 Given Q = C1\u2228\u00b7 \u00b7 \u00b7\u2228Ck, where each Ci a BCQ, and an instance D:\n(a) S(D) is the collection of all S-minimal subsets of D that satisfy a disjunct Ci of Q. (b) Sn(D) consists of the S-minimal subsets \u039b of Dn for which there exists a \u039b\u2032\u2208 S(D) with \u039b \u2286 \u039b\u2032 and \u039br \u039b\u2032 \u2286 Dx.\nSn(D) contains all S-minimal sets of endogenous tuples that simultaneously (and possibly accompanied by exogenous tuples) make the query true. It is easy to see that S(D) and Sn(D) can be computed in polynomial time in the size of D.\nNow, generalizing a result for CQs in [47], actual causes for a UBCQs can be computed in PTIME in the size of D without computing contingency sets. We formulate this results in terms of the corresponding causality decision problem (CDP).\nProposition 5 Given an instance D, a UBCQ Q, and t \u2208 Dn:\n(a) t is an actual cause for Q iff there is \u039b \u2208 Sn(D) with t \u2208 \u039b.\n8 For a precise formulation, see Definition 5. 9 Actually, [47] presents a PTIME algorithm for computing responsibilities for a restricted\nclass of CQs.\n(b) The causality decision problem (about membership of)\nCDP := {(D, t) | t \u2208 Dn, and t \u2208 Causes(D,Q)} (5)\nbelongs to PTIME .\nProof (a) Assume S(D) = {\u039b1, . . . , \u039bm}, and there exists a \u039b \u2208 Sn(D) with t \u2208 \u039b. Consider a set \u0393 \u2286 Dn such that, for all \u039bi \u2208 Sn(D) where \u039bi 6= \u039b, \u0393 \u2229 \u039bi 6= \u2205 and \u0393 \u2229 \u039b = \u2205. With such a \u0393 , t is an actual cause for Q with contingency set \u0393 . So, it is good enough to prove that such \u0393 always exists. In fact, since all subsets of Sn(D) are S-minimal, then, for each \u039bi \u2208 Sn(D) with \u039bi 6= \u039b, \u039bi \u2229 \u039b = \u2205. Therefore, \u0393 can be obtained from the set of difference between each \u039bi and \u039b.\nNow, if t is an actual cause for Q, then there exist an S-minimal \u0393 \u2208 Dn, such that Dr(\u0393 \u222a{t}) 6|= Q, but Dr\u0393 |= Q. This implies that there exists an S-minimal subset \u039b of D, such that t \u2208 \u039b and \u039b |= Q. Due to the S-minimality of \u0393 , it is easy to see that t is included in a subset of Sn(D). (b) This is a simple generalization of the proof of the same result for single conjunctive queries found in [47].\nExample 7 (ex. 5 cont.) Consider the query Q : \u2203xy(P (x) \u2227 Q(x, y)) \u2228 \u2203xy(P (x) \u2227 R(x, y)), and assume that for D, Dn = {P (a), R(a, c)} and Dx = {P (e), Q(a, b)}. It holds S(D) = {{P (a), Q(a, b)}, {P (a), R(a, c)}}. Since {P (a)} \u2286 {P (a), R(a, c)}, Sn(D) = {{P (a)}}. So, P (a) is the only actual cause for Q.\n4.2 Contingency sets for unions of conjunctive queries\nIt is possible to develop a (naive) algorithm that accepts as input an instance D and a UBCQ Q, and returns Causes(D,Q); and also, for each t \u2208 Causes(D,Q), its (set of) S-minimal contingency sets Cont(D,Q, t).\nThe basis for the algorithm is a correspondence between the actual causes for Q with their contingency sets and a hitting-set problem.10 More precisely, for a fixed UBCQ Q, consider the hitting-set framework\nH n(D) = \u3008Dn,Sn(D)\u3009, (6)\nwith Sn(D) as in Definition 3. Different computational and decision problems are based on Hn(D), and we will confront some below. Notice that hitting-sets (HSs) are all subsets of Dn.\nThe S-minimal hitting-sets for Hn(D) correspond to actual causes with their S-minimal contingencies for Q. Most responsible causes for Q are in correspondence with hitting-sets for Hn(D). This is formalized as follows:\n10 If C is a collection of non-empty subsets of a set S, a subset S\u2032 \u2286 S is a hitting-set for C if, for every C \u2208 C, C \u2229 S\u2032 6= \u2205. S\u2032 is an S-minimal hitting-set if no proper subset of it is also a hitting-set. S is a minimum hitting-set if it has minimum cardinality.\nProposition 6 For an instance D, a UBCQ Q, and t \u2208 Dn:\n(a) t is an actual cause for Q with S-minimal contingency set \u0393 iff \u0393 \u222a {t} is an S-minimal hitting-set for Hn(D). (b) t is a most responsible actual cause for Q with C-minimal contingency set \u0393 iff \u0393 \u222a {t} is a minimum hitting-set for Hn(D).\nThe proof is similar to that of part (a) of Proposition 5.\nExample 8 (ex. 5 and 7 cont.) D andQ are as before, but now all tuples are endogenous. Here, S(D) = Sn(D) = {{P (a), Q(a, b)}, {P (a), R(a, c)}}. Hn(D) has two S-minimal hitting-sets: H1 = {P (a)} and H2 = {Q(a, b), R(a, c)}. Each of them implicitly contains an actual cause (any of its elements) with an S-minimal contingency set (what\u2019s left after removing the actual cause). H1 is also the C-minimal hitting-set, and contains the most responsible actual cause, P (a).\nRemark 4 For Hn(D) = \u3008Dn,Sn(D)\u3009, Sn(D) can be computed in PTIME in data complexity, and its elements are bounded in size by |Q|, which is the maximum number of atoms in one of Q\u2019s disjuncts. This is a special kind of hitting-set problems. For example, deciding if there is a hitting-set of size at most k as been called the d-hitting-set problem [50], and d is the bound on the size of the sets in the set class. In our case, d would be |Q|.\n4.3 Causality, repairs, and consistent answers\nCorollary 2 and Proposition 6 can be used to compute repairs. If the classes of S- and C-minimal hitting-sets for Hn(D) (with Dn = D) are available, computing S- and C-repairs will be in PTIME in the sizes of those classes. However, it is well known that computing minimal hitting-sets is a complex problem. Actually, as Example 6 implicitly shows, we can have exponentially many of them in |D|; so as exponentially many minimal repairs for D with respect to a denial constraint. We can see that the complexity of contingency sets computation is in line with the complexities of computing hitting-sets and repairs.\nAs Corollary 2 and Proposition 6 show, the computation of causes, contingency sets, and most responsible causes via minimal/minimum hitting-set computation can be used to compute repairs and decide about repair questions. Since the hitting-set problems in our case are of the d-hitting-set kind, good algorithms and approximations for the latter (cf. Section 6.1) could be used in the context of repairs.\nIn the rest of this section we consider an instance D whose tuples are all endogenous, and a set \u03a3 of DCs. For the disjunctive violation view V\u03a3 , the following result is obtained from Propositions 3 and 4, and Corollary 2.\nCorollary 3 For an instance D, with Dx = \u2205, and a set \u03a3 of DCs, it holds:\n(a) For every t \u2208 Causes(D,V\u03a3), there is an S-repair that does not contain t.\n(b) For every t \u2208 MRC (D,V\u03a3), there is a C-repair that does not contain t. (c) For every D\u2032 \u2208 Srep(D,\u03a3) and D\u2032\u2032 \u2208 Crep(D,\u03a3), it holds D r D\u2032 \u2286\nCauses(D,V\u03a3) and D rD\u2032\u2032 \u2286 MRC (D,V\u03a3).\nFor a projection-free, and a possibly non-boolean CQ Q, we are interested in its consistent answers fromD with respect to \u03a3. For example, for Q(x, y, z) : R(x, y)\u2227S(y, z), the S-consistent (C-consistent) answers would be of the form \u3008a, b, c\u3009, where R(a, b) and S(b, c) belong to all S-repairs (C-repairs) of D.\nFrom Corollary 3, \u3008a, b, c\u3009 is an S-consistent (resp. C-consistent) answer iff R(a, b) and S(b, c) belong to D, but they are not actual causes (resp. most responsible actual causes) for V\u03a3 .\nThe following simple result and its corollary will be useful in Section 6.\nProposition 7 For an instance D, with Dx = \u2205, a set \u03a3 of DCs, and a projection-free CQ Q(x\u0304) : P1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Pk(x\u0304k):\n(a) c\u0304 is an S-consistent answer iff, for each i, Pi(c\u0304i) \u2208 (D r Causes(D,V\u03a3)). (b) c\u0304 is a C-consistent answer iff, for each i, Pi(c\u0304i) \u2208 (D rMRC (D,V\u03a3)).\nExample 9 (ex. 5 cont.) Consider Q(x) : P (x). We had Causes(D,V\u03a3) = {P (a), Q(a, b), R(a, c)}, MRC (D,V\u03a3) = {P (a)}. Then, \u3008e\u3009 is both an S- and a C-consistent answer.\nNotice that Proposition 7 can easily be extended to conjunctions of ground atomic queries.\nCorollary 4 Given an instance D and a set \u03a3 of DCs, the ground atomic query Q: P (c) is C-consistently true iff P (c) \u2208 D and it is not a most responsible cause for V\u03a3 .\nExample 10 ForD = {P (a, b), R(b, c), R(a, d)} and the DC \u03ba :\u2190 P (x, y), R(y, z), we obtain: Causes(D, V \u03ba) = MRC (D,V \u03ba) = {P (a, b), R(b, c)}.\nFrom Proposition 7, the ground atomic query Q: R(a, d) is both S- and C-consistently true in D with respect to \u03ba, because, D r Causes(D,V \u03ba) = D rMRC (D,V \u03ba) = {R(a, d)}.\nThe CQs considered in Proposition 7 and its Corollary 4 are not particularly interesting per se, but we will use those results to obtain new complexity results for causality later on, e.g. Theorem 3."}, {"heading": "5 Causes and Repairs from Consistency-Based Diagnosis", "text": "The main objective in this section is to characterize database causality computation as a diagnosis problem.11 This is interesting per se, and will also\n11 The other direction is beyond the scope of this work. More importantly, logic-based diagnosis in general is a much richer scenario than that of database causality. In the former, we can have arbitrary logical specification, whereas under data causality, we have only monotone queries at hand.\nallow us to apply ideas and techniques from model-based diagnosis to causality. As a side result we obtain a characterization of database repairs in terms of diagnosis.\nLet D be an instance for schema S, and Q : \u2203x\u0304(P1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Pm(x\u0304m)), a BCQ. Assume Q is, possibly unexpectedly, true in D. So, for the associated DC \u03ba(Q) : \u2200x\u0304\u00ac(P1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Pm(x\u0304m)), D 6|= \u03ba(Q). Q is our observation, for which we want to find explanations, using a consistency-based diagnosis approach.\nFor each predicate P \u2208 P , we introduce predicate AbP , with the same arity as P . Intuitively, a tuple in its extension is abnormal for P . The \u201csystem description\u201d, SD , includes, among other elements, the original database, expressed in logical terms, and the DC as true \u201cunder normal conditions\u201d.\nMore precisely, we consider the following diagnosis problem, M = (SD , Dn, Q), associated to Q. The FO system description, SD , contains the following elements:\n(a) Th(D), which is Reiter\u2019s logical reconstruction of D as a FO theory [54] (cf. Example 11). (b) Sentence \u03ba(Q)Ab , which is \u03ba(Q) rewritten as follows:\n\u03ba(Q)Ab : \u2200x\u0304\u00ac(P1(x\u03041) \u2227 \u00acAbP1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Pm(x\u0304m) \u2227 \u00acAbPm(x\u0304m)). (7)\n(c) Formula (7) can be refined by applying the abnormality predicate, Ab, to endogenous tuples only. For this we need to use additional auxiliary predicates EndP , with the same arity of P \u2208 S, which contain the endogenous tuples in P \u2019s extension (see Example 11). Accordingly, we introduce the inclusion dependencies: For each P \u2208 P ,\n\u2200x\u0304(AbP (x\u0304) \u2192 EndP (x\u0304)), and \u2200x\u0304(EndP (x\u0304) \u2192 P (x\u0304)).\nThe last entry, Q, in M is the \u201cobservation\u201d, which together with SD will produce and inconsistent theory, because we make the initial and explicit assumption that all the abnormality predicates are empty (equivalently, that all tuples are normal), i.e. we consider, for each predicate P , the sentence12\n\u2200x\u0304(AbP (x\u0304) \u2192 false), (8)\nwhere, false is a propositional atom that is always false.\nThe second entry in M is Dn. This is the set of \u201ccomponents\u201d that we can use to try to restore consistency, in this case, by (minimally) changing the abnormality condition on tuples in Dn. In other words, the universal rules (8) are subject to exceptions or qualifications: some endogenous tuples may be abnormal. Each diagnosis shows an S-minimal set of endogenous tuples that are abnormal.\n12 Notice that these can also be seen as DCs, since they can be written as \u2200x\u0304\u00acAbP (x\u0304).\nExample 11 (ex. 1 cont.) Consider the query Q : \u2203x\u2203y(S(x)\u2227R(x, y)\u2227S(y)), and the instance D = {S(a3), S(a4), R(a4, a3)}, with Dn = {S(a4), S(a3)}, consider the diagnostic problem M = (SD , {S(a4), S(a3)}, Q), with SD containing the sentences in (a)-(c) below:\n(a) Predicate completion axioms plus unique names assumption:\n\u2200xy(R(x, y) \u2194 x = a4 \u2227 y = a3), \u2200x(S(x) \u2194 x = a3 \u2228 x = a4), (9)\n\u2200xy(EndR(x, y) \u2194 false), \u2200x(EndS(x) \u2194 x = a3 \u2228 x = a4), (10)\na4 6= a3. (11)\n(b) The denial constraint qualified by non-abnormality, \u03ba(Q)Ab :\n\u2200xy\u00ac(S(x) \u2227 \u00acAbS(x) \u2227R(x, y) \u2227 \u00acAbR(x, y) \u2227 S(y) \u2227 \u00acAbS(y)).\nIn diagnosis formalizations this formula would be usually presented as:\n\u2200xy((\u00acAbS(x) \u2227 \u00acAbR(x, y) \u2227 \u00acAbS(y)) \u2212\u2192 \u00ac(S(x) \u2227R(x, y) \u2227 S(y))).\nThat is, under the normality assumption, the \u201csystem\u201d behaves as intended; in this case, there are no violations of the denial constraint. This main formula in the diagnosis specification can also be written as a disjunctive positive rule:\n\u2200xy(S(x) \u2227R(x, y) \u2227 S(y) \u2212\u2192 AbS(x) \u2228 AbR(x, y) \u2228 AbS(y)). (12)\n(c) Abnormality/endogenousity predicates are in correspondence to the database schema, and only endogenous tuples can be abnormal:\n\u2200xy(AbR(x, y) \u2192 EndR(x, y)), \u2200xy(EndR(x, y) \u2192 R(x, y)), (13)\n\u2200x(AbS(x) \u2192 EndS(x)), \u2200x(EndS(x) \u2192 S(x)). (14)\nIn addition to this specification, we have the observation Q:\n\u2203x\u2203y(S(x) \u2227R(x, y) \u2227 S(y)). (15)\nFinally, we make the assumption that there are not abnormal tuples:\n\u2200xy(AbR(x, y) \u2192 false), \u2200x(AbS(x) \u2192 false). (16)\nThe FO theory formed by (9) - (16) (more precisely, (9), (11), (12), (15) and (16)) is inconsistent.\nNow, in more general terms, the observation is Q (being true), obtained by evaluating query Q on (theory of) D. In this case, D 6|= \u03ba(Q). Since all the abnormality predicates are assumed to be empty, \u03ba(Q) is equivalent to \u03ba(Q)Ab , which also becomes false with respect toD. As a consequence, SD\u222a{(8)}\u222a{Q} is an inconsistent FO theory. A diagnosis is a set of endogenous tuples that, by becoming abnormal, restore consistency.\nDefinition 4 (a) A diagnosis for M is a \u2206 \u2286 Dn, such that\nSD \u222a {AbP (c\u0304) | P (c\u0304) \u2208 \u2206} \u222a {\u00acAbP (c\u0304) | P (c\u0304) \u2208 D r\u2206} \u222a {Q} is consistent.\n(b) Diags(M, t) denotes the set of S-minimal diagnoses for M that contain tuple t \u2208 Dn. (c) Diagc(M, t) denotes the set of C-minimal diagnoses in Diags(M, t).\nExample 12 (ex. 11 cont.) The theory can be made consistent by giving up (16), and making S-minimal sets of tuples abnormal. According to (13)-(14), those tuples have to be endogenous.\nM has two S-minimal diagnosis: \u22061 = {S(a3)} and \u22064 = {S(a4)}. The first one corresponds to replacing the second formula in (16) by \u2200x(AbS(x) \u2227 x 6= a3 \u2192 false), obtaining now a consistent theory.\nHere, Diags(M, S(a3)) = Diag c(M, S(a3)) = {{S(a3)}}, and Diag s(M, S(a4)) = Diag\nc(M, S(a4)) = {{ S(a4)}}. If R(a4, a3) is also endogenous, then also {R(a4, a3)} becomes a minimal\ndiagnosis.\nBy definition, Diagc(M, t) \u2286 Diags(M, t). Diagnoses for M and actual causes for Q are related.\nProposition 8 Consider an instance D, a BCQ Q, and the diagnosis problem M associated to Q. Tuple t \u2208 Dn is an actual cause for Q iff Diags(M, t) 6= \u2205.\nThe responsibility of an actual cause t is determined by the cardinality of the diagnoses in Diagc(M, t).\nProposition 9 For an instance D, a BCQ Q, the associated diagnosis problem M, and a tuple t \u2208 Dn, it holds: (a) \u03c1\nD (t) = 0 iff Diagc(M, t) = \u2205.\n(b) Otherwise, \u03c1 D (t) = 1|\u2206| , where \u2206 \u2208 Diag c(M, t).\nFor the proofs of Propositions 8 and 9, it is easy to verify that the conflict sets of M coincide with the sets in S(Dn) (cf. Definition 3). The results are obtained from the characterization of minimal diagnosis as minimal hittingsets of sets of conflict sets (cf. Section 2 and [53]) and Proposition 6.\nExample 13 (ex. 12 cont.) From Propositions 8 and 9, S(a3) and S(a4) are actual cases, with responsibility 1. If R(a4, a3) is also endogenous, it also becomes an actual cause with responsibility 1.\nIn consistency-based diagnosis, minimal diagnoses can be obtained as Sminimal hitting-sets of the collection of S-minimal conflict sets (cf. Section 2) [53]. In our case, conflict sets are S-minimal sets of endogenous tuples that, if not abnormal (only endogenous ones can be abnormal), and together, and possibly in combination with exogenous tuples, make (7) false.\nIt is easy to verify that the conflict sets of M coincide with the sets in S(Dn) (cf. Definition 3 and Remark 4). As a consequence, conflict sets for M can be computed in PTIME, the hitting-sets for M contain actual causes for Q, and the hitting-set problem for the diagnosis problems is of the d-hitting-set kind.\nThe reduction from causality to consistency-based diagnosis allows us to apply constructions and techniques for the latter (cf. [27,49]), to the former.\nExample 14 (ex. 11 cont.) The diagnosis problem M = (SD , {S(a4), S(a3)}, Q) gives rise to the hitting-set framework Hn(D) = \u3008{S(a4), S(a3)}, {{(S(a3), S(a4)}}\u3009, with {S(a3), S(a4)} corresponding to the conflict set c = {S(a4), S(a3)}.\nHn(D) has two minimum hitting-sets: {S(a3)} and {S(a4)}, which are the S-minimal diagnosis for M. Then, the two tuples are actual causes for Q (cf. Proposition 8). From Proposition 9, \u03c1\nD (S(a3)) = \u03c1D(S(a4)) = 1.\nThe solutions to the diagnosis problem can be used for computing repairs.\nProposition 10 Consider an instance D with Dx = \u2205, a set of DCs of the form \u03ba : \u2200x\u0304\u00ac(P1(x\u03041)\u2227\u00b7 \u00b7 \u00b7\u2227Pm(x\u0304m), and their associated \u201cabnormality-aware\u201d integrity constraints13 in (7) (in this case we do not need EndP atoms).\nEach S-minimal diagnosis \u2206 gives rise to an S-repair of D, namely D\u2206 = Dr{P (c\u0304) \u2208 D | AbP (c\u0304) \u2208 \u2206}; and every S-repair can be obtained in this way. Similarly, for C-repairs using C-minimal diagnoses.\nExample 15 (ex. 13 cont.) The instance D = {S(a3), S(a4), R(a4, a3)}, with all tuples endogenous, has three (both S- and C-) repairs with respect to the DC \u03ba : \u2200xy\u00ac(S(x) \u2227 R(x, y) \u2227 S(y)), namely D1 = {S(a3), R(a4, a3)}, D2 = {S(a4), R(a4, a3)}, and D3 = {S(a3), S(a4)}. They can be obtained as D\u22061 , D\u22062 , D\u22063 from the only (S- and C-) diagnoses, \u22061 = {S(a3)}, \u22062 = {S(a4)}, \u22063 = {R(a4, a3)}, resp.\nWe have characterized repairs in terms of diagnosis. Thinking of the other direction, and as a final remark, it is worth observing that the very particular kind of diagnosis problem we introduced above (with restricted logical formulas) can be formulated as a preferred-repair problem [9, Sec. 2.5]. Without going into the details, the idea is to materialize tables for the auxiliary predicates AbP and EndP , and consider the DCs of the form (7) (with the EndP atoms when not all tuples are endogenous), plus the DCs (8), saying that the initial extensions for the AbP predicates are empty. If D is inconsistent with respect to this set of DCs, the S-repairs that are obtained by only inserting endogenous tuples into the extensions of the AbP predicates correspond to S-minimal diagnosis, and each S-minimal diagnosis can be obtained in this way.\n13 Notice that these are not denial constraints."}, {"heading": "6 Complexity Results", "text": "There are three main computational problems in database causality. For a BCQ Q and database D:\n(a) The causality problem (CP) is about computing the actual causes for Q. Its decision version of this problem, CDP, is stated in (5). Both CP and CDP are solvable in polynomial time [47], which can be extended to UBCQs (cf. Proposition 5). (b) The responsibility problem (RP) is about computing the responsibility \u03c1 D (t) of a given actual cause t. (Since a tuple that is not an actual cause\nhas responsibility 0, this problem subsumes (a).) This is a maximization problem due to the minimization of |\u0393 | in the denominator. We will consider the decision version of this problem that, as usual for maximization problems [29], asks whether the real-valued function being computed (responsibility in this case) takes a value greater than a given threshold v of the form 1\nk , for a positive integer k.\nDefinition 5 For a BCQ Q, the responsibility decision problem (RDP) is (deciding about membership of):\nRDP(Q) = {(D, t, v) | t \u2208 Dn, v \u2208 {0} \u222a { 1 k | k \u2208 N+}, and\nD |= Q and \u03c1 D (t) > v},\nthat is, deciding if a tuple has a responsibility greater than a bound v (as a cause for Q).\nThe complexity analysis of RDP in [47] is restricted to conjunctive queries without self-joins. Here, we will generalize the complexity analysis for RDP to general CQs.\n(c) Computing themost responsible actual causes (MRC). Its decision version, MRCDP, the most responsible cause decision problem, is a natural problem, because actual causes with the highest responsibility tend to provide most interesting explanations for query answers [47,48].\nDefinition 6 For a BCQ Q, the most responsible cause decision problem is (membership of):\nMRCDP(Q) = {(D, t) | t \u2208 Dn and 0 < \u03c1 D (t) is a maximum for D}.\nWe start by analyzing a more basic decision problem, that of deciding if a set of tuples \u0393 is an S-minimal contingency set associated to a cause t (cf. (3)). Due to the results in Sections 3 and 4, it is clear that there is a close connection between this problem and the S-repair checking problem [9, Chap. 5], about deciding if instance D\u2032 is an S-repair of instance D with respect to a set of integrity constraints. Actually, the following result is obtained from the PTIME solvability of the S-repair checking problem for DCs [18] (see also [1]).\nProposition 11 For a BCQ Q, the minimal contingency set decision problem (MCSDP), i.e. MCSDP(Q) := {(D, t, \u0393 ) | \u0393 is minimal element in Cont(D,Q, t)}, belongs to PTIME .\nProof To decide if (D, t, \u0393 ) \u2208 MCSDP(Q), it is good enough to observe, from Proposition 1, that (D, t, \u0393 ) \u2208 MCSDP(Q) iff Dr (\u0393 \u222a{t}) is an S-repair for D with respect to \u03ba(Q). S-repair checking can be done in PTIME in data [18].\nWe could also consider the decision problem defined in Proposition 11, but with C-minimal \u0393 . We will not use results about this problem in the following. Furthermore, its connection with the C-repair checking problem is less direct. As one can see from Section 3, C-minimal contingency sets correspond to a repair semantics somewhere between the S-minimal and C-minimal repair semantics (a subclass of Srep, but a superclass of Crep): It is about an Sminimal repair with minimum cardinality that does not contain a particular tuple.\nNow we establish that RDP is NP-complete for CQs in general. The NPhardness is shown in [47]. Membership of NP is obtained using Proposition 11.\nTheorem 1 (a) For every BCQ Q, RDP(Q) \u2208 NP . (b) [47] There are CQs Q for which RDP(Q) is NP-hard.\nProof (a) We give a non-deterministic PTIME algorithm to solve RDP. Nondeterministically guess a subset \u0393 \u2286 Dn, return yes if |\u0393 | < 1\nv and (D, t,\n\u0393 ) \u2208 MCSDP ; otherwise return no. According to Proposition 11 this can be done in PTIME in data complexity.\nIn order to better understand the complexity of RP, the responsibility computation problem, we will investigate the functional, non-decision version of RDP.\nThe main source of complexity when computing responsibilities is related to the hitting-set problem associated to Hn(D) = \u3008Dn,Sn(D)\u3009 in Remark 4 (cf. (6)). In this case, it is about computing the cardinality of a minimum hitting-set that contains a given vertex (tuple) t. That this is a kind of dhitting-set problem [50] will be useful in Section 6.1.\nRemark 5 Our responsibility problem can also be seen as a vertex cover problem on the hypergraph14\nGn(D) = \u3008Dn,Sn(D)\u3009 (17)\nassociated to Hn(D) = \u3008Dn,Sn(D)\u3009 (that is, the hitting-set framework can be seen as a hypergraph). In it, the hyperedges are the members of Sn(D).\n14 In an hypergraph H, a set of vertices is a vertex cover if it intersects every hyperedge. A minimal vertex cover has no proper subset that is also a vertex cover. A minimum vertex cover has minimum cardinality among the vertex covers. Similarly, an independent set of H is a set of vertices such that no pair of them is contained in a hyperedge. Maximal and maximum independent sets are defined in an obvious manner.\nDetermining the responsibility of a tuple t becomes the problem on hypergraphs of determining the size of a minimum vertex cover that contains vertex t (among all vertex covers that contain the vertex). Again, in this problem the hyperedges are bounded in size by |Q|.15\nExample 16 For Q : \u2203xy(P (x) \u2227R(x, y) \u2227 P (y)), and D = Dn = {P (a), P (c), R(a, c), R(a, a)}, S(D) = Sn(D) = {{P (a), R(a, a)}, {P (a), P (c), R(a, c)}}.\nThe hypergraph Gn(D) has D as set of vertices, and its hyperedges are {P (a), R(a, a)} and {P (a), P (c), R(a, c)}. Its minimal vertex covers are: vc1 = {P (a)}, vc2 = {P (c), R(a, a)}, vc3 = {R(a, a), R(a, c)}. Only the first has minimum cardinality. Accordingly, its only element, P (a), is an actual cause with responsibility 1. The other tuples are actual causes with responsibility 12 .\nRemark 6 To simplify the presentation of the next computational problems (Lemmas 1 and 2 and Proposition 12), we will formulate and address them in terms of graphs. However, they still hold for hypergraphs [43,44], which is what we need for the complexity results obtained in the rest of this section.\nLemma 1 (representation lemma) There is a fixed database schema S and a BCQ Q \u2208 L(S), without built-ins, such that, for every graph G = (V,E), with non-empty E, and v \u2208 V , there is an instance D for S and a tuple t \u2208 D, such that the size of a minimum vertex cover of G containing v is the inverse of the responsibility of t as an actual cause for Q.\nProof Consider a graph G = (V,E), and assume the vertices of G are uniquely labeled.\nConsider the database schema with relations Ver(v0) and Edges(v1, v2, e), and the conjunctive query Q : \u2203v1v2e(Ver(v1) \u2227 Ver(v2) \u2227 Edges(v1, v2, e)). Ver stores the vertices of G, and Edges , the labeled edges. For each edge (v1, v2) \u2208 E, Edges contains n tuples of the form (v1, v2, i), where n is the number of vertices in G. All the values in the third attribute of Edges are different, say from 1 to n \u00d7 |E|. This padding of relation Edge will ensure in the rest of the proof that C-minimal contingency sets for the query answer consist only of vertices, i.e. elements of Ver (as opposed to Edge tuples). The size of the padded instance is still polynomial in the size of G. It is clear that D |= Q.\nAssume VC is the minimum vertex cover of G that contains vertex v, where tuple t is Ver(v). Consider the set of tuples \u039b = {Ver(x) | x \u2208 VC}. Since v \u2208 VC , \u039b = \u039b\u2032 \u222a{Ver(v)}. Then, Dr (\u039b\u2032\u222aVer(v)) 6|= Q. This is because for every tuple Edge(vi, vj , k) in the instance, either vi or vj belongs to VC . Due to the minimality of VC , D r \u039b\u2032 |= Q. Therefore, tuple Ver(v) is an actual cause for Q.\n15 We recall that repairs of databases with respect to DCs can be characterized as maximal independent sets of conflict hypergraphs (conflict graphs in the case of FDs) whose vertices are the database tuples, and hyperedges connect tuples that together violate a DC [4,18].\nSuppose \u0393 is a C-minimal contingency set associated to Ver(v). Due to the C-minimality of \u0393 , it entirely consists of tuples in Ver . It holds that Dr(\u0393\u222a{Ver(v)}) 6|= Q andDr\u0393 |= Q. Consider the set VC \u2032 = {x | Ver(x) \u2208 \u0393} \u222a {v}. Since Dr (\u0393 \u222a {Ver(v)}) 6|= Q, for every tuple Edge(vi, vj , k) in D, either vi \u2208 VC \u2032 or vj \u2208 VC \u2032. Therefore, VC \u2032 is a minimum vertex cover of G that contains v. It holds that \u03c1 D (Ver(v)) = 11+|\u0393 | . So, the size of a minimum vertex cover of G that contains v can be obtained from \u03c1 D (Ver(v)).\nHaving represented our responsibility problem as a graph-theoretic problem, we first consider functional computational problems in graphs.\nDefinition 7 The minimal vertex cover membership problem (MVCMP) consists in, given a graph G = (V,E), and a vertex v \u2208 V as inputs, computing the size of a minimum vertex cover of G that contains v.\nLemma 2 Given a graph G and a vertex v in it, there is a graph G\u2032 extending G that can be constructed in polynomial time in |G|, such that the size of a minimum vertex cover for G that contains v and the size of a minimum vertex cover for G\u2032 coincide.\nProof The size of VCG(v), the minimum vertex cover of G that contains the vertex v, can be computed from the size of IG, the maximum independent set of G, that does not contain v. In fact,\n|VCG(v)| = |G| \u2212 |IG|. (18)\nSince IG is a maximum independent set that does not contain v, it must contain one of the adjacent vertices of v (otherwise, IG is not maximum, and v can be added to IG). Therefore, |VCG(v)| can be computed from the size of a maximum independent set I that contains v\u2032, one of the adjacent vertices of v.\nGiven a graph G and a vertex v\u2032 in it, a graph G\u2032 that extends G can be constructed in polynomial time in the size of G, in such a way that: there is a maximum independent set I of G containing v\u2032 iff v\u2032 belongs to every maximum independent set of G\u2032 iff the sizes of maximum independent sets for G and G\u2032 differ by one. Actually, graph G\u2032 can be obtained by adding a new vertex v\u2032\u2032 that is connected only to the neighbors of v\u2032. It holds:16\n|IG| = |IG\u2032 | \u2212 1, (19)\n|IG\u2032 | = |G \u2032| \u2212 |VCG\u2032 |, (20)\nwhere IG\u2032 is a maximum indent set in G \u2032, and VCG\u2032 is a minimum vertex cover of G\u2032. From (18), (19) and (20), we obtain: |VCG(v)| = |VCG\u2032 |.\nFrom Lemma 2 and the FPNP(log(n))-completeness of determining the size of a maximum clique in a graph [39], we obtain:\n16 This construction is inspired by [43, Lemma 1]. More details can be found in [44].\nProposition 12 The MVCMP problem for graphs is FPNP(log(n))-complete.\nProof We prove membership by describing an algorithm in FPNP(log(n)) for computing the size of the minimum vertex cover of a graph G = (V,E) that contains a vertex v \u2208 V. We use Lemma 2, and build the extended graph G\u2032.\nThe size of a minimum vertex cover for G\u2032 gives the size of the minimum vertex cover of G that contains v. Since computing the maximum cardinality of a clique can be done in time FPNP(log(n)) [39], computing a minimum vertex cover can be done in the same time (just consider the complement graph). Therefore, MVCMP belong to FPNP (log(n)).\nHardness can be obtained by a reduction from computing minimum vertex covers in graphs to MVCMP. Given a graph G construct the graph G\u2032 as follows: Add a vertex v to G and connect it to all vertices of G. It is easy to see that v belongs to all minimum vertex covers of G\u2032. Furthermore, the sizes of minimum vertex covers for G and G\u2032 differ by one. Consequently, the size of a minimum vertex cover of G can be obtained from the size of a minimum vertex cover of G\u2032 that contains v. Computing the minimum vertex cover is FPNP(log(n))-complete. This follows from the FPNP(log(n))-completeness of computing the maximum cardinality of a clique in a graph [39].\nTheorem 2 (a) For every BCQ, Q, computing the responsibility of a tuple\nas a cause for Q is in FPNP(log(n)). (b) There is a database schema and a BCQ Q, without built-ins, such that\ncomputing the responsibility of a tuple as a cause for Q is FPNP(log(n))complete.\nProof For membership, we observe from Remark 5 that computing a tuple\u2019s responsibility amounts to computing the size of a minimum vertex cover containing the tuple in the graph associated to the query and instance at hand. By Proposition 12, this problem belongs to FPNP(log(n)).\nHardness follows from Lemma 1 and the hardness result in Proposition 12.\nNow we address the most responsible causes problem, MRCDP (cf. Definition 6). We use the connection with consistent query answering of Section 4.3, namely Corollary 4, and the PNP (log(n))-completeness of consistent query answering under the C-repair semantics for queries that are conjunctions of ground atoms and a particular DC [43, Theorem 4].\nTheorem 3 (a) For every BCQ, MRCDP(Q) \u2208 PNP(log(n)). (b) There is a database schema and a BCQ Q, without built-ins, for which\nMRCDP(Q) is PNP(log(n))-complete.\nProof (a) To show that MRCDP(Q) belongs to PNP(log(n)), consider first the hitting-set framework Hn(D) = \u3008Dn,Sn(D)\u3009 (cf. Definition 3 and 6) and its associated hypergraph Gn(D) (cf. (17)).\nIt holds that t is a most responsible cause for Q iff Hn(D) has a C-minimal hitting-set that contains t (cf. Proposition 6). Therefore, t is a most responsible cause for Q iff t belongs to some minimum vertex cover of Gn(D).\nIt is easy to see that Gn(D) has a minimum vertex cover that contains t iff Gn(D) has a maximum independent set that does not contains t. Checking if t belongs to all maximum independent set of Gn(D) can be done in PNP(log(n)) [43, Lemma 2].\nIf t belongs to all independent sets of Gn(D), then (D, t) 6\u2208 MRCDP(Q); otherwise (D, t) \u2208 MRCDP(Q). As a consequence, the decision can be made in time PNP(log(n)).\n(b) The proof is by a reduction, via Corollary 4, from consistent query answering under the C-repair semantics for queries that are conjunctions of ground atoms, which was proved to be PNP(log(n))-complete in [43, Theorem 4]. Actually, that proof (of hardness) uses a particular database schema S and a DC \u03ba. In our case, we can use the same schema S and the violation query V \u03ba associated to \u03ba (cf. Section 4).\nFrom Proposition 6 and the FPNP(log(n))-completeness of determining the size of C-repairs for DCs [43, Theorem 3], we obtain the following for the computation of the highest responsibility value.\nProposition 13 (a) For every BCQ, computing the responsibility of the most\nresponsible causes is in FPNP(log(n)). (b) There is a database schema and a BCQ Q, without built-ins, for which\ncomputing the responsibility of the most responsible causes is FPNP(log(n))complete.\nProof (a) To show the membership of FPNP(log(n)), consider the hypergraph Gn(D) as obtained in Theorem 3. The responsibility of most responsible causes for Q can be obtained from the size of the minimum vertex cover of Gn(D) (cf. Proposition 6). The size of the minimum vertex cover in a graph can be computed in FPNP(log(n)), which is obtained from the membership of FPNP(log(n)) of computing the maximum cardinality of a clique in graph [39].\nIt is easy to verify that minimum vertex covers in hypergraphs can be computed in the same time.\n(b) This is by a reduction from the problem of determining the size of C-repairs for DCs shown to be FPNP(log(n))-complete in [43, Theorem 3]. Actually, that proof (of hardness) uses a particular database schema S and a DC \u03ba. In our case, we may consider the same schema S and the violation query V \u03ba associated to \u03ba (cf. Section 4).\nThe size of C-repairs for an inconsistent instance D of the schema S with respect to \u03ba can be obtained from the responsibility of most responsible causes for V \u03ba (cf. Corollary 2).\n6.1 FPT of responsibility\nWe need to cope with the intractability of computing most responsible causes. The area of fixed parameter tractability (FPT) [28] provides tools to attack this problem. In this regard, we recall that a decision problem with inputs of the form (I, p), where p is a distinguished parameter of the input, is fixed parameter tractable (or belongs to the class FPT), if it can be solved in time O(f(|p|) \u00b7 |I|c), where c and the hidden constant do not depend on |p| or |I|, and f does not depend on |I|.\nIn our case, the parameterized version of the decision problem RDP(Q) (cf. Definition 5) is denoted with RDPp(Q), and the distinguished parameter is k, such that v = 1\nk .\nThat RDPp(Q) belongs to FPT can be obtained from its formulation as a d-hitting-set problem (d being the fixed upper bound on the size of the sets in the set class). The latter problem consists in, given a hitting-set framework with d-bounded subsets and an element t (a tuple in our case), deciding if there is a hitting-set of cardinality smaller that k that contains t. This problem belongs to FPT.\nTheorem 4 For every BCQ Q, RDPp(Q) belongs to FPT, where the parameter is the inverse of the responsibility bound.\nProof First, there is a PTIME parameterized algorithm for the d-hitting-set problem about deciding if there is a hitting-set of size at most k that runs in time O(ek + n), with n the size of the underlying set and e = d \u2212 1 + o(d\u22121) [50]. In our case, n = |D|, and d = |Q| (cf. also [26]).\nNow, to decide if the responsibility of a given tuple t is greater than v = 1 k , we consider the associated hypergraph Gn(D), and we decide if it has a vertex cover that contains t and whose size is less than k. In order to answer this, we use Lemma 2, and build the extended hypergraph G\u2032.\nThe size of a minimum vertex cover for G\u2032 gives the size of the minimum vertex cover of Gn(D) that contains t. If Gn(D) has a vertex cover that contains t of size less than k, then G\u2032 has a vertex cover of size less than k. If G\u2032 has a vertex cover of size less than k, its minimum size for a vertex cover is less than k. Since this minimum is the same as the size of a minimum vertex cover for Gn(D) that contains t, Gn(D) has a vertex cover of size less than k that contains t. As a consequence, it is good enough to decide if G\u2032 has a vertex cover of size less than k. For this, we use the hitting-set formulation of this hypergraph problem, and the already mentioned FPT algorithm.\nThis result and the corresponding algorithm sketched in its proof show that the higher the required responsibility degree, the lower the computational effort needed to compute the actual causes with at least that level of responsibility. In other terms, parameterized algorithms are effective for computing actual causes with high responsibility or most responsible causes. In general, parameterized algorithms are very effective when the parameter is relatively small [28].\nNow, in order to compute most responsible causes, we could apply, for each actual cause t, the just presented FPT algorithm on the hypergraph Gn(D), starting with k = 1, i.e. asking if there is vertex cover of size less than 1 that contains t. If the algorithm returns a positive result, then t is a counterfactual cause, and has responsibility 1. Otherwise, the algorithm will be launched with k = 2, 3, . . . , |Dn|, until a positive result is returned. (The procedure can be improved through binary search on k = 1, 2, 3, . . . ,m, with m possibly much smaller than |D|.)\nThe complexity results and algorithms provided in this section can be extend to UBCQs. This is due to Remark 2 and the construction of Sn(D), which the results in this section build upon.\nFor the d-hitting-set problem there are also efficient parameterized approximation algorithms [11]. They could be used to approximate the responsibility problem. Furthermore, approximation algorithms developed for the minimum vertex cover problem on bounded hypergraphs [34,51] should be applicable to approximate most responsible causes for query answers. Via the causality/repair connection (cf. Section 4.3), it should be possible to develop approximation algorithms to compute S-repairs of particular sizes, C-repairs, and consistent query answers with respect to DCs.\n6.2 Complexity of diagnosis with positive disjunctive rules\nIt is known that consistency-based diagnosis decision problems can be unsolvable [53]. However, there are decidable classes of FO diagnosis specifications, and those classes are amenable to complexity analysis. However, there is little research on the complexity analysis of solvable classes of consistency-based diagnosis problems. The connection we established in the previous sections between causality, repairs and consistency-based diagnosis can be used to obtain new algorithmic and complexity results for the latter. Without trying to be exhaustive about this, which is beyond the scope of this paper, we give an example of the kind of results that can be obtained.\nConsidering the diagnosis problem we obtained in Section 5, we can define a class of diagnosis problems. Cf. Example 11, in particular (12), for motivation.\nDefinition 8 A disjunctive positive (DP) diagnosis specification \u03a3 is a consistent FO logical theory, such that:\n(a) \u03a3 has a signature (schema) consisting of a finite set of constants, a set of predicates S, a set Sab of predicates of the form AbR,17 with R \u2208 S, and AbR with the same arity of R. S and Sab are mutually disjoint. (b) \u03a3 is inconsistent with ABS := {\u2200x\u0304(AbR(x\u0304) \u2192 false) | R \u2208 S}. (c) Consists of: (c1) Sentences of the form \u2200x\u0304(C(x\u0304) \u2212\u2192 \u2228 iAbRi(x\u0304i)), with x\u0304i \u2286 x\u0304, and\nC(x\u0304) a conjunction of atoms that does not include Ab-atoms of any kind.\n17 Or any other \u201cabducible\u201d predicates that are different from those in S.\n(c2) Sentences of the forms \u2200x\u0304(AbR(x\u0304) \u2212\u2192 (R(x\u0304) \u2227 S(x\u0304))), with S \u2208 S. (c3) A finite background universal theory T expressed in terms of predicates\nin S (and constants) that has a unique Herbrand model.18\nAs above, a diagnosis is a set of AbR-atoms that, when assumed to be true, restores the consistency of the correspondingly modified \u03a3 \u222aABS .\nThere are at least two important computational tasks that emerge, namely, given a disjunctive positive (DP) diagnosis specification \u03a3 together with ABS :\n1. The minimum-cardinality diagnosis (MCD) problem, about computing minimum-cardinality diagnoses. 2. The minimal membership diagnosis, (MMD) about computing minimumcardinality diagnoses that contain a given Ab-atom.\nIt is not difficult to see that these problems are computable (or solvable in their decision versions). Now we can obtain complexity lower bounds for them. Actually, in Section 5, the responsibility and most responsible causes problem were reduced to diagnosis problems for specifications that turned out to be disjunctive positive (see (12)).\nMore specifically, Proposition 9 reduces computing responsibility of a tuple to computing the size of a minimum-cardinality diagnosis that contains the tuple. Furthermore, as a simple corollary of Proposition 9, we obtain the computation of minimum-cardinality diagnoses allows us to compute most responsible causes. Now, combining all this with Proposition 13 and Theorem 2, we obtain the following lower bounds for our diagnosis problems.\nTheorem 5 For disjunctive positive diagnosis specifications, the MCD and MMD problems are FPNP(log(n))-hard in the size of their underlying Herbrand structure."}, {"heading": "7 Preferred Causes for Query Answers", "text": "In Section 3 we characterized causes and most responsible causes in terms of S-repairs and C-repairs, resp. We could generalize the notion of a cause and/or its responsibility by using, in principle, any repair semantics S. The latter is represented by a class of repairs RepS(D,\u03a3), of D with respect to a set of denial constraints (cf. Section 2.2). When dealing with (sets of) DCs, the repair actions can only be of certain kinds. Usually tuple deletions have been considered. This is the case of the S- and C-repairs we have considered in this work so far.\nWe could go beyond and consider the notion of prioritized repair [59]. Also changes of attribute values can be the chosen repair actions, including the use of null values, to \u201cdestroy\u201d joins (again, with different semantics, e.g. with nulls a\u0300 la SQL [12,8]).\n18 This condition is clearly satisfied by the logical reconstruction of a relational database, but can be relaxed in several ways.\nIn this section we explore the possibility of introducing a notion of preferred cause that is based on a given repair semantics. This idea is inspired by (and generalizes) the characterization of causes in terms of repairs that we obtained before, namely (1), (2), Proposition 1, and Corollary 1.\nIf we define causes and their (minimal) contingency sets on the basis of a given repair semantics, the minimality condition involved in the latter will have an impact on the notion of minimal (or preferred) contingency set, and indirectly, on the notions of responsibility and most responsible cause.19\nIn Section 7.1 we summarize prioritized repairs. In Section 7.2 we impose preferences on causes on the basis of the prioritized repairs introduced in [59] (and further investigated in [25]). In Section 7.3, we briefly investigate the possibility of capturing endogenous repairs, i.e. that do not change exogenous tuples, by means of a priority relation. Finally, in Section 7.4, we briefly consider the possibility of defining (preferred) causes via attribute-based repairs that use null values.\n7.1 Prioritized repairs\nThe prioritized repairs in [59] are based on a priority relation, \u227b, on the set of database tuples. In the case of a pair of (mutually) conflicting tuples, i.e. that simultaneously violate a constraint in a given set set of DCs (possibly in company of other tuples), the repair process reflects the user preference -as captured by the priority relation- on the tuples that are privileged to be kept in the database, i.e. in the intended repairs.\nGiven such a priority relation, in [59] different classes of prioritized repairs are introduced, namely the class of globally optimal repairs, that of Paretooptimal repairs, and that of completion-optimal repairs. Intuitively, each class relies on a different optimality criterion that is used to extend the priority relation \u227b on pairs of conflicting facts to a priority relation on the set of Srepairs. As a consequence, each of these three classes is contained in that of the S-repairs. In particular, all these repairs are based on tuple deletions.\nLet us denote with Rep\u227b,X (D,\u03a3) the class of all prioritized repairs based on \u227b and the optimality criterion X . Its elements are called (\u227b,X)-prioritized repairs of D with respect to a the set \u03a3 of DCs. It holds Rep\u227b,X (D,\u03a3) \u2286 Srep(D,\u03a3), and then, all the elements of Rep\u227b,X (D,\u03a3) are subsets of D.\nIn order to show a concrete class Rep\u227b,X (D,\u03a3), we first recall the definitions of priority relation and global-optimal repair from [59].\n19 We could say that the efforts in [35,36] to modify the Halpern-Pearl (HP) original definition of causality are about considering more appropriate restrictions on contingencies. Since in some cases the original HP definition does not provide intuitive results regarding causality, the modifications avoid this by recognizing some contingencies as \u201cunreasonable\u201d or \u201cfarfetched\u201d.\nDefinition 9 Given an instance D and a set of denial constraints \u03a3 , a binary relation \u227b on D is a priority relation with respect to \u03a3 if: (a) \u227b is acyclic, and (b) for every t, t\u2032 \u2208 D, if t \u227b t\u2032, then t and t\u2032 are mutually conflicting.20\nDefinition 10 Let D be an instance, \u03a3 a set of DCs, and \u227b a corresponding priority relation. Let D\u2032 and D\u2032\u2032 be two consistent sub-instances of D. D\u2032 is a global improvement of D\u2032\u2032 if D\u2032 6= D\u2032\u2032, and for every tuple t\u2032 \u2208 D\u2032\u2032 rD\u2032, there exists a tuple t \u2208 D\u2032 rD\u2032\u2032 such that t \u227b t\u2032. D\u2032 is a global-optimal repair of D, if D\u2032 is an S-repair and does not have a global improvement.\nIn this definition, the optimality criterion, a possible X above, is that of globaloptimal repair, or (\u227b, go)-repair, which leads to a class Rep\u227b,go(D,\u03a3). We consider this repair semantics just for illustration purposes.\nExample 17 Consider the database schema Author(Name, Journal), Journal(JournalN , Topic,Paper#), and the following instance D:\nAuthor Name Journal John TKDE Tom TKDE John TODS\nJournal JournalN Paper# Topic TKDE 30 XML TKDE 31 CUBE TODS 32 XML\nConsider the following denial constraint:\n\u03ba : \u2200xyzz\u2032\u00ac(Author(x , y) \u2227 Journal(y, z , z \u2032) \u2227 x = John \u2227 z\u2032 = XML), (21)\ncapturing the condition that \u201cJohn has not published a paper in a journal that has published papers on XML\u201d.\nD is inconsistent with respect to \u03ba, and contains the following sets of conflicting tuples:\nC1 = {Author(John,TKDE ), Journal(TKDE , 30 ,XML)},\nC2 = {Author(John,TODS ), Journal(TODS , 32 ,XML)}.\nD has the following S-repairs, each obtained by deleting one tuple from each of C1 and C2, to resolve the conflicts:\nD1 = {Author(Tom,TKDE), Journal(TKDE , 31 ,CUBE),Author(John,TODS),\nJournal(TKDE , 30 ,XML)}\nD2 = {Author(Tom,TKDE), Journal(TKDE , 31 ,CUBE), Journal(TKDE , 30 ,XML),\nJournal(TODS , 32 ,XML)}\nD3 = {Author(Tom,TKDE), Journal(TKDE , 31 ,CUBE),Author(John,TKDE),\nJournal(TODS , 32 ,XML)}\nD4 = {Author(Tom,TKDE), Journal(TKDE , 31 ,CUBE),Author(John,TKDE),\nAuthor(John,TODS)}\n20 We can say {t, t\u2032} is a conflict, i.e. the two tuples jointly participate in the violation of one of the DCs in \u03a3.\n(a) Now, assume a user prefers to resolve a conflict by removing tuples from the Author table rather than the Journal table, maybe because he considers the latter more reliable than the former. This is expressed the following priority relationships on conflicting tuples: Journal(TKDE,30,XML) \u227b Author(John,TKDE) and Journal(TODS,32,XML) \u227b Author(John,TODS).\nIn this case only D2 is a global-optimal repair. Actually, D2 is a global improvement over each of D1, D3 and D4. For D1, for example: D2 r D1 = {Journal(TODS,32,XML} and D1rD2 = {Author(John, TODS)}. We can see that, for each tuple in D2rD1, there is a tuple in D1rD2 that has a higher priority. Therefore, D2 is a global improvement on D1. So, in this case Rep\n\u227b,go(D,\u03ba) = {D2}\nIn this case, the uniqueness of the global-optimal repair is quite natural as the preference relation among conflicting tuples is a total relation. So, we know how to resolve every conflict according to the user preferences.\n(b) For a more subtle situation, assume the user has the priorities as before, but in addition he tends to believe that John has a paper in TODS. In this case we have only the relationship Journal(TKDE,30,XML) \u227b\u2032 Author(John,TKDE), and no preference for resolving the second conflict. Now both D1 and D2 are global-optimal repairs. That is, now Rep\u227b \u2032,go(D,\u03ba) = {D1, D2}.\n7.2 Preferred causes from prioritized repairs\nAccording to the motivation provided at the beginning of this section, we now define preferred causes on the basis of a class of prioritized repairs. (Compare (22) below with (1) and (2).) To keep things simple, we concentrate on single BCQs, Q, whose associated denial constraints are denoted by \u03ba(Q).\nBefore providing technical details, we motivate the notion of preference in the context of causality. In this direction, first notice that under actual causality, we already make a difference -and only this difference- between endogenous and exogenous tuples. We can think of extending this priority relation among tuples in such a way that, for example, we prioritize -as causes- tuples in a given relation R, and we are not interested in tuples in another relation S. So, the user can specify a priority relation between the two relations, or different scores for these relations [46].\nIn Section 4.2 actual causes and their minimal contingency sets for a UBCQ were characterized as the minimal hitting-sets of the collection C of minimal subsets of a database that entail the query. Those minimal hitting-sets are obtained by removing at least one tuple from each of the elements of C (cf. Proposition 6). At this point, user preferences, or priorities, could be applied to tuples that belong to a same set C.\nDefinition 11 Given an instance D and a BCQ Q, tuples t and t\u2032 are jointlycontributing if t 6= t\u2032, and there exists an S-minimal \u039b \u2286 D such that \u039b |= Q and t, t\u2032 \u2208 \u039b.\nNow we define priority relations on jointly-contributing tuples.\nDefinition 12 Given an instance D and a BCQ Q, a binary relation \u227bc on D is a causal priority relation with respect to Q if: (a) \u227bc is acyclic, and (b) for every t, t\u2032 \u2208 D, if t \u227bc t\u2032, then t and t\u2032 are jointly-contributing tuples.\nThis definition introduces a natural notion of preference on causality. Actually, this way of approaching priorities on causes is in (inverse) correspondence with preference on repairs as based on priority relations on conflicting tuples. To see this, first observe that for a given instance D and BCQ Q: t and t\u2032 are jointly-contributing tuples for Q iff t and t\u2032 are mutually conflicting tuples for \u03ba(Q).\nNext, in the context of prioritized repairs, a priority relation reflects a user preference on tuples that are preferred to be kept in the database. This is the inverse of causality, where a causal priority relation, as we defined it, reflects the tuples that are preferred to be (hypothetically or counterfactually) removed from database, to make them preferred causes.\nIn the following assume \u227brc is the inverse of a causal priority relation \u227bc. That is, t \u227brc t\n\u2032 iff t\u2032 \u227bc t. Clearly, \u227brc is acyclic, and can be imposed, with the expected result, on pairs of conflicting tuples. As a consequence, \u227brc can be used to define prioritized repairs.\nDefinition 13 Let D be an instance, Q a BCQ, t a tuple in D, \u227bc a causal priority relation on D\u2019s tuples.\n(a) Diff \u227b r c ,X(D,\u03ba(Q), t) := {D rD\u2032 | D\u2032 \u2208 Rep\u227b r c ,X(D,\u03ba(Q)), and\nt \u2208 D rD\u2032}. (22)\n(b) t \u2208 D is a (\u227bc,X)-preferred cause for Q iff Diff \u227br c ,X(D,\u03ba(Q), t) 6= \u2205.\nNotice that every (\u227bc,X)-preferred cause is also an actual cause. This follows from Proposition 1 and the fact that prioritized repairs are also S-repairs.\nSimilarly to Proposition 2, for each \u039b \u2208 Diff \u227b r c ,X(D,\u03ba(Q), t), it holds that t \u2208 \u039b, t is a (\u227bc,X)-preferred cause, and also an actual cause for Q with S-minimal contingency set \u039b r {t}. In particular, t\u2019s responsibility can be defined and computed as before, but now restricting its contingency sets to those of the form \u039br {t}, with \u039b \u2208 Diff \u227b r c ,X(D,\u03ba(Q), t). In this way, a causal priority relation may affect the responsibility of a cause (with respect to the non-prioritized case).\nExample 18 (example 17 cont.) The following BCQ query Q is true in D:\n\u2203JournalN \u2203Paper#(Author(John, Journal) \u2227\nJournal(JournalN ,Paper#,XML));\nand its associated DC \u03ba(Q) is \u03ba in (21). We want to obtain the preferred causes for Q being, possibly unexpectedly, true inD, with the following preferences: (a) We prefer those among the Author tuples. (b) It is likely that John does have a paper in TODS. So, we prefer Author(John, TODS) not to be the cause.\nThese causal priorities are in inverse correspondence with those in the second case of Example 17(b) about priorities for repairs. That is, for our causal priority relation \u227bc here, its inverse \u227brc is \u227b \u2032 in Example 17(b). There we had Rep\u227b \u2032,go(D,\u03ba(Q)) = {D1, D2}, which we can use to apply Definition 13. We obtain as the globally-optimal causes, i.e. as (\u227bc, go)-causes: Author(John, TKDE), Author(TODS,32,XML) and Author(John,TODS), all with the same responsibility, 12 .\nNotice that Definition 13 can be easily extended to UBCQs. This is done, as earlier in this work, by considering the set \u03a3 of denial constraints associated to a UBCQ. In the other direction, we recall that if we start with a set of DCs \u03a3, the corresponding UBCQ is denoted with V\u03a3 .\nAs we did in the previous sections of this work, we could take advantage of algorithmic and complexity results about prioritized repairs [59,25], to obtain complexity results for preferred causes problems. As an example, we establish the complexity of the minimal contingency set decision problem for (\u227bc, go)preferred causes. More precisely, for an instance D and a UBCQ Q, the minimal preference-contingency set (decision) problem is about deciding if a set of tuples \u0393 is an S-minimal contingency set associated to a (\u227bc, go)-preferred cause t. Notation: Cont\u227bc,X(D,Q, t) := {\u039b r {t} | \u039b \u2208 Diff \u227b r c ,X(D,\u03ba(Q), t)} is the\nclass of all S-minimal contingency sets for a (\u227bc,X)-preferred cause t.\nDefinition 14 For a UBCQ Q, the minimal preference-contingency set decision problem is about membership of:\nMPCDP(Q) := {(D,\u227bc, t, \u0393 ) | t \u2208 D,\u0393 \u2286 D, and \u0393 \u2208 Cont \u227bc,go(D,Q, t)}.\nFrom Definition 13, there is a close connection between MPCDP and the global-optimal repair checking problem, i.e. about deciding if an instance D\u2032 is a (\u227b, go)-repair of D with respect to a set of denial constraints. If we accept functional dependencies (FDs) among our denial constraints (and then, UBCQs that involve inequalities), the following result can be obtained from the NP-completeness of globally-optimal repair checking [59] for FDs.\nProposition 14 For a UBCQ Q with inequalities, MPCDP(Q) is NP-hard.\nProof It is good enough to reduce globally-optimal repair checking to our contingency checking problem. So, consider an inconsistent instance D with respect to a set of denial constraint \u03a3, a priority relation for repairs \u227b, and D\u2032 \u2286 D. To check if D\u2032 \u2208 Rep\u227b,go(D,\u03a3) we can check, for an arbitrary element t \u2208 D rD\u2032, if (D,\u227br, t,D r (D\u2032 \u222a {t}) \u2208 MPCDP(V\u03a3).\nIt is worth contrasting this result with the tractability result in Proposition 11 for the minimal contingency set decision problem (MCSDP) for actual causes. Notice that Proposition 11 still holds for UBCQs with inequality.\nNotice that we could generalize the notion of preferred cause by appealing to any notion of repair. More precisely, if we have a repair semantics rSem (based on tuple deletions for DCs), we could replace Rep\u227b,X(D,\u03ba(Q)) in (22) by RepS(D,\u03ba(Q)). However, to obtain the intended results for causes, we have to be careful, as above, about a possible inverse relationship between preference on repairs and preference on causes.\n7.3 Endogenous repairs\nThe partition of a database into endogenous and exogenous tuples that is used in the causality setting may also be of interest in the context of repairs. Considering that we should have more control on endogenous tuples than on exogenous ones, which may come from external sources, it makes sense to consider endogenous repairs, which would be obtained by updates (of any kind) on endogenous tuples only. (Of course, a symmetric treatment of \u201cexogenous\u201d repairs is also possible; what is relevant here is the partition.)\nFor example, in the case of DCs, endogenous repairs would be obtained by deleting endogenous tuples only. More formally, given D = Dn \u222aDx, possibly inconsistent with a set of DCs \u03a3, an endogenous repair D\u2032 of D is a maximally consistent sub-instance of D with D rD\u2032 \u2286 Dn, i.e. D\u2032 keeps all the exogenous tuples of D. If endogenous repairs form the class Srepn(D,\u03a3), it holds Srepn(D,\u03a3) \u2286 Srep(D,\u03a3).\nExample 19 Consider D = Dn \u222aDx, with Dn = {R(a2, a1), R(a4, a3), S(a3), S(a4)} and Dx = {R(a3, a3), S(a2)}, and the DC \u03ba : \u00ac\u2203xy(S(x) \u2227 R(x, y) \u2227 S(y)).\nHere, Srep(D,\u03ba) = {D1, D2, D3}, withD1 = {R(a2, a1), R(a4, a3), R(a3, a3), S(a4), S(a2)}, D2 = {R(a2, a1), S(a3), S(a4), S(a2)}, and D3 = {R(a2, a1), R(a4, a3), S(a3), S(a2)}. The only endogenous S-repair is D1.\nIn this section, without trying to be exhaustive or detailed, we consider the possibility of defining endogenous repairs on the basis of a suitable priority relation \u227b on tuples,21 while at the same time taking advantage of the op optimality condition considered in Section 7.1.22\nFirst, if we assume that relation \u227b\u2032, the extension of \u227b, is such, that t \u227b\u2032 t\u2032 when t \u2208 Dx and t\u2032 \u2208 Dn (\u227b\u2032 is \u227b if the latter already has this property), then it is easy to verify that every endogenous S-repair globally improves any non-endogenous S-repair. As a consequence, if there is an endogenous Srepair, then all the (\u227b\u2032, go)-repairs are endogenous. Notice that the extension \u227b\u2032 may destroy the acyclicity assumption on the priority relation, because we are starting from a given (acyclic) relation \u227b, which we are now extending.\n21 Pairs of conflicting tuples would inherit the priority relationships from the general priority relation. 22 Of course, we could use other optimality criteria at this points, but considering all possibilities is beyond the scope of this work.\nIt might be the case that there is no endogenous S-repair, in which case non-endogenous S-repairs would not the improved by an endogenous one. So, if we want to prevent the existence of non-endogenous repairs, we can add an extra, dummy predicate D(\u00b7) to the schema, and the endogenous tuple D(d) to D. We modify every DC in \u03a3, say \u03ba : \u2190 C(x\u0304), by adding an extra, dummy condition: \u03bad : \u2190 D(d), C(x\u0304), obtaining a set \u03a3d of DCs. In this case, the S-repairs will be: Dd := Dr {D(d)}, which is endogenous, and also all those S-repairs of D with respect to \u03a3 (now each including D(d)). The latter are all non-endogenous. If we assume that t \u227b\u2032 D(d), for every t \u2208 Dx, then every non-endogenous S-repair will be improved by Dd, and will not be considered.\n7.4 Null-based causes\nConsider an instance D = {R(c1, . . . , cn), . . .} that may be inconsistent with respect to a set of DCs. The allowed repair updates are changes of attribute values by the constant null. We assume that null does not join with any other value, including null itself.\nIn order to keep track of changes, we may introduce numbers as first arguments in tuples, as global tuple identifiers (ids). So, D becomes D = {R(1; c1, . . . , cn), . . .}. Assume that id(t) returns the id of the tuple t \u2208 D. For example, id(R(1; c1, . . . , cn)) = 1.\nIf, by updating D into D\u2032 in this way, the value of the ith attribute in R is changed to null, then the change is captured as the string R[1; i]. These strings are collected forming the set Diff null (D,D\u2032). For example, if D = {R(1; a, b), S(2; c, d), S(3; e, f)} is changed intoD\u2032 = {R(1; a, null), S(2; null , d), S(3; null , null)}, we have Diff null (D,D\u2032) = {R[1; 2], S[2; 1], S[3; 1], S[3; 2]}.\nA null-repair of D with respect to a set of DCs \u03a3 is a consistent instance D\u2032, such that Diff null (D,D\u2032) is minimal under set inclusion.23 Repnull (D,\u03a3) denotes the class of null-based repairs of D with respect to \u03a3.\nExample 20 (example 19 cont.) Consider the following inconsistent instance with respect to DC \u03ba : \u00ac\u2203xy(S(x) \u2227R(x, y) \u2227 S(y)):\nD = {R(1; a2, a1), R(2; a3, a3), R(3; a4, a3), S(4; a2), S(5; a3), S(6; a4)}. For simplicity, we do not make any difference between endogenous and exogenous tuples. Here, the class of null-based repairs, Repnull (D,\u03ba), is formed by:\nD1 = {R(1; a2, a1), R(2; a3, a3), R(3; a4, a3), S(4; a2), S(5; null), S(6; a4)}, D2 = {R(1; a2, a1), R(2; null , a3), R(3; a4, null), S(4; a2), S(5; a3), S(6; a4)}, D3 = {R(1; a2, a1), R(2; null , a3), R(3; a4, a3), S(4; a2), S(5; a3), S(6; null)}, D4 = {R(1; a2, a1), R(2; a3, null), R(3; a4, null), S(4; a2), S(5; a3), S(6; a4)}, D5 = {R(1; a2, a1), R(2; a3, null), R(3; null , a3), S(4; a2), S(5; a3), S(6; a4)}, D6 = {R(1; a2, a1), R(2; a3, null), R(3; a4, a3), S(4; a2), S(5; a3), S(6; null)}. Here, Diff null (D,D2) = {R[2; 1], R[3; 2]}, and Diff null (D,D3) = {R[2; 1], S[6; 1]}.\n23 An alternative, but equivalent formulation can be found in [8].\nAccording to the motivation provided at the beginning of this section, we can now define causes appealing to the class of null-based repairs of D. Since repair actions in this case, are attribute-value changes, causes can be defined at both the tuple and attribute levels. The same applies to the definition of responsibility (in this case generalizing Proposition 2).\nDefinition 15 For D an instance and Q a BCQ, and t \u2208 D be a tuple of the form R(i; c1, . . . , cn).\n(a) R[i; cj] is a null-based attribute-value cause forQ if there isD\u2032 \u2208 Rep null (D,\n\u03ba(Q)) with R[i; j] \u2208 Diff null (D,D\u2032). (That is, the value cj for attribute Aj in the tuple is a cause if it is changed into a null in some repair.) (b) t is a null-based tuple cause for Q if some R[i; cj] is a null-based attributevalue cause for Q. (That is, the whole tuple is a cause if at least one of its attribute values is changed into a null in some repair.) (c) The responsibility, \u03c1t-null(t), of t, a null-based tuple cause for Q, is the inverse of min{|Diff null (D,D\u2032)| : R[i; j] \u2208 Diff null (D,D\u2032), for some j, and D\u2032 \u2208 Repnull (D,\u03ba(Q))}. (d) The responsibility, \u03c1a-null(R[i; cj]), of R[i; cj], a null-based attribute-value\ncause for Q, is the inverse of min{|Diff null (D,D\u2032)| : R[i; j] \u2208 Diff null (D, D\u2032), and D\u2032 \u2208 Repnull (D,\u03ba(Q))}.\nIn cases (c) and (d) we minimize over the number of changes in a repair that are made together with that of the candidate tuple/attribute-value to be a cause. In the case of a tuple cause, any change made in one of its attributes is considered in the minimization. For this reason, the minimum may be smaller than the one for a fixed attribute value change; and so the responsibility at the tuple level may be greater than that at the attribute level. More precisely, if t = R(i; c1, . . . , cn) \u2208 D, and R[i; cj]) is a null-based attribute-value cause, then it holds \u03c1a-null(R[i; cj]) \u2264 \u03c1t-null(t).\nExample 21 (ex. 20 cont.) Consider R(2; a3, a3) \u2208 D. Its projection on its first (non-id) attribute, R[2; a3], is an attribute-level cause since R[2; 1] \u2208 Diff null (D,D2). Also R[2; 1] \u2208 Diff null (D,D3).\nSince |Diff null (D,D2)| = |Diff null (D,D3)| = 2, it holds \u03c1a-null(R[2; 1]) =\n1 2 .\nClearly R(2; a3, a3) is a null-based tuple cause for Q, with \u03c1t-null(t) = 1 2 .\nNotice that the definition of tuple-level responsibility, i.e. case (c) in Definition 15, does not take into account that a same id, i, may appear several times in a Diff null (D,D\u2032). In order to do so, we could redefine the size of the latter by taking into account those multiplicities. For example, if we decrease the size of the Diff by one with every repetition of the id, the responsibility for a cause may (only) increase, which makes sense."}, {"heading": "8 Discussion and Conclusions", "text": "Our work opens interesting research directions, some of which are briefly discussed below. They are matter of ongoing and future research.\n8.1 Endogenous repairs\nAs discussed in Section 7, the partition of a database into endogenous and exogenous tuples may also be of interest in the context of repairs. We may prefer endogenous repairs that change (delete in this case) only endogenous tuples. However, if there are no endogenous tuples, a preference condition could be imposed on repairs, keeping those that change exogenous tuples the least. This is something to explore.\nAs a further extension, it could be possible to assume that combinations of (only) exogenous tuples never violate the integrity constraints, which could be checked at upload time. In this sense, there would be a part of the database that is considered to be consistent, while the other is subject to possible repairs. For somehow related research, see [31].\nGoing a bit further, we could even consider the relations in the database with an extra, binary attribute, N , that is used to annotate if a tuple is endogenous or exogenous (it could be both), e.g. a tuple like R(a, b, yes). integrity constraints could be annotated too, e.g. the \u201cexogenous\u201d version of DC \u03ba, could be \u03baE : \u2190 P (x, y, yes), R(y, z, yes), and could be assumed to be satisfied.\n8.2 Objections to causality\nCausality as introduced by Halpern and Pearl in [32,33], aka. HP-causality, is the basis for the notion of causality in [47]. HP-causality has been the object of some criticism [35], which is justified in some (more complex, non-relational) settings, specially due to the presence of different kinds of logical variables (or lack thereof). In our context the objections do not apply: variables just say that a certain tuple belongs to the instance (or not); and for relational databases the closed-world assumption applies. In [35,36], the definition of HP-causality is slightly modified. In our setting, this modified definition does not change actual causes or their properties.\n8.3 Open queries\nWe have limited our discussion to boolean queries. It is possible to extend our work to consider conjunctive queries with free variables, e.g. Q(x) : \u2203yz(R(x, y) \u2227 S(y, z)). In this case, a query answer would be of the form \u3008a\u3009, for a a constant, and causes would be found for such an answer. In this case,\nthe associated DC would be of the form \u03ba\u3008a\u3009 : \u2190 R(a, y), S(y, z), and the rest would be basically as above.\n8.4 ASP specification of causes\nS-repairs can be specified by means of answer set programs (ASPs) [3,6], and C-repairs too, with the use of weak program constraints [3]. This should allow for the introduction of ASPs in the context of causality, for specification and reasoning. There are also ASP-based specifications of diagnosis [24] that could be brought into a more complete picture.\n8.5 Causes and functional dependencies, and beyond\nFunctional dependencies are DCs with conjunctive violation views with inequality, and are still monotonic. There is much research on repairs and consistent query answering for functional dependencies, and more complex integrity constraints [9]. In causality, mostly CQs without built-ins have been considered. The repair connection could be exploited to obtain more refined results for causality and CQs with inequality, and also other classes of queries, even non-monotonic ones, that correspond violation views for other kinds of integrity constraints. In a different, but related direction, causality for monotonic queries in the presence of integrity constraints has been investigated in [56].\n8.6 View updates and abduction\nAbduction [20,23] is another form of model-based diagnosis, and is related to the subjects investigated in this work. The view update problem, about updating a database through views, is a classical problem in databases that has been treated through abduction [37,21]. User knowledge imposed through view updates creates or reflects uncertainty about the base data, because alternative base instances may give an account of the intended view updates. The view update problem, specially in its particular form of deletion propagation, has been recently related in [41,42] to causality as introduced in [47]. (Notice only tuple deletions are used with violation views and repairs associated to DCs.)\nDatabase repairs are also related to the view update problem. Actually, answer set programs (ASP) for database repairs [6] implicity repair the database by updating intentional, annotated predicates (cf. Section 8.4). Even more, in [8], in order to protect sensitive information, databases are explicitly and virtually \u201crepaired\u201d through secrecy views that specify the information that has to be kept secret. These are prioritized repairs that have been specified via ASPs. Abduction has been explicitly applied to database repairs [5].\nThe deep interrelations between causality, abductive reasoning, view updates and repairs are the objects of our ongoing research efforts [10,57].\nTo conclude, let us emphasize that in this research we have unveiled and formalized some first interesting relationships between causality in databases, database repairs, and consistency-based diagnosis. These connections allow us to apply results and techniques developed for each of them to the others. This is particularly beneficial for causality in databases, where still a limited number of results and techniques have been obtained or developed.\nThe connections we established here inspired complexity results for causality, e.g. Theorems 2 and 3, and were used to prove them. We appealed to several non-trivial results found in [43] (and the proofs thereof found in [44]) about repairs and CQA. It is also the case that the well-established hitting-set approach to diagnosis inspired a similar approach to causal responsibility, which in its turn allowed us to obtain results about its fixed-parameter tractability. It is also the case that diagnostic reasoning, as a form of non-monotonic reasoning, can provide a solid foundation for causality in databases and query answer explanation, in general [16,17].\nIn ongoing research we have established connections between query answer causality, abductive diagnosis and database updates through views [57]. It is interesting that several of these areas of data management and knowledge representation, including those considered in this work, fall under what has been called \u201creverse data management\u201d tasks [45]. Our work establishes formal connections between them and sets the ground for further investigation into their interrelationships.\nAcknowledgments: Research funded by NSERC Discovery, and the NSERC Strategic Network on Business Intelligence (BIN). Conversations with Alexandra Meliou during Leo Bertossi\u2019s visit to U. of Washington in 2011 are much appreciated. He is also grateful to Dan Suciu and Wolfgang Gatterbauer for their hospitality. L. Bertossi is grateful to Benny Kimelfeld for stimulating conversations. Part of the research was developed by L. Bertossi during partial sabbatical stays at LogicBlox and The Center for Semantic Web Research (Chile). Their support is much appreciated. We appreciate the comments from the anonymous reviewers."}], "references": [{"title": "Repair Checking in Inconsistent Databases: Algorithms and Complexity", "author": ["F. Afrati", "P. Kolaitis"], "venue": "Proc. ICDT", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Consistent Query Answers in Inconsistent Databases", "author": ["M. Arenas", "L. Bertossi", "J. Chomicki"], "venue": "Proc. ACM PODS,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1999}, {"title": "Answer Sets for Consistent Query Answers", "author": ["M. Arenas", "L. Bertossi", "J. Chomicki"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "Scalar Aggregation in Inconsistent Databases", "author": ["M. Arenas", "L. Bertossi", "J. Chomicki", "X. He", "V. Raghavan", "J. Spinrad"], "venue": "Theoretical Computer Science,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "Coherent Integration of Databases by Abductive Logic Programming", "author": ["O. Arieli", "M. Denecker", "B. Van Nuffelen", "M. Bruynooghe"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2004}, {"title": "Characterizing and Computing Semantically Correct Answers from Databases with Annotated Logic and Answer Sets", "author": ["P. Barcelo", "L. Bertossi", "L. Bravo"], "venue": "In Semantics of Databases, Springer LNCS", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "Consistent Query Answering in Databases", "author": ["L. Bertossi"], "venue": "ACM SIGMOD Record,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2006}, {"title": "Achieving Data Privacy through Secrecy Views and NullBased Virtual Updates", "author": ["L. Bertossi", "L. Li"], "venue": "IEEE Transaction on Knowledge and Data Engineering,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Database Repairing and Consistent Query Answering", "author": ["L. Bertossi"], "venue": "Morgan & Claypool, Synthesis Lectures on Data Management,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Unifying Causality, Diagnosis, Repairs and View-Updates in Databases. Presented at the First International Workshop on Big Uncertain Data (BUDA", "author": ["L. Bertossi", "B. Salimi"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2014}, {"title": "Parameterized Approximation Algorithms for Hitting Set", "author": ["L. Brankovic", "H.H. Fernau"], "venue": "In Approximation and Online Algorithms,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Semantically Correct Query Answers in the Presence of Null Values", "author": ["L. Bravo", "L. Bertossi"], "venue": "Proc. EDBT WS on Inconsistency and Incompleteness in Databases (IIDB 06), J. Chomicki and J. Wijsen (eds.), Springer LNCS", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2006}, {"title": "Why and Where: A Characterization of Data Provenance", "author": ["P. Buneman", "S. Khanna", "W.C. Tan"], "venue": "Proc. ICDT,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2001}, {"title": "Provenance in Databases", "author": ["P. Buneman", "W.C. Tan"], "venue": "Proc. ACM SIGMOD,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2007}, {"title": "Provenance in Databases: Why, How, And Where", "author": ["J. Cheney", "L. Chiticariu", "W.C. Tan"], "venue": "Foundations and Trends in Databases,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2009}, {"title": "Provenance: A Future History", "author": ["J. Cheney", "S. Chong", "N. Foster", "M.I. Seltzer", "S. Vansummeren"], "venue": "OOPSLA Companion (Onward!),", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Is Provenance Logical", "author": ["J. Cheney"], "venue": "Proc. LID,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2011}, {"title": "Minimal-Change Integrity Maintenance Using Tuple Deletions", "author": ["J. Chomicki", "J. Marcinkowski"], "venue": "Information and Computation,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2005}, {"title": "Responsibility and Blame: A Structural-Model Approach", "author": ["H. Chockler", "J.Y. Halpern"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2004}, {"title": "A Spectrum of Logical Definitions of Model-Based Diagnosis", "author": ["L. Console", "P. Torasso"], "venue": "Computational Intelligence,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1991}, {"title": "The Role of Abduction in Database View Updating", "author": ["L. Console", "Sapino M. L", "D. Theseider-Dupre"], "venue": "J. Intell. Inf. Syst.,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1995}, {"title": "Tracing the Lineage of View Data in aWarehousing Environment", "author": ["Y. Cui", "J. Widom", "J.L. Wiener"], "venue": "ACM Trans. Database Syst.,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2000}, {"title": "Abduction from Logic Programs: Semantics and Complexity", "author": ["T. Eiter", "G. Gottlob", "N. Leone"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1997}, {"title": "The Diagnosis Frontend of the DLV System", "author": ["Eiter", "Th", "W. Faber", "N. Leone", "G. Pfeifer"], "venue": "AI Commun.,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1999}, {"title": "Dichotomies in the Complexity of Preferred Repairs", "author": ["R Fagin", "B. Kimelfeld", "Kolaitis", "Ph"], "venue": "Proc. ACM PODS,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2015}, {"title": "Parameterized Algorithmics for d-Hitting Set", "author": ["H. Fernau"], "venue": "Int. J. Comput. Math.,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2010}, {"title": "Approximate model-based diagnosis using greedy stochastic search", "author": ["Feldman A", "G. Provan", "A.V. Gemund"], "venue": "Journal of Artificial Intelligence Research (JAIR),", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2010}, {"title": "Parameterized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Texts in Theoretical Computer Science,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}, {"title": "Computers and Intractability: A Guide to the Theory of NP-Completenes", "author": ["M. Garey", "D.S. Johnson"], "venue": null, "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1979}, {"title": "Diagnosis and Repair of Constraint Violations in Database Systems", "author": ["M. Gertz"], "venue": "PhD Thesis, Universita\u0308t Hannover,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1996}, {"title": "Causes and Explanations: A Structural-Model Approach: Part 1", "author": ["J. Halpern", "J. Pearl"], "venue": "Proc. UAI,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2001}, {"title": "Causes and Explanations: A Structural-Model Approach: Part 1", "author": ["J. Halpern", "J. Pearl"], "venue": "British J. Philosophy of Science,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2005}, {"title": "Improved Approximation Algorithms for the Vertex Cover Problem in Graphs and Hyper-Graphs", "author": ["E. Halperin"], "venue": "Proc. ACM-SIAM Symposium on Discrete Algorithms,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2000}, {"title": "Appropriate Causal Models and Stability of Causation", "author": ["J. Halpern"], "venue": "Proc. KR\u201914,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2014}, {"title": "A Modification of Halpern-Pearl Definition of Causality", "author": ["J. Halpern"], "venue": "Proc. IJCAI,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2015}, {"title": "Database Updates through Abduction", "author": ["Kakas A. C", "P. Mancarella"], "venue": "Proc. VLDB,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1990}, {"title": "Semiring-Annotated Data: Queries and Provenance", "author": ["G. Karvounarakis", "T.J. Green"], "venue": "SIGMOD Record,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2012}, {"title": "The Complexity of Optimization Problems", "author": ["M. Krentel"], "venue": "J. Computer and Systems,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 1988}, {"title": "Querying Data Provenance", "author": ["Karvounarakis", "Z.G.G. Ives", "V. Tannen"], "venue": "Proc. ACM SIGMOD,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2010}, {"title": "A Dichotomy in the Complexity of Deletion Propagation with Functional Dependencies", "author": ["B. Kimelfeld"], "venue": "Proc. ACM PODS,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2012}, {"title": "Maximizing Conjunctive Views in Deletion Propagation", "author": ["B. Kimelfeld", "J. Vondrak", "R. Williams"], "venue": "ACM Trans. Database Syst.,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2012}, {"title": "Complexity of Consistent Query Answering in Databases under Cardinality-Based and Incremental Repair Semantics", "author": ["A. Lopatenko", "L. Bertossi"], "venue": "Proc. ICDT,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2007}, {"title": "Bringing Provenance to its Full Potential Using Causal Reasoning", "author": ["A. Meliou", "W. Gatterbauer", "D. Suciu"], "venue": "Proc. TaPP,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2011}, {"title": "The Complexity of Causality and Responsibility for Query Answers and Non-Answers", "author": ["A. Meliou", "Gatterbauer", "K.F.W. Moore", "D. Suciu"], "venue": "Proc. VLDB,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2010}, {"title": "Causality in Databases", "author": ["A. Meliou", "Gatterbauer. W", "J.Y. Halpern", "C. Koch", "Moore K. F", "D. Suciu"], "venue": "IEEE Data Eng. Bull,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2010}, {"title": "Controlling the Complexity in Model-Based Diagnosis", "author": ["I Mozetic", "C. Holzbaur"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 1994}, {"title": "An efficient fixed-parameter algorithm for 3-hitting set", "author": ["R. Niedermeier", "P. Rossmanith"], "venue": "In J. Discrete Algorithms,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2003}, {"title": "On Approximation of the Vertex Cover Problem in Hypergraphs", "author": ["M. Okun"], "venue": "In Discrete Optimization,", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2005}, {"title": "A Theory of Diagnosis from First Principles", "author": ["R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 1987}, {"title": "Towards a Logical Reconstruction of Relational Database Theory", "author": ["R. Reiter"], "venue": "In On Conceptual Modelling,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 1984}, {"title": "The Diagnosis and Repair Connections", "author": ["B. Salimi", "Bertossi", "L. Causality in Databases"], "venue": "Presented at The 15th International Workshop on Non-Monotonic Reasoning", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2014}, {"title": "Causes for Query Answers from Databases, Datalog Abduction and View-Updates: The Presence of Integrity Constraints", "author": ["B. Salimi", "L. Bertossi"], "venue": "Proc. FLAIRS,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2016}, {"title": "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates", "author": ["B. Salimi", "L. Bertossi"], "venue": "In Proc. UAI Causal Inference Workshop,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2015}, {"title": "From Causes for Database Queries to Repairs and ModelBased Diagnosis and Back", "author": ["B. Salimi", "L. Bertossi"], "venue": "In Proc. 18th International Conference on Database Theory (ICDT", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2015}, {"title": "Prioritized Repairing and Consistent Query Answering in Relational Databases", "author": ["S. Staworko", "J. Chomicki", "J. Marcinkowski"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2012}, {"title": "Model-based Problem Solving", "author": ["P. Struss"], "venue": "In Handbook of Knowledge Representation, chap. 10. Elsevier,", "citeRegEx": "60", "shortCiteRegEx": "60", "year": 2008}, {"title": "Provenance Propagation in Complex Queries", "author": ["V. Tannen"], "venue": "In Buneman Festschrift,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2013}], "referenceMentions": [{"referenceID": 43, "context": "the notion of explanation for a query result was introduced in [47], on the basis of the deeper concept of actual causation.", "startOffset": 63, "endOffset": 67}, {"referenceID": 44, "context": "In applications involving large data sets, it is crucial to rank potential causes by their responsibilities [48,47], which reflect the relative (quantitative) degrees of their causality for a query result.", "startOffset": 108, "endOffset": 115}, {"referenceID": 43, "context": "In applications involving large data sets, it is crucial to rank potential causes by their responsibilities [48,47], which reflect the relative (quantitative) degrees of their causality for a query result.", "startOffset": 108, "endOffset": 115}, {"referenceID": 43, "context": "Actual causation, as used in [47], can be traced back to [32,33], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 29, "endOffset": 33}, {"referenceID": 30, "context": "Actual causation, as used in [47], can be traced back to [32,33], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 57, "endOffset": 64}, {"referenceID": 31, "context": "Actual causation, as used in [47], can be traced back to [32,33], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 57, "endOffset": 64}, {"referenceID": 18, "context": "Causal responsibility was introduced in [19], to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.", "startOffset": 40, "endOffset": 44}, {"referenceID": 12, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 13, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 14, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 21, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 38, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 36, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 56, "context": "Apart from the explicit use of causality, research on explanations for query results has focused mainly, and rather implicitly, on provenance [13,14,15, 22,40,38,61].", "startOffset": 142, "endOffset": 165}, {"referenceID": 43, "context": "A close connection between causality and provenance has been established in [47].", "startOffset": 76, "endOffset": 80}, {"referenceID": 44, "context": "However, causality is a more refined notion that identifies causes for query results on the basis of user-defined criteria, and ranks causes according to their responsibilities [48].", "startOffset": 177, "endOffset": 181}, {"referenceID": 48, "context": "Consistency-based diagnosis [53], a form of model-based diagnosis [60, sec.", "startOffset": 28, "endOffset": 32}, {"referenceID": 1, "context": "These notions were introduced in [2] (see [7,9] for surveys).", "startOffset": 33, "endOffset": 36}, {"referenceID": 6, "context": "These notions were introduced in [2] (see [7,9] for surveys).", "startOffset": 42, "endOffset": 47}, {"referenceID": 8, "context": "These notions were introduced in [2] (see [7,9] for surveys).", "startOffset": 42, "endOffset": 47}, {"referenceID": 50, "context": "These three forms of reasoning, namely inferring causes from databases, consistency-based diagnosis, and consistent query answering (and repairs) are all non-monotonic [55].", "startOffset": 168, "endOffset": 172}, {"referenceID": 49, "context": "Actually, a causality-based explanation for a conjunctive query answer can be viewed as a diagnosis, where in essence the first-order logical reconstruction of the relational database provides the system description [54], and the observation is the query answer.", "startOffset": 216, "endOffset": 220}, {"referenceID": 8, "context": "Being the causality problems the main focus of this work, we take advantage of algorithms and complexity results both for consistency-based diagnosis on one side; and database repairs and consistent query answering [9], on another.", "startOffset": 215, "endOffset": 218}, {"referenceID": 29, "context": "2 Although not in the context of repairs, consistency-based diagnosis has been applied to consistency restoration of a database with respect to integrity constraints [30].", "startOffset": 166, "endOffset": 170}, {"referenceID": 48, "context": "Hitting-set-based algorithmic approaches to diagnosis [53] inspire our algorithmic/complexity approaches to causality.", "startOffset": 54, "endOffset": 58}, {"referenceID": 54, "context": "We define notions of preferred causes; in particular one based on prioritized repairs [59].", "startOffset": 86, "endOffset": 90}, {"referenceID": 53, "context": "This is an extended version of [58].", "startOffset": 31, "endOffset": 35}, {"referenceID": 43, "context": "A tuple t \u2208 D is an actual cause for Q if there exists \u0393 \u2286 D, called a contingency set, such that t is a counterfactual cause for Q in D r \u0393 [47].", "startOffset": 141, "endOffset": 145}, {"referenceID": 43, "context": "However, the definitions of actual cause and contingency set can be applied without a change to monotone queries in general [47], in particular to unions of BCQs (UBCQs), with or without builtins.", "startOffset": 124, "endOffset": 128}, {"referenceID": 1, "context": "Srep(D, IC ) denotes the set of S-repairs of D with respect to IC [2].", "startOffset": 66, "endOffset": 69}, {"referenceID": 17, "context": "Consistent query answering for DCs under S-repairs was investigated in detail [18].", "startOffset": 78, "endOffset": 82}, {"referenceID": 41, "context": "C-repairs and consistent query answering under them were investigated in detail in [43].", "startOffset": 83, "endOffset": 87}, {"referenceID": 8, "context": "[9] for more references.", "startOffset": 0, "endOffset": 3}, {"referenceID": 48, "context": "Diagnosis can be obtained from conflict sets [53].", "startOffset": 45, "endOffset": 49}, {"referenceID": 3, "context": "[4] for an example of the latter that uses key constraints, which are DCs with inequalities (with violation views that contain inequality).", "startOffset": 0, "endOffset": 3}, {"referenceID": 43, "context": "The PTIME algorithm for computing actual causes in [47] is for single conjunctive queries, but does not compute the actual causes\u2019 contingency sets.", "startOffset": 51, "endOffset": 55}, {"referenceID": 43, "context": "Actually, doing the latter increases the complexity, because deciding responsibility of actual causes is NP -hard [47] (which would be tractable if we could efficiently compute all (minimal) contingency sets).", "startOffset": 114, "endOffset": 118}, {"referenceID": 43, "context": "Now, generalizing a result for CQs in [47], actual causes for a UBCQs can be computed in PTIME in the size of D without computing contingency sets.", "startOffset": 38, "endOffset": 42}, {"referenceID": 43, "context": "9 Actually, [47] presents a PTIME algorithm for computing responsibilities for a restricted class of CQs.", "startOffset": 12, "endOffset": 16}, {"referenceID": 43, "context": "(b) This is a simple generalization of the proof of the same result for single conjunctive queries found in [47].", "startOffset": 108, "endOffset": 112}, {"referenceID": 46, "context": "For example, deciding if there is a hitting-set of size at most k as been called the d-hitting-set problem [50], and d is the bound on the size of the sets in the set class.", "startOffset": 107, "endOffset": 111}, {"referenceID": 49, "context": "(a) Th(D), which is Reiter\u2019s logical reconstruction of D as a FO theory [54] (cf.", "startOffset": 72, "endOffset": 76}, {"referenceID": 48, "context": "Section 2 and [53]) and Proposition 6.", "startOffset": 14, "endOffset": 18}, {"referenceID": 48, "context": "Section 2) [53].", "startOffset": 11, "endOffset": 15}, {"referenceID": 26, "context": "[27,49]), to the former.", "startOffset": 0, "endOffset": 7}, {"referenceID": 45, "context": "[27,49]), to the former.", "startOffset": 0, "endOffset": 7}, {"referenceID": 43, "context": "Both CP and CDP are solvable in polynomial time [47], which can be extended to UBCQs (cf.", "startOffset": 48, "endOffset": 52}, {"referenceID": 28, "context": "We will consider the decision version of this problem that, as usual for maximization problems [29], asks whether the real-valued function being computed (responsibility in this case) takes a value greater than a given threshold v of the form 1 k , for a positive integer k.", "startOffset": 95, "endOffset": 99}, {"referenceID": 43, "context": "The complexity analysis of RDP in [47] is restricted to conjunctive queries without self-joins.", "startOffset": 34, "endOffset": 38}, {"referenceID": 43, "context": "Its decision version, MRCDP, the most responsible cause decision problem, is a natural problem, because actual causes with the highest responsibility tend to provide most interesting explanations for query answers [47,48].", "startOffset": 214, "endOffset": 221}, {"referenceID": 44, "context": "Its decision version, MRCDP, the most responsible cause decision problem, is a natural problem, because actual causes with the highest responsibility tend to provide most interesting explanations for query answers [47,48].", "startOffset": 214, "endOffset": 221}, {"referenceID": 17, "context": "Actually, the following result is obtained from the PTIME solvability of the S-repair checking problem for DCs [18] (see also [1]).", "startOffset": 111, "endOffset": 115}, {"referenceID": 0, "context": "Actually, the following result is obtained from the PTIME solvability of the S-repair checking problem for DCs [18] (see also [1]).", "startOffset": 126, "endOffset": 129}, {"referenceID": 17, "context": "S-repair checking can be done in PTIME in data [18].", "startOffset": 47, "endOffset": 51}, {"referenceID": 43, "context": "The NPhardness is shown in [47].", "startOffset": 27, "endOffset": 31}, {"referenceID": 43, "context": "(b) [47] There are CQs Q for which RDP(Q) is NP-hard.", "startOffset": 4, "endOffset": 8}, {"referenceID": 46, "context": "That this is a kind of dhitting-set problem [50] will be useful in Section 6.", "startOffset": 44, "endOffset": 48}, {"referenceID": 41, "context": "However, they still hold for hypergraphs [43,44], which is what we need for the complexity results obtained in the rest of this section.", "startOffset": 41, "endOffset": 48}, {"referenceID": 3, "context": "15 We recall that repairs of databases with respect to DCs can be characterized as maximal independent sets of conflict hypergraphs (conflict graphs in the case of FDs) whose vertices are the database tuples, and hyperedges connect tuples that together violate a DC [4,18].", "startOffset": 266, "endOffset": 272}, {"referenceID": 17, "context": "15 We recall that repairs of databases with respect to DCs can be characterized as maximal independent sets of conflict hypergraphs (conflict graphs in the case of FDs) whose vertices are the database tuples, and hyperedges connect tuples that together violate a DC [4,18].", "startOffset": 266, "endOffset": 272}, {"referenceID": 37, "context": "From Lemma 2 and the FP-completeness of determining the size of a maximum clique in a graph [39], we obtain:", "startOffset": 92, "endOffset": 96}, {"referenceID": 37, "context": "Since computing the maximum cardinality of a clique can be done in time FP [39], computing a minimum vertex cover can be done in the same time (just consider the complement graph).", "startOffset": 75, "endOffset": 79}, {"referenceID": 37, "context": "This follows from the FP-completeness of computing the maximum cardinality of a clique in a graph [39].", "startOffset": 98, "endOffset": 102}, {"referenceID": 37, "context": "The size of the minimum vertex cover in a graph can be computed in FP, which is obtained from the membership of FP of computing the maximum cardinality of a clique in graph [39].", "startOffset": 173, "endOffset": 177}, {"referenceID": 27, "context": "The area of fixed parameter tractability (FPT) [28] provides tools to attack this problem.", "startOffset": 47, "endOffset": 51}, {"referenceID": 46, "context": "Proof First, there is a PTIME parameterized algorithm for the d-hitting-set problem about deciding if there is a hitting-set of size at most k that runs in time O(e + n), with n the size of the underlying set and e = d \u2212 1 + o(d) [50].", "startOffset": 230, "endOffset": 234}, {"referenceID": 25, "context": "also [26]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 27, "context": "In general, parameterized algorithms are very effective when the parameter is relatively small [28].", "startOffset": 95, "endOffset": 99}, {"referenceID": 10, "context": "For the d-hitting-set problem there are also efficient parameterized approximation algorithms [11].", "startOffset": 94, "endOffset": 98}, {"referenceID": 32, "context": "Furthermore, approximation algorithms developed for the minimum vertex cover problem on bounded hypergraphs [34,51] should be applicable to approximate most responsible causes for query answers.", "startOffset": 108, "endOffset": 115}, {"referenceID": 47, "context": "Furthermore, approximation algorithms developed for the minimum vertex cover problem on bounded hypergraphs [34,51] should be applicable to approximate most responsible causes for query answers.", "startOffset": 108, "endOffset": 115}, {"referenceID": 48, "context": "It is known that consistency-based diagnosis decision problems can be unsolvable [53].", "startOffset": 81, "endOffset": 85}, {"referenceID": 54, "context": "We could go beyond and consider the notion of prioritized repair [59].", "startOffset": 65, "endOffset": 69}, {"referenceID": 11, "context": "with nulls \u00e0 la SQL [12,8]).", "startOffset": 20, "endOffset": 26}, {"referenceID": 7, "context": "with nulls \u00e0 la SQL [12,8]).", "startOffset": 20, "endOffset": 26}, {"referenceID": 54, "context": "2 we impose preferences on causes on the basis of the prioritized repairs introduced in [59] (and further investigated in [25]).", "startOffset": 88, "endOffset": 92}, {"referenceID": 24, "context": "2 we impose preferences on causes on the basis of the prioritized repairs introduced in [59] (and further investigated in [25]).", "startOffset": 122, "endOffset": 126}, {"referenceID": 54, "context": "The prioritized repairs in [59] are based on a priority relation, \u227b, on the set of database tuples.", "startOffset": 27, "endOffset": 31}, {"referenceID": 54, "context": "Given such a priority relation, in [59] different classes of prioritized repairs are introduced, namely the class of globally optimal repairs, that of Paretooptimal repairs, and that of completion-optimal repairs.", "startOffset": 35, "endOffset": 39}, {"referenceID": 54, "context": "In order to show a concrete class Rep (D,\u03a3), we first recall the definitions of priority relation and global-optimal repair from [59].", "startOffset": 129, "endOffset": 133}, {"referenceID": 33, "context": "19 We could say that the efforts in [35,36] to modify the Halpern-Pearl (HP) original definition of causality are about considering more appropriate restrictions on contingencies.", "startOffset": 36, "endOffset": 43}, {"referenceID": 34, "context": "19 We could say that the efforts in [35,36] to modify the Halpern-Pearl (HP) original definition of causality are about considering more appropriate restrictions on contingencies.", "startOffset": 36, "endOffset": 43}, {"referenceID": 42, "context": "So, the user can specify a priority relation between the two relations, or different scores for these relations [46].", "startOffset": 112, "endOffset": 116}, {"referenceID": 54, "context": "As we did in the previous sections of this work, we could take advantage of algorithmic and complexity results about prioritized repairs [59,25], to obtain complexity results for preferred causes problems.", "startOffset": 137, "endOffset": 144}, {"referenceID": 24, "context": "As we did in the previous sections of this work, we could take advantage of algorithmic and complexity results about prioritized repairs [59,25], to obtain complexity results for preferred causes problems.", "startOffset": 137, "endOffset": 144}, {"referenceID": 54, "context": "If we accept functional dependencies (FDs) among our denial constraints (and then, UBCQs that involve inequalities), the following result can be obtained from the NP-completeness of globally-optimal repair checking [59] for FDs.", "startOffset": 215, "endOffset": 219}, {"referenceID": 7, "context": "23 An alternative, but equivalent formulation can be found in [8].", "startOffset": 62, "endOffset": 65}, {"referenceID": 30, "context": "Causality as introduced by Halpern and Pearl in [32,33], aka.", "startOffset": 48, "endOffset": 55}, {"referenceID": 31, "context": "Causality as introduced by Halpern and Pearl in [32,33], aka.", "startOffset": 48, "endOffset": 55}, {"referenceID": 43, "context": "HP-causality, is the basis for the notion of causality in [47].", "startOffset": 58, "endOffset": 62}, {"referenceID": 33, "context": "HP-causality has been the object of some criticism [35], which is justified in some (more complex, non-relational) settings, specially due to the presence of different kinds of logical variables (or lack thereof).", "startOffset": 51, "endOffset": 55}, {"referenceID": 33, "context": "In [35,36], the definition of HP-causality is slightly modified.", "startOffset": 3, "endOffset": 10}, {"referenceID": 34, "context": "In [35,36], the definition of HP-causality is slightly modified.", "startOffset": 3, "endOffset": 10}, {"referenceID": 2, "context": "S-repairs can be specified by means of answer set programs (ASPs) [3,6], and C-repairs too, with the use of weak program constraints [3].", "startOffset": 66, "endOffset": 71}, {"referenceID": 5, "context": "S-repairs can be specified by means of answer set programs (ASPs) [3,6], and C-repairs too, with the use of weak program constraints [3].", "startOffset": 66, "endOffset": 71}, {"referenceID": 2, "context": "S-repairs can be specified by means of answer set programs (ASPs) [3,6], and C-repairs too, with the use of weak program constraints [3].", "startOffset": 133, "endOffset": 136}, {"referenceID": 23, "context": "There are also ASP-based specifications of diagnosis [24] that could be brought into a more complete picture.", "startOffset": 53, "endOffset": 57}, {"referenceID": 8, "context": "There is much research on repairs and consistent query answering for functional dependencies, and more complex integrity constraints [9].", "startOffset": 133, "endOffset": 136}, {"referenceID": 51, "context": "In a different, but related direction, causality for monotonic queries in the presence of integrity constraints has been investigated in [56].", "startOffset": 137, "endOffset": 141}, {"referenceID": 19, "context": "Abduction [20,23] is another form of model-based diagnosis, and is related to the subjects investigated in this work.", "startOffset": 10, "endOffset": 17}, {"referenceID": 22, "context": "Abduction [20,23] is another form of model-based diagnosis, and is related to the subjects investigated in this work.", "startOffset": 10, "endOffset": 17}, {"referenceID": 35, "context": "The view update problem, about updating a database through views, is a classical problem in databases that has been treated through abduction [37,21].", "startOffset": 142, "endOffset": 149}, {"referenceID": 20, "context": "The view update problem, about updating a database through views, is a classical problem in databases that has been treated through abduction [37,21].", "startOffset": 142, "endOffset": 149}, {"referenceID": 39, "context": "The view update problem, specially in its particular form of deletion propagation, has been recently related in [41,42] to causality as introduced in [47].", "startOffset": 112, "endOffset": 119}, {"referenceID": 40, "context": "The view update problem, specially in its particular form of deletion propagation, has been recently related in [41,42] to causality as introduced in [47].", "startOffset": 112, "endOffset": 119}, {"referenceID": 43, "context": "The view update problem, specially in its particular form of deletion propagation, has been recently related in [41,42] to causality as introduced in [47].", "startOffset": 150, "endOffset": 154}, {"referenceID": 5, "context": "Actually, answer set programs (ASP) for database repairs [6] implicity repair the database by updating intentional, annotated predicates (cf.", "startOffset": 57, "endOffset": 60}, {"referenceID": 7, "context": "Even more, in [8], in order to protect sensitive information, databases are explicitly and virtually \u201crepaired\u201d through secrecy views that specify the information that has to be kept secret.", "startOffset": 14, "endOffset": 17}, {"referenceID": 4, "context": "Abduction has been explicitly applied to database repairs [5].", "startOffset": 58, "endOffset": 61}, {"referenceID": 9, "context": "The deep interrelations between causality, abductive reasoning, view updates and repairs are the objects of our ongoing research efforts [10,57].", "startOffset": 137, "endOffset": 144}, {"referenceID": 52, "context": "The deep interrelations between causality, abductive reasoning, view updates and repairs are the objects of our ongoing research efforts [10,57].", "startOffset": 137, "endOffset": 144}, {"referenceID": 41, "context": "We appealed to several non-trivial results found in [43] (and the proofs thereof found in [44]) about repairs and CQA.", "startOffset": 52, "endOffset": 56}, {"referenceID": 15, "context": "It is also the case that diagnostic reasoning, as a form of non-monotonic reasoning, can provide a solid foundation for causality in databases and query answer explanation, in general [16,17].", "startOffset": 184, "endOffset": 191}, {"referenceID": 16, "context": "It is also the case that diagnostic reasoning, as a form of non-monotonic reasoning, can provide a solid foundation for causality in databases and query answer explanation, in general [16,17].", "startOffset": 184, "endOffset": 191}, {"referenceID": 52, "context": "In ongoing research we have established connections between query answer causality, abductive diagnosis and database updates through views [57].", "startOffset": 139, "endOffset": 143}], "year": 2016, "abstractText": "In this work we establish and investigate connections between causes for query answers in databases, database repairs with respect to denial constraints, and consistency-based diagnosis. The first two are relatively new research areas in databases, and the third one is an established subject in knowledge representation. We show how to obtain database repairs from causes, and the other way around. Causality problems are formulated as diagnosis problems, and the diagnoses provide causes and their responsibilities. The vast body of research on database repairs can be applied to the newer problems of computing actual causes for query answers and their responsibilities. These connections are interesting per se. They also allow us, after a transition inspired by consistency-based diagnosis to computational problems on hittingsets and vertex covers in hypergraphs, to obtain several new algorithmic and complexity results for database causality.", "creator": "LaTeX with hyperref package"}}}