{"id": "1507.02672", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Jul-2015", "title": "Semi-supervised Learning with Ladder Networks", "abstract": "We combine internship math long grade-school learning in with actuation outlets. The extension newer either trained would both interfere the payoff of supervised own tutoring cost functions by automates, overcome the fail for layer -... pretraining. Our work endeavor came top included the Ladder computer proposes supported Valpola (1996-97) which we extend having combining but custom then rehabilitation. We show referring well reduces model continues western - well - of - art improvement in two tasks: MNIST and CIFAR - 10 distinct. a eliminated - approved setting more pre-test formula_17 MNIST in such uefa - projects being supposed - labeled start.", "histories": [["v1", "Thu, 9 Jul 2015 19:52:19 GMT  (817kb,D)", "http://arxiv.org/abs/1507.02672v1", null], ["v2", "Tue, 24 Nov 2015 09:22:23 GMT  (823kb,D)", "http://arxiv.org/abs/1507.02672v2", "Revised denoising function, updated results, fixed typos"]], "reviews": [], "SUBJECTS": "cs.NE cs.LG stat.ML", "authors": ["antti rasmus", "mathias berglund", "mikko honkala", "harri valpola", "tapani raiko"], "accepted": true, "id": "1507.02672"}, "pdf": {"name": "1507.02672.pdf", "metadata": {"source": "CRF", "title": "Semi-Supervised Learning with Ladder Network", "authors": ["Antti Rasmus", "Harri Valpola", "Mikko Honkala", "Tapani Raiko"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "In this paper, we introduce an unsupervised learning method that fits well with supervised learning. The idea of using unsupervised learning to complement supervision is not new. Combining an auxiliary task to help train a neural network was proposed by Suddarth and Kergosien (1990). By sharing the hidden representations among more than one task, the network generalizes better. There are multiple choices for the unsupervised task, for example, reconstructing the inputs at every level of the model (e.g., Ranzato and Szummer, 2008) or classification of each input sample into its own class (Dosovitskiy et al., 2014).\nAlthough some methods have been able to simultaneously apply both supervised and unsupervised learning (Ranzato and Szummer, 2008; Goodfellow et al., 2013a), often these unsupervised auxiliary tasks are only applied as pre-training, followed by normal supervised learning (e.g., Hinton and Salakhutdinov, 2006). In complex tasks there is often much more structure in the inputs than can be represented, and unsupervised learning cannot, by definition, know what will be useful for the task at hand. Consider, for instance, the autoencoder approach applied to natural images: an auxiliary decoder network tries to reconstruct the original input from the internal representation. The autoencoder will try to preserve all the details needed for reconstructing the image at pixel level, even though classification is typically invariant to all kinds of transformations which do not preserve pixel values. Most of the information required for pixel-level reconstruction is irrelevant and takes space from the more relevant invariant features which, almost by definition, cannot alone be used for reconstruction.\nOur approach follows Valpola (2015) who proposed a Ladder network where the auxiliary task is to denoise representations at every level of the model. The model structure is an autoencoder with skip connections from the encoder to decoder and the learning task is similar to that in denoising autoencoders but applied to every layer, not just inputs. The skip connections relieve the pressure to represent details at the higher layers of the model because, through the skip connections, the decoder can recover any details discarded by the encoder. Previously the Ladder network has only been demonstrated in unsupervised learning (Valpola, 2015; Rasmus et al., 2015a) but we now combine it with supervised learning.\nar X\niv :1\n50 7.\n02 67\n2v 1\n[ cs\n.N E\n] 9\nJ ul\n2 01\nThe key aspects of the approach are as follows:\nCompatibility with supervised methods. The unsupervised part focuses on relevant details found by supervised learning. Furthermore, it can be added to existing feedforward neural networks, for example multi-layer perceptrons (MLPs) or convolutional neural networks (Section 3). We show that we can take a state-of-the-art supervised learning method as a starting point and improve the network further by adding simultaneous unsupervised learning (Section 4).\nScalability due to local learning. In addition to supervised learning target at the top layer, the model has local unsupervised learning targets on every layer making it suitable for very deep neural networks. We demonstrate this with two deep supervised network architectures.\nComputational efficiency. The encoder part of the model corresponds to normal supervised learning. Adding a decoder, as proposed in this paper, approximately triples the computation during training but not necessarily the training time since the same result can be achieved faster due to better utilization of available information. Overall, computation per update scales similarly to whichever supervised learning approach is used, with a small multiplicative factor.\nAs explained in Section 2, the skip connections and layer-wise unsupervised targets effectively turn autoencoders into hierarchical latent variable models which are known to be well suited for semisupervised learning. Indeed, we obtain state-of-the-art results in semisupervised learning in MNIST, permutation invariant MNIST and CIFAR-10 classification tasks (Section 4). However, the improvements are not limited to semi-supervised settings: for the permutation invariant MNIST task, we also achieve a new record with the normal full-labeled setting.1"}, {"heading": "2 Derivation and justification", "text": "Latent variable models are an attractive approach to semi-supervised learning because they can combine supervised and unsupervised learning in a principled way. The only difference is whether the class labels are observed or not. This approach was taken, for instance, by Goodfellow et al. (2013a) with their multi-prediction deep Boltzmann machine. A particularly attractive property of hierarchical latent variable models is that they can, in general, leave the details for the lower levels to represent, allowing higher levels to focus on more invariant, abstract features that turn out to be relevant for the task at hand.\nThe training process of latent variable models can typically be split into inference and learning, that is, finding the posterior probability of the unobserved latent variables and then updating the underlying probability model to better fit the observations. For instance, in the expectation-maximization (EM) algorithm, the E-step corresponds to finding the expectation of the latent variables over the posterior distribution assuming the model fixed and M-step then maximizes the underlying probability model assuming the expectation fixed.\nIn general, the main problem with latent variable models is how to make inference and learning efficient. Suppose there are layers l of latent variables z(l). Typically latent variable models represent the probability distribution of all the variables explicitly as a product of terms, such as p(z(l) | z(l+1)) in directed graphical models. The inference process and model updates are then derived from Bayes\u2019 rule, typically as some kind of approximation. Often the inference is iterative as it is generally impossible to solve the resulting equations in a closed form as a function of the observed variables.\nThere is a close connection between denoising and probabilistic modeling. On the one hand, given a probabilistic model, you can compute the optimal denoising. Say you want to reconstruct a latent z using a prior p(z) and an observation z\u0303 = z + noise. We first compute the posterior distribution p(z | z\u0303), and use its center of gravity as the reconstruction z\u0302. One can show that this minimizes the expected denoising cost (z\u0302 \u2212 z)2. On the other hand, given a denoising function, one can draw samples from the corresponding distribution by creating a Markov chain that alternates between corruption and denoising (Bengio et al., 2013).\n1Preliminary results on the full-labeled setting on permutation invariant MNIST task were reported in a short early version of this paper (Rasmus et al., 2015b). Compared to that, we have added noise to all layers of the model and further simplified the denoising function g. This further improved the results.\nValpola (2015) proposed the Ladder network where the inference process itself can be learned by using the principle of denoising which has been used in supervised learning (Sietsma and Dow, 1991), denoising autoencoders (dAE) (Vincent et al., 2010) and denoising source separation (DSS) (Sa\u0308rela\u0308 and Valpola, 2005) for complementary tasks. In dAE, an autoencoder is trained to reconstruct the original observation x from a corrupted version x\u0303. Learning is based simply on minimizing the norm of the difference of the original x and its reconstruction x\u0302 from the corrupted x\u0303, that is the cost is \u2016x\u0302\u2212 x\u20162. While dAEs are normally only trained to denoise the observations, the DSS framework is based on the idea of using denoising functions z\u0302 = g(z) of latent variables z to train a mapping z = f(x) which models the likelihood of the latent variables as a function of the observations. The cost function is identical to that used in a dAE except that latent variables z replace the observations x, that is, the cost is \u2016z\u0302\u2212z\u20162. The only thing to keep in mind is that z needs to be normalized somehow as otherwise the model has a trivial solution at z = z\u0302 = constant. In a dAE, this cannot happen as the model cannot change the input x.\nFigure 1 depicts the optimal denoising function z\u0302 = g(z\u0303) for a one-dimensional bimodal distribution which could be the distribution of a latent variable inside a larger model. The shape of the denoising function depends on the distribution of z and the properties of the corruption noise. With no noise at all, the optimal denoising function would be a straight line. In general, the denoising function pushes the values towards higher probabilities as shown by the green arrows.\nFigure 2 shows the structure of the Ladder network. Every layer contributes to the cost function a term C(l)d = \u2016z(l) \u2212 z\u0302(l)\u20162 which trains the layers above (both encoder and decoder) to learn the denoising function z\u0302(l) = g(l)(z\u0303(l)) which maps the corrupted z\u0303(l) onto the denoised estimate z\u0302(l). As the estimate z\u0302(l) incorporates all the prior knowledge about z, the same cost function term also trains the encoder layers below to find cleaner features which better match the prior expectation.\nSince the cost function needs both the clean z(l) and corrupted z\u0303(l), the encoder is run twice: a clean pass for z(l) and a corrupted pass for z\u0303(l). Another feature which differentiates the Ladder network from regular dAEs is that each layer has a skip connection between the encoder and decoder. This feature mimics the inference structure of latent variable models and makes it possible for the higher levels of the network to leave some of the details for lower levels to represent. Rasmus et al. (2015a) showed that such skip connections allow dAEs to focus on abstract invariant features on the higher levels, making the Ladder network a good fit with supervised learning that can select which information is relevant for the task at hand.\nAlgorithm 1 Calculation of the output and cost function of the Ladder network\nRequire: x(n) # Corrupted encoder and classifier h\u0303(0) \u2190 z\u0303(0) \u2190 x(n) + noise for l = 1 to L do z\u0303 (l) pre \u2190W(l)h\u0303(l\u22121)\n\u00b5\u0303(l) \u2190 batchmean(z\u0303(l)pre) \u03c3\u0303(l) \u2190 batchstd(z\u0303(l)pre) z\u0303(l) \u2190 batchnorm(z\u0303(l)pre) + noise h\u0303(l) \u2190 activation(\u03b3(l) (z\u0303(l) + \u03b2(l))) end for P (y\u0303 | x)\u2190 h\u0303(L) # Clean encoder (for denoising targets) h(0) \u2190 z(0) \u2190 x(n) for l = 1 to L do z(l) \u2190 batchnorm(W(l)h(l\u22121)) h(l) \u2190 activation(\u03b3(l) (z(l) + \u03b2(l))) end for\n# Final classification: P (y | x)\u2190 h(L) # Decoder and denoising for l = L to 0 do\nif l = L then u(L) \u2190 batchnorm(h\u0303(L)) else u(l) \u2190 batchnorm(V(l)z\u0302(l+1)) end if \u2200i : z\u0302(l)i \u2190 g(z\u0303 (l) i , u (l) i ) # Eq. (1) \u2200i : z\u0302(l)i,BN \u2190 z\u0302 (l) i \u2212\u00b5\u0303(l) i\n\u03c3\u0303 (l) i\nend for # Cost function C for training: C\u2190 0 if t(n) then\nC\u2190 \u2212 logP (y\u0303 = t(n) | x) end if C\u2190 C +\u2211Ll=1 \u03bbl \u2225\u2225\u2225z(l) \u2212 z\u0302(l)BN\u2225\u2225\u22252 # Eq. (2)\nOne way to picture the Ladder network is to consider it as a collection of nested denoising autoencoders which share parts of the denoising machinery between each other. From the viewpoint of the autoencoder at layer l, the representations on the higher layers can be treated as hidden neurons. In other words, there is no particular reason why z\u0302(l+i) produced by the decoder should resemble the corresponding representations z(l+i) produced by the encoder. It is only the cost function C(l+i)d that ties these together and forces the inference to proceed in a reverse order in the decoder. This sharing helps a deep denoising autoencoder to learn the denoising process as it splits the task into meaningful sub-tasks of denoising intermediate representations."}, {"heading": "3 Implementation of the Model", "text": "The steps to implement the Ladder network (Section 3.1) are typically as follows: 1) take a feedforward model which serves supervised learning and as the encoder (Section 3.2), 2) add a decoder which can invert the mappings on each layer of the encoder and supports unsupervised learning (Section 3.3), and 3) train the whole Ladder network by minimizing a sum of all the cost function terms.\nIn this section, we will go through these steps in detail for a fully connected MLP network and briefly outline the modifications required for convolutional networks, both of which are used in our experiments (Section 4)."}, {"heading": "3.1 General Steps for Implementing the Ladder Network", "text": "Consider training a classifier2, or a mapping from input x to output y with targets t, from a training set of pairs {x(n), t(n) | 1 \u2264 n \u2264 N}. Semi-supervised learning (Chapelle et al., 2006) studies how auxiliary unlabeled data {x(n) | N + 1 \u2264 n \u2264 M} can help in training a classifier. It is often the case that labeled data is scarce whereas unlabeled data is plentiful, that is N M . The Ladder network can improve results even without auxiliary unlabeled data but the original motivation was to make it possible to take well-performing feedforward classifiers and augment them with an auxiliary decoder as follows:\n1. Train any standard feedforward neural network. The network type is not limited to standard MLPs, but the approach can be applied, for example, to convolutional or recurrent networks. This will be the encoder part of the Ladder network.\n2. For each layer, analyze the conditional distribution of representations given the layer above, p(z(l) | z(l+1)). The observed distributions could resemble for example Gaussian distributions where the mean and variance depend on the values z(l+1), bimodal distributions where the relative probability masses of the modes depend on the values z(l+1), and so on.\n3. Define a function z\u0302(l) = g(z\u0303(l), z\u0302(l+1)) which can approximate the optimal denoising function for the family of observed distributions. The function g is therefore expected to form a reconstruction z\u0302(l) that resembles the clean z(l) given the corrupted z\u0303(l) and the higher level reconstruction z\u0302(l+1) .\n4. Train the whole network in a full-labeled or semi-supervised setting using standard optimization techniques such as stochastic gradient descent."}, {"heading": "3.2 Fully Connected MLP as Encoder", "text": "As a starting point we use a fully connected MLP network with rectified linear units. We follow Ioffe and Szegedy (2015) to apply batch normalization to each preactivation including the topmost layer in the L-layer network. This serves two purposes. First, it improves convergence due to reduced covariate shift as originally proposed by Ioffe and Szegedy (2015). Second, as explained in Section 2, DSS-type cost functions for all but the input layer require some type of normalization to prevent the denoising cost from encouraging the trivial solution where the encoder outputs just\n2Here we only consider the case where the output t(n) is a class label but it is trivial to apply the same approach to other regression tasks.\nconstant values as these are the easiest to denoise. Batch normalization conveniently serves this purpose, too.\nFormally, batch normalization for layers l = 1 . . . L is implemented as\nz(l) = NB(W (l)h(l\u22121)) h(l) = \u03c6 ( \u03b3(l)(z(l) + \u03b2(l)) ) ,\nwhere h(0) = x, NB is a component-wise batch normalization NB(xi) = (xi \u2212 \u00b5\u0302xi)/\u03c3\u0302xi , where \u00b5\u0302xi and \u03c3\u0302xi are estimates calculated from the minibatch, \u03b3\n(l) and \u03b2(l) are trainable parameters, and \u03c6(\u00b7) is the activation function such as the rectified linear unit (ReLU) for which \u03c6(\u00b7) = max(0, \u00b7). For outputs y = h(L) we always use the softmax activation. For some activation functions the scaling parameter \u03b2(l) or the bias \u03b3(l) are redundant and we only apply them in non-redundant cases. For example, the rectified linear unit does not need scaling, linear activation function needs neither scaling nor bias, but softmax requires both.\nAs explained in Section 2 and shown in Figure 2, the Ladder network requires two forward passes, clean and corrupted, which produce clean z(l) and h(l) and corrupted z\u0303(l) and h\u0303(l), respectively. We implemented corruption by adding isotropic Gaussian noise n to inputs and after each batch normalization:\nx\u0303 = h\u0303(0) = x + n(0)\nz\u0303(l)pre = W (l)h\u0303(l\u22121)\nz\u0303(l) = NB(z\u0303 (l) pre) + n (l) h\u0303(l) = \u03c6 ( \u03b3(l)(z\u0303(l) + \u03b2(l)) ) .\nNote that we collect the value z\u0303(l)pre here because it will be needed in the decoder cost function in Section 3.3.\nThe supervised cost Cc is the average negative log probability of the noisy output y\u0303 matching the target t(n) given the inputs x(n)\nCc = \u2212 1\nN N\u2211 n=1 logP (y\u0303 = t(n) | x(n)).\nIn other words, we also use the noise to regularize supervised learning.\nWe saw networks with this structure reach close to state-of-the-art results in purely supervised learning (e.g., see Table 1) which makes them good starting points for improvement via semi-supervised learning by adding an auxiliary unsupervised task."}, {"heading": "3.3 Decoder for Unsupervised Learning", "text": "When designing a suitable decoder to support unsupervised learning, we followed the steps outlined in Section 3.1: we analyzed the histograms of the activations of hidden neurons in well-performing models trained by supervised learning and then designed denoising functions z\u0302(l) = g(z\u0303(l), z\u0302(l+1)) which are able to approximate the optimal denoising function that provides the best estimate of the clean version z(l). In this section, we present just the end result of the analysis but more details can be found in Appendix B.\nThe encoder provides multiple targets which the decoder could try to denoise. We chose the target to be the batch-normalized projections z(l) before the activation function is applied. As mentioned earlier, batch-normalization of the target prevents the encoder from collapsing the representation to a constant. Such a solution minimizes denoising error but is obviously not the one we are looking for. On the other hand, it makes sense to target the encoder representation before the activation function is applied. This is because the activation function is typically the step where information is lost, for example, due to saturation or pooling. In the Ladder network, the decoder can recover this lost information through the lateral skip connections from the encoder to the decoder.\nThe network structure of the decoder does not need to resemble the decoder but in order to keep things simple, we chose a decoder structure whose weight matrices V(l+1) have shapes similar to\nthe weight matrices W(l) of the encoder, except being transposed, and which performs the denoising neuron-wise. This keeps the number of parameters of the decoder in check but still allows the network to represent any distributions: any dependencies between hidden neurons can still be represented through the higher levels of the network which effectively implement a higher-level denoising autoencoder.\nIn practice the neuron-wise denoising function g is implemented by first computing a vertical mapping from z\u0302(l+1) and then batch normalizing the resulting projections:\nu(l) = NB(V (l+1)z\u0302(l+1)) ,\nwhere the matrix V(l) has the same dimension as the transpose of W(l) on the encoder side. The projection vector u(l) has the same dimensionality as z(l) which means that the final denoising can be applied neuro-wise with a miniature MLP network that takes two inputs, z\u0303(l)i and u (l) i , and outputs the denoised estimate z\u0302(l)i : z\u0302 (l) i = g (l) i (z\u0303 (l) i , u (l) i ) .\nNote the slight abuse of notation here since g(l)i is now a function of scalars z\u0303 (l) i and u (l) i rather than the full vectors z\u0303(l) and z\u0302(l+1).\nFigure 3 illustrates the structure of the miniature MLPs which are parametrized as follows:\nz\u0302 (l) i = g (l) i (z\u0303 (l) i , u (l) i ) = a (l) i \u03be (l) i + b (l) i sigmoid(c (l) i \u03be (l) i ) (1)\nwhere \u03be(l)i = [1, z\u0303 (l) i , u (l) i , z\u0303 (l) i u (l) i ] T is the augmented input, a(l)i and c (l) i are trainable 1\u00d7 4 weight vectors, and b(l)i is a trainable weight. In other words, each hidden neuron of the network has its own miniature MLP network with 9 parameters. While this makes the number of parameters in the decoder slightly higher than in the encoder, the difference is insignificant as most of the parameters are in the vertical projection mappings W(l) and V(l) which have the same dimensions (apart from transposition).\nFor the lowest layer, x\u0302 = z\u0302(0) and x\u0303 = z\u0303(0) by definition, and for the highest layer we chose u(L) = y\u0303. This allows the highest-layer denoising function to utilize prior information about the classes being mutually exclusive which seems to improve convergence in cases where there are very few labeled samples.\nThe proposed parametrization is capable of learning denoising of several different distributions including sub- and super-Gaussian and bimodal distributions. This means that the decoder supports sparse coding and independent component analysis.3 The parametrization also allows the distribution to be modulated by z(l+1) through u(l), encouraging the decoder to find representations z(l) that\n3For more details on how denoising functions represent corresponding distributions see Valpola (2015, Section 4.1).\nhave high mutual information with z(l+1). This is crucial as it allows supervised learning to have an indirect influence on the representations learned by the unsupervised decoder: any abstractions selected by supervised learning will bias the lower levels to find more representations which carry information about the same thing.\nRasmus et al. (2015a) showed that modulated connections in g are crucial for allowing the decoder to recover discarded details from the encoder and thus for allowing invariant representations to develop. The proposed parametrization can represent such modulation but also standard additive connections that are normally used in dAEs. We also tested alternative formulations for the denoising function, the results of which can be found in Appendix B.\nThe cost function for the unsupervised path is the mean squared reconstruction error per neuron, but there is a slight twist which we found to be important. Batch normalization has useful properties as noted in Section 3.2, but it also introduces noise which affects both the clean and corrupted encoder pass. This noise is highly correlated between z(l) and z\u0303(l) because the noise derives from the statistics of the samples that happen to be in the same minibatch. This highly correlated noise in z(l) and z\u0303(l) biases the denoising functions to be simple copies4 z\u0302(l) \u2248 z\u0303(l).\nThe solution we found was to implicitly use the projections z(l)pre as the target for denoising and scale the cost function in such a way that the term appearing in the error term is the batch normalized z(l) instead. For the moment, let us see how that works for a scalar case:\n1\n\u03c32 \u2016zpre \u2212 z\u0302\u20162 = \u2225\u2225\u2225\u2225zpre \u2212 \u00b5\u03c3 \u2212 z\u0302 \u2212 \u00b5\u03c3 \u2225\u2225\u2225\u22252 = \u2016z \u2212 z\u0302BN\u20162\nz = NB(zpre) = zpre \u2212 \u00b5\n\u03c3\nz\u0302BN = z\u0302 \u2212 \u00b5 \u03c3 ,\nwhere \u00b5 and \u03c3 are the batch mean and batch std of zpre, respectively, that were used in batch normalizing zpre into z. The unsupervised denoising cost function Cd is thus\nCd = L\u2211 l=1 \u03bblC (l) d = L\u2211 l=0 \u03bbl Nml N\u2211 n=1 \u2225\u2225\u2225z(l)(n)\u2212 z\u0302(l)BN(n)\u2225\u2225\u22252 , (2) where ml is the layer\u2019s width, N the number of training samples, and the hyperparameter \u03bbl a layerwise multiplier determining the importance of the denoising cost.\nThe model parameters W(l),\u03b3(l),\u03b2(l),V(l),a(l)i , b (l) i , c (l) i can be trained simply by using the backpropagation algorithm to optimize the total cost C = Cc + Cd. The feedforward pass of the full Ladder network is listed in Algorithm 1. Classification results are read from the y in the clean feedforward path."}, {"heading": "3.4 Variations", "text": "Section 3.3 detailed how to build a decoder for the Ladder network to match the fully connected encoder described in 3.2. It is easy to extend the same approach to other encoders, for instance, convolutional neural networks (CNN). For the decoder of fully connected networks we used vertical mappings whose shape is a transpose of the encoder mapping. The same treatment works for the convolution operations: in the networks we have tested in this paper, the decoder has convolutions whose parametrization mirrors the encoder and effectively just reverses the flow of information. As the idea of convolution is to reduce the number of parameters by weight sharing, we applied this to the parameters of the denoising function g, too.\nMany convolutional networks use pooling operations with stride, that is, they downsample the spatial feature maps. The decoder needs to compensate this with a corresponding upsampling. There are several alternative ways to implement this and in this paper we chose the following options: 1)\n4The whole point of using denoising autoencoders rather than regular autoencoders is to prevent skip connections from short-circuiting the decoder and force the decoder to learn meaningful abstractions which help in denoising.\non the encoder side, pooling operations are treated as separate layers with their own batch normalization and linear activations function and 2) the downsampling of the pooling on the encoder side is compensated by upsampling with copying on the decoder side. This provides multiple targets for the decoder to match, helping the decoder to recover the information lost on the encoder side.\nIt is worth noting that a simple special case of the decoder is a model where \u03bbl = 0 when l < L. This corresponds to a denoising cost only on the top layer and means that most of the decoder can be omitted. This model, which we call the \u0393-model due to the shape of the graph, is useful as it can easily be plugged into any feedforward network without decoder implementation. In addition, the \u0393-model is the same for MLPs and convolutional neural networks. The encoder in the \u0393-model still includes both the clean and the corrupted paths as in the full ladder."}, {"heading": "4 Experiments", "text": "With the experiments with MNIST and CIFAR-10 dataset, we wanted to compare our method to other semi-supervised methods but also to show that we can attach the decoder both to a fullyconnected MLP network and to a convolutional neural network, both of which were described in Section 3. We also wanted to compare the performance of the simpler \u0393-model (Sec. 3.4) to the full Ladder network and experimented with only having a cost function on the input layer. With CIFAR-10, we only tested the \u0393-model.\nWe also measured the performance of the supervised baseline models which only included the encoder and the supervised cost function. In all cases where we compared these directly with Ladder networks, we did our best to optimize the hyperparameters and regularization of the baseline supervised learning models so that any improvements could not be explained, for example, by the lack of suitable regularization which would then have been provided by the denoising costs.\nWith the convolutional networks, our focus was exclusively on semi-supervised learning. The supervised baselines for all labels only intend to show that the performance of the selected network architectures are in line with the ones reported in the literature. We make claims neither about the optimality nor the statistical significance of these baseline results.\nWe used the Adam optimization algorithm (Kingma and Ba, 2015) for weight updates. The learning rate was 0.002 for the first part of learning, followed by an annealing phase during which the learning rate was linearly decreased to zero. Minibatch size was 100. The source code for all the experiments is available at https://github.com/arasmus/ladder unless explicitly noted in the text."}, {"heading": "4.1 MNIST dataset", "text": "For evaluating semi-supervised learning, we used the standard 10 000 test samples as a held-out test set and randomly split the standard 60 000 training samples into 10 000-sample validation set and used M = 50 000 samples as the training set. From the training set, we randomly chose N = 100, 1000, or all labels for the supervised cost.5 All the samples were used for the decoder which does not need the labels. The validation set was used for evaluating the model structure and hyperparameters. We also balanced the classes to ensure that no particular class was over-represented. We repeated each training 10 times varying the random seed that was used for the splits.\nAfter optimizing the hyperparameters, we performed the final test runs using all the M = 60 000 training samples with 10 different random initializations of the weight matrices and data splits. We trained all the models for 100 epochs followed by 50 epochs of annealing. With minibatch size of 100, this amounts to 75 000 weight updates for the validation runs and 90 000 for the final test runs.\n5In all the experiments, we were careful not to optimize any parameters, hyperparameters, or model choices based on the results on the held-out test samples. As is customary, we used 10 000 labeled validation samples even for those settings where we only used 100 labeled samples for training. Obviously this is not something that could be done in a real case with just 100 labeled samples. However, MNIST classification is such an easy task even in the permutation invariant case that 100 labeled samples there correspond to a far greated number of labeled samples in many other datasets."}, {"heading": "4.1.1 Fully-connected MLP", "text": "A useful test for general learning algorithms is the permutation invariant MNIST classification task. Permutation invariance means that the results need to be invariant with respect to permutation of the elements of the input vector. In other words, one is not allowed to use prior information about the spatial arrangement of the input pixels. This excludes, among others, convolutional networks and geometric distortions of the input images.\nWe chose the layer sizes of the baseline model somewhat arbitrarily to be 784-1000-500-250-250- 250-10. The network is deep enough to demonstrate the scalability of the method but not yet an overkill for MNIST.\nThe hyperparameters we tuned for each model are the noise level that is added to the inputs and to each layer, and denoising cost multipliers \u03bb(l). We also ran the supervised baseline model with various noise levels. For models with just one cost multiplier, we optimized them with a search grid {. . ., 0.1, 0.2, 0.5, 1, 2, 5, 10, . . .}. Ladder networks with cost function on all layers have a much larger search space and we explored it much more sparsely. For instance, the optimal model we found for N = 100 labels had \u03bb(0) = 1000, \u03bb(1) = 10 and \u03bb(\u22652) = 0.1. A good value for the std of Gaussian corruption noise n(l) was mostly 0.3 but with N = 1000 labels, a better value was 0.2. According to validation data, denoising costs above the input layer were not helpful with N = 50 000 labels so we only tested the bottom model with allN = 60 000 labels. For the complete set of selected denoising cost multipliers and other hyperparameters, please refer to the code.\nThe results presented in Table 1 show that the proposed method outperforms all the previously reported results. The improvement is most significant in the most difficult 100-label case where denoising targets on all layers provides the greatest benefit over having a denoising target only on the input layer. This suggests that the improvement can be attributed to efficient unsupervised learning on all the layers of the Ladder network. Encouraged by the good results, we also tested with N = 50 labels and got a test error of 1.39 % (\u00b1 0.55 %). The simple \u0393-model also performed surprisingly well, particularly for N = 1000 labels. The denoising cost at the highest layer turns out to encourage distributions with two sharp peaks. While this clearly allows the model to utilize information in unlabeled samples, effectively self-labeling them, it also seems to suffer from confirmation bias, particularly with less labels. While the median error with N = 100 labels is 2.61 %, the average is significantly worse due to some runs in which the model seems to get stuck with its inital misconception about the classes. The Ladder network with denoising targets on every layer converges much more reliably as can be seen from the low standard deviation of the results."}, {"heading": "4.1.2 Convolutional networks", "text": "We tested two convolutional networks for the general MNIST classification task but omitted data augmentation such as geometric distortions. We focused on the 100-label case since with more labels the results were already so good even in the more difficult permutation invariant task.\nThe first network was a straight-forward extension of the fully-connected network tested in the permutation invariant case. We turned the first fully connected layer into a convolution with 26- by-26 filters, resulting in a 3-by-3 spatial map of 1000 features. Each of the 9 spatial locations was processed independently by a network with the same structure as in the previous section, finally resulting in a 3-by-3 spatial map of 10 features. These were pooled with a global mean-pooling layer. Essentially we thus convolved the image with the complete fully-connected network. Depooling on the top-most layer and deconvolutions on the layers below were implemented as described in Section 3.4. Since the internal structure of each of the 9 almost independent processing paths was the same as in the permutation invariant task, we used the same hyperparameters that were optimal for the permutation invariant task. In Table 2, this model is referred to as Conv-FC.\nWith the second network, which was inspired by ConvPool-CNN-C from Springenberg et al. (2014), we only tested the \u0393-model. The MNIST classification task can typically be solved with a smaller number of parameters than CIFAR-10 for which this topology was originally developed, so we modified the network by removing layers and reducing the amount of parameters in the remaining layers. In addition, we observed that adding a small fully connected layer having 10 neurons on top of the global mean pooling layer improved the results in the semi-supervised task. We did not tune other parameters than the noise level, which was chosen from {0.3, 0.45, 0.6} using the validation set. The exact architecture of this network is detailed in Table 4 in Appendix A. It is referred to as Conv-Small since it is a smaller version of the network used for CIFAR-10 dataset.\nThe results in Table 2 confirm that even the single convolution on the bottom level improves the results over the fully connected network. More convolutions improve the \u0393-model significantly although the high variance of the results suggests that the model still suffers from confirmation bias. The Ladder network with denoising targets on every level converges much more reliably. Taken together, these results suggest that combining the generalization ability of convolutional networks6 and efficient unsupervised learning of the full Ladder network would have resulted in even better performance but this was left for future work."}, {"heading": "4.2 Convolutional networks on CIFAR-10", "text": "CIFAR-10 dataset consists of small 32-by-32 RGB images from 10 classes. There are 50 000 labeled samples for training and 10 000 for testing. Like the MNIST dataset, it has been used for testing semi-supervised learning so we decided to test the simple \u0393-model with a convolutional network that has reported to perform well in the standard supervised setting with all labels. We tested a few model architectures and selected ConvPool-CNN-C by Springenberg et al. (2014). We also evaluated the strided convolutional version by Springenberg et al. (2014), and while it performed well with all labels, we found that the max-pooling version overfitted less with fewer labels, and thus used it.\nThe main differences to ConvPool-CNN-C are the use of Gaussian noise instead of dropout and the convolutional per-channel batch normalization following Ioffe and Szegedy (2015). While dropout\n6In general, fully convolutional networks excel in MNIST classification task. The performance of the fully supervised Conv-Small with all labels is in line with the literature and is provided as a rough reference only (only one run, no attempts to optimize, not available in the code package).\nwas useful with all labels, it did not seem to offer any advantage over additive Gaussian noise with less labels. For a more detailed description of the model, please refer to model Conv-Large in Table 4.\nWhile testing the model performance with a limited number of labeled samples (N = 4 000), we found out that the model over-fitted quite severely: training error for most samples decreased so much that the network did not effectively learn anything from them as the network was already very confident about their classification. The network was equally confident about validation samples even when they were misclassified. We noticed that we could regularize the network by stripping away the scaling parameter \u03b2(L) from the last layer. This means that the variance of the input to the softmax is restricted to unity. We also used this setting with the corresponding \u0393-model although the denoising target already regularizes the network significantly and the improvement was not as pronounced.\nThe hyperparameters (noise level, denoising cost multipliers and number of epochs) for all models were optimized using M = 40 000 samples for training and the remaining 10 000 samples for validation. After the best hyperparameters were selected, the final model was trained with these settings on all the M = 50 000 samples. All experiments were run with with 5 different random initializations of the weight matrices and data splits. We applied global contrast normalization and whitening following Goodfellow et al. (2013b), but no data augmentation was used.\nThe results are shown in Table 3. The supervised reference was obtained with a model closer to the original ConvPool-CNN-C in the sense that dropout rather than additive Gaussian noise was used for regularization.7 We spent some time in tuning the regularization of our fully supervised baseline model for N = 4 000 labels and indeed, its results exceed the previous state of the art. This tuning was important to make sure that the improvement offered by the denoising target of the \u0393-model is not a sign of poorly regularized baseline model. Although the improvement is not as dramatic as with MNIST experiments, it came with a very simple addition to standard supervised training."}, {"heading": "5 Related Work", "text": "Early works in semi-supervised learning (McLachlan, 1975; Titterington et al., 1985) proposed an approach where inputs x are first assigned to clusters, and each cluster has its class label. Unlabeled data would affect the shapes and sizes of the clusters, and thus alter the classification result. This approach can be reinterpreted as input vectors being corrupted copies x\u0303 of the ideal input vectors x (the cluster centers), and the classification mapping being split into two parts: first denoising x\u0303 into x (possibly probabilistically), and then labeling x.\nIt is well known (see, e.g., Zhang and Oles, 2000) that when training a probabilistic model that directly estimates P (y | x), unlabeled data cannot help. One way to study this is to assign probabilistic labels q(yt) = P (yt | xt) to unlabeled inputs xt and try to train P (y | x) using those labels: It can be shown (see, e.g., Raiko et al., 2015, Eq. (31)) that the gradient will vanish. There are different ways of circumventing that phenomenon by adjusting the assigned labels q(yt). These are all related to the \u0393-model.\nLabel propagation methods (Szummer and Jaakkola, 2003) estimate P (y | x), but adjust probabilistic labels q(yt) based on the assumption that nearest neighbors are likely to have the same label. The labels start to propagate through regions with high density P (x). The \u0393-model implicitly assumes\n7Same caveats hold for this fully supervised reference result for all labels as with MNIST: only one run, no attempts to optimize, not available in the code package.\nthat the labels are uniform in the vicinity of a clean input since corrupted inputs need to produce the same label. This produces a similar effect: The labels start to propagate through regions with high density P (x). Weston et al. (2012) explored deep versions of label propagation.\nCo-training (Blum and Mitchell, 1998) assumes we have multiple views on x, say x = (x(1),x(2)). When we train classifiers for the different views, we know that even for the unlabeled data, the true label is the same for each view. Each view produces its own probabilistic labeling q(j)(yt) = P (yt | x (j) t ) and their combination q(yt) can be fed to train the individual classifiers. If we interpret having several corrupted copies of an input as different views on it, we see the relationship to the proposed method.\nLee (2013) adjusts the assigned labels q(yt) by rounding the probability of the most likely class to one and others to zero. The training starts by trusting only the true labels and then gradually increasing the weight of the so called pseudo-labels. Similar scheduling could be tested with our \u0393-model as it seems to suffer from confirmation bias. It may well be that the denoising cost which is optimal in the beginning of the learning is smaller than the optimal at later stages of learning.\nDosovitskiy et al. (2014) pre-train a convolutional network with unlabeled data by treating each clean image as its own class. During training, the image is corrupted by transforming its location, scaling, rotation, contrast, and color. This helps to find features that are invariant to the used transformations. Discarding the last classification layer and replacing it with a new classifier trained on real labeled data leads to surprisingly good experimental results.\nThere is an interesting connection between our \u0393-model and the contractive cost used by Rifai et al. (2011a): a linear denoising function z\u0302(L)i = aiz\u0303 (L) i + bi, where ai and bi are parameters, turns the denoising cost into a stochastic estimate of the contractive cost. In other words, our \u0393-model seems to combine clustering and label propagation with regularization by contractive cost.\nRecently Miyato et al. (2015) achieved impressive results with a regularization method that is similar to the idea of contractive cost. They required the output of the network to change as little as possible close to the input samples. As this requires no labels, they were able to use unlabeled samples for regularization. While their semi-supervised results were not as good as ours with a denoising target at the input layer, their results with full labels come very close. Their cost function is at the last layer which suggests that the approaches are complementary and could be combined, potentially further improving the results.\nSo far we have reviewed semi-supervised methods which have an unsupervised cost function at the output layer only and therefore are related to our \u0393-model. We will now move to other semisupervised methods that concentrate on modeling the joint distribution of the inputs and the labels.\nThe Multi-prediction deep Boltzmann machine (MP-DBM) (Goodfellow et al., 2013a) is a way to train a DBM with backpropagation through variational inference. The targets of the inference include both supervised targets (classification) and unsupervised targets (reconstruction of missing inputs) that are used in training simultaneously. The connections through the inference network are somewhat analogous to our lateral connections. Specifically, there are inference paths from observed inputs to reconstructed inputs that do not go all the way up to the highest layers. Compared to our approach, MP-DBM requires an iterative inference with some initialization for the hidden activations, whereas in our case, the inference is a simple single-pass feedforward procedure.\nThe Deep AutoRegressive Network (Gregor et al., 2014) is an unsupervised method for learning representations that also uses lateral connections in the hidden representations. The connectivity within the layer is rather different from ours, though: Each unit hi receives input from the preceding units h1 . . . hi\u22121, whereas in our case each unit z\u0302i receives input only from zi. Their learning algorithm is based on approximating a gradient of a description length measure, whereas we use a gradient of a simple loss function.\nKingma et al. (2014) proposed deep generative models for semi-supervised learning, based on variational autoencoders. Their models can be trained either with the variational EM algorithm, stochastic gradient variational Bayes, or stochastic backpropagation. They also experimented on a stacked version (called M1+M2) where the bottom autoencoder M1 reconstructs the input data, and the top autoencoder M2 can concentrate on classification and on reconstructing only the hidden representation of M1. The stacked version performed the best, hinting that it might be important not to\ncarry all the information up to the highest layers. Compared with the Ladder network, an interesting point is that the variational autoencoder computes the posterior estimate of the latent variables with the encoder alone while the Ladder network uses the decoder, too, to compute an implicit posterior approximate (encoder provides the likelihood part which gets combined with the prior). It will be interesting to see whether the approaches can be combined. A Ladder-style decoder might provide the posterior and another decoder could then act as the generative model of variational autoencoders.\nZeiler et al. (2011) train deep convolutional autoencoders in a manner comparable to ours. They define max-pooling operations in the encoder to feed the max function upwards to the next layer, while the argmax function is fed laterally to the decoder. The network is trained one layer at a time using a cost function that includes a pixel-level reconstruction error, and a regularization term to promote sparsity. Zhao et al. (2015) use a similar structure and call it the stacked what-where autoencoder (SWWAE). Their network is trained simultaneously to minimize a combination of the supervised cost and reconstruction errors on each level, just like ours.\nRecently Bengio (2014) proposed target propagation as an alternative to backpropagation. The idea is to base learning not on errors and gradients but on expectations. This is very similar to the idea of denoising source separation and therefore resembles the propagation of expectations in the decoder of the Ladder network. In the Ladder network, the additional lateral connections between the encoder and the decoder play an important role and it will remain to be seen whether the lateral connections are compatible with target propagation. Nevertheless, it is an interesting possibility that while the Ladder network includes two mechanisms for propagating information, backpropagation of gradients and forward propagation of expectations in the decoder, it may be possible to rely solely on the latter, avoiding problems related to propagation of gradients through many layers, such as exploding gradients."}, {"heading": "6 Discussion", "text": "We showed how a simultaneous unsupervised learning task improves CNN and MLP networks reaching the state-of-the-art in various semi-supervised learning tasks. Particularly the performance obtained with very small numbers of labels is much better than previous published results which shows that the method is capable of making good use of unsupervised learning. However, the same model also achieves state-of-the-art results and a significant improvement over the baseline model with full labels in permutation invariant MNIST classification which suggests that the unsupervised task does not disturb supervised learning.\nThe proposed model is simple and easy to implement with many existing feedforward architectures, as the training is based on backpropagation from a simple cost function. It is quick to train and the convergence is fast, especially with batch normalization.\nNot surprisingly, largest improvements in performance were observed in models which have a large number of parameters relative to the number of available labeled samples. With CIFAR-10, we started with a model which was originally developed for a fully supervised task. This has the benefit of building on existing experience but it may well be that the best results will be obtained with models which have far more parameters than fully supervised approaches could handle.\nAn obvious future line of research will therefore be to study what kind of encoders and decoders are best suited for the Ladder network. In this work, we made very little modifications to the encoders whose structure has been optimized for supervised learning and we designed the parametrization of the vertical mappings of the decoder to mirror the encoder: the flow of information is just reversed. There is nothing preventing the decoder to have a different structure than the encoder. Also, there were lateral connections from the encoder to the decoder on every layer and on every pooling operation. The miniature MLP used for every denoising function g gives the decoder enough capacity to invert the mappings but the same effect could have been accomplished by not requiring the decoder to match the activations of the encoder on every layer.\nA particularly interesting future line of research will be the extension of the Ladder networks to the temporal domain. While there exist datasets with millions of labeled samples for still images, it is prohibitively costly to label thousands of hours of video streams. The Ladder network can be scaled up easily and therefore offers an attractive approach for semi-supervised learning in such large-scale problems."}, {"heading": "Acknowledgements", "text": "We have received comments and help from a number of colleagues who would all deserve to be mentioned but we wish to thank especially Yann LeCun, Diederik Kingma, Aaron Courville and Ian Goodfellow for their helpful comments and suggestions. The software for the simulations for this paper was based on Theano (Bastien et al., 2012; Bergstra et al., 2010) and Blocks (van Merrie\u0308nboer et al., 2015). We also acknowledge the computational resources provided by the Aalto Science-IT project. The Academy of Finland has supported Tapani Raiko."}, {"heading": "A Specification of the convolutional models", "text": "Here we describe two model structures, Conv-Small and Conv-Large, that were used for MNIST and CIFAR-10 datasets, respectively. They were both inspired by ConvPool-CNN-C by Springenberg et al. (2014). Table 4 details the model architectures and differences between the models in this work and ConvPool-CNN-C. It is noteworthy that this architecture does not use any fully connected layers, but replaces them with a global mean pooling layer just before the softmax function. The main differences between our models and ConvPool-CNN-C are the use of Gaussian noise instead of dropout and the convolutional per-channel batch normalization following Ioffe and Szegedy (2015). We also used 2x2 stride 2 max-pooling instead of 3x3 stride 2 max-pooling. LeakyReLU was used to speed up training, as mentioned by Springenberg et al. (2014). We utilized batch normalization in all layers, including pooling layers. Gaussian noise was also added to all layers, instead of applying dropout in only some of the layers as with ConvPool-CNN-C."}, {"heading": "B Formulation of the Denoising Function", "text": "The denoising function g tries to map the clean z(l) to the reconstructed z\u0302(l), where z\u0302(l) = g(z\u0303(l), z\u0302(l+1)). The reconstruction is therefore based on the corrupted value, and the reconstruction of the layer above.\nAn optimal functional form of g depends on the conditional distribution p(z(l) | z(l+1)). For example, if the distribution p(z(l) | z(l+1)) is Gaussian, the optimal function g, that is the function that achieves the lowest reconstruction error, is going to be linear with respect to z\u0303(l) (Valpola, 2015, Section 4.1).\nWhen analyzing the distribution p(z(l) | z(l+1)) learned by a purely supervised network, it would therefore be desirable to parametrize g in such a way as to be able to optimally denoise the kinds of distributions the network has found for the hidden activations.\nIn our preliminary analyses of the distributions learned by the hidden layers, we found many different very non-Gaussian distributions that we wanted the g-function to be able to denoise. One example were bimodal distributions, that were often observed in the layer below the final classification layer. We could also observe that in many cases, the value of z(l+1) had an impact on p(z(l) | z(l+1)) beyond shifting the mean of the distribution, which led us to propose a form where the vertical connections from z\u0302(l+1) could modulate the horizontal connections from z\u0303(l) instead of only additively shifting the distribution defined by g. This corresponds to letting the variance and other higher-order cumulants of z(l) depend on z\u0302(l+1).\nBased on this analysis, we proposed the following parametrization for g: z\u0302 = g(z\u0303, u) = a\u03be + bsigmoid(c\u03be) (3)\nwhere \u03be = [1, z\u0303, u, z\u0303u]T is the augmented input, a and c are trainable weight vectors, b is a trainable scalar weight. We have left out the superscript (l) and subscript i in order not to clutter the equations8. This corresponds to a miniature MLP network as explained in Section 3.3.\nIn order to test whether the elements of the proposed function g were necessary, we systematically removed components from g or changed g altogether and compared to the results obtained with the original parametrization. We tuned the hyperparameters of each comparison model separately using a grid search over some of the relevant hyperparameters. However, the std of additive Gaussian corruption noise was set to 0.3. This means that with N = 1000 labels, the comparison does not include the best-performing model reported in Table 1.\nAs in the proposed function g, all comparison denoising functions mapped neuron-wise the corrupted hidden layer pre-activation z\u0303(l) to the reconstructed hidden layer activation given one projection from the reconstruction of the layer above: z\u0302(l)i = g(z\u0303 (l) i , u (l) i ).\nThe comparison functions g2...5 are parametrized as follows:\nComparison g2: No augmented term g2(z\u0303, u) = a\u03be\n\u2032 + bsigmoid(c\u03be\u2032) (4) where \u03be\u2032 = [1, z\u0303, u]T . g2 therefore differs from g in that the input lacks the augmented term z\u0303u. In the original formulation, the augmented term was expected to increase the freedom of the denoising to modulate the distribution of z by u. However, we wanted to test the effect on the results.\nComparison g3: Linear g g3(z\u0303, u) = a\u03be. (5) g3 differs from g in that it is linear and does not have a sigmoid term. As this formulation is linear, it only supports Gaussian distributions. Although the parametrization has the augmented term that lets u modulate the slope and shift of the distribution, the scope of possible denoising functions is still fairly limited.\nComparison g4: u affects only the mean of p(z | u) g4(z\u0303, u) = a1u+ a2sigmoid(a3u+ a4) + a5z\u0303 + a6sigmoid(a7z\u0303 + a8) + a9 (6)\ng4 differs from g in that the inputs from u are not allowed to modulate the terms that depend on z\u0303, but that the effect is additive. This means that the parametrization only supports optimal denoising functions for a conditional distribution p(z | u) where u only shifts the mean of the distribution of z but otherwise leaves the shape of the distribution intact.\nComparison g5: Gaussian z As reviewed by Valpola (2015, Section 4.1), assuming z is Gaussian given u, the optimal denoising can be represented as\ng5(z\u0303, u) = (z\u0303 \u2212 \u00b5(u)) \u03c5(u) + \u00b5(u) . (7) We modeled both \u00b5(u) and \u03c5(u) with a miniature MLP network: \u00b5(u) = a1sigmoid(a2u+ a3) + a4u + a5 and \u03c5(u) = a6sigmoid(a7u + a8) + a9u + a10. Given u, this parametrization is linear with respect to z\u0303, and both the slope and the bias depended nonlinearly on u.\n8For the exact definition, see Eq. (1).\nResults All models were tested in a similar setting as the semi-supervised fully connected MNIST task usingN = 1000 labeled samples. We also reran the best comparison model onN = 100 labels. The results of the analyses are presented in Table 5.\nAs can be seen from the table, the alternative parametrizations of g are mostly inferior to the proposed parametrizations at least in the model structure we use. A notable exception is the denoising function g5 which corresponds to a Gaussian model of z. Although the difference is small, it actually achieved the best performance with both N = 100 labels and N = 1000 labels. It therefore looks like using two miniature MLPs, one for the mean and the other for the variance of a Gaussian denoising model, offers a slight benefit over a single miniature MLP that was used in the experiments in Section 4.\nNote that even if p(z|u) is Gaussian given u, its marginal p(z) is typically non-Gaussian. A conditionally Gaussian p(z|u) which was implicitly used in g5 forces the network to represent any non-Gaussian distributions with higher-level hidden neurons and these may well turn out to be useful features. For instance, if the marginal p(z) is a mixture of Gaussian distributions, higher levels have a pressure to represent the mixture index because then p(z|u) would be Gaussian and the denoising g5 optimal as long as the higher layer represents the index information in such a way that g5 can decode it from u.\nIn any case, these results support the finding by Rasmus et al. (2015a) that modulation of the lateral connection from z\u0303 to z\u0302 by u is critical for encouraging the development of invariant representation in the higher layers of the model. Comparison function g4 lacked this modulation and it performed clearly worse than any other denoising function listed in Table 5. Even the linear g3 performed very well as long it had the term z\u0303u. Leaving the nonlinearity but removing z\u0303u in g2 hurt the performance much more.\nIn addition to the alternative parametrizations for the g-function, we ran experiments using a more standard autoencoder structure. In that structure, we attached an additional decoder to the standard MLP by using one hidden layer as the input to the decoder, and the reconstruction of the clean input as the target. The structure of the decoder was set to be the same as the encoder, that is the number and size of the layers from the input to the hidden layer where the decoder was attached was the same as the number and size of the layers in the decoder. The final activation function in the decoder was set to be the sigmoid nonlinearity. During training, the target was the weighted sum of the reconstruction cost and the classification cost.\nWe tested the autoencoder structure with 100 and 1000 labeled samples. We ran experiments for all possible decoder lengths, that is we tried attaching the decoder to all hidden layers. However, we did not manage to get significantly better performance than the standard supervised model without any decoder in any of the experiments."}], "references": [{"title": "Theano: new features and speed improvements", "author": ["F. Bastien", "P. Lamblin", "R. Pascanu", "J. Bergstra", "I.J. Goodfellow", "A. Bergeron", "N. Bouchard", "Y. Bengio"], "venue": "Deep Learning and Unsupervised Feature Learning NIPS 2012 Workshop.", "citeRegEx": "Bastien et al\\.,? 2012", "shortCiteRegEx": "Bastien et al\\.", "year": 2012}, {"title": "How auto-encoders could provide credit assignment in deep networks via target propagation", "author": ["Y. Bengio"], "venue": "arXiv:1407.7906.", "citeRegEx": "Bengio,? 2014", "shortCiteRegEx": "Bengio", "year": 2014}, {"title": "Generalized denoising auto-encoders as generative models", "author": ["Y. Bengio", "L. Yao", "G. Alain", "P. Vincent"], "venue": "C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 26 (NIPS 2013), pages 899\u2013907.", "citeRegEx": "Bengio et al\\.,? 2013", "shortCiteRegEx": "Bengio et al\\.", "year": 2013}, {"title": "Theano: a CPU and GPU math expression compiler", "author": ["J. Bergstra", "O. Breuleux", "F. Bastien", "P. Lamblin", "R. Pascanu", "G. Desjardins", "J. Turian", "D. WardeFarley", "Y. Bengio"], "venue": "Proceedings of the Python for Scientific Computing Conference (SciPy 2010). Oral Presentation.", "citeRegEx": "Bergstra et al\\.,? 2010", "shortCiteRegEx": "Bergstra et al\\.", "year": 2010}, {"title": "Combining labeled and unlabeled data with co-training", "author": ["A. Blum", "T. Mitchell"], "venue": "Proc. of the eleventh annual conference on Computational learning theory (COLT \u201998), pages 92\u2013100.", "citeRegEx": "Blum and Mitchell,? 1998", "shortCiteRegEx": "Blum and Mitchell", "year": 1998}, {"title": "Discriminative unsupervised feature learning with convolutional neural networks", "author": ["A. Dosovitskiy", "J.T. Springenberg", "M. Riedmiller", "T. Brox"], "venue": "Advances in Neural Information Processing Systems 27 (NIPS 2014), pages 766\u2013774.", "citeRegEx": "Dosovitskiy et al\\.,? 2014", "shortCiteRegEx": "Dosovitskiy et al\\.", "year": 2014}, {"title": "Large-scale feature learning with spikeand-slab sparse coding", "author": ["I. Goodfellow", "Y. Bengio", "A.C. Courville"], "venue": "Proc. of ICML 2012, pages 1439\u20131446.", "citeRegEx": "Goodfellow et al\\.,? 2012", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2012}, {"title": "Multi-prediction deep Boltzmann machines", "author": ["I. Goodfellow", "M. Mirza", "A. Courville", "Y. Bengio"], "venue": "Advances in Neural Information Processing Systems 26 (NIPS 2013), pages 548\u2013 556.", "citeRegEx": "Goodfellow et al\\.,? 2013a", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2013}, {"title": "Explaining and harnessing adversarial examples", "author": ["I. Goodfellow", "J. Shlens", "C. Szegedy"], "venue": "the International Conference on Learning Representations (ICLR 2015). arXiv:1412.6572.", "citeRegEx": "Goodfellow et al\\.,? 2015", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2015}, {"title": "Maxout networks", "author": ["I.J. Goodfellow", "D. Warde-Farley", "M. Mirza", "A. Courville", "Y. Bengio"], "venue": "Proc. of ICML 2013.", "citeRegEx": "Goodfellow et al\\.,? 2013b", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2013}, {"title": "Deep autoregressive networks", "author": ["K. Gregor", "I. Danihelka", "A. Mnih", "C. Blundell", "D. Wierstra"], "venue": "Proc. of ICML 2014, Beijing, China.", "citeRegEx": "Gregor et al\\.,? 2014", "shortCiteRegEx": "Gregor et al\\.", "year": 2014}, {"title": "Reducing the dimensionality of data with neural networks", "author": ["G.E. Hinton", "R.R. Salakhutdinov"], "venue": "Science, 313(5786), 504\u2013507.", "citeRegEx": "Hinton and Salakhutdinov,? 2006", "shortCiteRegEx": "Hinton and Salakhutdinov", "year": 2006}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["S. Ioffe", "C. Szegedy"], "venue": "arXiv:1502.03167.", "citeRegEx": "Ioffe and Szegedy,? 2015", "shortCiteRegEx": "Ioffe and Szegedy", "year": 2015}, {"title": "Adam: A method for stochastic optimization", "author": ["D. Kingma", "J. Ba"], "venue": "the International Conference on Learning Representations (ICLR 2015), San Diego. arXiv:1412.6980.", "citeRegEx": "Kingma and Ba,? 2015", "shortCiteRegEx": "Kingma and Ba", "year": 2015}, {"title": "Semi-supervised learning with deep generative models", "author": ["D.P. Kingma", "S. Mohamed", "D.J. Rezende", "M. Welling"], "venue": "Advances in Neural Information Processing Systems 27 (NIPS 2014), pages 3581\u20133589.", "citeRegEx": "Kingma et al\\.,? 2014", "shortCiteRegEx": "Kingma et al\\.", "year": 2014}, {"title": "Pseudo-label: The simple and efficient semi-supervised learning method for deep neural networks", "author": ["Lee", "D.-H."], "venue": "Workshop on Challenges in Representation Learning, ICML 2013.", "citeRegEx": "Lee and D..H.,? 2013", "shortCiteRegEx": "Lee and D..H.", "year": 2013}, {"title": "Iterative reclassification procedure for constructing an asymptotically optimal rule of allocation in discriminant analysis", "author": ["G. McLachlan"], "venue": "J. American Statistical Association, 70, 365\u2013369.", "citeRegEx": "McLachlan,? 1975", "shortCiteRegEx": "McLachlan", "year": 1975}, {"title": "Distributional smoothing by virtual adversarial examples. arXiv:1507.00677", "author": ["T. Miyato", "S. ichi Maeda", "M. Koyama", "K. Nakae", "S. Ishii"], "venue": null, "citeRegEx": "Miyato et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Miyato et al\\.", "year": 2015}, {"title": "Semi-supervised learning using an unsupervised atlas", "author": ["N. Pitelis", "C. Russell", "L. Agapito"], "venue": "Machine Learning and Knowledge Discovery in Databases (ECML PKDD 2014), pages 565\u2013580. Springer.", "citeRegEx": "Pitelis et al\\.,? 2014", "shortCiteRegEx": "Pitelis et al\\.", "year": 2014}, {"title": "Techniques for learning binary stochastic feedforward neural networks", "author": ["T. Raiko", "M. Berglund", "G. Alain", "L. Dinh"], "venue": "ICLR 2015, San Diego.", "citeRegEx": "Raiko et al\\.,? 2015", "shortCiteRegEx": "Raiko et al\\.", "year": 2015}, {"title": "Semi-supervised learning of compact document representations with deep networks", "author": ["M.A. Ranzato", "M. Szummer"], "venue": "Proc. of ICML 2008, pages 792\u2013799. ACM.", "citeRegEx": "Ranzato and Szummer,? 2008", "shortCiteRegEx": "Ranzato and Szummer", "year": 2008}, {"title": "Denoising autoencoder with modulated lateral connections learns invariant representations of natural images", "author": ["A. Rasmus", "T. Raiko", "H. Valpola"], "venue": "arXiv:1412.7210.", "citeRegEx": "Rasmus et al\\.,? 2015a", "shortCiteRegEx": "Rasmus et al\\.", "year": 2015}, {"title": "Lateral connections in denoising autoencoders support supervised learning", "author": ["A. Rasmus", "H. Valpola", "T. Raiko"], "venue": "arXiv:1504.08215.", "citeRegEx": "Rasmus et al\\.,? 2015b", "shortCiteRegEx": "Rasmus et al\\.", "year": 2015}, {"title": "Higher order contractive auto-encoder", "author": ["S. Rifai", "G. Mesnil", "P. Vincent", "X. Muller", "Y. Bengio", "Y. Dauphin", "X. Glorot"], "venue": "ECML PKDD 2011.", "citeRegEx": "Rifai et al\\.,? 2011a", "shortCiteRegEx": "Rifai et al\\.", "year": 2011}, {"title": "The manifold tangent classifier", "author": ["S. Rifai", "Y.N. Dauphin", "P. Vincent", "Y. Bengio", "X. Muller"], "venue": "Advances in Neural Information Processing Systems 24 (NIPS 2011), pages 2294\u2013 2302.", "citeRegEx": "Rifai et al\\.,? 2011b", "shortCiteRegEx": "Rifai et al\\.", "year": 2011}, {"title": "Denoising source separation", "author": ["J. S\u00e4rel\u00e4", "H. Valpola"], "venue": "JMLR, 6, 233\u2013272.", "citeRegEx": "S\u00e4rel\u00e4 and Valpola,? 2005", "shortCiteRegEx": "S\u00e4rel\u00e4 and Valpola", "year": 2005}, {"title": "Creating artificial neural networks that generalize", "author": ["J. Sietsma", "R.J. Dow"], "venue": "Neural networks, 4(1), 67\u201379.", "citeRegEx": "Sietsma and Dow,? 1991", "shortCiteRegEx": "Sietsma and Dow", "year": 1991}, {"title": "Striving for simplicity: The all convolutional net", "author": ["J.T. Springenberg", "A. Dosovitskiy", "T. Brox", "M.A. Riedmiller"], "venue": "arxiv:1412.6806.", "citeRegEx": "Springenberg et al\\.,? 2014", "shortCiteRegEx": "Springenberg et al\\.", "year": 2014}, {"title": "Dropout: A simple way to prevent neural networks from overfitting", "author": ["N. Srivastava", "G. Hinton", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"], "venue": "JMLR, 15(1), 1929\u20131958.", "citeRegEx": "Srivastava et al\\.,? 2014", "shortCiteRegEx": "Srivastava et al\\.", "year": 2014}, {"title": "Rule-injection hints as a means of improving network performance and learning time", "author": ["S.C. Suddarth", "Y. Kergosien"], "venue": "Proceedings of the EURASIP Workshop 1990 on Neural Networks, pages 120\u2013129. Springer.", "citeRegEx": "Suddarth and Kergosien,? 1990", "shortCiteRegEx": "Suddarth and Kergosien", "year": 1990}, {"title": "Partially labeled classification with Markov random walks", "author": ["M. Szummer", "T. Jaakkola"], "venue": "Advances in Neural Information Processing Systems 15 (NIPS 2002), 14, 945\u2013952.", "citeRegEx": "Szummer and Jaakkola,? 2003", "shortCiteRegEx": "Szummer and Jaakkola", "year": 2003}, {"title": "Statistical analysis of finite mixture distributions", "author": ["D. Titterington", "A. Smith", "U. Makov"], "venue": "Wiley Series in Probability and Mathematical Statistics. Wiley.", "citeRegEx": "Titterington et al\\.,? 1985", "shortCiteRegEx": "Titterington et al\\.", "year": 1985}, {"title": "From neural PCA to deep unsupervised learning", "author": ["H. Valpola"], "venue": "Adv. in Independent Component Analysis and Learning Machines, pages 143\u2013171. Elsevier. arXiv:1411.7783.", "citeRegEx": "Valpola,? 2015", "shortCiteRegEx": "Valpola", "year": 2015}, {"title": "Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion", "author": ["P. Vincent", "H. Larochelle", "I. Lajoie", "Y. Bengio", "Manzagol", "P.-A."], "venue": "JMLR, 11, 3371\u20133408.", "citeRegEx": "Vincent et al\\.,? 2010", "shortCiteRegEx": "Vincent et al\\.", "year": 2010}, {"title": "Deep learning via semi-supervised embedding", "author": ["J. Weston", "F. Ratle", "H. Mobahi", "R. Collobert"], "venue": "Neural Networks: Tricks of the Trade, pages 639\u2013655. Springer.", "citeRegEx": "Weston et al\\.,? 2012", "shortCiteRegEx": "Weston et al\\.", "year": 2012}, {"title": "Adaptive deconvolutional networks for mid and high level feature learning", "author": ["M.D. Zeiler", "G.W. Taylor", "R. Fergus"], "venue": "ICCV 2011, pages 2018\u20132025. IEEE.", "citeRegEx": "Zeiler et al\\.,? 2011", "shortCiteRegEx": "Zeiler et al\\.", "year": 2011}, {"title": "The value of unlabeled data for classification problems", "author": ["T. Zhang", "F. Oles"], "venue": "Proc. of ICML 2000, pages 1191\u20131198.", "citeRegEx": "Zhang and Oles,? 2000", "shortCiteRegEx": "Zhang and Oles", "year": 2000}, {"title": "Stacked what-where auto-encoders", "author": ["J. Zhao", "M. Mathieu", "R. Goroshin", "Y. Lecun"], "venue": "arXiv:1506.02351.", "citeRegEx": "Zhao et al\\.,? 2015", "shortCiteRegEx": "Zhao et al\\.", "year": 2015}, {"title": "We utilized batch normalization in all layers, including pooling layers. Gaussian noise was also added to all layers, instead of applying dropout in only some of the layers as with ConvPool-CNN-C. B Formulation of the Denoising Function The denoising function g tries to map the clean z to the reconstructed \u1e91", "author": ["Springenberg"], "venue": null, "citeRegEx": "Springenberg,? \\Q2014\\E", "shortCiteRegEx": "Springenberg", "year": 2014}], "referenceMentions": [{"referenceID": 32, "context": "Our work builds on top of the Ladder network proposed by Valpola (2015) which we extend by combining the model with supervision.", "startOffset": 57, "endOffset": 72}, {"referenceID": 5, "context": ", Ranzato and Szummer, 2008) or classification of each input sample into its own class (Dosovitskiy et al., 2014).", "startOffset": 87, "endOffset": 113}, {"referenceID": 27, "context": "Combining an auxiliary task to help train a neural network was proposed by Suddarth and Kergosien (1990). By sharing the hidden representations among more than one task, the network generalizes better.", "startOffset": 75, "endOffset": 105}, {"referenceID": 20, "context": "Although some methods have been able to simultaneously apply both supervised and unsupervised learning (Ranzato and Szummer, 2008; Goodfellow et al., 2013a), often these unsupervised auxiliary tasks are only applied as pre-training, followed by normal supervised learning (e.", "startOffset": 103, "endOffset": 156}, {"referenceID": 7, "context": "Although some methods have been able to simultaneously apply both supervised and unsupervised learning (Ranzato and Szummer, 2008; Goodfellow et al., 2013a), often these unsupervised auxiliary tasks are only applied as pre-training, followed by normal supervised learning (e.", "startOffset": 103, "endOffset": 156}, {"referenceID": 32, "context": "Previously the Ladder network has only been demonstrated in unsupervised learning (Valpola, 2015; Rasmus et al., 2015a) but we now combine it with supervised learning.", "startOffset": 82, "endOffset": 119}, {"referenceID": 21, "context": "Previously the Ladder network has only been demonstrated in unsupervised learning (Valpola, 2015; Rasmus et al., 2015a) but we now combine it with supervised learning.", "startOffset": 82, "endOffset": 119}, {"referenceID": 30, "context": "Our approach follows Valpola (2015) who proposed a Ladder network where the auxiliary task is to denoise representations at every level of the model.", "startOffset": 21, "endOffset": 36}, {"referenceID": 6, "context": "This approach was taken, for instance, by Goodfellow et al. (2013a) with their multi-prediction deep Boltzmann machine.", "startOffset": 42, "endOffset": 68}, {"referenceID": 2, "context": "On the other hand, given a denoising function, one can draw samples from the corresponding distribution by creating a Markov chain that alternates between corruption and denoising (Bengio et al., 2013).", "startOffset": 180, "endOffset": 201}, {"referenceID": 22, "context": "Preliminary results on the full-labeled setting on permutation invariant MNIST task were reported in a short early version of this paper (Rasmus et al., 2015b).", "startOffset": 137, "endOffset": 159}, {"referenceID": 26, "context": "Valpola (2015) proposed the Ladder network where the inference process itself can be learned by using the principle of denoising which has been used in supervised learning (Sietsma and Dow, 1991), denoising autoencoders (dAE) (Vincent et al.", "startOffset": 172, "endOffset": 195}, {"referenceID": 33, "context": "Valpola (2015) proposed the Ladder network where the inference process itself can be learned by using the principle of denoising which has been used in supervised learning (Sietsma and Dow, 1991), denoising autoencoders (dAE) (Vincent et al., 2010) and denoising source separation (DSS) (S\u00e4rel\u00e4 and Valpola, 2005) for complementary tasks.", "startOffset": 226, "endOffset": 248}, {"referenceID": 25, "context": ", 2010) and denoising source separation (DSS) (S\u00e4rel\u00e4 and Valpola, 2005) for complementary tasks.", "startOffset": 46, "endOffset": 72}, {"referenceID": 21, "context": "Rasmus et al. (2015a) showed that such skip connections allow dAEs to focus on abstract invariant features on the higher levels, making the Ladder network a good fit with supervised learning that can select which information is relevant for the task at hand.", "startOffset": 0, "endOffset": 22}, {"referenceID": 12, "context": "We follow Ioffe and Szegedy (2015) to apply batch normalization to each preactivation including the topmost layer in the L-layer network.", "startOffset": 10, "endOffset": 35}, {"referenceID": 12, "context": "We follow Ioffe and Szegedy (2015) to apply batch normalization to each preactivation including the topmost layer in the L-layer network. This serves two purposes. First, it improves convergence due to reduced covariate shift as originally proposed by Ioffe and Szegedy (2015). Second, as explained in Section 2, DSS-type cost functions for all but the input layer require some type of normalization to prevent the denoising cost from encouraging the trivial solution where the encoder outputs just", "startOffset": 10, "endOffset": 277}, {"referenceID": 13, "context": "We used the Adam optimization algorithm (Kingma and Ba, 2015) for weight updates.", "startOffset": 40, "endOffset": 61}, {"referenceID": 34, "context": "Embedding (Weston et al., 2012) 16.", "startOffset": 10, "endOffset": 31}, {"referenceID": 24, "context": "40* MTC (Rifai et al., 2011b) 12.", "startOffset": 8, "endOffset": 29}, {"referenceID": 18, "context": "46 AtlasRBF (Pitelis et al., 2014) 8.", "startOffset": 12, "endOffset": 34}, {"referenceID": 14, "context": "31 DGN (Kingma et al., 2014) 3.", "startOffset": 7, "endOffset": 28}, {"referenceID": 28, "context": "96 DBM, Dropout (Srivastava et al., 2014) 0.", "startOffset": 16, "endOffset": 41}, {"referenceID": 8, "context": "79 Adversarial (Goodfellow et al., 2015) 0.", "startOffset": 15, "endOffset": 40}, {"referenceID": 17, "context": "78 Virtual Adversarial (Miyato et al., 2015) 2.", "startOffset": 23, "endOffset": 44}, {"referenceID": 34, "context": "Test error without data augmentation % with # of used labels 100 all EmbedCNN (Weston et al., 2012) 7.", "startOffset": 78, "endOffset": 99}, {"referenceID": 37, "context": "75 SWWAE (Zhao et al., 2015) 9.", "startOffset": 9, "endOffset": 28}, {"referenceID": 27, "context": "With the second network, which was inspired by ConvPool-CNN-C from Springenberg et al. (2014), we only tested the \u0393-model.", "startOffset": 67, "endOffset": 94}, {"referenceID": 27, "context": "We tested a few model architectures and selected ConvPool-CNN-C by Springenberg et al. (2014). We also evaluated the strided convolutional version by Springenberg et al.", "startOffset": 67, "endOffset": 94}, {"referenceID": 27, "context": "We tested a few model architectures and selected ConvPool-CNN-C by Springenberg et al. (2014). We also evaluated the strided convolutional version by Springenberg et al. (2014), and while it performed well with all labels, we found that the max-pooling version overfitted less with fewer labels, and thus used it.", "startOffset": 67, "endOffset": 177}, {"referenceID": 12, "context": "The main differences to ConvPool-CNN-C are the use of Gaussian noise instead of dropout and the convolutional per-channel batch normalization following Ioffe and Szegedy (2015). While dropout", "startOffset": 152, "endOffset": 177}, {"referenceID": 27, "context": "Test error % with # of used labels 4 000 All All-Convolutional ConvPool-CNN-C (Springenberg et al., 2014) 9.", "startOffset": 78, "endOffset": 105}, {"referenceID": 6, "context": "31 Spike-and-Slab Sparse Coding (Goodfellow et al., 2012) 31.", "startOffset": 32, "endOffset": 57}, {"referenceID": 6, "context": "We applied global contrast normalization and whitening following Goodfellow et al. (2013b), but no data augmentation was used.", "startOffset": 65, "endOffset": 91}, {"referenceID": 16, "context": "Early works in semi-supervised learning (McLachlan, 1975; Titterington et al., 1985) proposed an approach where inputs x are first assigned to clusters, and each cluster has its class label.", "startOffset": 40, "endOffset": 84}, {"referenceID": 31, "context": "Early works in semi-supervised learning (McLachlan, 1975; Titterington et al., 1985) proposed an approach where inputs x are first assigned to clusters, and each cluster has its class label.", "startOffset": 40, "endOffset": 84}, {"referenceID": 30, "context": "Label propagation methods (Szummer and Jaakkola, 2003) estimate P (y | x), but adjust probabilistic labels q(yt) based on the assumption that nearest neighbors are likely to have the same label.", "startOffset": 26, "endOffset": 54}, {"referenceID": 34, "context": "Weston et al. (2012) explored deep versions of label propagation.", "startOffset": 0, "endOffset": 21}, {"referenceID": 4, "context": "Co-training (Blum and Mitchell, 1998) assumes we have multiple views on x, say x = (x,x).", "startOffset": 12, "endOffset": 37}, {"referenceID": 23, "context": "There is an interesting connection between our \u0393-model and the contractive cost used by Rifai et al. (2011a): a linear denoising function \u1e91 i = aiz\u0303 (L) i + bi, where ai and bi are parameters, turns the denoising cost into a stochastic estimate of the contractive cost.", "startOffset": 88, "endOffset": 109}, {"referenceID": 17, "context": "Recently Miyato et al. (2015) achieved impressive results with a regularization method that is similar to the idea of contractive cost.", "startOffset": 9, "endOffset": 30}, {"referenceID": 7, "context": "The Multi-prediction deep Boltzmann machine (MP-DBM) (Goodfellow et al., 2013a) is a way to train a DBM with backpropagation through variational inference.", "startOffset": 53, "endOffset": 79}, {"referenceID": 10, "context": "The Deep AutoRegressive Network (Gregor et al., 2014) is an unsupervised method for learning representations that also uses lateral connections in the hidden representations.", "startOffset": 32, "endOffset": 53}, {"referenceID": 1, "context": "Recently Bengio (2014) proposed target propagation as an alternative to backpropagation.", "startOffset": 9, "endOffset": 23}, {"referenceID": 0, "context": "The software for the simulations for this paper was based on Theano (Bastien et al., 2012; Bergstra et al., 2010) and Blocks (van Merri\u00ebnboer et al.", "startOffset": 68, "endOffset": 113}, {"referenceID": 3, "context": "The software for the simulations for this paper was based on Theano (Bastien et al., 2012; Bergstra et al., 2010) and Blocks (van Merri\u00ebnboer et al.", "startOffset": 68, "endOffset": 113}], "year": 2015, "abstractText": "We combine supervised learning with unsupervised learning in deep neural networks. The proposed model is trained to simultaneously minimize the sum of supervised and unsupervised cost functions by backpropagation, avoiding the need for layer-wise pretraining. Our work builds on top of the Ladder network proposed by Valpola (2015) which we extend by combining the model with supervision. We show that the resulting model reaches state-of-the-art performance in various tasks: MNIST and CIFAR-10 classification in a semi-supervised setting and permutation invariant MNIST in both semi-supervised and full-labels setting.", "creator": "LaTeX with hyperref package"}}}