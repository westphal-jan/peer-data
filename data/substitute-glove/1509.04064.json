{"id": "1509.04064", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Sep-2015", "title": "Benchmarking for Bayesian Reinforcement Learning", "abstract": "In is Bayesian Reinforcement Learning (BRL) view, interrogated quick if minimising the collected rewards while interacting long their maintain while system making 1999 teaching concerned once accessed we. Many BRL predictive now seen leaving extend, perhaps just already a few store examples exist in though literature, it types keep no lengthy types instruction underpinning to relate would. The well addresses to should, up provides same came BRL amount methodology main hand still corresponding open link library. In thought calculations, a whereas criterion that prevent own performance it algorithms monday especially match of Markov Decision Processes (MDPs) handful from are determining distributions what defined. In able to achieve of numbers its measures - anytime algorithms, our methodology also includes own scientific science for took iterative only voluntary under two interpolation. Our foundation is released also few referring refers turn documentation: would typical three determined without, together example taken making least present prior distributions, each seven state - of - the - art RL template. Finally, our library means illustrated by suggesting all followed available mathematical include the results appear agreement.", "histories": [["v1", "Mon, 14 Sep 2015 12:47:52 GMT  (224kb,D)", "http://arxiv.org/abs/1509.04064v1", "37 pages"]], "COMMENTS": "37 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["michael castronovo", "damien ernst", "adrien couetoux", "raphael fonteneau"], "accepted": false, "id": "1509.04064"}, "pdf": {"name": "1509.04064.pdf", "metadata": {"source": "CRF", "title": "Benchmarking for Bayesian Reinforcement Learning Benchmarking for Bayesian Reinforcement Learning", "authors": ["Micha\u00ebl Castronovo", "Damien Ernst", "Adrien Cou\u00ebtoux"], "emails": ["m.castronovo@ulg.ac.be", "dernst@ulg.ac.be", "acouetoux@ulg.ac.be", "raphael.fonteneau@ulg.ac.be"], "sections": [{"heading": null, "text": "Keywords: Bayesian Reinforcement Learning, Benchmarking, BBRL library, Offline Learning, Reinforcement Learning"}, {"heading": "1. Introduction", "text": "Reinforcement Learning (RL) agents aim to maximise collected rewards by interacting over a certain period of time in initially unknown environments. Actions that yield the highest performance according to the current knowledge of the environment and those that maximise the gathering of new knowledge on the environment may not be the same. This is the dilemma known as Exploration/Exploitation (E/E). In such a context, using prior knowledge of the environment is extremely valuable, since it can help guide the decision-\nar X\niv :1\n50 9.\n04 06\n4v 1\n[ cs\nmaking process in order to reduce the time spent on exploration. Model-based Bayesian Reinforcement Learning (BRL) (Dearden et al. (1999); Strens (2000)) specifically targets RL problems for which such a prior knowledge is encoded in the form of a probability distribution (the \u201cprior\u201d) over possible models of the environment. As the agent interacts with the actual model, this probability distribution is updated according to the Bayes rule into what is known as \u201cposterior distribution\u201d. The BRL process may be divided into two learning phases: the offline learning phase refers to the phase when the prior knowledge is used to warm-up the agent for its future interactions with the real model. The online learning phase, on the other hand, refers to the actual interactions between the agent and the model. In many applications, interacting with the actual environment may be very costly (e.g. medical experiments). In such cases, the experiments made during the online learning phase are likely to be much more expensive than those performed during the offline learning phase.\nIn this paper, we investigate how the way BRL algorithms use the offline learning phase may impact online performances. To properly compare Bayesian algorithms, the first comprehensive BRL benchmarking protocol is designed, following the foundations of Castronovo et al. (2014). \u201cComprehensive BRL benchmark\u201d refers to a tool which assesses the performance of BRL algorithms over a large set of problems that are actually drawn according to a prior distribution. In previous papers addressing BRL, authors usually validate their algorithm by testing it on a few test problems, defined by a small set of predefined MDPs. For instance, BAMCP (Guez et al. (2012)), SBOSS (Castro and Precup (2010)), and BFS3 (Asmuth and Littman (2011)) are all validated on a fixed number of MDPs. In their validation process, the authors select a few BRL tasks, for which they choose one arbitrary transition function, which defines the corresponding MDP. Then, they define one prior distribution compliant with the transition function. This type of benchmarking is problematic in the sense that the authors actually know the hidden transition function of each test case. It also creates an implicit incentive to over-fit their approach to a few specific transition functions, which should be completely unknown before interacting with the model. In this paper, we compare BRL algorithms in several different tasks. In each task, the real transition function is defined using a random distribution, instead of being arbitrarily fixed. Each algorithm is thus tested on an infinitely large number of MDPs, for each test case. To perform our experiments, we developed the BBRL library, whose objective is to also provide other researchers with our benchmarking tool.\nThis paper is organised as follows: Section 2 presents the problem statement. Section 3 formally defines the experimental protocol designed for this paper. Section 4 briefly presents the library. Section 5 shows a detailed application of our protocol, comparing several wellknow BRL algorithms on three different benchmarks. Section 6 concludes the study."}, {"heading": "2. Problem Statement", "text": "This section is dedicated to the formalisation of the different tools and concepts discussed in this paper."}, {"heading": "2.1 Reinforcement Learning", "text": "Let M = (X,U, f(\u00b7), \u03c1M , pM,0(\u00b7), \u03b3) be a given unknown MDP, where X = {x(1), . . . , x(nX)} denotes its finite state space and U = {u(1), . . . , u(nU )} refers to its finite action space. When the MDP is in state xt at time t and action ut is selected, the agent moves instantaneously to a next state xt+1 with a probability of P (xt+1|xt, ut) = f(xt, ut, xt+1). An instantaneous deterministic, bounded reward rt = \u03c1M (xt, ut, xt+1) \u2208 [Rmin, Rmax] is observed.\nLet ht = (x0, u0, r0, x1, \u00b7 \u00b7 \u00b7 , xt\u22121, ut\u22121, rt\u22121, xt) \u2208 H denote the history observed until time t. An E/E strategy is a stochastic policy \u03c0 which, given the current state xt, returns an action ut \u223c \u03c0(ht). Given a probability distribution over initial states pM,0(\u00b7), the expected return of a given E/E strategy \u03c0 with respect to the MDP M can be defined as follows:\nJ\u03c0M = E x0\u223cpM,0(\u00b7) [R\u03c0M (x0)],\nwhere R\u03c0M (x0) is the stochastic sum of discounted rewards received when applying the policy \u03c0, starting from an initial state x0:\nR\u03c0M (x0) = +\u221e\u2211 t=0 \u03b3t rt.\nRL aims to learn the behaviour that maximises J\u03c0M , i.e. learning a policy \u03c0 \u2217 defined as follows:\n\u03c0\u2217 \u2208 arg max \u03c0 J\u03c0M ."}, {"heading": "2.2 Prior Knowledge", "text": "In this paper, the actual MDP is assumed to be initially unknown. Model-based Bayesian Reinforcement Learning (BRL) proposes to the model the uncertainty, using a probability distribution p0M(\u00b7) over a set of candidate MDPs M. Such a probability distribution is called a prior distribution and can be used to encode specific prior knowledge available before interaction. Given a prior distribution p0M(\u00b7), the expected return of a given E/E strategy \u03c0 is defined as:\nJ\u03c0p0M(\u00b7) = E M\u223cp0M(\u00b7) [J\u03c0M ] ,\nIn the BRL framework, the goal is to maximise J\u03c0 p0M(\u00b7) , by finding \u03c0\u2217, which is called \u201cBayesian optimal policy\u201d and defined as follows:\n\u03c0\u2217 \u2208 arg max \u03c0 J\u03c0p0M(\u00b7) ."}, {"heading": "2.3 Computation time characterisation", "text": "Most BRL algorithms rely on some properties which, given sufficient computation time, ensure that their agents will converge to an optimal behaviour. However, it is not clear to know beforehand whether an algorithm will satisfy fixed computation time constraints while providing good performances.\nThe parameterisation of the algorithms makes the selection even more complex. Most BRL algorithms depend on parameters (number of transitions simulated at each iteration, etc.) which, in some way, can affect the computation time. In addition, for one given algorithm and fixed parameters, the computation time often varies from one simulation to another. These features make it nearly impossible to compare BRL algorithms under strict computation time constraints. In this paper, to address this problem, algorithms are run with multiple choices of parameters, and we analyse their time performance a posteriori.\nFurthermore, a distinction between the offline and online computation time is made. Offline computation time corresponds to the moment when the agent is able to exploit its prior knowledge, but cannot interact with the MDP yet. One can see it as the time given to take the first decision. In most algorithms concerned in this paper, this phase is generally used to initialise some data structure. On the other hand, online computation time corresponds to the time consumed by an algorithm for taking each decision.\nThere are many ways to characterise algorithms based on their computation time. One can compare them based on the average time needed per step or on the offline computation time alone. To remain flexible, for each run of each algorithm, we store its computation times (Bi)\u22121\u2264i, with i indexing the time step, and B\u22121 the offline learning time. Then a feature function \u03c6((Bi)\u22121\u2264i) is extracted from this data. This function is used as a metric to characterise and discriminate algorithms based on their time requirements.\nIn our protocol, which is detailed in the next section, two types of characterisation are used. For a set of experiments, algorithms are classified based on their offline computation time only, i.e. we use \u03c6((Bi)\u22121\u2264i) = B\u22121. Afterwards, the constraint is defined as \u03c6((Bi)\u22121\u2264i) \u2264 K, K > 0 in case it is required to only compare the algorithms that have an offline computation time lower than K.\nFor another set of experiments, algorithms are separated according to their empirical average online computation time. In this case, \u03c6((Bi)\u22121\u2264i) = 1 n \u2211 0\u2264i<nBi. Algorithms can then be classified based on whether or not they respect the constraint \u03c6((Bi)\u22121\u2264i) \u2264 K, K > 0.\nThis formalisation could be used for any other computation time characterisation. For example, one could want to analyse algorithms based on the longest computation time of a trajectory, and define \u03c6((Bi)\u22121\u2264i) = max\u22121\u2264iBi."}, {"heading": "3. A new Bayesian Reinforcement Learning benchmark protocol", "text": ""}, {"heading": "3.1 A comparison criterion for BRL", "text": "In this paper, a real Bayesian evaluation is proposed, in the sense that the different algorithms are compared on a large set of problems drawn according to a test probability distribution. This is in contrast with the Bayesian literature (Guez et al. (2012); Castro and Precup (2010); Asmuth and Littman (2011)), where authors pick a fixed number of MDPs on which they evaluate their algorithm.\nOur criterion to compare algorithms is to measure their average rewards against a given random distribution of MDPs, using another distribution of MDPs as a prior knowledge. In our experimental protocol, an experiment is defined by a prior distribution p0M(\u00b7) and a test distribution pM(\u00b7). Both are random distributions over the set of possible MDPs, not stochastic transition functions. To illustrate the difference, let us take an example. Let\n(x, u, x\u2032) be a transition. Given a transition function f : X \u00d7 U \u00d7X \u2192 [0; 1], f(x, u, x\u2032) is the probability of observing x\u2032 if we chose u in x. In this paper, this function f is assumed to be the only unknown part of the MDP that the agent faces. Given a certain test case, f corresponds to a unique MDP M \u2208 M. A Bayesian learning problem is then defined by a probability distribution over a set M of possible MDPs. We call it a test distribution, and denote it pM(\u00b7). Prior knowledge can then be encoded as another distribution overM, and denoted p0M(\u00b7). We call \u201caccurate\u201d a prior which is identical to the test distribution (p0M(\u00b7) = pM(\u00b7)), and we call \u201cinaccurate\u201d a prior which is different (p0M(\u00b7) 6= pM(\u00b7)).\nIn previous Bayesian literature, authors select a fixed number of MDPs M1, ...,Mn, train and test their algorithm on them. Doing so does not guarantee any generalisation capabilities. To solve this problem, a protocol that allows rigorous comparison of BRL algorithms is designed. Training and test data are separated, and can even be generated from different distributions (in what we call the inaccurate case).\nMore precisely, our protocol can be described as follows: Each algorithm is first trained on the prior distribution. Then, their performances are evaluated by estimating the expectation of the discounted sum of rewards, when they are facing MDPs drawn from the test distribution. Let J \u03c0(p0M) pM be this value:\nJ \u03c0(p0M) pM = E\nM\u223cpM\n[ J \u03c0(p0M) M ] ,\nwhere \u03c0(p0M) is the algorithm \u03c0 trained offline on p 0 M. In our Bayesian RL setting, we want to find the algorithm \u03c0\u2217 which maximises J \u03c0(p0M) pM for the \u3008p0M, pM\u3009 experiment:\n\u03c0\u2217 \u2208 arg max \u03c0 J \u03c0(p0M) pM .\nIn addition to the performance criterion, we also measure the empirical computation time. In practice, all problems are subject to time constraints. Hence, it is important to take this parameter into account when comparing different algorithms."}, {"heading": "3.2 The experimental protocol", "text": "In practice, we can only sample a finite number of trajectories, and must rely on estimators to compare algorithms. In this section our experimental protocol is described, which is based on our comparison criterion for BRL and provides a detailed computation time analysis.\nAn experiment is defined by (i) a prior distribution p0M and (ii) a test distribution pM. Given these, an agent is evaluated \u03c0 as follows:\n1. Train \u03c0 offline on p0M.\n2. Sample N MDPs from the test distribution pM.\n3. For each sampled MDP M , compute estimate J\u0304 \u03c0(p0M) M of J \u03c0(p0M) M .\n4. Use these values to compute an estimate J\u0304 \u03c0(p0M) pM .\nTo estimate J \u03c0(p0M) M , the expected return of agent \u03c0 trained offline on p 0 M, one trajectory\nis sampled on the MDP M , and the cumulated return is computed J\u0304 \u03c0(p0M) Mi = R\u03c0(p 0 M)\nM (x0). To estimate this return, each trajectory is truncated after T steps. Therefore, given an\nMDP M and its initial state x0, we observe R\u0304 \u03c0(p0M) M (x0), an approximation of R \u03c0(p0M) M (x0):\nR\u0304\u03c0(p 0 M) M (x0) = T\u2211 t=0 \u03b3trt.\nIf Rmax denotes the maximal instantaneous reward an agent can receive when interacting with an MDP drawn from pM, then choosing T as guarantees the approximation error is bounded by > 0:\nT =\n\u230a log( \u00d7 (1\u2212\u03b3)Rmax )\nlog \u03b3\n\u230b .\n= 0.01 is set for all experiments, as a compromise between measurement accuracy and computation time.\nFinally, to estimate our comparison criterion J \u03c0(p0M) pM , the empirical average of the algo-\nrithm performance is computed over N different MDPs, sampled from pM :\nJ\u0304 \u03c0(p0M) pM = 1\nN \u2211 0\u2264i<N J\u0304 \u03c0(p0M) Mi = 1 N \u2211 0\u2264i<N R\u0304\u03c0(p 0 M) Mi (x0) (1)\nFor each agent \u03c0, we retrieve \u00b5\u03c0 = J\u0304 \u03c0 M and \u03c3\u03c0, the empirical mean and standard deviation of the results observed respectively. This gives us the following statistical confidence interval at 95% for J\u03c0M :\nJ\u03c0M \u2208 [ J\u0304\u03c0M \u2212\n2\u03c3\u03c0 N ; J\u0304\u03c0M + 2\u03c3\u03c0 N\n] .\nThe values reported in the following figures and tables are estimations of the interval within which J\u03c0M is, with probability 0.95.\nAs introduced in Section 2.3, in our methodology, a function \u03c6 of computation times is used to classify algorithms based on their time performance. The choice of \u03c6 depends on the type of time constraints that are the most important to the user. In this paper, we reflect this by showing three different ways to choose \u03c6. These three choices lead to three different ways to look at the results and compare algorithms. The first one is to classify algorithms based on their offline computation time, the second one is to classify them based on the algorithms average online computation time. The third is a combination of the first two choices of \u03c6, that we denote \u03c6off ((Bi)\u22121\u2264i) = B\u22121 and \u03c6on((Bi)\u22121\u2264i) = 1 n \u2211 0\u2264i<nBi. The objective is that for each pair of constraints \u03c6off ((Bi)\u22121\u2264i) < K1 and \u03c6on((Bi)\u22121\u2264i) < K2, K1,K2 > 0, we want to identify the best algorithms that respect these constraints. In order to achieve this: (i) All agents that do not satisfy the constraints are discarded; (ii) for each algorithm, the agent leading to the best performance in average is selected; (iii) we build the list of agents whose performances are not significantly different1.\n1. A paired sampled Z-test with a confidence level of 95% has been used to determine when two agents are statistically equivalent (more details in Appendix C).\nThe results will help us to identify, for each experiment, the most suitable algorithm(s) depending on the constraints the agents must satisfy. This protocol is an extension of the one presented in Castronovo et al. (2014)."}, {"heading": "4. BBRL library", "text": "BBRL2 is a C++ open-source library for Bayesian Reinforcement Learning (discrete state/action spaces). This library provides high-level features, while remaining as flexible and documented as possible to address the needs of any researcher of this field. To this end, we developed a complete command-line interface, along with a comprehensive website:\nhttps://github.com/mcastron/BBRL\nBBRL focuses on the core operations required to apply the comparison benchmark presented in this paper. To do a complete experiment with the BBRL library, follow these five steps:\n1. We create a test and a prior distribution. Those distributions are represented by Flat Dirichlet Multinomial distributions (FDM), parameterised by a state space X, an action space U , a vector of parameters \u03b8, and reward function \u03c1. For more information about the FDM distributions, check Section 5.2.\n./BBRL -DDS --mdp_distrib_generation \\\n--name <name > \\ --short_name <short name > \\ --n_states <nX > --n_actions <nU > \\ --ini_state <x0> \\ --transition_weights \\\n<\u03b8(1)> \u00b7 \u00b7 \u00b7 <\u03b8(nXnUnX)> \\ --reward_type \"RT_CONSTANT\" \\ --reward_means \\\n<\u03c1(x(1), u(1), x(1))> \u00b7 \u00b7 \u00b7 <\u03c1(x(nX), u(nU ), x(nX))> \\ --output <output file >\nA distribution file is created.\n2. We create an experiment. An experiment is defined by a set of N MDPs, drawn from a test distribution defined in a distribution file, a discount factor \u03b3 and a horizon limit T .\n./BBRL -DDS --new_experiment \\\n--name <name > \\ --mdp_distribution \"DirMultiDistribution\" \\\n--mdp_distribution_file <distribution file > \\\n--n_mdps <N > --n_simulations_per_mdp 1 \\ --discount_factor <\u03b3> --horizon_limit <T > \\\n2. BBRL stands for Benchmaring tools for Bayesian Reinforcement Learning.\n--compress_output \\ --output <output file >\nAn experiment file is created and can be used to conduct the same experiment for several agents.\n3. We create an agent. An agent is defined by an algorithm alg, a set of parameters \u03c8, and a prior distribution defined in a distribution file, on which the created agent will be trained.\n./BBRL -DDS --offline_learning \\\n--agent <alg> [<parameters \u03c8 >]\\ --mdp_distribution \"DirMultiDistribution\" \\\n--mdp_distribution_file <distribution file > \\\n--output <output file >\nAn agent file is created. The file also stores the computation time observed during the offline training phase.\n4. We run the experiment. We need to provide an experiment file, an algorithm alg and an agent file.\n./BBRL -DDS --run_experiment \\\n--experiment \\\n--experiment_file <experiment file > \\\n--agent <alg> \\ --agent_file <agent file > \\ --n_threads 1 \\ --compress_output \\ --safe_simulations \\ --refresh_frequency 60 \\ --backup_frequency 900 \\ --output <output file >\nA result file is created. This file contains a set of all transitions encountered during each trajectory. Additionally, the computation times we observed are also stored in this file. It is often impossible to measure precisely the computation time of a single decision. This is why only the computation time of each trajectory is reported in this file.\n5. Our results are exported. After each experiment has been performed, a set of K result files is obtained. We need to provide all agent files and result files to export the data.\n./BBRL -export --agent <alg(1)> \\ --agent_file <agent file #1> \\\n--experiment \\\n--experiment_file <result file #1> \\\n... --agent <alg(K)> \\ --agent_file <agent file #K> \\ --experiment \\\n--experiment_file <result file #K>\nBBRL will sort the data automatically and produce several files for each experiment.\n\u2022 A graph comparing offline computation cost w.r.t. performance; \u2022 A graph comparing online computation cost w.r.t. performance; \u2022 A graph where the X-axis represents the offline time bound, while the Y-axis\nrepresents the online time bound. A point of the space corresponds to set of bounds. An algorithm is associated to a point of the space if its best agent, satisfying the constraints, is among the best ones when compared to the others;\n\u2022 A table reporting the results of each agent.\nBBRL will also produce a report file in LATEX gathering the 3 graphs and the table for each experiment.\nMore than 2.000 commands have to be entered in order to reproduce the results of this paper. We decided to provide several Lua script in order to simplify the process. By completing some configuration files, the user can define the agents, the possible values of their parameters and the experiments to conduct.\nThose configuration files are then used by a script called make_scripts.sh, included within the library, whose purpose is to generate four other scripts:\n\u2022 0-init.sh Create the experiment files, and create the formulas sets required by OPPS agents.\n\u2022 1-ol.sh Create the agents and train them on the prior distribution(s).\n\u2022 2-re.sh Run all the experiments.\n\u2022 3-export.sh Generate the LATEX reports.\nDue to the high computation power required, we made those scripts compatible with workload managers such as SLURM. In this case, each cluster should provide the same amount of CPU power in order to get consistent time measurements. To sum up, when the configuration files are completed correctly, one can start the whole process by executing the four scripts, and retrieve the results in nice LATEX reports.\nIt is worth noting that there is no computation budget given to the agents. This is due to the diversity of the algorithms implemented. No algorithm is \u201canytime\u201d natively, in the sense that we cannot stop the computation at any time and receive an answer from the agent instantly. Strictly speaking, it is possible to develop an anytime version of some of the algorithms considered in BBRL. However, we made the choice to stay as close as possible to the original algorithms proposed in their respective papers for reasons of fairness. In consequence, although computation time is a central parameter in our problem statement, it is never explicitly given to the agents. We instead let each agent run as long as necessary and analyse the time elapsed afterwards.\nAnother point which needs to be discussed is the impact of the implementation of an algorithm on the comparison results. For each algorithm, many implementations are possible, some being better than others. Even though we did our best to provide the best possible implementations, BBRL does not compare algorithms but rather the implementations of each algorithms. Note that this issue mainly concerns small problems, since the complexity of the algorithms is preserved."}, {"heading": "5. Illustration", "text": "This section presents an illustration of the protocol presented in Section 3. We first describe the algorithms considered for the comparison in Section 5.1, followed by a description of the benchmarks in Section 5.2. Section 5.3 shows and analyses the results obtained."}, {"heading": "5.1 Compared algorithms", "text": "In this section, we present the list of the algorithms considered in this study. The pseudocode of each algorithm can be found in Appendix A. For each algorithm, a list of \u201creasonable\u201d values is provided to test each of their parameters. When an algorithm has more than one parameter, all possible parameter combinations are tested."}, {"heading": "5.1.1 Random", "text": "At each time-step t, the action ut is drawn uniformly from U ."}, {"heading": "5.1.2 -Greedy", "text": "The -Greedy agent maintains an approximation of the current MDP and computes, at each time-step, its associated Q-function. The selected action is either selected randomly (with a probability of (1 \u2265 \u2265 0), or greedily (with a probability of 1 \u2212 ) with respect to the approximated model.\nTested values:\n\u2022 \u2208 {0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0}."}, {"heading": "5.1.3 Soft-max", "text": "The Soft-max agent maintains an approximation of the current MDP and computes, at each time-step, its associated Q-function. The selected action is selected randomly, where the probability to draw an action u is proportional to Q(xt, u). The temperature parameter \u03c4 allows to control the impact of the Q-function on these probabilities (\u03c4 \u2192 0+: greedy selection; \u03c4 \u2192 +\u221e: random selection).\nTested values:\n\u2022 \u03c4 \u2208 {0.05, 0.10, 0.20, 0.33, 0.50, 1.0, 2.0, 3.0, 5.0, 25.0}."}, {"heading": "5.1.4 OPPS", "text": "Given a prior distribution p0M(.) and an E/E strategy space S (either discrete or continuous), the Offline, Prior-based Policy Search algorithm (OPPS) identifies a strategy \u03c0\u2217 \u2208 S which maximises the expected discounted sum of returns over MDPs drawn from the prior.\nThe OPPS for Discrete Strategy spaces algorithm (OPPS-DS) (Castronovo et al. (2012, 2014)) formalises the strategy selection problem as a k-armed bandit problem, where k =\n|S|. Pulling an arm amounts to draw an MDP from p0M(.), and play the E/E strategy associated to this arm on it for one single trajectory. The discounted sum of returns observed is the return of this arm. This multi-armed bandit problem has been solved by using the UCB1 algorithm (Auer et al. (2002); Audibert et al. (2007)). The time budget is defined by a variable \u03b2, corresponding to the total number of draws performed by the UCB1.\nThe E/E strategies considered by Castronovo et. al are index-based strategies, where the index is generated by evaluating a small formula. A formula is a mathematical expression, combining specific features (Q-functions of different models) by using standard mathematical operators (addition, subtraction, logarithm, etc.). The discrete E/E strategy space is the set of all formulas which can be built by combining at most n features/operators (such a set is denoted by Fn).\nOPPS-DS does not come with any guarantee. However, the UCB1 bandit algorithm used to identify the best E/E strategy within the set of strategies provides statistical guarantees that the best E/E strategies are identified with high probability after a certain budget of experiments. However, it is not clear that the best strategy of the E/E strategy space considered yields any high-performance strategy regardless the problem.\nTested values:\n\u2022 S \u2208 {F2,F3,F4,F5,F6}3,\n\u2022 \u03b2 \u2208 {50, 500, 1250, 2500, 5000, 10000, 100000, 1000000}."}, {"heading": "5.1.5 BAMCP", "text": "Bayes-adaptive Monte Carlo Planning (BAMCP) (Guez et al. (2012)) is an evolution of the Upper Confidence Tree (UCT) algorithm (Kocsis and Szepesva\u0301ri (2006)), where each transition is sampled according to the history of observed transitions. The principle of this algorithm is to adapt the UCT principle for planning in a Bayes-adaptive MDP, also called the belief-augmented MDP, which is an MDP obtained when considering augmented states made of the concatenation of the actual state and the posterior. The BAMCP algorithm is made computationally tractable by using a sparse sampling strategy, which avoids sampling a model from the posterior distribution at every node of the planification tree. Note that the BAMCP also comes with theoretical guarantees of convergence towards Bayesian optimality.\nIn practice, the BAMCP relies on two parameters: (i) Parameter K which defines the number of nodes created at each time-step, and (ii) Parameter depth which defines the depth of the tree from the root.\nTested values:\n\u2022 K \u2208 {1, 500, 1250, 2500, 5000, 10000, 25000},\n\u2022 depth \u2208 {15, 25, 50}.\n3. The number of arms k is always equal to the number of strategies in the given set. For your information: |F2| = 12, |F3| = 43, |F4| = 226, |F5| = 1210, |F6| = 7407"}, {"heading": "5.1.6 BFS3", "text": "The Bayesian Forward Search Sparse Sampling (BFS3) (Asmuth and Littman (2011)) is a Bayesian RL algorithm whose principle is to apply the principle of the FSSS (Forward Search Sparse Sampling, see Kearns et al. (2002)) algorithm to belief-augmented MDPs. It first samples one model from the posterior, which is then used to sample transitions. The algorithm then relies on lower and upper bounds on the value of each augmented state to prune the search space. The authors also show that BFS3 converges towards Bayesoptimality as the number of samples increases.\nIn practice, the parameters of BFS3 are used to control how much computational power is allowed. The parameter K defines the number of nodes to develop at each time-step, C defines the branching factor of the tree and depth controls its maximal depth.\nTested values:\n\u2022 K \u2208 {1, 500, 1250, 2500, 5000, 10000},\n\u2022 C \u2208 {2, 5, 10, 15},\n\u2022 depth \u2208 {15, 25, 50}."}, {"heading": "5.1.7 SBOSS", "text": "The Smarter Best of Sampled Set (SBOSS) (Castro and Precup (2010)) is a Bayesian RL algorithm which relies on the assumption that the model is sampled from a Dirichlet distribution. From this assumption, it derives uncertainty bounds on the value of state action pairs. It then uses those bounds to decide how many models to sample from the posterior, and how often the posterior should be updated in order to reduce the computational cost of Bayesian updates. The sampling technique is then used to build a merged MDP, as in Asmuth et al. (2009), and to derive the corresponding optimal action with respect to that MDP. In practice, the number of sampled models is determined dynamically with a parameter . The re-sampling frequency depends on a parameter \u03b4.\nTested values:\n\u2022 \u2208 {1.0, 1e\u2212 1, 1e\u2212 2, 1e\u2212 3, 1e\u2212 4, 1e\u2212 5, 1e\u2212 6},\n\u2022 \u03b4 \u2208 {9, 7, 5, 3, 1, 1e\u2212 1, 1e\u2212 2, 1e\u2212 3n1e\u2212 4, 1e\u2212 5, 1e\u2212 6}."}, {"heading": "5.1.8 BEB", "text": "The Bayesian Exploration Bonus (BEB) (Kolter and Ng (2009)) is a Bayesian RL algorithm which builds, at each time-step t, the expected MDP given the current posterior. Before solving this MDP, it computes a new reward function \u03c1 (t) BEB(x, u, y) = \u03c1M (x, u, y)+ \u03b2\nc (t) <x,u,y>\n,\nwhere c (t) <x,u,y> denotes the number of times transition < x, u, y > has been observed at\ntime-step t. This algorithm solves the mean MDP of the current posterior, in which we replaced \u03c1M (\u00b7, \u00b7, \u00b7) by \u03c1(t)BEB(\u00b7, \u00b7, \u00b7), and applies its optimal policy on the current MDP for one step. The bonus \u03b2 is a parameter controlling the E/E balance. BEB comes with theoretical guarantees of convergence towards Bayesian optimality.\nTested values:\n\u2022 \u03b2 \u2208 {0.25, 0.5, 1, 1.5, 2, 2.5, 3, 4, 8, 16}."}, {"heading": "5.1.9 Computation times variance", "text": "Each algorithm has one or more parameters that can affect the number of sampled transitions from a given state, or the length of each simulation. This, in turn, impacts the computation time requirement at each step. Hence, for some algorithms, no choice of parameters can bring the computation time below or over certain values. In other words, each algorithm has its own range of computation time. Note that, for some methods, the computation time is influenced concurrently by several parameters. We present a qualitative description of how computation time varies as a function of parameters in Table 1.\n4. If a random decision is chosen, the model is not solved. 5. K defines the number of nodes to develop at each step, and depth defines the maximal depth of the tree. 6. K defines the number of nodes to develop at each step, C the branching factor of the tree and depth its\nmaximal depth. 7. The number of models sampled is inversely proportional to , while the frequency at which the models\nare sampled is inversely proportional to \u03b4. When an MDP has been sufficiently explored, the number of models to sample and the frequency of the sampling will decrease."}, {"heading": "5.2 Benchmarks", "text": "In our setting, the transition matrix is the only element which differs between two MDPs drawn from the same distribution. For each < state, action > pair < x, u >, we define a Dirichlet distribution, which represents the uncertainty about the transitions occurring from < x, u >. A Dirichlet distribution is parameterised by a set of concentration parameters \u03b1 (1) <x,u>, \u00b7 \u00b7 \u00b7 , \u03b1 (nX) <x,u>.\nWe gathered all concentration parameters in a single vector \u03b8. Consequently, our MDP distributions are parameterised by \u03c1M (the reward function) and several Dirichlet distributions, parameterised by \u03b8. Such a distribution is denoted by p\u03c1M ,\u03b8(\u00b7). In the Bayesian Reinforcement Learning community, these distributions are referred to as Flat Dirichlet Multinomial distributions (FDMs).\nWe chose to study two different cases:\n\u2022 Accurate case: the test distribution is fully known (p0M(.) = pM(.)),\n\u2022 Inaccurate case: the test distribution is unknown (p0M(.) 6= pM(.)).\nIn the inaccurate case, we have no assumption on the transition matrix. We represented this lack of knowledge by a uniform FDM distribution, where each transition has been observed one single time (\u03b8 = [1, \u00b7 \u00b7 \u00b7 , 1]).\nSections 5.2.1, 5.2.2 and 5.2.3 describes the three distributions considered for this study."}, {"heading": "5.2.1 Generalised Chain distribution (p\u03c1", "text": "GC ,\u03b8GC (\u00b7))\nThe Generalised Chain (GC) distribution is inspired from the five-state chain problem (5 states, 3 actions) (Dearden et al. (1998)). The agent starts at State 1, and has to go through State 2, 3 and 4 in order to reach the last state (State 5), where the best rewards are. The agent has at its disposal 3 actions. An action can either let the agent move from State x(n) to State x(n+1) or force it to go back to State x(1). The transition matrix is drawn from a FDM parameterised by \u03b8GC , and the reward function is denoted by \u03c1GC . More details can be found in Appendix B.1."}, {"heading": "5.2.2 Generalised Double-Loop distribution (p\u03c1", "text": "GDL,\u03b8GDL(\u00b7))\nThe Generalised Double-Loop (GDL) distribution is inspired from the double-loop problem (9 states, 2 actions) (Dearden et al. (1998)). Two loops of 5 states are crossing at State 1,\nwhere the agent starts. One loop is a trap: if the agent enters it, it has no choice to exit but crossing over all the states composing it. Exiting this loop provides a small reward. The other loop is yielding a good reward. However, each action of this loop can either let the agent move to the next state of the loop or force it to return to State 1 with no reward. The transition matrix is drawn from an FDM parameterised by \u03b8GDL, and the reward function is denoted by \u03c1GDL. More details can be found in Appendix B.2."}, {"heading": "5.2.3 Grid distribution (p\u03c1", "text": "Grid,\u03b8Grid(\u00b7))\nThe Grid distribution is inspired from the Dearden\u2019s maze problem (25 states, 4 actions) (Dearden et al. (1998)). The agent is placed at a corner of a 5x5 grid (the S cell), and has to reach the opposite corner (the G cell). When it succeeds, it returns to its initial state and receives a reward. The agent can perform 4 different actions, corresponding to the 4 directions (up, down, left, right). However, depending on the cell on which the agent is, each action has a certain probability to fail, and can prevent the agent to move in the selected direction. The transition matrix is drawn from an FDM parameterised by \u03b8Grid, and the reward function is denoted by \u03c1Grid. More details can be found in Appendix B.3."}, {"heading": "5.3 Discussion of the results", "text": "5.3.1 Accurate case\nAs it can be seen in Figure 6, OPPS is the only algorithm whose offline time cost varies. In the three different settings, OPPS can be launched after a few seconds, but behaves very poorly. However, its performances increased very quickly when given at least one minute of computation time. Algorithms that do not use offline computation time have a wide range of different scores. This variance represents the different possible configurations for these algorithms, which only lead to different online computation time.\nOn Figure 7, BAMCP, BFS3 and SBOSS have variable online time costs. BAMCP behaved poorly on the first experiment, but obtained the best score on the second one and was pretty efficient on the last one. BFS3 was good only on the second experiment. SBOSS was never able to get a good score in any cases. Note that OPPS online time cost varies slightly depending on the formula\u2019s complexity.\nIf we take a look at the top-right point in Figure 8, which defines the less restrictive bounds, we notice that OPPS-DS and BEB were always the best algorithms in every experiment. -Greedy was a good candidate in the two first experiments. BAMCP was also a very good choice except for the first experiment. On the contrary, BFS3 and SBOSS were only good choices in the first experiment.\nIf we look closely, we can notice that OPPS-DS was always one of the best algorithm since we have met its minimal offline computation time requirements.\nMoreover, when we place our offline-time bound right under OPPS-DS minimal offline time cost, we can see how the top is affected from left to right:\nGC: (Random), (SBOSS), (BEB, -Greedy), (BEB, BFS3, -Greedy),\nGDL: (Random), (Random, SBOSS), ( -Greedy), (BEB, -Greedy),\n(BAMCP, BEB, -Greedy),\nGrid: (Random), (SBOSS), ( -Greedy), (BEB, -Greedy).\nWe can clearly see that SBOSS was the first algorithm to appear on the top, with a very small online computation cost, followed by -Greedy and BEB. Beyond a certain online time bound, BFS3 emerged in the first experiment while BAMCP emerged in the second experiment. Neither of them was able to compete with BEB or -Greedy in the last experiment.\nSoft-max was never able to reach the top regardless the configuration. Figure 9 reports the best score observed for each algorithm, disassociated from any time measure. Note that the variance is very similar for all algorithms in GDL and Grid experiments. On the contrary, the variance oscillates between 1.0 and 2.0. However, OPPS seems to be the less stable algorithm in the three cases.\n5.3.2 Inaccurate case\nAs seen in the accurate case, Figure 10 also shows impressive performances for OPPSDS, which has beaten all other algorithms in every experiment. We can also notice that, as observed in the accurate case, in the Grid experiment, the OPPS-DS agents scores are very close. However, only a few were able to significantly surpass the others, contrary to the accurate case where most OPPS-DS agents were very good candidates.\nSurprisingly, SBOSS was a very good alternative to BAMCP and BFS3 in the two first experiments as shown in Figure 11. It was able to surpass both algorithms on the first one while being very close to BAMCP performances in the second. Relative performances of BAMCP and BFS3 remained the same in the inaccurate case, even if the BAMCP advantage is less visible in the second experiment. BEB was no longer able to compete with OPPS-DS and was even beaten by BAMCP and BFS3 in the last experiment. -Greedy was still a decent choice except in the first experiment. As observed in the accurate case, Soft-max was very bad in every case.\nIn Figure 12, if we take a look at the top-right point, we can see OPPS-DS is the best choice in the second and third experiment. BEB, SBOSS and -Greedy share the first place with OPPS-DS in the first one.\nIf we place our offline-time bound right under OPPS-DS minimal offline time cost, we can see how the top is affected from left to right:\nGC: (Random), (Random, SBOSS), (SBOSS), (BEB, SBOSS, -Greedy),\n(BEB, BFS3, SBOSS, -Greedy),\nGDL: (Random), (Random, SBOSS), (BAMCP, Random, SBOSS),\n(BEB, SBOSS, -Greedy), (BEB, BFS3, SBOSS, -Greedy),\n(BAMCP, BEB, BFS3, SBOSS, -Greedy),\nGrid: (Random), (Random, SBOSS), (BAMCP, BEB, BFS3, Random, SBOSS),\n( -Greedy).\nSBOSS is again the first algorithm to appear in the rankings. -Greedy is the only one which could reach the top in every case, even when facing BAMCP and BFS3 fed with high online computation cost. BEB no longer appears to be undeniably better than the others. Besides, the two first experiments show that most algorithms obtained similar results, except for BAMCP which does not appear on the top in the first experiment. In the last experiment, -Greedy succeeded to beat all other algorithms.\nFigure 13 does not bring us more information than those we observed in the accurate case."}, {"heading": "5.3.3 Summary", "text": "In the accurate case, OPPS-DS was always among the best algorithms, at the cost of some offline computation time. When the offline time budget was too constrained for OPPS-DS, different algorithms were suitable depending on the online time budget:\n\u2022 Low online time budget: SBOSS was the fastest algorithm to make better decisions than a random policy.\n\u2022 Medium online time budget8: BEB reached performances similar to OPPS-DS on each experiment.\n\u2022 High online time budget9: In the first experiment, BFS3 managed to catch up BEB and OPPS-DS when given sufficient time. In the second experiment, it was BAMCP which has achieved this result. Neither BFS3 nor BAMCP was able to compete with BEB and OPPS-DS in the last experiment.\nThe results obtained in the inaccurate case were very interesting. BEB was not as good as it seemed to be in the accurate case, while SBOSS improved significantly compared to the others. For its part, OPPS-DS obtained the best overall results in the inaccurate case by outperforming all the other algorithms in two out of three experiments while remaining among the best ones in the last experiment."}, {"heading": "6. Conclusion", "text": "We have proposed a new extensive BRL comparison methodology which takes into account both performance and time requirements for each algorithm. In particular, our benchmarking protocol shows that no single algorithm dominates all other algorithms on all scenarios. The protocol we introduced can compare any time algorithm to non-anytime algorithms while measuring the impact of inaccurate offline training. By comparing algorithms on large sets of problems, we avoid over fitting to a single problem. Our methodology is associated with an open-source library, BBRL, and we hope that it will help other researchers to design algorithms whose performances are put into perspective with computation times, that may be critical in many applications. This library is specifically designed to handle new algorithms easily, and is provided with a complete and comprehensive documentation website."}, {"heading": "Acknowledgments", "text": "Michae\u0308l Castronovo acknowledges the financial support of the FRIA. Raphael Fonteneau is a postdoctoral fellow of the F.R.S.-FNRS (Belgian Funds for Scientifique Research).\n8. \u00b1 100 times more than the low online time budget 9. \u00b1 100 times more than the medium online time budget"}, {"heading": "Appendix A. Pseudo-code of the algorithms", "text": "Algorithm 1 -Greedy\n1: procedure offline-learning(p0M(.)) 2: M\u0302 \u2190 \u201cBuild an initial model based on p0M(.)\u201d 3: end procedure 4: 5: function search(x, h) 6: {Draw a random value in [0; 1]} 7: r \u2190 U(0, 1) 8:\n9: if r < then {Random case} 10: return \u201cAn action selected randomly\u201d 11: 12: else {Greedy case} 13: \u03c0\u2217\nM\u0302 \u2190value-iteration(M\u0302)\n14: return \u03c0\u2217 M\u0302\n(x) 15: end if 16: end function 17: 18: procedure online-learning(x, u, y, r) 19: \u201cUpdate model M\u0302 w.r.t. transition < x, u, y, r >\u201d 20: end procedure\nAlgorithm 2 Soft-max\n1: procedure offline-learning(p0M(.)) 2: M\u0302 \u2190 \u201cBuild an initial model based on p0M(.)\u201d 3: end procedure 4: 5: function search(x, h) 6: {Draw a random value in [0; 1]} 7: r \u2190 U(0, 1) 8: 9: {Select an action randomly, with a probability proportional to Q\u2217 M\u0302\n(x, u)} 10: Q\u2217\nM\u0302 \u2190 \u201cCompute the optimal Q-function of M\u0302\u201d\n11: for 1 \u2264 i \u2264 |U | do 12: if r < \u2211 j\u2264i exp ( Q\u2217 M\u0302 (x,u(j)) / \u03c4 )\n\u2211 u\u2032 exp ( Q\u2217 M\u0302 (x,u\u2032) / \u03c4 ) then\n13: return u(i) 14: end if 15: end for 16: end function 17: 18: procedure online-learning(x, u, y, r) 19: \u201cUpdate model M\u0302 w.r.t. transition < x, u, y, r >\u201d 20: end procedure\nAlgorithm 3 OPPS-DS\n1: procedure offline-learning(p0M(.)) 2: {Initialise the k arms of UCB1} 3: for 1 \u2264 i \u2264 k do 4: M \u223c p0M(.) 5: R\u03c0iM \u2190 \u201cSimulate strategy \u03c0i on MDP M over a single trajectory\u201d 6: \u00b5(i)\u2190 R\u03c0iM 7: \u03b8(i)\u2190 1 8: end for 9:\n10: {Run UCB1 with a budget of \u03b2} 11: for k + 1 \u2264 b \u2264 \u03b2 do 12: a\u2190 arg maxa\u2032 \u00b5(a\u2032) + \u221a 2 log(b) \u03b8(a\u2032) 13: M \u223c p0M(.) 14: R\u03c0aM \u2190 \u201cSimulate strategy \u03c0a on MDP M over a single trajectory\u201d 15: \u00b5(a)\u2190 \u03b8(a)\u00b5(a)+R \u03c0a M\n\u03b8(a)+1\n16: \u03b8(a)\u2190 \u03b8(a) + 1 17: end for 18: 19: {Select the E/E strategy associated to the most drawn arm} 20: a\u2217 \u2190 arg maxa\u2032 \u03b8(a\u2032) 21: \u03c0OPPS \u2190 \u03c0a\u2217 22: end procedure 23: 24: function search(x, h) 25: return u \u223c \u03c0OPPS(x, h) 26: end function 27: 28: procedure online-learning(x, u, y, r) 29: \u201cUpdate strategy \u03c0OPPS w.r.t. transition < x, u, y, r >\u201d 30: end procedure\nAlgorithm 4 BAMCP (1/2)\n1: function search(x, h) 2: {Develop a MCTS and compute Q(., .)} 3: for 1 \u2264 k \u2264 K do 4: M \u223c phM 5: Simulate(\u3008x, h\u3009,M, 0) 6: end for 7: 8: {Return the best action w.r.t. Q(., .)} 9: return arg maxuQ(\u3008x, h\u3009, u)\n10: end function 11: 12: function simulate(\u3008x, h\u3009,M, d) 13: if N(\u3008x, h\u3009) = 0 then {New node reached} 14: \u201cInitialise N(\u3008x, h\u3009, u), Q(\u3008x, h\u3009, u)\u201d 15: u \u223c \u03c00(\u3008x, h\u3009) 16: \u201cSample x\u2032, r from model M\u201d 17: 18: {Estimate the score of this node by using the rollout policy} 19: R\u2190 r + \u03b3 Rollout(\u3008x\u2032, hux\u2032\u3009, P, d) 20: 21: \u201cUpdate N(\u3008x, h\u3009), N(\u3008x, h\u3009, u), Q(\u3008x, h\u3009, u)\u201d 22: return R 23: end if 24: 25: {Select the next branch to explore} 26: u\u2190 arg maxu\u2032 Q(\u3008x, h\u3009, u) + c \u221a ( log(N(\u3008x,h\u3009))N(\u3008x,h\u3009,u\u2032) ) 27: \u201cSample x\u2032, r from model M\u201d 28: 29: {Follow the branch and evaluate it} 30: R\u2190 r + \u03b3 Simulate(\u3008x\u2032, hux\u2032\u3009,M, d+ 1) 31: 32: \u201cUpdate N(\u3008x, h\u3009), N(\u3008x, h\u3009, u), Q(\u3008x, h\u3009, u)\u201d 33: return R 34: end function\nAlgorithm 5 BAMCP (2/2)\n1: procedure rollout(\u3008x, h\u3009,M, d) 2: if \u03b3dRmax < then {Truncate the trajectory if precision has been\nreached} 3: return 0 4: end if 5: 6: {Use the rollout policy to choose the action to perform} 7: u \u223c \u03c00(x, h) 8:\n9: {Simulate a single transition from M and continue the rollout process} 10: y \u223c PM 11: r \u2190 \u03c1M (x, u, y) 12: return r + \u03b3 rollout(\u3008y, huy\u3009,M, d+ 1) 13: end procedure 14: 15: procedure online-learning(x, u, y, r) 16: \u201cUpdate the posterior w.r.t. transition < x, u, y, r >\u201d 17: end procedure\nAlgorithm 6 BFS3\n1: function search(x, h) 2: {Update the current Q-function} 3: Mmean \u2190 \u201cCompute the mean MDP of ptM(.).\u201d 4: for all u \u2208 U do 5: for 1 \u2264 i \u2264 C do 6: {Draw y and r from the mean MDP of the posterior} 7: y \u223c PMmean 8: r \u2190 \u03c1M (x, u, y) 9:\n10: {Update the Q-value in (x, u) by using FSSS algorithm} 11: Q(x, u)\u2190 Q(x, u) + 1C [ r + \u03b3 FSSS(y, d, t) ] 12: end for 13: end for 14: 15: {Return the action u with the maximal Q-value in x} 16: return arg maxuQ(x, u) 17: end function\nAlgorithm 7 FSSS (1/2)\n1: function FSSS(x, d, t) 2: {Develop a MCTS and compute bounds on V (x)} 3: for 1 \u2264 i \u2264 t do 4: rollout(s, d, 0) 5: end for 6: 7: {Make an optimistic estimation of V (x)} 8: V\u0302 (x)\u2190 maxu Ud(x, u) 9: return V\u0302 (x)\n10: end function\nAlgorithm 8 FSSS (2/2)\n1: procedure rollout(x, d, l) 2: if d = l then {Stop when reaching the maximal depth} 3: return 4: end if 5: 6: if \u00acV isitedd(x) then {New node reached} 7: {Initialise this node} 8: for all u \u2208 U do 9: \u201cInitialise Nd(x, u, x\n\u2032),Rd(x, u)\u201d 10: for 1 \u2264 i \u2264 C do 11: \u201cSample x\u2032, r from M\u201d 12: \u201cUpdate Nd(x, u, x\n\u2032),Rd(x, u)\u201d 13: 14: if \u00acV isitedd(x\u2032) then 15: Ud+1(x \u2032), Ld+1(x \u2032) = Vmax, Vmin 16: end if 17: end for 18: end for 19: 20: {Back-propagate this node\u2019s information} 21: Bellman-backup(x, d) 22: 23: V isitedd(x)\u2190true 24: end if 25: 26: {Select an action and simulate a transition optimistically} 27: u\u2190 arg maxu Ud(x, u) 28: x\u2032 \u2190 arg maxx\u2032 ( Ud+1(x \u2032)\u2212 Ld+1(x\u2032) ) Nd(x, u, x\n\u2032) 29: 30: {Continue the rollout process and back-propagate the result} 31: rollout(x\u2032, d, l + 1) 32: Bellman-backup(x, d) 33: return 34: end procedure\nAlgorithm 9 SBOSS (1/2)\n1: function search(x, h) 2: {Compute the transition matrix of the mean MDP of the posterior} 3: Mmean \u2190 \u201cCompute the mean MDP of ptM(.).\u201d 4: Pt \u2190 PMmean 5: 6: {Update the policy to follow if necessary} 7: \u2200(x, u) : \u2206(x, u) = \u2211 y\u2208X |Pt(x,u,y)\u2212PlastUpdate(x,u,y)| \u03c3(x,u,y) 8: if t = 1 or \u2203(x\u2032, u\u2032) : \u2206(x\u2032, u\u2032) > \u03b4 then 9: {Sample some transition vectors for each state-action pair}\n10: S \u2190 {} 11: for all (x, u) \u2208 X \u00d7 U do 12: {Compute the number of transition vectors to sample for (x, u)} 13: Kt(x, u)\u2190 maxy \u2308 \u03c32(x,u,y)\n\u2309 14: 15: {Sample Kt(x, u) transition vectors from < x, u >, sampled from the posterior} 16: for 1 \u2264 k \u2264 Kt(x, u) do 17: S \u2190 S \u222a \u201cA transition vector from < x, u >, sampled from the\nposterior\u201d 18: end for 19: end for 20: 21: M# \u2190 \u201cBuild a new MDP by merging all transitions from S\u201d 22: \u03c0\u2217\nM# \u2190value-iteration(M#)\n23: \u03c0SBOSS \u2190fit-action-space(\u03c0\u2217M#) 24: PlastUpdate \u2190 Pt 25: end if 26: 27: {Return the optimal action in x w.r.t. \u03c0SBOSS} 28: return u \u223c \u03c0SBOSS(x) 29: end function\nAlgorithm 10 SBOSS (2/2)\n1: function fit-action-space(\u03c0\u2217 M#\n) 2: for all x \u2208 X do 3: \u03c0(x)\u2190 \u03c0\u2217\nM# (x) mod |U |\n4: end for 5: 6: return \u03c0 7: end function 8:\n9: procedure online-learning(x, u, y, r) 10: \u201cUpdate the posterior w.r.t. transition < x, u, y, r >\u201d 11: end procedure\nAlgorithm 11 BEB\n1: procedure search(x, h) 2: M \u2190 \u201cCompute the mean MDP of ptM(.).\u201d 3: 4: {Add a bonus reward to all transitions} 5: for < x, u, y >\u2208 X \u00d7 U \u00d7 X do \u03c1M (x, u, y)\u2190 \u03c1M (x, u, y) + \u03b2\nc (t) <x,u,y>\n6: end for 7: 8: {Compute the optimal policy of the modified MDP} 9: \u03c0\u2217M \u2190value-iteration(M)\n10: 11: {Return the optimal action in x w.r.t. \u03c0\u2217M} 12: return u \u223c \u03c0\u2217M (x) 13: end procedure 14: 15: procedure online-learning(x, u, y, r) 16: \u201cUpdate the posterior w.r.t. transition < x, u, y, r >\u201d 17: end procedure"}, {"heading": "Appendix B. MDP distributions in detail", "text": "In this section, we describe the MDPs drawn from the considered distributions in more detail. In addition, we also provide a formal description of the corresponding \u03b8 (parameterising the FDM used to draw the transition matrix) and \u03c1M (the reward function).\nB.1 Generalised Chain distribution\nOn those MDPs, we can identify two possibly optimal behaviours:\n\u2022 The agent tries to move along the chain, reaches the last state, and collect as many rewards as possible before returning to State 1;\n\u2022 The agent gives up to reach State 5 and tries to return to State 1 as often as possible.\nB.1.1 Formal description\nX = {1, 2, 3, 4, 5}, U = {1, 2, 3}\n\u2200u \u2208 U :\n\u03b8GC1,u = [1, 1, 0, 0, 0] \u03b8GC2,u = [1, 0, 1, 0, 0] \u03b8GC3,u = [1, 0, 0, 1, 0] \u03b8GC4,u = [1, 0, 0, 0, 1] \u03b8GC5,u = [1, 1, 0, 0, 1]\n\u2200x, u \u2208 X \u00d7 U :\n\u03c1GC(x, u, 1) = 2.0\n\u03c1GC(x, u, 5) = 10.0\n\u03c1GC(x, u, y) = 0.0, \u2200y \u2208 X \\ {1, 5}\nB.2 Generalised Double-Loop distribution\nSimilarly to the GC distribution, we can also identify two possibly optimal behaviours:\n\u2022 The agent enters the \u201cgood\u201d loop and tries to stay in it until the end;\n\u2022 The agent gives up and chooses to enter the \u201cbad\u201d loop as frequently as possible.\nB.2.1 Formal description\nX = {1, 2, 3, 4, 5, 6, 7, 8, 9}, U = {1, 2}\n\u2200u \u2208 U :\n\u03b8GDL1,u = [0, 1, 0, 0, 0, 1, 0, 0, 0] \u03b8GDL2,u = [0, 0, 1, 0, 0, 0, 0, 0, 0] \u03b8GDL3,u = [0, 0, 0, 1, 0, 0, 0, 0, 0] \u03b8GDL4,u = [0, 0, 0, 0, 1, 0, 0, 0, 0] \u03b8GDL5,u = [1, 0, 0, 0, 0, 0, 0, 0, 0] \u03b8GDL6,u = [1, 0, 0, 0, 0, 0, 1, 0, 0] \u03b8GDL7,u = [1, 0, 0, 0, 0, 0, 0, 1, 0] \u03b8GDL8,u = [1, 0, 0, 0, 0, 0, 0, 0, 1] \u03b8GDL9,u = [1, 0, 0, 0, 0, 0, 0, 0, 0]\n\u2200u \u2208 U :\n\u03c1GDL(5, u, 1) = 1.0\n\u03c1GDL(9, u, 1) = 2.0\n\u03c1GDL(x, u, y) = 0.0, \u2200x \u2208 X, \u2200y \u2208 X : y 6= 1\nB.3 Grid distribution\nMDPs drawn from the Grid distribution are 2-dimensional grids. Since the agents considered do not manage multi-dimensional state spaces, the following bijection was defined:\n{1, 2, 3, 4, 5} \u00d7 {1, 2, 3, 4, 5} \u2192 X = {1, 2, \u00b7 \u00b7 \u00b7 , 25} : n(i, j) = 5(i\u2212 1) + j\nwhere i and j are the row and column indexes of the cell on which the agent is.\nWhen the agent reaches the G cell (in (5, 5)), it is directly moved to (1, 1), and will perceive its reward of 10. In consequence, State (5, 5) is not reachable.\nTo move inside the Grid, the agent can perform four actions: U = {up, down, left, right}. Those actions only move the agent to one adjacent cell. However, each action has a certain probability to fail (depending on the cell on which the agent is). In case of failure, the agent does not move at all. Besides, if the agent tries to move out of the grid, it will not move either. Discovering a reliable (and short) path to reach the G cell will determine the success of the agent.\nB.3.1 Formal description\nX = {1, 2, \u00b7 \u00b7 \u00b7 , 25}, U = {up, down, left, right}\n\u2200(i, j) \u2208 {1, 2, 3, 4, 5} \u00d7 {1, 2, 3, 4, 5} \u2200(k, l) \u2208 {1, 2, 3, 4, 5} \u00d7 {1, 2, 3, 4, 5} :\n\u03b8Gridn(i,j),u (n(i, j)) = 1, \u2200u \u2208 U\n\u03b8Gridn(i,j),up (n(i\u2212 1, j)) = 1, (i\u2212 1) \u2265 1 \u03b8Gridn(i,j),down (n(i+ 1, j)) = 1, (i+ 1) \u2264 5, (i, j) 6= (4, 5) \u03b8Gridn(i,j),left (n(i, j \u2212 1)) = 1, (j \u2212 1) \u2265 1 \u03b8Gridn(i,j),right (n(i, j + 1)) = 1, (j + 1) \u2264 5, (i, j) 6= (5, 4)\n\u03b8Gridn(4,5),down(n(1, 1)) = 1 \u03b8Gridn(5,4),right(n(1, 1)) = 1\n\u03b8Gridn(i,j),u (n(k, l)) = 0, else\n\u03c1Grid((4, 5),down,(1, 1)) = 10.0\n\u03c1Grid((5, 4),right,(1, 1)) = 10.0\n\u03c1Grid((i, j), u, (k, l)) = 0.0, \u2200u \u2208 U\nAppendix C. Paired sampled Z-test\nLet \u03c0A and \u03c0B be the two agents we want to compare. We played the two agents on the same N MDPs, denoted by M1, \u00b7 \u00b7 \u00b7 ,MN . Let R\u03c0AMi and R \u03c0B Mi\nbe the scores we observed for the two agents on Mi.\nStep 1 - Hypothesis\nWe compute the mean and the standard deviation of the differences between the two sample sets, denoted by x\u0304d and s\u0304d, respectively.\nx\u0304d = 1\nN N\u2211 i=1 R\u03c0AMi \u2212R \u03c0B Mi\ns\u0304d = 1\nN N\u2211 i=1 (x\u0304d \u2212 (R\u03c0AMi \u2212R \u03c0B Mi ))2\nIf N \u2265 30, s\u0304d is a good estimation of \u03c3d, the standard deviation of the differences between the two populations (s\u0304d \u2248 \u03c3d). In order words, \u03c3d is the standard deviation we should observe when testing the two algorithms on a number of MDPs tending towards infinity. This was always the case in our experiments.\nWe now set Hypothesis H0 and Hypothesis H\u03b1:\nH0 : \u00b5d = 0\nH\u03b1 : \u00b5d > 0\nOur goal is to determine if \u00b5d, the mean of the differences between the two populations, is equal or greater than 0. More expressly, we want to know if the differences between the two agents\u2019 performances is significant (H\u03b1 is correct) or not (H0 correct). Only one of those hypotheses can be true.\nStep 2 - Test statistic\nThe test statistic consists to compute a certain value Z:\nZ = x\u0304d\n\u03c3d\n/\u221a N\nThis value will help us to determine if we should accept (or reject) hypothesis H\u03b1.\nStep 3 - Rejection region\nAssuming we want our decision to be correct with a probability of failure of \u03b1, we will have to compare Z with Z\u03b1, a value of a Gaussian curve. If Z > Z\u03b1, it means we are in the rejection region (R.R.) with a probability equal to 1\u2212 \u03b1. For a confidence of 95%, Z\u03b1 should be equal to 1.645.\nBeing in the R.R. means we have to reject Hypothesis H0 (and accept Hypothesis H\u03b1). In the order case, we have to accept Hypothesis H0 (and reject Hypothesis H\u03b1).\nStep 4 - Decision\nAt this point, we have either accepted Hypothesis H0 or Hypothesis H\u03b1.\n\u2022 Accepting Hypothesis H0 (Z < Z\u03b1): The two algorithms \u03c0A and \u03c0B are not significantly different.\n\u2022 Accepting Hypothesis H\u03b1 (Z \u2265 Z\u03b1): The two algorithms \u03c0A and \u03c0B are significantly different. Therefore, the algorithm with the greatest mean is definitely better with 95% confidence."}], "references": [{"title": "Approaching Bayes-optimalilty using Monte-Carlo tree search", "author": ["J. Asmuth", "M. Littman"], "venue": "In Proceedings of the 21st International Conference on Automated Planning and Scheduling,", "citeRegEx": "Asmuth and Littman.,? \\Q2011\\E", "shortCiteRegEx": "Asmuth and Littman.", "year": 2011}, {"title": "A Bayesian sampling approach to exploration in Reinforcement Learning", "author": ["J. Asmuth", "L. Li", "M.L. Littman", "A. Nouri", "D. Wingate"], "venue": "In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Asmuth et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Asmuth et al\\.", "year": 2009}, {"title": "Tuning bandit algorithms in stochastic environments", "author": ["J.Y. Audibert", "R. Munos", "C. Szepesv\u00e1ri"], "venue": "In Algorithmic Learning Theory,", "citeRegEx": "Audibert et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Audibert et al\\.", "year": 2007}, {"title": "Finite-time analysis of the multiarmed bandit problem", "author": ["P. Auer", "N. Cesa-Bianchi", "P. Fischer"], "venue": "Machine learning,", "citeRegEx": "Auer et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Auer et al\\.", "year": 2002}, {"title": "Smarter sampling in model-based bayesian reinforcement learning", "author": ["P.S. Castro", "D. Precup"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "Castro and Precup.,? \\Q2010\\E", "shortCiteRegEx": "Castro and Precup.", "year": 2010}, {"title": "Learning exploration/exploitation strategies for single trajectory Reinforcement Learning", "author": ["M. Castronovo", "F. Maes", "R. Fonteneau", "D. Ernst"], "venue": "Journal of Machine Learning Research (JMLR),", "citeRegEx": "Castronovo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Castronovo et al\\.", "year": 2012}, {"title": "Bayes Adaptive Reinforcement Learning versus Off-line Prior-based Policy Search: an Empirical Comparison. 23rd annual machine learning conference of Belgium and the Netherlands (BENELEARN", "author": ["M. Castronovo", "R. Fonteneau", "D. Ernst"], "venue": null, "citeRegEx": "Castronovo et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Castronovo et al\\.", "year": 2014}, {"title": "Bayesian Q-learning", "author": ["R. Dearden", "N. Friedman", "S. Russell"], "venue": "In Proceedings of Fifteenth National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Dearden et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Dearden et al\\.", "year": 1998}, {"title": "Model based Bayesian exploration", "author": ["R. Dearden", "N. Friedman", "D. Andre"], "venue": "In Proceedings of the Fifteenth Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Dearden et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Dearden et al\\.", "year": 1999}, {"title": "Efficient Bayes-adaptive Reinforcement Learning using sample-based search", "author": ["A. Guez", "D. Silver", "P. Dayan"], "venue": "In Neural Information Processing Systems (NIPS),", "citeRegEx": "Guez et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Guez et al\\.", "year": 2012}, {"title": "A sparse sampling algorithm for near-optimal planning in large Markov decision processes", "author": ["M. Kearns", "Y. Mansour", "A.Y. Ng"], "venue": "Machine Learning,", "citeRegEx": "Kearns et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Kearns et al\\.", "year": 2002}, {"title": "Bandit based Monte-Carlo planning", "author": ["L. Kocsis", "C. Szepesv\u00e1ri"], "venue": "European Conference on Machine Learning (ECML),", "citeRegEx": "Kocsis and Szepesv\u00e1ri.,? \\Q2006\\E", "shortCiteRegEx": "Kocsis and Szepesv\u00e1ri.", "year": 2006}, {"title": "Near-Bayesian exploration in polynomial time", "author": ["J. Zico Kolter", "Andrew Y. Ng"], "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,", "citeRegEx": "Kolter and Ng.,? \\Q2009\\E", "shortCiteRegEx": "Kolter and Ng.", "year": 2009}, {"title": "A Bayesian framework for Reinforcement Learning", "author": ["M. Strens"], "venue": "In Proceedings of the Seventeenth International Conference on Machine Learning (ICML),", "citeRegEx": "Strens.,? \\Q2000\\E", "shortCiteRegEx": "Strens.", "year": 2000}], "referenceMentions": [{"referenceID": 7, "context": "Model-based Bayesian Reinforcement Learning (BRL) (Dearden et al. (1999); Strens (2000)) specifically targets RL problems for which such a prior knowledge is encoded in the form of a probability distribution (the \u201cprior\u201d) over possible models of the environment.", "startOffset": 51, "endOffset": 73}, {"referenceID": 7, "context": "Model-based Bayesian Reinforcement Learning (BRL) (Dearden et al. (1999); Strens (2000)) specifically targets RL problems for which such a prior knowledge is encoded in the form of a probability distribution (the \u201cprior\u201d) over possible models of the environment.", "startOffset": 51, "endOffset": 88}, {"referenceID": 3, "context": "To properly compare Bayesian algorithms, the first comprehensive BRL benchmarking protocol is designed, following the foundations of Castronovo et al. (2014). \u201cComprehensive BRL benchmark\u201d refers to a tool which assesses the performance of BRL algorithms over a large set of problems that are actually drawn according to a prior distribution.", "startOffset": 133, "endOffset": 158}, {"referenceID": 3, "context": "To properly compare Bayesian algorithms, the first comprehensive BRL benchmarking protocol is designed, following the foundations of Castronovo et al. (2014). \u201cComprehensive BRL benchmark\u201d refers to a tool which assesses the performance of BRL algorithms over a large set of problems that are actually drawn according to a prior distribution. In previous papers addressing BRL, authors usually validate their algorithm by testing it on a few test problems, defined by a small set of predefined MDPs. For instance, BAMCP (Guez et al. (2012)), SBOSS (Castro and Precup (2010)), and BFS3 (Asmuth and Littman (2011)) are all validated on a fixed number of MDPs.", "startOffset": 133, "endOffset": 540}, {"referenceID": 3, "context": "(2012)), SBOSS (Castro and Precup (2010)), and BFS3 (Asmuth and Littman (2011)) are all validated on a fixed number of MDPs.", "startOffset": 16, "endOffset": 41}, {"referenceID": 0, "context": "(2012)), SBOSS (Castro and Precup (2010)), and BFS3 (Asmuth and Littman (2011)) are all validated on a fixed number of MDPs.", "startOffset": 53, "endOffset": 79}, {"referenceID": 7, "context": "This is in contrast with the Bayesian literature (Guez et al. (2012); Castro and Precup (2010); Asmuth and Littman (2011)), where authors pick a fixed number of MDPs on which they evaluate their algorithm.", "startOffset": 50, "endOffset": 69}, {"referenceID": 3, "context": "(2012); Castro and Precup (2010); Asmuth and Littman (2011)), where authors pick a fixed number of MDPs on which they evaluate their algorithm.", "startOffset": 8, "endOffset": 33}, {"referenceID": 0, "context": "(2012); Castro and Precup (2010); Asmuth and Littman (2011)), where authors pick a fixed number of MDPs on which they evaluate their algorithm.", "startOffset": 34, "endOffset": 60}, {"referenceID": 5, "context": "This protocol is an extension of the one presented in Castronovo et al. (2014).", "startOffset": 54, "endOffset": 79}, {"referenceID": 2, "context": "This multi-armed bandit problem has been solved by using the UCB1 algorithm (Auer et al. (2002); Audibert et al.", "startOffset": 77, "endOffset": 96}, {"referenceID": 2, "context": "(2002); Audibert et al. (2007)).", "startOffset": 8, "endOffset": 31}, {"referenceID": 9, "context": "5 BAMCP Bayes-adaptive Monte Carlo Planning (BAMCP) (Guez et al. (2012)) is an evolution of the Upper Confidence Tree (UCT) algorithm (Kocsis and Szepesv\u00e1ri (2006)), where each transition is sampled according to the history of observed transitions.", "startOffset": 53, "endOffset": 72}, {"referenceID": 9, "context": "5 BAMCP Bayes-adaptive Monte Carlo Planning (BAMCP) (Guez et al. (2012)) is an evolution of the Upper Confidence Tree (UCT) algorithm (Kocsis and Szepesv\u00e1ri (2006)), where each transition is sampled according to the history of observed transitions.", "startOffset": 53, "endOffset": 164}, {"referenceID": 0, "context": "6 BFS3 The Bayesian Forward Search Sparse Sampling (BFS3) (Asmuth and Littman (2011)) is a Bayesian RL algorithm whose principle is to apply the principle of the FSSS (Forward Search Sparse Sampling, see Kearns et al.", "startOffset": 59, "endOffset": 85}, {"referenceID": 0, "context": "6 BFS3 The Bayesian Forward Search Sparse Sampling (BFS3) (Asmuth and Littman (2011)) is a Bayesian RL algorithm whose principle is to apply the principle of the FSSS (Forward Search Sparse Sampling, see Kearns et al. (2002)) algorithm to belief-augmented MDPs.", "startOffset": 59, "endOffset": 225}, {"referenceID": 3, "context": "7 SBOSS The Smarter Best of Sampled Set (SBOSS) (Castro and Precup (2010)) is a Bayesian RL algorithm which relies on the assumption that the model is sampled from a Dirichlet distribution.", "startOffset": 49, "endOffset": 74}, {"referenceID": 1, "context": "The sampling technique is then used to build a merged MDP, as in Asmuth et al. (2009), and to derive the corresponding optimal action with respect to that MDP.", "startOffset": 65, "endOffset": 86}, {"referenceID": 12, "context": "8 BEB The Bayesian Exploration Bonus (BEB) (Kolter and Ng (2009)) is a Bayesian RL algorithm which builds, at each time-step t, the expected MDP given the current posterior.", "startOffset": 44, "endOffset": 65}, {"referenceID": 7, "context": "1 Generalised Chain distribution (p\u03c1 GC ,\u03b8 (\u00b7)) The Generalised Chain (GC) distribution is inspired from the five-state chain problem (5 states, 3 actions) (Dearden et al. (1998)).", "startOffset": 157, "endOffset": 179}, {"referenceID": 7, "context": "2 Generalised Double-Loop distribution (p\u03c1 GDL,\u03b8GDL(\u00b7)) The Generalised Double-Loop (GDL) distribution is inspired from the double-loop problem (9 states, 2 actions) (Dearden et al. (1998)).", "startOffset": 167, "endOffset": 189}, {"referenceID": 7, "context": "3 Grid distribution (p\u03c1 Grid,\u03b8Grid(\u00b7)) The Grid distribution is inspired from the Dearden\u2019s maze problem (25 states, 4 actions) (Dearden et al. (1998)).", "startOffset": 129, "endOffset": 151}], "year": 2015, "abstractText": "In the Bayesian Reinforcement Learning (BRL) setting, agents try to maximise the collected rewards while interacting with their environment while using some prior knowledge that is accessed beforehand. Many BRL algorithms have already been proposed, but even though a few toy examples exist in the literature, there are still no extensive or rigorous benchmarks to compare them. The paper addresses this problem, and provides a new BRL comparison methodology along with the corresponding open source library. In this methodology, a comparison criterion that measures the performance of algorithms on large sets of Markov Decision Processes (MDPs) drawn from some probability distributions is defined. In order to enable the comparison of non-anytime algorithms, our methodology also includes a detailed analysis of the computation time requirement of each algorithm. Our library is released with all source code and documentation: it includes three test problems, each of which has two different prior distributions, and seven state-of-the-art RL algorithms. Finally, our library is illustrated by comparing all the available algorithms and the results are discussed.", "creator": "LaTeX with hyperref package"}}}