{"id": "1511.03749", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Nov-2015", "title": "Complexity of the Description Logic ALCM", "abstract": "In every paper we new that the problem especially properly sharpness form example knowledge key by the Description Logic ALCM kind ExpTime - one. The M stands although ilir - real-world soon certain subsequently Motz, Rohrer, Severi. To shown really side reasons, does define being ExpTime Tableau polynomial-time as was facility of an optimized part checking predictability, is focus portion place ALC by Nguyen with Szalas.", "histories": [["v1", "Thu, 12 Nov 2015 01:31:38 GMT  (471kb,D)", "http://arxiv.org/abs/1511.03749v1", "Long version of a submitted paper, 43 pages"]], "COMMENTS": "Long version of a submitted paper, 43 pages", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["monica martinez", "edelweis rohrer", "paula severi"], "accepted": false, "id": "1511.03749"}, "pdf": {"name": "1511.03749.pdf", "metadata": {"source": "CRF", "title": "Complexity of the Description Logic ALCM", "authors": ["M\u00f3nica Mart\u0131\u0301nez", "Edelweis Rohrer", "Paula Severi"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The main motivation of the present work is to study the complexity of meta-modelling as defined in [1,2]. No study of complexity has been done so far for this approach and we would like to analyse if it increases the complexity of a given description logic. It is well-known that consistency of a (general) knowledge base in ALC is ExpTimecomplete. The hardness result was proved in [3]. A matching upper bound forALC was given by De Giacomo and Lenzerini by a reduction to PDL [4]. In this paper, we show that the consistency of a knowledge base inALCM is ExpTimecomplete where theM stands for the meta-modelling approach mentioned above. Hardness follows trivially from the fact that ALCM is an extension of ALC since any algorithm that decides consistency of a knowledge base in ALCM can be used to decide consistency of a knowledge base in ALC. In order to give a matching upper bound on the complexity of this problem, it is enough to show that there is a particular algorithm with running time at most O(2n) where n is the size of the knowledge base. The standard tableau algorithm for ALC which builds completion trees, e.g. see [5], can be extended with the expansion rules for meta-modelling of [1,2]. This algorithm is the bases for Semantic Web reasoners such as Pellet [6]. However, it has a high (worse case) complexity, namely NExpTime, and cannot be used to prove that the consistency problem for ALCM is ExpTime-complete. Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14]. However, translations do not seem to work for ALCM due to the combination of a flexible syntax with a strong semantics of well-founded sets. A consistency algorithm for ALCM has to check if the domain of the canonical model under construction is a well-founded set. This is an unusual and interesting aspect of our approach but at the same time what makes it more difficult to solve. The contributions of this paper are the following:\n1. We define a tableau algorithm for checking consistency of a knowledge base in ALCM as an extension of an algorithm for ALC by Nguyen and Szalas [15].\nar X\niv :1\n51 1.\n03 74\n9v 1\n[ cs\n.L O\n] 1\n2 N\nov 2\n01 5\n2 2. We prove correctness and show that the complexity of our algorithm forALCM is ExpTime.\n3. From the above two items, we obtain the main result of our paper which is the fact that the problem of checking consistency of a knowledge base in ALCM is ExpTime-complete.\nHence, in spite of the fact that our algorithm has the burden of having to check for well-founded sets, complexity does not change when moving from ALC to ALCM."}, {"heading": "2 A Flexible Meta-modelling Approach for Re-using Ontologies", "text": "A knowledge base in ALCM contains an Mbox besides of a Tbox and an Abox. An Mbox is a set of equalities of the form a =m A where a is an individual and A is a concept [1,2]. Figure 1 shows an example of two ontologies separated by a horizontal line. The two ontologies conceptualize the same entities at different levels of granularity. In the ontology above the horizontal line, rivers and lakes are formalized as individuals while in the one below the line they are concepts. If we want to integrate these ontologies into a single ontology (or into an ontology network) it is necessary to interpret the individual river and the concept River as the same real object. Similarly for lake and Lake. The Mbox for this example contains two equations:\nriver =m River lake =m Lake\nThese equalities are called meta-modelling axioms and in this case, we say that the ontologies are related through meta-modelling. In Figure 1, meta-modelling axioms are represented by dashed edges. After adding the meta-modelling axioms for rivers and lakes, the concept HydrographicObject is now also a meta-concept because it is a concept that contains an individual which is also a concept. This kind of meta-modelling can be expressed in OWL Full but it cannot be expressed\nin OWL DL. The fact that it is expressed in OWL Full is not very useful since the metamodelling provided by OWL Full is so expressive that leads to undecidability [7]. OWL\n3 2 DL has a very restricted form of meta-modelling called punning where the same identifier can be used as an individual and as a concept [16]. These identifiers are treated as different objects by the reasoner and it is not possible to detect certain inconsistencies. We next illustrate two examples where OWL would not detect inconsistencies because the identifiers, though they look syntactically equal, are actually different.\nExample 1. If we introduce an axiom expressing that HydrographicObject is a subclass of River, then OWL\u2019s reasoner will not detect that the interpretation of River is not a well founded set (it is a set that belongs to itself).\nExample 2. We add two axioms, the first one says that river and lake as individuals are equal and the second one says that the classes River and Lake are disjoint. Then OWL\u2019s reasoner does not detect that there is a contradiction.\nIn order to detect these inconsistencies, river and River should be made semantically equal, i.e. the interpretations of the individual river and the concept River should be the same. The domain of an interpretation cannot longer consists of only basic objects but it must be any well-founded set. The well-foundness of our model is not ensured by means of fixing layers beforehand as in [8,10] but it is the reasoner which checks for circularities. This approach allows the user to have any number of levels or layers (meta-concepts, meta meta-concepts and so on). The user does not have to write or know the layer of the concept because the reasoner will infer it for him. In this way, axioms can also naturally mix elements of different layers and the user has the flexibility of changing the status of an individual at any point without having to make any substantial change to the ontology.\n3 The Description Logic ALC In this section we recall the Description Logic ALC [17,5]. We assume we have three pairwise disjoint sets: a set of individuals, a set of atomic concepts and a set of atomic roles. Individuals are denoted by a, b, . . ., atomic concepts by A,B, . . . and atomic roles by R,S, . . .. We use C,D to denote arbitrary concepts. Concepts are defined by the following grammar:\nC,D ::= A | > | (\u00acC) | (C uD) | (C tD) | (\u2200R.C) | (\u2203R.C)\nWe omit parenthesis according to the following precedence order of the description logics operators: (i) \u00ac, \u2200, \u2203 (ii) u, (iii) t. Outermost parenthesis can sometimes be omitted. We use d {C1, . . . , Cn} to denote C1 u . . . u Cn. Syntactic equality between concepts or individuals is denoted by =. We say that C is a (syntactic) subconcept of a concept D if C \u2208 sc(D) where sc is defined as follows.\nsc(C) = {C} if C \u2208 {A,>,\u22a5} sc(\u00acC) = sc(C) \u222a {\u00acC} sc(C uD) = sc(C) \u222a sc(D) \u222a {C uD} sc(C tD) = sc(C) \u222a sc(D) \u222a {C tD} sc(\u2200R.C) = sc(C) \u222a {\u2200R.C} sc(\u2203R.C) = sc(C) \u222a {\u2203R.C}\n4 A knowledge base K in ALC is a pair (T ,A) where\n1. T , called a Tbox, is a finite set of axioms of the form C v D, with C, D any two concepts. Statements of the form C \u2261 D are abbreviations for C v D and D v C. 2. A, called an Abox, is a finite set of statements of the form C(a), R(a, b), a = b or a 6= b.\nThe set of all individuals occurring in A is denoted by dom(A). To avoid confusion with the syntactic equality, for the statements of the Abox we always write the information of it, i.e. a = b \u2208 A. Note that Aboxes contain equalities and inequalities between individuals in spite of the fact that they are not part of the standard definition of ALC. There are two reasons for adding them. First of all, this is a very useful OWL feature. Second and most important, it makes it evident that equality and difference between individuals play an important role in the presence of meta-modelling since an equality between individuals is transferred into an equality between the corresponding concepts and conversely.\nAn interpretation I = (\u2206I , \u00b7I) consists of a non-empty set \u2206I (sometimes we drop the super-index when the name of the interpretation is clear from the context and write just \u2206), called the domain of I, and a function \u00b7I which maps every concept to a subset of \u2206 and every role to a subset of \u2206 \u00d7\u2206 such that, for all concepts C, D and role R the following equations are satisfied:\n>I = \u2206I (C uD)I = CI \u2229DI (C tD)I = CI \u222aDI (\u00acC)I = \u2206\\CI (\u2203R.C)I = {x | \u2203y.(x, y) \u2208 RI and y \u2208 CI} (\u2200R.C)I = {x | \u2200y.(x, y) \u2208 RI implies y \u2208 CI}\nAn interpretation I satisfies a conceptC, denoted by I |= C, ifCI 6= \u2205 and it satisfies a set X of concepts, denoted by I |= X , if ( d X )I 6= \u2205. Note that ( d X )I = \u22c2 C\u2208X C\nI . An interpretation I satisfies a TBox T , denoted by I |= T , if CI \u2286 DI for each C v D in T . An interpretation I satisfies a set X of concepts w.r.t. Tbox T or I satisfies (T ,X ), denoted by I |= (T ,X ), if I satisfies T and X . An interpretation I validates a concept C, denoted as I |= C \u2261 >, if CI = \u2206I . An interpretation I validates a set X of concepts if I validates every concept in X , or equivalently I |= d X \u2261 >. An interpretation I satisfies an ABox A, denoted by I |= A, if aI \u2208 CI for each C(a) in A, (aI , bI) \u2208 RI for each R(a, b) in A, aI = bI for each a = b in A and aI 6= bI for each a 6= b in A. An interpretation I is a model of (T ,A), denoted by I |= (T ,A) if it satisfies the Tbox T and the Abox A. We say that a knowledge base K = (T ,A) is consistent (or satisfiable) if there exists a model of K. We say that a concept is in negation normal form if negation occurs in front of atomic\n5 concepts only. The negation normal form of a concept is denoted by NNF(C) and defined in Figure 2. An Abox and a Tbox are also converted into negation normal form. An axiom C \u2261 D in T is converted into NNF(\u00acC t D) u NNF(\u00acD t C). Actually, a concept C in the set NNF(T ) which is in negation normal form represents the axiom C \u2261 >. This means that x \u2208 CI for all x in the domain \u2206I and all C in NNF(T ). Thus, an interpretation I is a model of T if and only if I validates every concept C \u2208 NNF(T ). When T is in negation normal form, then T is not a set of inclusions but just a set of concepts C such that C \u2261 > should hold. In that case, we say that I is a model of T , denoted by I |= d T \u2261 >, if I validates every concept C \u2208 T .\nDefinition 1 (Isomorphism between interpretations of ALC). An isomorphism between two interpretations I and I \u2032 of ALC is a bijective function f : \u2206\u2192 \u2206\u2032 such that\n\u2013 f(aI) = aI \u2032 \u2013 x \u2208 AI if and only if f(x) \u2208 AI\u2032 \u2013 (x, y) \u2208 RI if and only if (f(x), f(y)) \u2208 RI\u2032 .\nLemma 1. Let I and I \u2032 be two isomorphic interpretations ofALC. Then, I is a model of (T ,A) if and only if I \u2032 is a model of (T ,A).\nTo prove the previous lemma is enough to show that x \u2208 CI if and only if f(x) \u2208 CI\u2032 by induction on C.\nTheorem 1 (Complexity ofALC). Consistency of a (general) knowledge base inALC is ExpTime-complete.\n6 The hardness result was proved by Schild [3]. A matching upper bound for ALC was given by De Giacomo and Lenzerini by a reduction to PDL [4]. The classic Tableau algorithm is not optimal and cannot be used in this proof because it is NExpTime [5]. ExpTime Tableau algorithms for checking satisfiability w.r.t. a general Tbox are shown by Lenzerini, Donini and Masacci [18,19]. These algorithms globally cache only unsatisfiable sets. Gore\u0301 and Nguyen show an ExpTime Tableau algorithm for checking satisfiability of a concept in ALC w.r.t. a general Tbox that can globally cache satisfiable and unsatisfiable sets [20]. Nguyen and Szalas extend this same algorithm for checking consistency of a knowledge base (including a Tbox and an Abox) in ALC [15]."}, {"heading": "4 Well-founded Sets and Well-founded Relations", "text": "In this section we recall some basic notions on well-founded sets and relations [21]. In particular, the induction and recursion principles are important for us since we will use them in the proof of completeness of the Tableau Calculus for ALCM.\nDefinition 2 (Well-founded Relation). Let X be a set and \u227a a binary relation on X .\n1. Let Y \u2286 X . We say that m \u2208 Y is a minimal element of Y if there is no y \u2208 Y such that y \u227a m. 2. We say that \u227a is well-founded (on X) if for all Y 6= \u2205 such that Y \u2286 X , we have that Y has a minimal element.\nNote that in the general definition above the relation \u227a does not need to be transitive.\nLemma 2. The order \u227a is well-founded on X iff there are no infinite \u227a-decreasing sequences, i.e., there is no \u3008xi\u3009i\u2208N such that xi+1 \u227a xi and xi \u2208 X for all i \u2208 N.\nThe proof of the above lemma can be found in [21].\nDefinition 3 (Well-founded Set). A set X is well-founded if the set membership relation \u2208 is well-founded on the set X .\nAs a consequence of Lemma 2, we also have that:\n1. If X is a well-founded set then X 6\u2208 X . 2. If X is a well-founded set then it cannot contain an infinite \u2208-decreasing sequence,\ni.e., there is no \u3008xn\u3009n\u2208N such that xn+1 \u2208 xn and xn \u2208 X for all n \u2208 N.\nAn important reason that well-founded relations are interesting is because we can apply the induction and recursion principles, e.g., [21]. In this paper both principles will be used to prove correctness of the Tableau calculus for ALCM.\nDefinition 4 (Induction Principle). If \u227a is a well-founded relation on X , \u03d5 is some property of elements ofX , and we want to show that \u03d5(x) holds for all elements x \u2208 X , it suffices to show that: if x \u2208 X and \u03d5(y) is true for all y \u2208 X such that y \u227a x, then \u03d5(x) must also be true.\n7 Definition 5 (Function Restriction). The restriction of a function f : X \u2192 Y to a subset X \u2032 of X is denoted as f X\u2032 and defined as follows.\nf X\u2032 = {(x, f(x)) | x \u2208 X \u2032}\nOn par with induction, well-founded relations also support construction of objects by recursion.\nDefinition 6 (Recursion Principle). If \u227a is a well-founded relation on X and F a function that assigns an object F (x, g) to each pair of an element x \u2208 X and a function g on the initial segment {y \u2208 X | y \u227a x} of X . Then there is a unique function G such that for every x \u2208 X ,\nG(x) = F (x,G {y\u2208X|y\u227ax})\n5 The Description Logic ALCM\nIn this section, we extend the description logic ALC with the meta-modelling defined by Motz, Rohrer and Severi [1,2].\nDefinition 7 (Meta-modelling axiom). A meta-modelling axiom is a statement of the form a =m A where a is an individual and A is an atomic concept. We pronounce a =m A as a corresponds to A through meta-modelling. An MboxM is a finite set of meta-modelling axioms.\nIn Figure 3, the meta-modelling axiom a =m A express that the individual a corresponds to the concept A through meta-modelling. We define ALCM by keeping the same syntax for concept expressions as for ALC. A knowledge base K in ALCM is a triple (T ,A,M) where T , A andM are a Tbox, Abox and an Mbox respectively. The set of all individuals inM is denoted by dom(M) and the set of all concepts by range(M). Figure 4 shows the Tbox, Abox and Mbox of the knowledge base that corresponds to Figure 1.\nDefinition 8 (Satisfiability of meta-modelling). An interpretation I satisfies (or it is a model of) a =m A if aI = AI . An interpretation I satisfies (or it is model of)M, denoted by I |=M, if it satisfies each statement inM.\nThe semantics of ALCM makes use of the structured domain elements. In order to give semantics to meta-modelling, the domain has to consists of basic objects, sets of objects, sets of sets of objects and so on.\nDefinition 9 (Sn for n \u2208 N). Given a non empty set S0 of atomic objects, we define Sn by induction on N as follows: Sn+1 = Sn \u222a P(Sn)\nIt is easy to prove that Sn \u2286 Sn+1 and that Sn is well-founded for all n \u2208 N. A set X \u2286 Sn can contain elements x such that x \u2208 Si for any i \u2264 n.\nDefinition 10 (Model of a Knowledge Base in ALCM). An interpretation I is a model of a knowledge base K = (T ,A,M) in ALCM (denoted as I |= K) if the following holds:\n1. the domain \u2206 of the interpretation is a subset of some Sn for some n \u2208 N. 2. I is a model of (T ,A) in ALC. 3. I is a model ofM.\nIn the first part of Definition 10 we restrict the domain of an interpretation in ALCM to be a subset of Sn. The domain \u2206 can now contain sets since the set Sn is defined recursively using the powerset operation. In the presence of meta-modelling, the domain \u2206 cannot longer consist of only basic objects and cannot be an arbitrary set either. We require that the domain be a well-founded set. The reason for this is explained as follows. Suppose we have a domain \u2206I = {X} where X = {X} is a set that belongs to itself. Intuitively, X is the set\n{{{. . .}}}\nClearly, a set like X should be excluded from our interpretation domain since it cannot represent any real object from our usual applications in Semantic Web (in other areas or aspects of Computer Science, representing such objects is useful [22]). Note that S0 does not have to be the same for all models of a knowledge base. The second part of Definition 10 refers to the ALC-knowledge base without the Mbox axioms. In the third part of the definition, we add another condition that the model must\n9 satisfy considering the meta-modelling axioms. This condition restricts the interpretation of an individual that has a corresponding concept through meta-modelling to be equal to the concept interpretation.\nExample 3. We define a model for the knowledge base of Figure 4 where\nS0 = {queguay, santaLucia, deRocha, delSauce}\n\u2206 = { queguay, santaLucia, deRocha, delSauce, {queguay, santaLucia}, {deRocha, delSauce}, {{queguay, santaLucia}, {deRocha, delSauce}} }\nThe interpretation is defined on the individuals with meta-modelling and the corresponding atomic concepts to which they are equated as follows:\nriverI = RiverI = {queguay, santaLucia} lakeI = LakeI = {deRocha, delSauce}\nand on the remaining atomic concept which does not appear on the MBox the interpretation is defined as follows:\nHydrographicObjectI = {riverI , lakeI} = {{queguay, santaLucia}, {deRocha, delSauce}}\nDefinition 11 (Consistency inALCM). We say that a knowledge baseK = (T ,A,M) is consistent (satisfiable) if there exists a model of K.\nDefinition 12 (Logical Consequence in ALCM). We say that S is a logical consequence of K = (T ,A,M) (denoted as K |= S) if all models of K are also models of S where S is any of the following ALCM statements, i.e.,\nC v D C(a) R(a, b) a =m A a = b a 6= b.\nDefinition 13 (Meta-concept). We say that C is a meta-concept in K if there exists an individual a such that K |= C(a) and K |= a =m A.\nThen, C is a meta-meta-concept if there exists an individual a such that K |= C(a), K |= a =m A and A is a meta-concept. Note that a meta-meta-concept is also a metaconcept.\nWe have some new inference problems:\n1. Meta-modelling. Find out whether a =m A or not. 2. Meta-concept. Find out whether C is a meta-concept or not.\nAs most inference problems in Description Logic the above two problems can be reduced to satisfiability. For the first problem, note that since a 6=m A is not directly available in the syntax, we have replaced it by a 6= b and b =m A which is an equivalent statement to the negation of a =m A. For the proof of the following two lemmas, see [1].\n10\nLemma 3. K |= a =m A if and only if for some new individual b,K\u222a{a 6= b, b =m A} is inconsistent.\nLemma 4. A concept C is a meta-concept if and only if for some individual a we have that K\u222a {\u00acC(a)} is inconsistent and for some new individual b, K\u222a {a 6= b, b =m A} is inconsistent.\nNext lemma explains more formally why in our definition of ABox we included expressions of the form a = b and a 6= b. If we have an equality A \u2261 B between concepts then a and b should be equal. Similarly, if we have that A and B are different then a and b should be different. In other words, since we can express equality and difference between concepts, we also need to be able to express equality and difference at the level of individuals.\nLemma 5 (Equality Transference). Let K = (T ,A,M) be a knowledge base, K |= a =m A and K |= b =m B.\n1. If K |= a = b then K |= A \u2261 B. 2. If K |= A \u2261 B then K |= a = b.\nThe proof of the above lemma is immediate since a, b, A and B are all interpreted as the same object.\nWe define a tableau algorithm for checking consistency of a knowledge base inALCM by extending the standard tableau algorithm for ALC. The expansion rules for ALCM consist of the rules for ALC and some additional expansion rules for meta-modelling (see Figure 5). The additional expansion rules deal with the equalities and inequalities between individuals with meta-modelling which need to be transferred to the level of concepts as equalities and inequalities between the corresponding concepts. We also need to add an extra condition that checks for circularities (with respect to membership) avoiding non well-founded sets.\nA completion forest L for an ALC knowledge base consists of\n1. a set of nodes, labelled with individual names or variable names (fresh individuals which do not belong to the ABox), 2. directed edges between some pairs of nodes, 3. for each node labelled x, a set L(x) of concept expressions, 4. for each pair of nodes x and y, a set L(x, y) containing role names, and 5. two relations between nodes, denoted by \u2248 and 6\u2248. These relations keep record of\nthe equalities and inequalities of nodes in the algorithm. The relation \u2248 is assumed to be reflexive, symmetric and transitive while 6\u2248 is assumed to be symmetric. We also assume that the relation 6\u2248 is compatible with \u2248, i.e., if x\u2032 \u2248 x and x 6\u2248 y then x\u2032 6\u2248 y for all x, x\u2032, y. In the algorithm, every time we add a pair in \u2248, we close \u2248 under reflexivity, symmetry and transitivity. Moreover, every time we add a pair in either 6\u2248 or \u2248, we close 6\u2248 under compatibility with \u2248.\nWe assume that T y A have already been converted into negation normal form.\n11\nDefinition 14 (Initialization). The initial completion forest for K = (T ,A,M) is defined by the following procedure.\n1. For each individual a in the knowlegde (a \u2208 A \u222aM) set a \u2248 a. 2. For each a = b \u2208 A, set a \u2248 b. We also choose an individual as a representative\nof each equivalence class. 3. For each a 6= b in A, set a 6\u2248 b. 4. For each a \u2208 A \u222aM, we do the following:\n(a) in case a is a representative of an equivalence class then set L(a) = {C | C(a\u2032) \u2208 A, a \u2248 a\u2032};\n(b) in case a is not a representative of an equivalence class then set L(a) = \u2205. 5. For all a, b \u2208 A \u222aM that are representatives of some equivalence class, if {R | R(a\u2032, b\u2032) \u2208 A, a \u2248 a\u2032, b \u2248 b\u2032} 6= \u2205 then create an edge from a to b and set L(a, b) = {R | R(a\u2032, b\u2032) \u2208 A, a \u2248 a\u2032, b \u2248 b\u2032}.\nNote that in case a is not a representative of an equivalence class and it has some axiom C(a), we set L(a) = \u2205 because we do not want to apply any expansion rule to L(a). The expansion rules will only be applied to the representative of the equivalence class of a.\nDefinition 15 (Contradiction). A completion forest L has a contradiction if either\n\u2013 A and \u00acA belongs to L(x) for some atomic concept A and node x or \u2013 there are nodes x and y such that x 6\u2248 y and x \u2248 y.\nWe say that a node y is a successor of a node x if L(x, y) 6= \u2205. We define that y is a descendant of x by induction.\n1. Every successor of x, which is a variable, is a descendant of x. 2. Every successor of a descendant of x, which is a variable, is also a descendant of x.\nDefinition 16 (Blocking). We define the notion of blocking by induction. A node x is blocked by a node y if x is a descendant of y and L(x) \u2286 L(y) or x is a descendant of z and z is blocked by y.\nDefinition 17 (ALCM-Complete). A completion forest L is ALCM-complete (or just complete) if none of the rules of Figure 5 is applicable.\nDefinition 18 (Circularity). We say that the completion forest L has a circularity with respect toM if there is a sequence of meta-modelling axioms a0 =m A0, a1 =m A1, . . . an =m An all inM such that\nA1 \u2208 L(x0) x0 \u2248 a0 A2 \u2208 L(x1) x1 \u2248 a1 ...\n... An \u2208 L(xn\u22121) xn\u22121 \u2248 an\u22121 A0 \u2208 L(xn) xn \u2248 an\n12\nAfter initialization, the tableau algorithm proceeds by non-deterministically applying the expansion rules for ALCM given in Figure 5. The algorithm says that the ontology (T ,A,M) is consistent iff the expansion rules can be applied in such a way they yield a complete forest L without contradictions nor circularities. Otherwise the algorithm says that it is inconsistent. Note that due to the non-determinism of the algorithm, implementations of it have to guess the choices and possibly have to backtrack to choice points if a choice already made has led to a contradiction. The algorithm stops when we reach some L that is complete, has neither contradictions nor circularities or when all the choices have yield a forest with contradictions or circularities.\nThis tableau algorithm has complexity NEXP and hence, it is not optimal. In the following section we define an optimal algorithm for ALCM and prove that is ExpTime.\n13\n6 A Tableau Calculus for ALCM\nIn order to eliminate non-determinism, the completion trees of the standard tableau algorithm are replaced with structures called and-or graphs [15]. In such structure, both branches of a non-deterministic choice introduced by disjunction are explicitly represented. Satisfiability of the branches is propagated bottom-up and if it reaches an initial node, we can be sure that a model exists. A global catching of nodos and a proper rule-application strategy is used to guarantee the exponential bound on the size of the graph. The and-or graphs are built using a Tableau Calculus. Our Tableau Calculus for ALCM is an extension of the Tableau Calculus for ALC given by Nguyen and Szalas [15], which adds new rules for handling meta-modelling. From now on, we assume that Tboxes, Aboxes and all concepts are in negation normal form (NNF) (see Figure 2). Note that the concepts in an Mbox are already in NNF since they are all atomic. The Tableau Calculus for ALCM is defined by the tableau rules of Figures 6 and 7. In the premises and conclusions of these rules, we find judgements J that are built using the following grammar.\n1. Simple judgements J are of the following three forms:\n(T ,A,M) base judgement\n(T ,X ) variable judgement\n\u22a5 absurdity judgement\n2. Or-judgements are of the form J1 \u2228 J2, where J1 and J2 are simple judgements. 3. And-judgements are of the form J1 \u2227 . . .\u2227 Jk, where Ji are simple judgements for\nall 1 \u2264 i \u2264 k.\nThe first basic judgement is just the knowledge base (T ,A,M). After initialization, the Aboxes A of the Tableau Calculus do not contain equality assertions a = b because we choose the individual a as a canonical representative and replace b by a. We write A[a/b] andM[a/b] to denote the replacement of b by a in A andM respectively. For the second basic judgement, we have that T is a Tbox andX is a set of concepts. The set X intuitively represents the set of concepts satisfiable by a certain unknown x. The key feature of this tableau calculus is actually not to create variables x for the existential restrictions as the standard tableau for Description Logic does. It actually forgets the variables and only cares about the set X of concepts that should be satisfiable. By not writing x explicitly, the set X can be shared by another existential coming from another branch in the graph and this will allow us to obtain an ExpTime algorithm for checking consistency. Recall from Definition 11 and 10 that (T ,A,M) is satisfiable if there exists I such that\n1. I |= d T \u2261 > thus I is a model of T , 2. I |= A and 3. I |=M.\n14\nRecall that (T ,X ) is satisfiable if there exists I such that\n1. I |= d T \u2261 > thus I is a model of T and 2. I satisfies the set X of concepts, i.e. ( d X )I 6= \u2205.\nWe have that \u22a5 is always unsatisfiable. We say that J1 \u2227 . . . \u2227 Jk is satisfiable if Ji is satisfiable for all 1 \u2264 i \u2264 k. We use\u2227 {J1, . . . , Jk} to denote J1 \u2227 . . .\u2227 Jk. We say that J1 \u2228 J2 is satisfiable if J1 or J2 is satisfiable. The tableau rules are written downwards, they have only one simple judgement as premise and can have a sequence of simple judgements as conclusion. Unary rules have only a simple judgement as conclusion and they are of the form:\nJ0 J1\nwhere J0 and J1 are both simple. Non-unary rules have a conclusion which is a and-judgements or an or-judgements. In the first case, we have an and-rule which is of the form:\nJ0 J1 \u2227 . . .\u2227 Jk\nwhere Ji is simple for all 1 \u2264 i \u2264 k. In this case, the arity of the rule is k. When the conclusion is an or-judgements, we have an or-rule which is of the form:\nJ0 J1 \u2228 J2\nwhere J1 and J2 are simple. In this case, the arity of the rule is 2. A bottom rule is a rule whose conclusion is \u22a5. The (trans) and (trans\u2032) rules are called transitional, the rest of the rules are called static. The rules (t), (t\u2032) and (close) are all or-rules and all of them have arity 2. The rules (trans) and (trans\u2032) are and-rules. The arity of the and-rules depend on the number of existentials in A or in X . The rest of the rules are unary since their conclusion is a simple judgement. In the Tableau Calculus, the rules (t), (t\u2032) and (close) are deterministic. The inherent choice of these rules is explicitly represented using the or-judgement. The Tableau Calculus does not have an explicit Tbox-rule as the standard tableau algorithm. Instead, this rule is \u201cspread inside other rules\u201d, namely (trans), (trans\u2032) and (6=)-rules ensuring that the new individuals satisfy the concepts in the Tbox. Also, the initialization ensures that all the individuals of the initial knowledge base satisfy the concepts of the Tbox (see Definition 21). The rules (trans) and (trans\u2032) need to be and-rules because all the outermost existentials are treated simultaneously 3. Each of these rules is a compact way of doing what was necessary to do with three rules, \u2203-rule, \u2200-rule and the Tbox-rule in the standard tableau algorithm.\n3 The concept \u2203R.\u2203S.C has two nested existentials and the outermost one is \u2203R.\n15\nThe rules (trans) and (trans\u2032) are indirectly introducing unknown individuals for each outermost existential. Those unknown individuals should satisfy all concepts in the Tbox and inherit all concepts from the \u2200 of the corresponding role.\nWe explain the intuition behind the new rules that deal with meta-modelling, which are (\u22a53), (close), (=) and (6=). If a =m A and b =m B then the individuals a and b represent concepts. Any equality at the level of individuals should be transferred as an equality between concepts and similarly with the difference. Note that the Aboxes of the Tableau Calculus do not contain equality assertions a = b because we choose the individual a as a canonical representative and replace b by a in the initialization as well as in the (close)-rule. The (close)-rule is an or-rule that distinguishes between the two possibilities: either a and b are equal or they are different. In the case a and b are equal, we choose a as canonical representative and replace b by a. Note that b is replaced by a in the Mbox and we get a =m B as the result of replacing b by a in b =m B. In the case a and b are different, we simply add the axiom a 6= b to the Abox. The (=)-rule transfers an \u201cequality between individuals\u201d to the level of concepts. Since we choose canonical representatives for individuals, this happens only when a =m A and a =m B. Instead of adding the statement A \u2261 B to the TBox, we add its negation normal form which is (A u \u00acB) t (\u00acA u B). Since we add this new concept to the TBox, we also have to add that all the existing individuals satisfy this concept. Note that the principal premise a =m B is removed from the Mbox and does not appear in the conclusions of the rule. The (6=)-rule transfers the difference between individuals to the level of concepts. If a 6= b is in the Abox, then we should add that A 6\u2261 B. However, we cannot add A 6\u2261 B because the negation of \u2261 is not directly available in the language. So, what we do is to replace it by an equivalent statement, i.e. we add an element d0 that is in A but not in B or it is in B but it is not in A. Note also that the individual d0 should also satisfy all the concepts that are in the Tbox T . The (\u22a53)-rule ensures that there are no circularities and hence, the domain of the canonical interpretation is well-founded. This rule uses the following definition:\nDefinition 19 (Circularity of an Abox w.r.t an Mbox). We say thatA has a circularity w.r.t.M, denoted as circular(A,M), if there is a sequence of meta-modelling axioms a1 =m A1, a2 =m A2, . . ., an =m An all inM such that A1(a2), A2(a3), . . . , An(a1) are in A.\nFor example, the Abox A = {A(a), B(b)} has a circularity w.r.t to the Mbox M = {a =m A, b =m B}. A formula is either a concept, or an Abox statement or an Mbox statement. Formulas are denoted by greek letters \u03d5, etc. The distinguished formulas of the premise are called the principal formulas of the rule.\nRemark 1.\n\u2013 Note that the rules (t\u2032), (u\u2032), (\u2200), (6=) and (close) need a side condition to ensure termination (otherwise the same rule can be vacuously applied infinite times). The\nDefinition 20 (Preferences). The rules are applied in the following order:\n1. The bottom rules \u2013 which are (\u22a5), (\u22a51), (\u22a52) and (\u22a53) \u2013 are applied with higher priority. 2. The rest of the unary rules \u2013 which are (u), (\u2200), (u\u2032), (=) and ( 6=) \u2013 are applied only if no bottom rule is applicable. 3. The (t), (t\u2032) and (close)-rules are applied only if no unary rule is applicable. 4. The (trans) and (trans\u2032)-rules are applied if no other rule is applicable.\nWe now describe how to construct an and-or graph from the tableau calculus of Figures 6 and 7. This graph is built using global caching, i.e. the graph contains at most one node with that judgement as label and this node is processed (expanded) only once. The complexity of the tableau calculus without global caching would be double exponential. But using global caching, we do not repeat nodes and the complexity is exponential.\nDefinition 21 (And-or graph for a knowledge base inALCM). LetK = (T ,A,M) be a knowledge base in ALCM. The and-or graph for (T ,A,M), also called tableau for (T ,A,M), is a graph G constructed as follows.\n1. The graph contains nodes of three kinds: variable nodes,base nodes and absurdity nodes. The label of a variable node is (T ,X ). The label of a base node is (T ,A,M). The label of an absurdity node is \u22a5. 2. The root of the graph is a base node whose label is (T0,A0,M0) where\nT0 := T A0 := A\u2217 \u222a {C(a) | C \u2208 T , a \u2208 dom(A\u2217) \u222a dom(M\u2217)} M0 :=M\u2217\n18\nand A\u2217 andM\u2217 are obtained from A andM by choosing a canonical representative a for each assertion a = b and replacing b by a. 3. Base nodes are expanded using the rules of Figure 7 while variable nodes are expanded using the rules of Figure 6. 4. For every node v of the graph, if a k-ary rule \u03b4 is applicable to (the label of) v in the sense that an instance of \u03b4 has the label of v as premise and Z1, . . . , Zk as possible conclusions, then choose such a rule according to the preference of Definition 20 and apply it to v to make k successors w1, . . . , wk with labels Z1, . . . , Zk, respectively. 5. If the graph already contains a node w\u2032i with label Zi then instead of creating a new node wi with label Zi as a successor of v we just connect v to w\u2032i and assume wi = w \u2032 i. 6. If the applied rule is (trans) or (trans\u2032) then we label the edge (v, wi) by \u2203R.C if the principal formula is either \u2203R.C or (\u2203R.C)(a). 7. If the rule applied to v is an or-rule then v is an or-node. If the rule applied to v is an and-rule then v is an and-node. 8. If no rule is applicable to v then v is an end-node as well as an and-node.\nRemark 2. We make the following observations on the construction of the and-or graph.\n\u2013 The graph cannot contain edges from a variable node to a base node. \u2013 Each non-end node is \u201cexpanded\u201d exactly once, using only one rule. Expansion\ncontinues until no further expansion is possible. \u2013 The nodes have unique labels. \u2013 Nodes expanded by applying a non-branching static rule can be treated either as\nor-nodes or and-nodes. We choose to treat them as or-nodes. Applying the (u) to a node causes the node to become an or-node (which might seem counter-intuitive).\n\u2013 The graph is finite (see Lemma 13).\nDefinition 22 (Marking). A marking of an and-or graph G is a subgraph G\u2032 of G such that:\n\u2013 the root of G is the root of G\u2032. \u2013 if v is a node of G\u2032 and is an or-node of G then there exists exactly one edge (v, w)\nof G that is an edge of G\u2032. \u2013 if v is a node of G\u2032 and is an and-node of G then every edge (v, w) of G is an edge\nof G\u2032. \u2013 if (v, w) is an edge of G\u2032 then v and w are nodes of G\u2032.\nA marking G\u2032 of an and-or graph G for (T ,A,M) is consistent if it does not contain any node with label \u22a5. Example 4. Figure 8 shows the and-or graph for the following knowledge base.\nTbox > v \u2203S.A Abox \u2203R.A(d) \u2200R.\u00acB(d) Mbox a =m A b =m B\nTo reduce the number of nodes, we apply lazy unfolding (denoted by l. unf. in the figure) [23]. Instead of adding (A t \u00acB) u (B t \u00acA) in the (=)-rule, we add A \u2261 B. Then, we do lazy unfolding and replace A by B in expressions of the formA or \u00acA that appear in X or in expressions of the form A(x) or \u00acA(x) that appear in A.\n19\n20\n7 Correctness of the Tableau Calculus for ALCM\nIn this section we prove correctness of the Tableau Calculus for ALCM presented in the previous section.\nTheorem 2 (Correctness of the Tableau Calculus). The ALCM knowledge base K = (T ,A,M) is consistent if and only if the and-or graph for K has a consistent marking.\nThe if direction is proved in Theorem 3 (Soundness) and the only if direction is proved in Theorem 9 (Completeness). We give an idea of the proof. For the if direction, it is necessary to prove that the rules preserve satisfiability. A consistent marking exists because we start from a satisfiable node with label K = (T ,A,M). For the only if direction, we prove that the converse of base rules preserve satisfiability, i.e. if the conclusion is satisfiable, so is the premise. Then, it is enough to construct a canonical model for a base node where no base rules are applicable. We know at that point that the Mbox has no circularities which is crucial to enforce that the model is well-founded. We also know that the (=) and (6=)-rules cannot longer be applied, which means that there is an isomorphism between the canonical interpretation of ALC and ALCM.\nWe illustrate the idea of canonical interpretation with the following example. Suppose we have an ontology (T ,A,M) with four individuals a, b, c and d with axioms B(a), A(c), A(d) and the meta-modelling axioms given by a =m A and b =m B. The canonical interpretation I of the ALC ontology is then,\n\u2206I = {a, b, c, d} AI = {c, d} BI = {a}\nIntuitively, we see that we need to force the following equations to make the metamodelling axioms a =m A and b =m B satisfiable:\na = {c, d} b = {a}\nThese equations do not have circularities. Then, the canonical interpretation I \u2032 for the ontology in ALCM is now defined as follows.\n\u2206I \u2032 = {{c, d}, {{c, d}}, c, d} AI \u2032 = aI \u2032 = {c, d} BI \u2032 = bI \u2032 = {{c, d}}\nIn this case, I \u2032 is a model of (T ,A,M). By defining S0 = {c, d}, we see that \u2206I \u2032 \u2282 S2."}, {"heading": "7.1 Soundness", "text": "In order to prove soundness, the following lemma is crucial:\n21\nLemma 6 (Preservation of Satisfiability in the Tableau Calculus). All the rules of Figures 6 and 7 preserve satisfiability, i.e. if the premise is satisfiable so is the conclusion.\nProof. Note that the statement holds trivially for the bottom rules since their premises are unsatisfiable. We now give the proof of the statement for some of the rules that are most interesting.\n(close)-rule. Suppose the premise (T ,A,M) is satisfiable. Then, there exists an interpretation I such that\n\u2022 I |= d T \u2261 > \u2022 I |= A \u2022 I |=M\nAccording to the interpretation I, given two individuals a, b belonging to dom(M) we have that either aI = bI or aI 6= bI .\nWe will prove that in both cases (T ,A[a/b],M[a/b]) \u2228 (T ,A \u222a {a 6= b},M) is satisfiable. 1. Suppose aI = bI . It is easy to prove the following properties:\nI |= A, aI = bI implies I |= A[a/b]\nI |=M, aI = bI implies I |=M[a/b]\nHence, (T ,A[a/b],M[a/b]) is satisfiable and so is (T ,A[a/b],M[a/b]) \u2228 (T ,A \u222a {a 6= b},M).\n2. Suppose aI 6= bI . This means that I |= a 6= b and then I |= A \u222a {a 6= b}. Therefore, (T ,A\u222a{a 6= b},M) is satisfiable and so is (T ,A[a/b],M[a/b])\u2228 (T ,A \u222a {a 6= b},M).\n(=)-rule. Suppose the premise (T ,A,M\u222a{a =m A, a =m B}) is satisfiable. Hence, there exists an interpretation I such that\n\u2022 I |= d T \u2261 > \u2022 I |= A \u2022 I |=M\u222a {a =m A, a =m B} .\nWe need to prove that: 1. I |= d (T \u222a {(A t \u00acB) u (B t \u00acA)) \u2261 >\n2. I |= A \u222a {((A t \u00acB) u (B t \u00acA))(d) | d \u2208 dom(A) \u222a dom(M) \u222a {a}} 3. I |=M\u222a {a =m A}\n1. Since I |= a =m A, we have that\naI = AI (1)\n22\nand since I |= a =m B, we also have that\naI = BI (2)\nFrom (1) and (2), we get AI = BI (3)\nWe will prove that I validates (A t \u00acB) u (B t \u00acA), that is\n((A t \u00acB) u (B t \u00acA))I = \u2206I .\nApplying the definition of interpretation we have that\n((A t \u00acB) u (B t \u00acA))I = (AI \u222a (\u2206\\BI)) \u2229 (BI \u222a (\u2206\\AI)\nFrom (3) and replacing in the above expression we obtain\n((A t \u00acB) u (B t \u00acA))I = (AI \u222a (\u2206\\AI)) \u2229 (AI \u222a (\u2206\\AI) = \u2206I\nSo, I |= (A t \u00acB) u (B t \u00acA) \u2261 > and then\nI |= l (T \u222a {(A t \u00acB) u (B t \u00acA)) \u2261 >.\n2. Since ((A t \u00acB) u (B t \u00acA))I = \u2206I , we have that\ndI \u2208 ((A t \u00acB) u (B t \u00acA))I\nfor all d \u2208 dom(A) \u222a dom(M).\n3. M\u222a {a =m A} \u2282 M\u222a {a =m A, a =m B} and I |=M\u222a {a =m A, a =m B}, so I |=M\u222a {a =m A}\nThis means that the conclusion of the (=)-rule\n(T1,A1,M\u222a {a =m A})\nwhere T1 := T \u222a{(At\u00acB), (Bt\u00acA)} andA1 = A\u222a{((At\u00acB)u(Bt\u00acA))(d) | d \u2208 dom(A) \u222a dom(M) \u222a {a}} is satisfiable.\n(6=)-rule. Suppose the premise (T ,A \u222a {a 6= b},M\u222a {a =m A, b =m B}) is satisfiable. Consequently, there exists an interpretation I such that\n\u2022 I |= d T \u2261 > \u2022 I |= A, a 6= b thus I |= A and I |= a 6= b\n\u2022 I |=M, a =m A, b =m B thus I |=M, I |= a =m A and I |= b =m B\n.\nIn order to prove that the conclusion of the rule is satisfiable we only need to prove that\n23\n1. I |= (A u \u00acB t \u00acA uB)(d0) where d0 is a new individual and 2. I |= C(d0) for all C \u2208 T\nas the other conditions follow immediately from the satisfiable property of the premise.\n1. Since I |= a 6= b, we have that\naI 6= bI (4)\nSince I |= a =m A and I |= b =m B, we also have that\naI = AI bI = BI (5)\nIt follows from (4) and (5) that the sets AI and BI are different. Hence, there is an element in one of these sets that is not in the other. That is to say, there exists an element on the domain of the interpretation (x \u2208 \u2206I) that belongs to the set (AI \u2229 (\u2206\\BI)) \u222a ((\u2206\\AI) \u2229BI). If we use d0, a new individual in K, to denote x (d0I = x) we have that I |= (A u \u00acB t \u00acA uB)(d0).\n2. Since I |= d T \u2261 > we have that I validates every concept C \u2208 T . This\nmeans that x \u2208 CI for all x \u2208 \u2206I and for all C \u2208 T . In particular: d0I \u2208 CI and hence, I |= C(d0) for all C \u2208 T .\nIn this way we can conclude that the ( 6=)-rule preserves satisfiability.\nLemma 7 (Preservation of Satisfiability in the And-or-graph). In an And-or graph G, for every no-end node with satisfiable label:\n\u2013 if it is an and-node, all its successors have a satisfiable label. \u2013 if it is an or-node, at least one of its successors has a satisfiable label.\nProof. Let v be a no-end node with label E1 satisfiable. The successors of v are obtained by applying one of the rules of Figures 6 and 7 (let it be r) using E1 as premise of the rule. In addition, the labels of the successors nodes are obtained from the conclusion of the rule.\nv is an and-node The conclusion of r is a and-judgement of the form: J1 \u2227 . . . \u2227 Jk, where Ji are simple judgements for all 1 \u2264 i \u2264 k. Applying Lemma 6 we know that J1 \u2227 . . . \u2227 Jk is satisfiable since E1 (premise of r) is satisfiable. So each Ji is satisfiable. Based on the construction of the graph G the labels of the successors of v are each Ji. Consequently, the labels of all the successors of v are satisfiable. v is an or-node The conclusion of r is a or-judgement of the form: J1 \u2228 J2, where J1 and J2 are simple judgements. Since E1 (premise of r) is satisfiable, so is J1 \u2228 J2 (applying Lemma 6). From the definition of satisfiable we know that J1 is satisfiable or J2 is satisfiable. In these cases the node v has two successors w1, w2 and the labels of these nodes are J1 and J2 respectively. Hence, at least one of the successors of v has a label which is satisfiable.\n24\nTheorem 3 (Soundness of the Tableau Calculus of ALCM). Let K = (T ,A,M) be a knowledge base of ALCM in negation normal form. If K is consistent then the and-or graph for K has a consistent marking.\nProof. Let G be the and-or graph for K. We will construct G\u2032 a consistent marking of G.\n\u2013 First of all, we initialize G\u2032 with the root of G. IfK = (T ,A,M) is consistent then the label of this node calculated as stated in definition 21 is satisfiable. \u2013 Then for each node v in G\u2032: \u2022 if v is an and-node we add all the successors of v in G to G\u2032, and all the edges\nbetween them. Applying Lemma 7, we deduce that all these new nodes in G\u2032 have satisfiable labels. \u2022 if v is an or-node we add to G\u2032 the successors of v in G having a satisfiable label. We know this node exists from Lemma 7.\nIt is easy to show that G\u2032 is a marking of G (see Definition 22). The node we use to initialize G\u2032 has a satisfiable label and we ensure that each node we add has a satisfiable label, so in G\u2032 there is no node with label \u22a5. Consequently G\u2032 is a consistent marking of G. Since G\u2032 is a subgraph of a finite graph (see Remark 2), it is finite."}, {"heading": "7.2 Completeness", "text": "We define three notions of saturated R-structure 1) for a Tbox T , 2) for an ALCknowledge base (T ,A) and 3) for anALCM-knowledge base (T ,A,M). These three notions are conditions that ensure satisfiability of a set X of concepts w.r.t. T , satisfiability of a ALC-knowledge base (T ,A) and satisfiability of an ALCM-knowledge base (T ,A,M) respectively (see Theorems 4, 5 and 7). They correspond to the socalled \u201ctableau\u201d in Description Logic [24,1]. A saturated R-structure can be seen as an abstraction of a model. The weaker notion of consistent model graph given by Nguyen and Szalas [15] includes clauses 1-5 of Definition 24 but not the last one. Hence, it only ensures satisfiability of a set of concepts with respect to an empty Tbox. The sufficient conditions for satisfiability (Theorems 4, 5 and 7) structure the proof of completeness and make it more neat.\nDefinition 23 ( R-structure). We say that (\u2206,L, E) is an R-structure if\n\u2013 \u2206 is a non-empty set, \u2013 L maps each element in \u2206 to a set of concepts, \u2013 E : R\u2192 2\u2206\u00d7\u2206 maps each role in R to a set of pairs of elements in \u2206.\nDefinition 24 (Saturated R-structure). We say that S = (\u2206,L, E) is a saturated Rstructure for a Tbox T if S = (\u2206,L, E) is an R-structure that satisfies the following properties for all x, y \u2208 \u2206, R \u2208 R and concepts C,C1, C2.\n1. If \u00acC \u2208 L(x), then C 6\u2208 L(x). 2. If C1 u C2 \u2208 L(x), then C1 \u2208 L(x) and C2 \u2208 L(x). 3. If C1 t C2 \u2208 L(x), then C1 \u2208 L(x) or C2 \u2208 L(x).\n25\n4. If \u2200R.C \u2208 L(x) and (x, y) \u2208 E(R), then C \u2208 L(y). 5. If \u2203R.C \u2208 L(x), then there is some y \u2208 \u2206 such that (x, y) \u2208 E(R) and C \u2208 L(y). 6. If C \u2208 T then C \u2208 L(x) for all x \u2208 \u2206.\nDefinition 25. The interpretation I induced by an R-structure is defined as follows.\n\u2206I = \u2206 AI := {x \u2208 \u2206 | A \u2208 L(x)} RI := E(R)\nAs usual, it is enough for an interpretation as the one given above to define it only for atomic concepts A. Next lemma gives a characterization of that interpretation for complex concepts.\nLemma 8. Let S = (\u2206,L, E) be a saturated R-structure for a Tbox T and I be the interpretation induced by S. For every x \u2208 \u2206, if C \u2208 L(x) then x \u2208 CI .\nProof. This is proved by induction on C. We prove some cases.\n\u2013 Suppose C = A. This is the base case. By Definition 25, we have that x \u2208 AI . \u2013 SupposeC = \u00acD. SinceC is in negation normal form, we have thatD is an atomic\nconcept, say A. Since S is a saturated R-structure, by Definition 24, A /\u2208 L(x). By Definition 25, we have that x 6\u2208 AI . Hence, x \u2208 (\u00acA)I . \u2013 Suppose C = C1uC2. By Definition 24, C1 \u2208 L(x) and C2 \u2208 L(x). By induction hypothesis we have that x \u2208 CI1 and x \u2208 CI2 . Then x \u2208 CI1 \u2229 CI2 , so x \u2208 (C1 u C2)I , which means that x \u2208 CI . \u2013 Suppose C = \u2203R.D. By Definition 24, there is some y \u2208 \u2206 such that (x, y) \u2208 E(R) and D \u2208 L(y). By Definition 25, we have that (x, y) \u2208 RI . By induction hypothesis, y \u2208 DI . Then x \u2208 (\u2203R.D)I , and so x \u2208 CI .\nTheorem 4. Let S = (\u2206,L, E) be a saturated R-structure for a Tbox T . IfX \u2286 L(x0) for some x0 \u2208 \u2206 then X is satisfiable w.r.t. T .\nProof. Let I be an interpretation induced by S. It follows from Lemma 8 that x0 \u2208 CI for all C \u2208 X . Hence ( d X )I 6= \u2205. We also have that I is a model of T from the last clause of Definition 24.\nDefinition 26 (Saturated R-structure for (T ,A)). We say that S = (\u2206,L, E) is a saturated R-structure for (T ,A) if S = (\u2206,L, E) is a saturated R-structure for T that satisfies the following properties.\n1. \u2206 contains all the individuals of A. 2. If C(a) \u2208 A, then C \u2208 L(a). 3. If R(a, b) \u2208 A, then (a, b) \u2208 E(R). 4. If a 6= b \u2208 A then a and b are syntactically different.\nTheorem 5. Let A an Abox without equality axioms and S = (\u2206,L, E) be a saturated R-structure for (T ,A). Then, the ALC-knowledge base (T ,A) is satisfiable (consistent).\n26\nProof. Let I be the interpretation induced by S. For each individual a of A, we define aI = a. We will show that I is a model for (T ,A). I is a model of T by the last clause of Definition 24 and Lemma 8. To show that I is a model of A, we will prove that aI \u2208 CI for all C(a) \u2208 A, (aI , bI) \u2208 RI for all R(a, b) \u2208 A and aI 6= bI for all a 6= b \u2208 A.\n\u2013 Suppose C(a) \u2208 A. By Definition 26, C \u2208 L(a) and by Lemma 8, aI = a \u2208 CI . \u2013 Suppose R(a, b) \u2208 A. By Definition 26, (a, b) \u2208 E(R) and by Definition 25, (aI , bI) = (a, b) \u2208 RI . \u2013 Suppose a 6= b \u2208 A. By Definition 26, a and b are syntactically different, so aI 6= bI .\nDefinition 27 (Circularity of an R-structure w.r.t an Mbox). We say that S = (\u2206,L, E) has a circularity w.r.t. M if there is a sequence of meta-modelling axioms a1 =m A1, a2 =m A2, . . ., an =m An all inM such that A1 \u2208 L(a2), A2 \u2208 L(a3), . . . , An \u2208 L(a1).\nDefinition 28 (Saturated R-structure for (T ,A,M)). We say that S = (\u2206,L, E) is a saturated R-structure for (T ,A,M) if S = (\u2206,L, E) is a saturated R-structure for (T ,A) that satisfies the following properties.\n1. \u2206 contains all the individuals ofM. 2. S has no circularities w.r.t.M. 3. if a =m A \u2208 M and a =m B \u2208 M, then A = B, i.e. A and B are syntactically\nequal. 4. if a and b are syntactically different, a =m A \u2208 M and b =m B \u2208 M, then there\nis some t \u2208 \u2206 such that A u \u00acB tB u \u00acA \u2208 L(t).\nNote that the set\u2206 of a saturated R-structure for (T ,A,M) contains the individuals of M as well as the ones of A. In Theorem 8 we construct a R-structure for a knowledge base K = (T ,A,M) where no other rule is applicable to K except for the (trans\u2032)rule. In particular, A does not contain equalities andM does not contain two axioms with the same individual a, i.e. if a =m A and a =m B are in M then A and B are syntactically equal.\nDefinition 29 (From Basic Objects to Sets). Let S = (\u2206,L, E) be a saturated Rstructure for (T ,A,M). For x \u2208 \u2206 we define set(x) as follows.\nset(x) = x if x 6\u2208 dom(M) set(x) = {set(y) | A \u2208 L(y)} otherwise, i.e. x \u2208 dom(M) and x =m A \u2208M\nSince \u2206 contains the individuals ofM, an element of \u2206 either belongs to dom(M) or not. In case, x \u2208 dom(M) then we have that x =m A \u2208M.\nExample 5. We consider the example of Figure 4 and add a new individual hydrographic and the meta-modelling axiom\nhydrographic =m HydrographicObject\n27\nHere we have for example that river is an individual with meta-modelling. As such, its interpretation should be a set and not a basic object. The set associated to river is given by the function set and it is as follows.\nset(river) = {queguay, santaLucia}\nThe individual hydrographic has also meta-modelling. But its inhabitants also have meta-modelling. The set associated to hydrographic is a set of sets given as follows.\nset(hydrographic) = {{queguay, santaLucia}, {deRocha, delSauce}}\nOn the other hand, queguay does not have meta-modelling and we define set as follows.\nset(queguay) = queguay.\nTheorem 6 (Correctness of the recursive definition). Let S = (\u2206,L, E) be a saturated R-structure for (T ,A,M). The function set is a correct recursive definition.\nProof. It follows from the third clause of Definition 28 that set is indeed a function. In order to prove that is a correct recursive definition, we apply the recursion principle on well-founded relations (see Definition 6). For this, we define the relation\u227a on \u2206 as y \u227a a iff A \u2208 L(y) and a =m A \u2208M. Since L has no circularities w.r.t. M, it is easy to prove that \u227a is well-founded. Suppose towards a contradiction that\u227a is not well-founded. It follows from Lemma 2, that there exists an infinite \u227a-decreasing sequence, i.e. there is \u3008xi\u3009i\u2208N such that xi+1 \u227a xi and xi \u2208 \u2206 for all i \u2208 N. . . . \u227a xi+1 \u227a xi \u227a . . . \u227a x1 By definition of \u227a, we have that xi \u2208 dom(M) for all i \u2208 N. Since the Mbox is finite, there exists an element in the above sequence that should occurs at least twice, i.e. xi+1 = xi+n+1 = a1 for some i, n \u2208 N. Hence, we have a cycle\nxi+n+1\n= a1\n\u227a xi+n\n= an\n\u227a xn+i\u22121\n=\nan\u22121\n\u227a . . . \u227a xi+2\n= a2\n\u227a xi+1\n= a1\nIt is easy to see that this contradicts the fact that S has no circularities w.r.t.M. Since \u227a is well-founded, we can apply the recursion principle in Definition 29. Note that in the recursive step of that definition, we have that y \u227a x.\nLemma 9. Let S = (\u2206,L, E) be a saturated R-structure for (T ,A,M). If S0 = {x \u2208 \u2206 | x /\u2208 dom(M)} then\nset(x) \u2208 S]M\nProof. Let maxl\u227a(x) be the maximal length of all descending \u227a-sequences starting from x \u2208 \u2206. This number is finite because \u227a is well-founded by Theorem 6. It is not difficult to show that\n28\nmaxl\u227a(x) \u2264 ]M for all x in \u2206.\nIt is also easy to prove that set(x) \u2208 Smaxl\u227a(x)\nby induction on maxl\u227a(x). Then set(x) \u2208 Smaxl\u227a(x) \u2286 S]M since Sn is a monotonic function on n \u2208 N (see Definition 9).\nLemma 10. Let A be an Abox without equality axioms, S = (\u2206,L, E) be a saturated R-structure for (T ,A,M), {a =m A, b =m B} \u2286 M and I the interpretation induced by S. Then, a and b are syntactically equal if and only if AI = BI .\nProof. \u2013 if a and b are syntactically equal then a =m A and a =m B are both inM. Applying the Definition 28 we have that A = B and so are their interpretations.\n\u2013 if a and b are syntactically different, applying Definition 28, it follows that there is some t \u2208 \u2206 such that A u \u00acB tB u \u00acA \u2208 L(t). Applying Definition 24 we have two possibles cases: 1. A \u2208 L(t) and B 6\u2208 L(t), so t \u2208 AI and t 6\u2208 BI , then AI 6\u2286 BI . 2. A 6\u2208 L(t) and B \u2208 L(t), so t \u2208 BI and t 6\u2208 AI , then BI 6\u2286 AI .\nIn both cases, AI 6= BI\nTheorem 7. Let A an Abox without equality axioms and S = (\u2206,L, E) be a saturated R-structure for (T ,A,M). Then, (T ,A,M) is satisfiable (consistent).\nProof. The interpretation I induced by S is a model of (T ,A) by Theorem 5. We define the interpretation I \u2032 as follows.\n\u2206I \u2032 = {set(x) | x \u2208 \u2206I} AI \u2032 = {set(x) | x \u2208 AI} RI \u2032 = {(set(x), set(y)) | (x, y) \u2208 RI} aI \u2032 = set(aI)\nWe prove the three clauses of Definition 10.\n1. It follows from Lemma 9 that \u2206I \u2032 \u2286 S]M\n2. By Lemma 1, I \u2032 is a model of (T ,A) because I and I \u2032 are isomorphic interpretations.\nClaim. I and I \u2032 are isomorphic interpretations.\nIn order to prove the claim, we prove that set is a bijection between the domains of I and I \u2032 as follows.\n\u2013 It follows from Theorem 6 that set is a function. \u2013 It is surjective since the elements of the domain of I \u2032 are defined as the result\nof applying set to the elements of the domain of I.\n29\n\u2013 We prove that set is injective by induction on \u227a by appling the Induction Principle given in Definition 4. We prove that if x1 and x2 are two different elements in\u2206 then set(x1) 6= set(x2), or equivalently that if set(x1) = set(x2) then x1 = x2. Suppose now that x1 and x2 are two different elements of \u2206. \u2022 Base Case. Suppose x1, x2 are individuals without meta-modelling. It fol-\nlows from the definition of set that set(x1) 6= set(x2). \u2022 Base Case. Suppose only one of them has meta-modelling, say x1. We\nknow that set(x1) 6\u2208 \u2206 since it is a set but set(x2) \u2208 \u2206 (is x2) so set(x1) 6= set(x2). \u2022 Inductive Case. Suppose that x1 and x2 are individuals with meta-modelling: x1 =m A1 and x2 =m A2. It follows from the definition of set that:\nset(x1) = {set(q) | A1 \u2208 L(q)}\nset(x2) = {set(q\u2032) | A2 \u2208 L(q\u2032)} Suppose towards a contradiction that set(x1) = set(x2). Hence, set(x1) \u2286 set(x2) and set(x2) \u2286 set(x1). Since set(x1) \u2286 set(x2), for all q such that A1 \u2208 L(q) there exists q\u2032 such that A2 \u2208 L(q\u2032) and set(q) = set(q\u2032). It follows from the definition of \u227a that q \u227a x1 and q\u2032 \u227a x2, By induction hypothesis, if q 6= q\u2032 then set(q) 6= set(q\u2032). Since set(q) = set(q\u2032), we actually have that q = q\u2032. Thus, {q | A1 \u2208 L(q)} \u2286 {q\u2032 | A2 \u2208 L(q\u2032)}, which means that:\nA1 I \u2286 A2I (6)\nAnalogously, from set(x2) \u2286 set(x1) we can prove that\nA2 I \u2286 A1I (7)\nIt follows from (6) and (7) that A2I = A1I . Then, applying Lemma 10 we have that x1 = x2 which contradicts the fact that x1 and x2 are different. Hence, set(x1) 6= set(x2). In this way we can conclude that set is injective, so it is a bijection and thus I and I \u2032 are isomorphic interpretations.\n3. We prove that I \u2032 is a model ofM. Suppose a =m A \u2208 M. From the definition of I \u2032, we know that:\naI \u2032 = set(aI).\nApplying the definition of set, we have that:\naI \u2032 = {set(y) | A \u2208 L(y)}\nFinally, applying the Definition 25 we have\naI \u2032 = {set(y) | y \u2208 AI}\nwhich is the definition of AI \u2032 Thus I \u2032 |= a =m A for all a =m A \u2208M, then I \u2032 is a model ofM.\n30\nLemma 11. If (T ,A[a/b],M[a/b]) is satisfiable, {a, b} \u2286 dom(M) \u222a dom(A), then (T ,A,M) is satisfiable.\nProof. Suppose (T ,A[a/b],M[a/b]) is satisfiable. Then, there exists I such that I |= A[a/b], I |=M[a/b] and I |= d T \u2261 >.\nWe define a new interpretation I1 that extends I by adding bI1 = aI .\n\u2013 Since I |= d T \u2261 >, we obviously have that\nI1 |= l T \u2261 >. (8)\n\u2013 The Abox A[a/b] is obtained from A by replacing all occurrences of b by a. Let S \u2208 A. We will prove that I1 |= S. There are several possibilities: 1. Suppose that S \u2208 A does not contain b. Then, it is easy to see that I1 |= S\nbecause S and S[a/b] are exactly the same statement and I |= S. 2. Suppose that S is C(b). Then, S[a/b] is C(a). Hence, bI1 = aI \u2208 CI = CI1\nsince I |= C(a). So I1 |= C(b). 3. Suppose that S is a = b or b = a. Since bI1 = aI1 , I1 |= a = b and I1 |= b = a 4. Suppose that S is b = c and c is not a. Then, S[a/b] is a = c and I |= a = c. Since bI1 = aI1 = cI1 , I1 |= b = c. 5. Suppose that S is c = b and c is not a. This case is similar to the previous one. 6. Suppose that S is b 6= c and c is not a. Then, S[a/b] is a 6= c and I |= a 6= c.\nSince bI1 = aI1 6= cI1 , I1 |= b 6= c. 7. Suppose that S is c 6= b and c is not a. This case is similar to the previous one. 8. Suppose that S is a 6= b or b 6= a. But then S[a/b] is a 6= a. This case is not\npossible because a 6= a is not satisfiable. Hence, we have just proved that\nI1 |= A. (9)\n\u2013 Let S \u2208M. We will prove that I1 |= S. There are two possibilities: 1. Suppose S does not contain b. Then, it is easy to see that I1 |= S. 2. Suppose S is b =m A \u2208 M. Then S[a/b] is a =m A and I |= a =m A. Thus, bI1 = aI = AI = AI1 and I1 |= b =m A.\nWe conclude that\nI1 |=M. (10)\nFrom (8), (9) and (10) we can affirm that (T ,A,M) is satisfiable.\nLemma 12. Suppose there is an edge from a base node v to a base nodew in an and-or graph G. If the label of w is satisfiable, so is the label of v.\n31\nProof. As w is a successor of v in and-or graph G and v is a base node, the label of w is obtained from the application of some rule r of the Figure 7 to the label of v. Given that w is a base node, r must be one of : (u\u2032),(t\u2032),(\u2200),(close),(=) or(6=). We will analyse each one of these cases.\n{(u\u2032), (t\u2032), (\u2200)}-rules - The labels of v and w are of the form: (T ,Av,M) and (T ,Aw,M) respectively. If (T ,Aw,M) is satisfiable, so is (T ,Av,M) since they have the same TBox, MBox and Av is strictly contained in Aw. (close)-rule - If (T ,Av,M) is the label for v, there are two possibilities for the label of w: 1. Suppose the label is (T ,Av \u222a {a 6= b},M). As in the case above if (T ,Av \u222a {a 6= b},M) is satisfiable, so is (T ,Av,M) . 2. Suppose the label is (T ,Av[a/b],M[a/b]). This case follows from Lemma 11. (6=)-rule - If the label of v is (T ,Av \u222a {a 6= b},M\u222a {a =m A, b =m B}) then the\nlabel of w is of the form: (T ,Aw,M\u222a {a =m A, b =m B}). So if (T ,Aw,M\u222a{a =m A, b =m B}) is satisfiable, so is the label of v since they have the same TBox, MBox and Av \u222a {a 6= b} is strictly contained in Aw. (=)-rule - The label of v is of the form: (Tv,Av,M\u222a {a =m A, a =m B}), the label of w is (Tw,Aw,M\u222a{a =m A}) where Tw = Tv \u222a {(At\u00acB)u (B t\u00acA)} and Aw = Av \u222a {((A t \u00acB) u (B t \u00acA))(d) | d \u2208 dom(Av) \u222a dom(M) \u222a {a}}. Since the label of w is satisfiable, there exists I such that: 1. I validates all the concepts in Tw, so I validates all the concepts in Tv and\n(A t \u00acB) u (B t \u00acA). 2. I |= Aw, so I |= Av \u222a {((A t \u00acB) u (B t \u00acA))(d) | d \u2208 dom(Av) \u222a\ndom(M) \u222a {a}}, then I |= Av . 3. I |=M\u222a {a =m A}, then I |=M and I |= a =m A\nSince I validates (At\u00acB)u(Bt\u00acA) we have that: ((At\u00acB)u(Bt\u00acA))I = \u2206I . Applying the definition of interpretation we have that (AI \u222a (\u2206\\BI)) \u2229 (BI \u222a (\u2206\\AI)) = \u2206I , so (AI \u222a (\u2206\\BI)) = \u2206I and (BI \u222a (\u2206\\AI)) = \u2206I . Consequently, BI \u2286 AI and AI \u2286 BI , which it means that\nAI = BI (11)\nSince I |= a =m A we have that:\naI = AI (12)\nIt follows from (11) and (12) that aI = BI , so I |= a =m B.\nHence, we have proved all the necessary conditions for the satisfiability of (Tv,Av,M\u222a {a =m A, a =m B}).\nDefinition 30 (Saturation path). Let G be an and-or graph with a consistent marking G\u2032 and let v be a node of G\u2032. A saturation path of v w.r.t. G\u2032 is a finite sequence v0 = v, v1 . . . vk of nodes of G\u2032, with k \u2265 0, such that, for every 0 \u2264 i < k, vi is an or-node and (vi, vi+1) is and edge of G\u2032, and vk is and-node.\n32\nAlgorithm for building a saturated R-structure\nInput: G\u2032 a consistent marking of and-or graph w.r.t. K = (T ,A,M) such that K satisfies the hypotheses of Theorem 8. Output: A R-structure S = (\u2206,L, E) saturated for (T ,A,M).\n33\nSince the end-node is an and-node, all nodes of G\u2032 have a saturation path.\nThe domain \u2206 of the R-structure obtained by applying the algorithm of Table 1, consists of elements that also belong to dom(A) \u222a dom(M), which we call individuals, and elements that are created to meet the conditions of the knowledge base given by the existential restrictions, which we call variables.\nThe function f in the algorithm of Table 1 maps elements in \u2206 to an and-node of the graph G\u2032.\n1. If a is an individual from the knowledge base then f(a) = v0. The individual a comes from the unique base node which is the initial node v0. In this case, the base node is also an and-node because no base rule is applicable to the knowledge base except for (trans\u2032). 2. If y is a variable (a newly created individual), then f(y) = wh. The individual y comes from the last variable node wh in the saturated path which is an and-node.\nTheorem 8 (Correctness of the Algorithm of Table 1). Let K = (T ,A,M) be a knowledge base in ALCM in negation normal form such that\n1. A does not contain equalities, 2. no base rule is applicable to K except for the (trans\u2032)-rule, 3. C(d) \u2208 A for all C \u2208 T and d \u2208 dom(A) \u222a dom(M).\nSuppose G is an and-or graph for K = (T ,A,M) with a consistent marking G\u2032. Then, the structure S = (\u2206,L, E) obtained by applying the algorithm of Table 1 is a saturated R-structure for (T ,A,M).\nProof. We first prove that S is a saturated R-structure for T . For this, we need to prove the six conditions of Definition 24. Suppose x, y \u2208 \u2206, R \u2208 R and concepts C,C1, C2, D.\n1. Suppose towards a contradiction that there is x \u2208 \u2206 such that {\u00acC,C} \u2286 L(x). Since all concepts are in NNF, C is an atomic concept B, so {\u00acB,B} \u2286 L(x). We divide en two cases: (a) Suppose x \u2208 dom(A) \u222a dom(M).\nBy construction, {\u00acB(x), B(x)} \u2286 A. But then we can apply the (\u22a51)-rule which it is not possible by the second hypothesis for K, namely no base rule is applicable to K except for the (trans\u2032)-rule.\n(b) Suppose x 6\u2208 dom(A) \u222a dom(M). By construction, L(x) = \u22c3h i=0 Xi where (T ,X0), ..., (T ,Xh) are the labels\nof the saturation path w0, . . . , wh, f(x) = wh. It is not possible that each concept is on a different node sincew0, . . . ,wh is a saturation path and no rules eliminate an atomic concept of the label of a node. Then, {\u00acB,B} \u2286 Xi for some i such that 1 \u2264 i \u2264 h. By Definition 20, the (\u22a5)-rule has higher priority than any of the other rules. This means that wi should be the last node in the path, i.e. i = h. But then, wh would be an absurdity node which contradicts the G\u2032 is a consistent marking.\n34\n2. Suppose C1 u C2 \u2208 L(x). We split in two cases: (a) Suppose x \u2208 dom(A) \u222a dom(M).\nBy construction, C1 u C2 \u2208 L(x) if (C1 u C2)(x) \u2208 A. Then we have that {C1(x), C2(x)} \u2286 A because the (u\u2032)-rule is not applicable to A. Hence, {C1, C2} \u2286 L(x)\n(b) Suppose x 6\u2208 dom(A) \u222a dom(M). By construction, L(x) = \u22c3h i=0 Xi where f(x) = wh and the labels of the\nsaturation path w0, . . . , wh are (T ,X0), ..., (T ,Xh). Hence, there exists 1 \u2264 i \u2264 h such that C1 u C2 \u2208 Xi. We have that C1 u C2 6\u2208 Xh because wh is an and-node and the (u)-rule is not applicable to (T ,Xh). Hence, there is an i < h such that C1 u C2 \u2208 Xi, C1 u C2 6\u2208 Xi+1 and C1, C2 \u2208 Xi+1. Hence, C1, C2 \u2208 Xi+1 \u2286 L(x).\n3. Suppose C1 t C2 \u2208 L(x). We divide in two cases: (a) Suppose x \u2208 dom(A) \u222a dom(M).\nBy construction, C1 t C2 \u2208 L(x) if (C1 t C2)(x) \u2208 A. Then we have that C1(x) \u2208 A or C2(x) \u2208 A because the (t\u2032)-rule is not applicable to A. Hence, C1 \u2208 L(x) or C2 \u2208 L(x).\n(b) Suppose x 6\u2208 dom(A) \u222a dom(M). By construction, L(x) = \u22c3h i=0 Xi where f(x) = wh and the labels of the\nsaturation path w0, . . . , wh are (T ,X0), ..., (T ,Xh). C1 t C2 6\u2208 Xh because wh is and-node and the (t)-rule is not applicable to (T ,Xn). Hence, there exists 1 \u2264 i < h such that C1 t C2 \u2208 Xi, C1 t C2 6\u2208 Xi+1 and C1 \u2208 Xi+1 or C2 \u2208 Xi+1. So C1 \u2208 L(x) or C2 \u2208 L(x).\n4. Assume x \u2208 \u2206, \u2200R.D \u2208 L(x) and (x, y) \u2208 E(R), we show that D \u2208 L(y). (a) Suppose x \u2208 dom(A) \u222a dom(M).\nBy construction, \u2200R.D(x) \u2208 A. \u2013 Suppose y \u2208 dom(A) \u222a dom(M).\nThen R(x, y) \u2208 A since (x, y) \u2208 E(R). Then we have that D(y) \u2208 A because the (\u2200)-rule is not applicable to A. Hence, D \u2208 L(y).\n\u2013 Suppose y 6\u2208 dom(A) \u222a dom(M) . By construction, L(y) = \u22c3h i=0 Xi where the labels of the saturation path\nw0, . . . , wh are (T ,X0), ..., (T ,Xh). Since \u2200R.D(x) \u2208 A, it belongs to the label of v0. Since R(x, y) cannot belong to A because y 6\u2208 dom(A), we have that \u2203R.C(x) \u2208 A for some concept C. By application of the (trans\u2032)-rule we know that D belongs to the label of w0 and hence also to L(y).\n(b) Suppose x 6\u2208 dom(A) \u222a dom(M). Then, y 6\u2208 dom(A) \u222a dom(M) because in E there are no pairs (x, y) where x 6\u2208 dom(A) \u222a dom(M) and y \u2208 dom(A) \u222a dom(M). So by construction, we know that:\n\u2013 L(x) = \u22c3h i=0 Xi where the labels of the saturation path w0, . . . , wh are\n(T ,X0), ..., (T ,Xh). \u2013 L(y) = \u22c3p i=0Zi where the labels of the saturation path v0, . . . , vp are\n(T ,Z0), ..., (T ,Zp).\n35\nSince (x, y) \u2208 E(R) and R(x, y) 6\u2208 A, we know that \u2203R.C1 \u2208 L(x) for some C1. Since the rules applied to the nodes w0, . . . , wh\u22121 do not eliminate for all and exists concepts, we know that {\u2200R.D,\u2203R.C1} \u2286 Xh. The node v0 is obtained from wh by application of the (trans)-rule. In G\u2032 there is an edge (wh, v0) labelled \u2203R.C1. By the application of the (trans)-rule at the node wh we know that D \u2208 Z0, so D \u2208 L(y).\n5. Assume \u2203R.C \u2208 L(x) for x \u2208 \u2206. At the step 2 of the algorithm we create (if it does not exist) a new variable y and add (x, y) to E(R). For this y, L(y) = \u22c3h i=0 Xi where the labels of the saturation\npath w0, . . . , wh are (T ,X0), ..., (T ,Xh). Let u = f(x) (the node associated with x in G\u2032). Then, w0 is obtained from u by applying the (trans) or (trans\u2032)-rule. So C \u2208 X0 and also C \u2208 L(y).\n6. We prove that T \u2286 L(x) for all x \u2208 \u2206. We divide in cases: (a) Suppose x \u2208 dom(A) \u222a dom(M). By initialization,\nL(x) = {C | C(a) \u2208 A}\nThen, T \u2286 L(x) by the third hypothesis on K. (b) Suppose x 6\u2208 dom(A) \u222a dom(M). By construction, L(x) = \u22c3h i=0 Xi where\nf(x) = wh and the labels of the saturation path w0, . . . , wh are (T ,X0), ..., (T ,Xh). The node w0 was obtained by application of either the (trans\u2032)-rule or (trans)-rule. Since both rules add the Tbox to X0, we have that\nT \u2286 X0 \u2286 L(x)\nWe now prove that S is a saturated R-structure for (T ,A). For this, it only remains to prove the four conditions of Definition 26.\n1. By step 1 in the algorithm of Table 1 all the individuals of A belongs to \u2206.\n2. It holds by initialization of L(a) (step 1 in the algorithm) for each a \u2208 dom(A) \u222a dom(M) in the first step of algorithm, so if C(a) \u2208 A, then C \u2208 L(a).\n3. It holds by initialization of E(R) for each role name R (step 1 in the algorithm), so if R(a, b) \u2208 A, then (a, b) \u2208 E(R).\n4. If a 6= b \u2208 A then a and b are syntactically different, otherwise we could apply (\u22a52)-rule which it is not possible by the second hypothesis for K.\nWe now prove that S is a R-structure for ALCM. For this, we only need to prove the four conditions of Definition 28.\n1. By step 1 of the algorithm all the individuals ofM belongs to \u2206.\n36\n2. Suppose towards a contradicion that S has circularities w.r.t. aM. Then there is a sequence of meta-modelling axioms a1 =m A1, a2 =m A2 . . . an =m An all inM such that A1 \u2208 L(a2), A2 \u2208 L(a3) . . . An \u2208 L(a1). That is, A1(a2), A2(a3), . . . , An(a1) are in A, so from Definition 19 we have circular(A,M). But then we can apply the (\u22a53)-rule which contradicts the second hypothesis for K.\n3. Suppose a =m A \u2208 M and a =m B \u2208 M. Then, A = B. Otherwise we could apply the (=)-rule which it is not possible by the second hypothesis for K.\n4. Suppose a and b are syntactically different, a =m A \u2208M and b =m B \u2208M. Then there is some t \u2208 \u2206 such thatAu\u00acBtBu\u00acA \u2208 L(t). Otherwise we could apply the (6=)-rule which it is not possible by the second hypothesis for K.\nTheorem 9 (Completeness of the Tableau Calculus ofALCM). LetK = (T ,A,M) be a knowledge base ofALCM in negation normal form. If the and-or graph forK has a consistent marking then K is consistent.\nProof. Suppose G\u2032 is a consistent marking of the and-or graph G ofK. Let v0, v1, . . . , vn be the saturation path from the root of G\u2032. It is clear that every vi is a base node for all all 1 \u2264 i \u2264 n \u2212 1. The last node cannot be an absurdity node because G\u2032 a consistent marking. Hence, vn should be a base node as well. This means that the node vi has label\n(Ti,Ai,Mi)\nand in particular the label of v0 is\n(T0,A0,M0)\nwhere T0 := T A0 := A\u2217 \u222a {C(a) | C \u2208 T , a \u2208 dom(A\u2217) \u222a dom(M\u2217)} M0 :=M\u2217\nwhere A\u2217 andM\u2217 are obtained from A andM by choosing a canonical representative a for each assertion a = b and replacing b by a. We will apply the algorithm of Table 1 to (Tn,An,Mn). For this we need to prove that the hypotheses of Theorem 8 hold:\n1. No base rule is applicable to (Tn,An,Mn) except for (trans\u2032). To prove this we divide in cases:\n\u2013 Suppose vn is an end-node. Then, it follows trivially that no rule is applicable to the node. \u2013 Suppose that the rule (trans\u2032) was applied to vn to obtain its successors in the and-or graph G. It follows from Definition 20 that the (trans\u2032)-rule could be applied to vn only if the other rules are not applicable.\n2. It is easy to see that An does not contain equalities since A0 does not contain equalities.\n37\n3. We also have that C(d) \u2208 A for all C \u2208 T and d \u2208 dom(An) \u222a dom(Mn). This property holds in the initialization and it is also preserved after applying any of the base rules. Note that the only rule we could apply in the saturation path v0, . . . , vn that adds new individuals is the (6=)-rule.\nIt follows from Theorem 8 that there exists a a saturated R-structure for (Tn,An,Mn). By Theorem 7, (Tn,An,Mn) is satisfiable. Applying the Lemma 12 we know that (T0,A0,M0) is satisfiable and from Lemma 11 that (T ,A,M) is satisfiable too.\n8 An ExpTime Decision Procedure for ALCM\nIn this section, we prove that the complexity does not increase when we move from ALC to ALCM. In order to prove this, it is enough to give an algorithm for checking consistency of a knowledge base in ALCM that is ExpTime.\nLet K = (T ,A,M) a knowledge base in ALCM with T and A in negation normal form (NNF). We claim that the Algorithm for Checking Consistency in ALCM given in Table 2 is an ExpTime (complexity-optimal) algorithm for checking consistency of K. In the algorithm, a node u is a parent of a node v and v is a child of u iff the edge (u, v) is in G. Note also that there is a unique node with label \u22a5.\nAlgorithm for Checking Consistency in ALCM\nInput: K = (T ,A,M) in negation normal form. Output: true if K is consistent, and false otherwise.\nRecall that a formula is either a concept, or an Abox-statement or an Mbox-statement. We define the length of a formula to be the number of its symbols, and the size of a finite set of formulas to be the sum of the lenghts of its elements.\n38\nLemma 13. Let K = (T ,A,M) be an ALCM-knowledge base in negation normal form, n be the size of T \u222aA\u222aM, and G be an and-or graph forK. Then G hasO(2n4) nodes.\nProof. For each pair a, b of individuals with meta-modelling in the Mbox, the algorithm either adds a new TBox axiom, using the (=)-rule, or adds an individual that is denoted by da,b, using the ( 6=)-rule. We define\nT + = T \u222a {(A t \u00acB) u (B t \u00acA) | a =m A, b =m B \u2208M} A+ = A \u222a {(A u \u00acB tB u \u00acA)(da,b) | a =m A, b =m B \u2208M}\nThe sets T + and A+ have cardinality O(n2) since\n#{(a, b) | a, b \u2208 dom(M)} \u2264 n2 (13)\nThe label of each base node v of G is (Tv,Av,Mv). The sets Tv , Av andMv have the following upper bounds:\nTv \u2286 T +\nAv \u2286 {D(b) | C(a) \u2208 A+, D \u2208 sc(C) and b \u2208 dom(A+) \u222a dom(M)}\u222a {C(a) | C \u2208 sc(T +) and a \u2208 dom(A+) \u222a dom(M)}\u222a {a 6= b | a 6= b \u2208 A or a, b \u2208 dom(M)}\nMv \u2286 {a =m A | a \u2208 dom(M), A \u2208 range(M)}\nwhere sc(T +) denotes the image of T + under sc, i.e. sc(T +) = {sc(C) | C \u2208 T +}. Recall sc(C) gives the set of subconcepts of C. The upper bound for Av is the union of three sets:\n{D(b) | C(a) \u2208 A+, D \u2208 sc(C) and b \u2208 dom(A+) \u222a dom(M)}\u222a {C(a) | C \u2208 sc(T +) and a \u2208 dom(A+) \u222a dom(M)}\u222a {a 6= b | a 6= b \u2208 A or a, b \u2208 dom(M)}\nThe first set {D(b) | C(a) \u2208 A+, D \u2208 sc(C) and b \u2208 dom(A+) \u222a dom(M)} includes the axioms C(b) that are obtained from replacing a by b in C(a) \u2208 A. The cardinality of the first set has O(n4) = O(n2) \u00d7 O(n2). This is because we are combining D\u2019s with b\u2019s. The number of D\u2019s as well as the number of b\u2019s have O(n2) since in both cases the cardinality of A+ is the predominant one. Similarly, the cardinality of the second set has O(n4) = O(n2) \u00d7 O(n2). This is because we are combining C\u2019s with a\u2019s. There are as many C\u2019s as elements in sc(T +) and the latter hasO(n2). The number of a\u2019s has the same order as the cardinality ofA+ which is O(n2). It follows from (13) that the third set has cardinality O(n2). Hence, the cardinality of the upper bound for Av which is the union of these three sets has O(n4).\nThe number of base nodes has the following order:\nO(2n 2 )\u00d7O(2n 4 )\u00d7O(2n 2 ) = O(2n 4 )\n39\nwhich is the multiplication of the number of subsets of the upper bounds for Tv ,Av and Mv .\nThe label of each variable node w of G is (Tw,Xw) where\nTw \u2286 T +\nXw \u2286 {D | C(a) \u2208 A+ and D \u2208 sc(C)}\u222a {C | C \u2208 sc(T +)}\nThe cardinality of the bound for Xw has O(n2). Hence, the number of variables nodes are\nO(2n 2 )\u00d7O(2n 2 ) = O(2n 2 )\nwhich is the multiplication of the number of subsets of the upper bounds for Tw and Xw.\nAlgorithm for Checking Circularities\nInput: an Abox A and an MboxM. Output: true if there exists a circularity in A w.r.t.M and false otherwise.\nThe construction of the and-or graph needs to check if each node has circularities or not. We show an algorithm for checking circularities in Table 3. For example, consider the Mbox\na0 =m A0 a1 =m A1 a2 =m A2 a3 =m A3\nand the Abox A1(a0) A0(a2) A3(a2) A2(a1)\nWe construct the graph illustrated in Figure 9, whose nodes are a0, a1, a2 and a3. In this graph, there is an edge from the node ai to aj if (ai)I \u2208 (aj)I for a model I. In other words, the edges represent the membership relation \u2208.\nLemma 14. The Algorithm for Checking Consistency inALCM of Table 2 terminates and computes the set UnsatNodes in O(2n 4 ) steps where n is the size of T \u222a A \u222aM.\n40\nProof. Each node is processed in O(n) since checking for clashing and circularities take O(n). For checking circularities, we need to detect cycles in a graph (the edges represent the membership relation \u2208) which takes O(n) [25] (see Table 3). Lemma 13 guarantees that the and-or graph G can be built inO(2n4). Every node put into U is also put into UnsatNodes, but once a node is in UnsatNodes, it never leaves UnsatNodes and cannot be put back into U . Each iteration of the \u201cwhile\u201d removes one member of U . Since the number of nodes in G is O(2n4), this means that after at most O(2n4) iterations,U become empty. Each iteration is done inO(2n 4\n) steps. Hence the algorithm terminates after O(2n 4 ) steps.\nTheorem 10. The algorithm of Table 2 is an ExpTime decision procedure for checking consistency of a knowledge base in ALCM.\nProof. The proof of correctness is the same as of [20, Theorem 5.3]. We have to use Theorem 2. Complexity follows from Lemma 14.\nWe can now show the main new result of this paper:\nCorollary 1 (Complexity of ALCM). Consistency of a (general) knowledge base in ALCM is ExpTime-complete.\nHardness follows from the corresponding result for ALC (see Theorem 1). A matching upper bound for ALCM is given by the algorithm of Table 2 which by Theorem 10 is ExpTime."}, {"heading": "9 Related Work", "text": "We made several changes to the ExpTime tableau algorithm for ALC by Nguyen and Szalas to accommodate meta-modelling [15]. First of all, we added some rules for dealing with the equalities and inequalities that need to be transferred from the Tbox to the Abox and vice versa. There is also a new rule that returns inconsistency in case a circularity is found. This new rule is key for our approach to meta-modelling and ensures\n41\nthat the domain of the interpretation is well-founded. Since our tableau algorithm has the peculiarity of changing the TBox, the Tbox (and also the Mbox) have to be stored in the labels of the and-or graph, a fact that was not necessary in the simpler Tableau Calculus for ALC of Nguyen and Szalas [15]. In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14]. The approaches which define fixed layers or levels of metamodelling [8,10,12,13] impose a very strong limitation to the ontology engineer. Our approach allows the user to have any number of levels or layers (meta-concepts, meta meta-concepts and so on). Besides the benefits of not having to know the layer of each concept and having the flexibility of mixing different layers, there is a more pragmatic advantage which arises from ontology engineering. In a real scenario of evolving ontologies, that need to be integrated, not all individuals of a given concept need to have meta-modelling and hence, they do not have to belong to the same level in the hierarchy. The key feature in our semantics is to interpret a and A as the same object when a and A are connected through meta-modelling, i.e., if a =m A then aI = AI . This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26]. Our semantics also requires that the domain of the interpretation be a well-founded set. A domain such as \u2206I = {X} where X = {X} is a set that belongs to itself, it cannot represent any real object from our usual applications in Semantic Web."}, {"heading": "10 Conclusions and Future Work", "text": "The ExpTime algorithm forALCM presented in this paper can be optimized in several ways. Instead of constructing first the and-or graph and then checks whether the graph contains a consistent marking, we can do these two tasks simultaneously [20]. Adding (At\u00acB)u(Bt\u00acA) to the Tbox is not efficient since it generates too many expansions with or-branching. We can instead add A \u2261 B and apply optimizing techniques of lazy unfolding [23]. We plan to extend this algorithm to include other logical constructors such as cardinality restrictions, role hierarchies and nominals [27,28]. It is also possible to show Pspace-completeness forALCM under certain conditions of unfoldable Tboxes. The details of this proof will appear in a separate report.\nAcknowledgements. The third author would like to acknowledge a Daphne Jackson fellowship sponsored by EPSRC and the University of Leicester. We would also like to thank Alfredo Viola for some excellent suggestions."}], "references": [{"title": "The description logic SHIQ with a flexible meta-modelling hierarchy", "author": ["R. Motz", "E. Rohrer", "P.Severi"], "venue": "Journal of Web Semantics: Science, Services and Agents on the World Wide Web,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2015}, {"title": "Reasoning for ALCQ extended with a flexible metamodelling hierarchy", "author": ["R. Motz", "E. Rohrer", "P. Severi"], "venue": "Joint International Semantic Technology Conference, JIST 2014,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "A correspondence theory for terminological logics: Preliminary report", "author": ["K. Schild"], "venue": "In Proceedings of the 12th International Joint Conference on Artificial Intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1991}, {"title": "TBox and ABox Reasoning in Expressive Description Logics", "author": ["G. De Giacomo", "M. Lenzerini"], "venue": "In Proceedings of Description Logic Workshop,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1996}, {"title": "The Description Logic Handbook: Theory, Implementation, and Applications", "author": ["F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider", "editors"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Pellet: A practical OWL-DL reasoner", "author": ["Evren Sirin", "Bijan Parsia", "Bernardo Cuenca Grau", "Aditya Kalyanpur", "Yarden Katz"], "venue": "Journal of Web Semantics: Science, Services and Agents on the World Wide Web,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2007}, {"title": "On the properties of metamodeling in OWL", "author": ["B. Motik"], "venue": "Journal of Logic and Computation,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "OWL FA: A metamodeling extension of OWL DL", "author": ["J.Z. Pan", "I. Horrocks", "G. Schreiber"], "venue": "In OWLED,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "Integrated metamodeling and diagnosis in OWL 2", "author": ["B. Glimm", "S. Rudolph", "J. V\u00f6lker"], "venue": "In International Semantic Web Conference", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2010}, {"title": "Modelling and reasoning in metamodelling enabled ontologies", "author": ["N. Jekjantuk", "G. Gr\u00f6ner", "J.Z. Pan"], "venue": "International Journal Software and Informatics,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Higher-order description logics for domain metamodeling", "author": ["G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "In Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "Towards typed higher-order description logics", "author": ["M. Homola", "J. Kluka", "V. Sv\u00e1tek", "M. Vacura"], "venue": "In Proceedings of the 26th International Workshop on Description Logic,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Typed higher-order variant of SROIQ - why not", "author": ["M. Homola", "J. Kluka", "V. Sv\u00e1tek", "M. Vacura"], "venue": "In Informal Proceedings of the 27th International Workshop on Description Logics,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2014}, {"title": "Making metaquerying practical for Hi(DLLiteR) knowledge bases", "author": ["M. Lenzerini", "L. Lepore", "A. Poggi"], "venue": "In On the Move to Meaningful Internet Systems: OTM 2014 ConferencesConfederated International Conferences: CoopIS, and ODBASE 2014,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "ExpTime tableaux for checking satisfiability of a knowledge base in the description logic ALC", "author": ["L.A. Nguyen", "A. Szalas"], "venue": "In First International Conference, ICCCI 2009,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2009}, {"title": "Foundations of Semantic Web Technologies", "author": ["P. Hitzler", "M. Kr\u00f6tzsch", "S. Rudolph"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Attributive concept descriptions with complements", "author": ["M. Schmidt-Schau\u00df", "G. Smolka"], "venue": "Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1991}, {"title": "Exptime tableaux for ALC", "author": ["G. De Giacomo", "F.M. Donini", "F. Massacci"], "venue": "In Proceedings of Description Logic Workshop,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1996}, {"title": "EXPTIME tableaux for ALC", "author": ["F.M. Donini", "F. Massacci"], "venue": "Artificial Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2000}, {"title": "Exptime tableaux for ALC using sound global caching", "author": ["R. Gor\u00e9", "L.A. Nguyen"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2013}, {"title": "Notes and Exercises for Set Theory for Computer Science (pdf ) an MPhil course in Advanced Computer Science at the University of Cambridge", "author": ["G. Winskel"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2015}, {"title": "Vicious Circles: On the mathematics of Non-Wellfounded Phenomena", "author": ["J. Barwise V. Akman", "L. Moss"], "venue": "Journal of Logic, Language and Information,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1997}, {"title": "Implementation and optimisation techniques", "author": ["I. Horrocks"], "venue": null, "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "A description logic with transitive and inverse roles and role hierarchies", "author": ["I. Horrocks", "U. Sattler"], "venue": "J Logic Computation,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1999}, {"title": "Towards expressive metamodelling with instantiation", "author": ["P. Kubincov\u00e1", "J. Kluka", "M. Homola"], "venue": "In Proceedings of the 28th International Workshop on Description Logics,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2015}, {"title": "An ExpTime tableau decision procedure for ALCQI", "author": ["Y. Ding", "V. Haarslev"], "venue": "In Proceedings of Description Logic Workshop,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2007}, {"title": "An ExpTime tableau method for dealing with nominals and qualified number restrictions in deciding the description logic SHOQ", "author": ["L.A. Nguyen", "J. Golinska-Pilarek"], "venue": "Fundamenta Informaticae - Concurrency Specification and Programming 2013,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2014}], "referenceMentions": [{"referenceID": 0, "context": "The main motivation of the present work is to study the complexity of meta-modelling as defined in [1,2].", "startOffset": 99, "endOffset": 104}, {"referenceID": 1, "context": "The main motivation of the present work is to study the complexity of meta-modelling as defined in [1,2].", "startOffset": 99, "endOffset": 104}, {"referenceID": 2, "context": "The hardness result was proved in [3].", "startOffset": 34, "endOffset": 37}, {"referenceID": 3, "context": "A matching upper bound forALC was given by De Giacomo and Lenzerini by a reduction to PDL [4].", "startOffset": 90, "endOffset": 93}, {"referenceID": 4, "context": "see [5], can be extended with the expansion rules for meta-modelling of [1,2].", "startOffset": 4, "endOffset": 7}, {"referenceID": 0, "context": "see [5], can be extended with the expansion rules for meta-modelling of [1,2].", "startOffset": 72, "endOffset": 77}, {"referenceID": 1, "context": "see [5], can be extended with the expansion rules for meta-modelling of [1,2].", "startOffset": 72, "endOffset": 77}, {"referenceID": 5, "context": "This algorithm is the bases for Semantic Web reasoners such as Pellet [6].", "startOffset": 70, "endOffset": 73}, {"referenceID": 6, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 7, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 8, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 9, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 10, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 11, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 12, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 13, "context": "Other approaches to meta-modelling use translations to prove decidability and/or complexity [7,8,9,10,11,12,13,14].", "startOffset": 92, "endOffset": 114}, {"referenceID": 14, "context": "We define a tableau algorithm for checking consistency of a knowledge base in ALCM as an extension of an algorithm for ALC by Nguyen and Szalas [15].", "startOffset": 144, "endOffset": 148}, {"referenceID": 0, "context": "An Mbox is a set of equalities of the form a =m A where a is an individual and A is a concept [1,2].", "startOffset": 94, "endOffset": 99}, {"referenceID": 1, "context": "An Mbox is a set of equalities of the form a =m A where a is an individual and A is a concept [1,2].", "startOffset": 94, "endOffset": 99}, {"referenceID": 6, "context": "The fact that it is expressed in OWL Full is not very useful since the metamodelling provided by OWL Full is so expressive that leads to undecidability [7].", "startOffset": 152, "endOffset": 155}, {"referenceID": 15, "context": "2 DL has a very restricted form of meta-modelling called punning where the same identifier can be used as an individual and as a concept [16].", "startOffset": 137, "endOffset": 141}, {"referenceID": 7, "context": "The well-foundness of our model is not ensured by means of fixing layers beforehand as in [8,10] but it is the reasoner which checks for circularities.", "startOffset": 90, "endOffset": 96}, {"referenceID": 9, "context": "The well-foundness of our model is not ensured by means of fixing layers beforehand as in [8,10] but it is the reasoner which checks for circularities.", "startOffset": 90, "endOffset": 96}, {"referenceID": 16, "context": "In this section we recall the Description Logic ALC [17,5].", "startOffset": 52, "endOffset": 58}, {"referenceID": 4, "context": "In this section we recall the Description Logic ALC [17,5].", "startOffset": 52, "endOffset": 58}, {"referenceID": 2, "context": "The hardness result was proved by Schild [3].", "startOffset": 41, "endOffset": 44}, {"referenceID": 3, "context": "A matching upper bound for ALC was given by De Giacomo and Lenzerini by a reduction to PDL [4].", "startOffset": 91, "endOffset": 94}, {"referenceID": 4, "context": "The classic Tableau algorithm is not optimal and cannot be used in this proof because it is NExpTime [5].", "startOffset": 101, "endOffset": 104}, {"referenceID": 17, "context": "a general Tbox are shown by Lenzerini, Donini and Masacci [18,19].", "startOffset": 58, "endOffset": 65}, {"referenceID": 18, "context": "a general Tbox are shown by Lenzerini, Donini and Masacci [18,19].", "startOffset": 58, "endOffset": 65}, {"referenceID": 19, "context": "a general Tbox that can globally cache satisfiable and unsatisfiable sets [20].", "startOffset": 74, "endOffset": 78}, {"referenceID": 14, "context": "Nguyen and Szalas extend this same algorithm for checking consistency of a knowledge base (including a Tbox and an Abox) in ALC [15].", "startOffset": 128, "endOffset": 132}, {"referenceID": 20, "context": "In this section we recall some basic notions on well-founded sets and relations [21].", "startOffset": 80, "endOffset": 84}, {"referenceID": 20, "context": "The proof of the above lemma can be found in [21].", "startOffset": 45, "endOffset": 49}, {"referenceID": 20, "context": ", [21].", "startOffset": 2, "endOffset": 6}, {"referenceID": 0, "context": "In this section, we extend the description logic ALC with the meta-modelling defined by Motz, Rohrer and Severi [1,2].", "startOffset": 112, "endOffset": 117}, {"referenceID": 1, "context": "In this section, we extend the description logic ALC with the meta-modelling defined by Motz, Rohrer and Severi [1,2].", "startOffset": 112, "endOffset": 117}, {"referenceID": 21, "context": "Clearly, a set like X should be excluded from our interpretation domain since it cannot represent any real object from our usual applications in Semantic Web (in other areas or aspects of Computer Science, representing such objects is useful [22]).", "startOffset": 242, "endOffset": 246}, {"referenceID": 0, "context": "For the proof of the following two lemmas, see [1].", "startOffset": 47, "endOffset": 50}, {"referenceID": 14, "context": "In order to eliminate non-determinism, the completion trees of the standard tableau algorithm are replaced with structures called and-or graphs [15].", "startOffset": 144, "endOffset": 148}, {"referenceID": 14, "context": "Our Tableau Calculus for ALCM is an extension of the Tableau Calculus for ALC given by Nguyen and Szalas [15], which adds new rules for handling meta-modelling.", "startOffset": 105, "endOffset": 109}, {"referenceID": 22, "context": "in the figure) [23].", "startOffset": 15, "endOffset": 19}, {"referenceID": 23, "context": "They correspond to the socalled \u201ctableau\u201d in Description Logic [24,1].", "startOffset": 63, "endOffset": 69}, {"referenceID": 0, "context": "They correspond to the socalled \u201ctableau\u201d in Description Logic [24,1].", "startOffset": 63, "endOffset": 69}, {"referenceID": 14, "context": "The weaker notion of consistent model graph given by Nguyen and Szalas [15] includes clauses 1-5 of Definition 24 but not the last one.", "startOffset": 71, "endOffset": 75}, {"referenceID": 14, "context": "We made several changes to the ExpTime tableau algorithm for ALC by Nguyen and Szalas to accommodate meta-modelling [15].", "startOffset": 116, "endOffset": 120}, {"referenceID": 14, "context": "Since our tableau algorithm has the peculiarity of changing the TBox, the Tbox (and also the Mbox) have to be stored in the labels of the and-or graph, a fact that was not necessary in the simpler Tableau Calculus for ALC of Nguyen and Szalas [15].", "startOffset": 243, "endOffset": 247}, {"referenceID": 6, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 7, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 8, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 9, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 10, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 11, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 12, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 13, "context": "In the literature of Description Logic, there are other approaches to meta-modelling [7,8,9,10,11,12,13,14].", "startOffset": 85, "endOffset": 107}, {"referenceID": 7, "context": "The approaches which define fixed layers or levels of metamodelling [8,10,12,13] impose a very strong limitation to the ontology engineer.", "startOffset": 68, "endOffset": 80}, {"referenceID": 9, "context": "The approaches which define fixed layers or levels of metamodelling [8,10,12,13] impose a very strong limitation to the ontology engineer.", "startOffset": 68, "endOffset": 80}, {"referenceID": 11, "context": "The approaches which define fixed layers or levels of metamodelling [8,10,12,13] impose a very strong limitation to the ontology engineer.", "startOffset": 68, "endOffset": 80}, {"referenceID": 12, "context": "The approaches which define fixed layers or levels of metamodelling [8,10,12,13] impose a very strong limitation to the ontology engineer.", "startOffset": 68, "endOffset": 80}, {"referenceID": 6, "context": "This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26].", "startOffset": 107, "endOffset": 125}, {"referenceID": 10, "context": "This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26].", "startOffset": 107, "endOffset": 125}, {"referenceID": 11, "context": "This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26].", "startOffset": 107, "endOffset": 125}, {"referenceID": 12, "context": "This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26].", "startOffset": 107, "endOffset": 125}, {"referenceID": 13, "context": "This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26].", "startOffset": 107, "endOffset": 125}, {"referenceID": 24, "context": "This allows us to detect inconsistencies in the ontologies which is not possible under the Hilog semantics [7,11,12,13,14,26].", "startOffset": 107, "endOffset": 125}, {"referenceID": 19, "context": "Instead of constructing first the and-or graph and then checks whether the graph contains a consistent marking, we can do these two tasks simultaneously [20].", "startOffset": 153, "endOffset": 157}, {"referenceID": 22, "context": "We can instead add A \u2261 B and apply optimizing techniques of lazy unfolding [23].", "startOffset": 75, "endOffset": 79}, {"referenceID": 25, "context": "We plan to extend this algorithm to include other logical constructors such as cardinality restrictions, role hierarchies and nominals [27,28].", "startOffset": 135, "endOffset": 142}, {"referenceID": 26, "context": "We plan to extend this algorithm to include other logical constructors such as cardinality restrictions, role hierarchies and nominals [27,28].", "startOffset": 135, "endOffset": 142}], "year": 2015, "abstractText": "In this paper we show that the problem of checking consistency of a knowledge base in the Description Logic ALCM is ExpTime-complete. The M stands for meta-modelling as defined by Motz, Rohrer and Severi. To show our main result, we define an ExpTime Tableau algorithm as an extension of an algorithm for checking consistency of a knowledge base in ALC by Nguyen and Szalas.", "creator": "LaTeX with hyperref package"}}}