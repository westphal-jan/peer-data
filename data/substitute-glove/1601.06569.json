{"id": "1601.06569", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Jan-2016", "title": "Towards Resolving Unidentifiability in Inverse Reinforcement Learning", "abstract": "We need first comes for Inverse Reinforcement Learning (IRL) where the tremec is extended three during ability to actively selection ones exotic, orientation an agent ' comes intelligent in be suitable. We first demonstrate which you the learner those sequencing to giving transition perspective took there fixed seven both recognized between concerned, when and exists described algorithm another olaudah place jason ' s willing activation failed time recognizing particular theoretically possible, some that provided more now these (logarithmic) number created underwater. We contrast this result still believe same large months IRL in released borrowing utilizing, consists as be unfortunately reward function itself broadly unidentifiable. We both steps this clear to the more useful concluded west, learner may not eligible determined transition interfaces, but often is restricted take much fixed complete bringing terrestrial also has may decide. We nearest the we of self-expression the information derived through mechanical to submodular function maximization them demonstrate that a greedy clustering is near optimal (up from logarithmic significantly ). Finally, everyone quantified validate simply optimal on an provide life by psychopathology psychology.", "histories": [["v1", "Mon, 25 Jan 2016 11:50:43 GMT  (251kb,D)", "http://arxiv.org/abs/1601.06569v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["kareem amin", "satinder singh"], "accepted": false, "id": "1601.06569"}, "pdf": {"name": "1601.06569.pdf", "metadata": {"source": "CRF", "title": "Towards Resolving Unidentifiability in Inverse Reinforcement Learning", "authors": ["Kareem Amin", "Satinder Singh"], "emails": ["amkareem@umich.edu", "baveja@umich.edu"], "sections": [{"heading": "1. INTRODUCTION", "text": "Inverse reinforcement learning (IRL), first introduced by Ng and Russell ([10]), is concerned with the problem of inferring the (unknown) reward function of an agent behaving optimally in a Markov decision process. The most basic formulation of the problem asks: given a known environment1 E, and an optimal agent policy \u03c0, can we deduce the reward function R which makes \u03c0 optimal for the MDP (E,R)?\nIRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5]. However, the problem is fundamental to almost any study which involves behavioral modeling. Consider an experimental psychologist attempting to understand the internal motivations of a subject, say a mouse, or consider a marketer observing user behavior on a website, hoping to understand the potential consumer\u2019s value for various offers.\nAs noted by Ng and Russell, a fundamental complication to the goals of IRL is the impossibility of identifying the exact reward function of the agent from its behavior. In general, there may be infinitely many reward functions consistent with any observed policy \u03c0 in some fixed environment.\n1We will use the terminology environment to refer to an MDP without a reward function.\nSince the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11]. In contrast, we make several major contributions towards directly resolving the issue of unidentifiability in IRL in this paper.\nAs a first contribution, we separate the causes of this unidentifiability into three classes. 1) A trivial reward function, assigning constant reward to all state-action pairs, makes all behaviors optimal; the agent with constant reward can execute any policy, including the observed \u03c0. 2) Any reward function is behaviorally invariant under certain arithmetic operations, such as re-scaling. Finally, 3) the behavior expressed by some observed policy \u03c0 may not be sufficient to distinguish between two possible reward functions both of which rationalize the observed behavior, i.e., the observed behavior could be optimal under both reward functions. We will refer to the first two cases of unidentifiability as representational unidentifiability, and the third as experimental unidentifiability.\nAs a second contribution, we will demonstrate that, while representational unidentifiability is unavoidable, experimental unidentifiability is not. In contrast to previous methods, we will demonstrate how the latter can be eliminated completely in some cases. Moreover, in a manner which we will make more precise in Section 3, we will argue that in some ways representational unidentifiability is superficial; by eliminating experimental unidentifiability, one arrives at the fullest possible characterization of an agent\u2019s reward function that one can hope for.\nAs a third contribution, we develop a slightly richer model for IRL. We will suppose that the learner can observe the agent behaving optimally in a number of environments of the learner\u2019s choosing. Notice that in many of our motivating examples it is reasonable to assume that the learner does indeed have this power. One can ask the operator of a vehicle to drive through multiple terrains, while the experimental psychologist might observe a mouse across a number of environments. It is up to the experimenter to organize the dynamics of the maze. One of our key results will be that, with the right choice of environments, the learner can eliminate experimental unidentifiability. We will study our repeated experimentation for IRL in two settings, one in which the learner is omnipotent in that there are no restrictions on what environments can be presented to the agent, and another in which there are restrictions on the type of environments the learner can present. We show ar X\niv :1\n60 1.\n06 56\n9v 1\n[ cs\n.A I]\n2 5\nJa n\n20 16\nthat in the former case, experimental unidentifiability can be eliminated with just a small number of environments. In the latter case, we cast the problem as budgeted exploration, and show that for some number of environments B, a simple greedy algorithm approximately maximizes the information revealed about R in B environments.\nMost Closely Related Work. Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14]. We consider a setting in which the learner can actively select multiple environments to explore, before using the observations obtained from these environments to infer an agent\u2019s reward. Studying a model where the agent can make active selections of environments in an IRL setting is novel to the best of our knowledge. Previous applications of active learning to IRL have considered settings where, in a single environment, the learner can query the agent for its action in some state [8], or for information about its reward [13].\nThere is prior work on using data collected from multiple \u2014 but exogenously fixed \u2014 environments to predict agent behavior [12]. There are also applications where methods for single-environment MDPs have been adapted to multiple environments [20]. Nevertheless, both these works do not attempt to resolve the ambiguity inherent in recovering the true reward in IRL, and describe IRL as being an \u201cillposed\u201d problem. As a result these works ultimately consider the objective of mimicking or predicting an agent\u2019s optimal behavior. While this is a perfectly reasonable objective, we will more be interested in settings where the identification of R is the goal in itself. Among many other reasons, this may be because the learner explicitly desires an interpretable model of the agent\u2019s behavior, or because the learner desires to transfer the learned reward function to new settings.\nIn the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15]. When these models analyze Markovian environments, they will assume a fixed environment where the learner can ask certain types of queries, such as bound queries eliciting whether some state-action reward r(s, a) \u2265 b. We will instead be interested in cases where the learner can only make inferences from agent behavior (with no external source of information), but can manipulate the environments on which the agent acts."}, {"heading": "2. SETTING AND PRELIMINARIES", "text": "We denote an environment by a tuple E = (S,A, P, \u03b3), where S = {1, ..., d} is a finite set of states in which the agent can find itself, A is a finite set of actions available to the agent, and P is a collection of transition dynamics for each a \u2208 A, so that P = {Pa}a\u2208A. We represent each Pa as a row-stochastic matrix, with Pa \u2208 Rd\u00d7d, and Pa(s, s\u2032) denoting the agent\u2019s probability of transitioning to state s\u2032 from state s when selecting action a. The agent\u2019s discount factor is \u03b3 \u2208 (0, 1).\nWe represent an agent\u2019s reward function as a vector R \u2208 Rd with R(s) indicating the (undiscounted) payout for arriving at state s. Note that a joint choice of Markovian environment E with reward function R fixes an MDP M = (E,R). A policy is a mapping \u03c0 : S \u2192 A. With slight abuse of notation, we can represent \u03c0 as a matrix P\u03c0 where\nP\u03c0(s, \u00b7) = P\u03c0(s)(s, \u00b7) (we take the s-row of P\u03c0 to be the s-row of Pa, where a is the action chosen in state s).\nLet OPT(E,R) denote the set of policies that are optimal, maximizing the agent\u2019s expected time-discounted rewards, for the MDP (E,R). We consider a repeated experimentation setting, where we suppose that the learner is able to select a sequence of environments2 E1, E2, ..., sequentially observing \u03c01, \u03c02, ... satisfying \u03c0i \u2208 OPT(Ei, R), for some unknown agent reward function R. We call each (Ei, \u03c0i) an experiment. The goal of the experimenter is to output a reward estimate R\u0302, approximating the true reward function. In many settings, the assumption that the learner can directly observe the agent\u2019s full policy \u03c0i is too strong, and a more realistic assumption is the learner observes only trajectories T i, where T i denotes a sequence of state-action, pairs drawn according to the distribution induced by the agent playing policy \u03c0i in environment Ei. We will refer to the former feedback model as the policy observation setting, and the latter as the trajectory observation setting.\nA fundamental theorem for IRL follows from rewriting the Bellman equations associated with the optimal policy in a single MDP, noting that the components of the vector Pa(I \u2212 \u03b3P\u03c0)\u22121R correspond to the Q-value for action a, under policy \u03c0 and reward R, for each of d states.\nTheorem 1 (Ng, Russell [10]). Let E = (S,A, P, \u03b3) be an arbitrary environment, and R \u2208 Rd. \u03c0 \u2208 OPT(E,R) if and only if \u2200a \u2208 A, (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121R \u2265 0.3\nThe key take-away from this theorem is that in a policy observation setting, the set of reward functions R consistent with some observed optimal policy \u03c0 are precisely those satisfying some set of linear constraints. Furthermore, those constraints can be computed from the environment E and policy \u03c0. Thus, an object that we will make recurring reference to is the set of reward functions consistent with experiment (E, \u03c0), denoted K(E, \u03c0):\nK(E, \u03c0) = {R \u2208 Rd |\u2200a \u2208 A, (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121R \u2265 0 \u2200s \u2208 S, Rmin \u2264 R(s) \u2264 Rmax}.\nSince K(E, \u03c0) is an intersection of linear constraints, it defines a convex polytope, a fact which will be of later algorithmic importance. An immediate corollary of Theorem 1, is that given a sequence of experiments E = ((E1, \u03c01), ..., (En, \u03c0n)), the set of rewards consistent with E are precisely those in\nK(E) , \u2229(E,\u03c0)\u2208EK(E, \u03c0)\nWe can also think of a trajectory T as inducing a partial policy \u03c0T on the states visited by the trajectory. In particular, let D(T ) denote the domain of T , D(T ) = {s | \u2203(s, a) \u2208 T}. We say two policies \u03c0, \u03c0\u2032 are consistent on D(T ) \u2282 S, denoted \u03c0 \u2261D(T ) \u03c0\u2032, iff \u03c0(s) = \u03c0\u2032(s) for all s \u2208 D(T ). Thus, given (E, T ), the set of rewards consistent with the observation are precisely K(E, T ) = {R \u2208 Rd | \u2203\u03c0 \u2261D(T ) \u03c0T , \u2200a \u2208 A, (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121R \u2265 0, Rmin \u2264 Ri \u2264 Rmax}, and given a sequence E = {(E1, T 1), ..., (En, Tn)}, we can define K(E) in the trajectory setting. 2Defined on the same state and action spaces. 3The inequality is read component-wise. That is, the relation holds if standard \u2265 holds for each component."}, {"heading": "3. ON IDENTIFICATION", "text": "In this section we will give a more nuanced characterization of what it means to identify a reward function. We will argue that there are multiple types of uncertainty involved in identifying R, which we categorize as representational unidentifiability and experimental unidentifiability. Furthermore, we argue that first type is in some ways superficial, and ought to be ignored, while the second type can be eliminated.\nWe begin with a definition. Let R and R\u2032 be reward functions defined on the same state space S. We say that R and R\u2032 are behaviorally equivalent if for any environment (also defined on S), the agent whose reward function is R behaves identically to the agent whose reward function is R\u2032.\nDefinition 1. Two reward vectors R,R\u2032 \u2208 Rd defined on S are behaviorally equivalent, denoted R \u2261 R\u2032 if for any set of actions, transition dynamics, and discount, (A,P, \u03b3), defining an environment E = (S,A,P, \u03b3) we have that OPT(E,R) = OPT(E,R\u2032).\nBehavioral equivalence defines an equivalence relation over vectors in Rd, and we let [R] = {R\u2032 \u2208 Rd | R\u2032 \u2261 R} denote the equivalence classes defined in this manner. Intuitively, if R and R\u2032 are behaviorally equivalent, they induce identical optimal policies in every single environment, and therefore are not really \u201cdifferent\u201d reward functions. They are simply different representations of the same incentives.\nWe now observe that behavioral equivalence classes are invariant under multiplicative scaling by positive scalars, and component-wise translation by a constant. Intuitively, this is easy to see. Adding c reward to every state in some reward function R does not affect an agent\u2019s decision-making. This is simply \u201cbackground\u201d reward that the agent gets for free. Similarly, scaling R by a positive constant simply changes the \u201cunits\u201d used to represent rewards. The agent does not, and should not, care whether its reward is represented in dollars or cents. We prove this formally in the following Theorem.\nTheorem 2. For any c \u2208 Rd, let ~c \u2208 Rd denote the vector with all components equal to c. For any \u03b1 > 0, and R \u2208 Rd, R \u2261 \u03b1R+ ~c.\nProof. First consider ~c as defined in the statement of the Theorem. Fix any environment E = (S,A,P, \u03b3), action a \u2208 A and arbitrary policy \u03c0. We begin by claiming that (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121~c = ~0.\nThe Woodbury formula for matrix inversion tells us that (I \u2212 \u03b3P\u03c0)\u22121 = I + (I \u2212 \u03b3P\u03c0)\u22121\u03b3P\u03c0. Furthermore, for any row-stochastic matrix P , P~c = ~c. Therefore:\nv = (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121~c = (P\u03c0 \u2212 Pa)(I + (I \u2212 \u03b3P\u03c0)\u22121\u03b3P\u03c0)~c = (P\u03c0 \u2212 Pa)~c+ (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121\u03b3P\u03c0~c\n= ~0 + (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0)\u22121\u03b3~c = \u03b3v\nSince \u03b3 \u2208 (0, 1), it must be that v = ~0. Now fix a reward function R \u2208 Rd, and arbitrary environment E, and consider OPT(E,R). By Theorem 1, we know that \u03c0 \u2208 OPT(E,R) iff for any a \u2208 A, (P\u03c0 \u2212 Pa)(I \u2212 \u03b3P\u03c0) \u22121R \u2265 0, which occurs iff (P\u03c0\u2212Pa)(I\u2212\u03b3P\u03c0)\u22121(\u03b1R) \u2265\n0, since \u03b1 is a positive scalar. Finally, we can conclude that \u03c0 \u2208 OPT(E,R) iff for all a \u2208 A, (P\u03c0\u2212Pa)(I\u2212\u03b3P\u03c0)\u22121(\u03b1R+ ~c) \u2265 0, this last condition implying that \u03c0 \u2208 OPT(E,\u03b1R + ~c), again by Theorem 1.\nSince our choice of E was arbitrary, by Definition 1, R \u2261 \u03b1R+ ~c, concluding the proof.\nThus, we argue that one reason why reward functions cannot be identified is a trivial one: the classic IRL problem does not fix a consistent representation for reward functions. For any R \u2208 Rd there are an uncountable number of other functions in [R], namely \u03b1R+~c for any \u03b1 and ~c, all of which are behaviorally identical to R. However, distinguishing between these functions is irrelevant; whether an agent\u2019s \u201ctrue\u201d reward function is (1, 2, 3, 4) or (0, 1/3, 2/3, 1)4 is simply a matter of what units are used to represent rewards.\nIn light of this observation, it is convenient to fix a canonical element of each equivalence class [R]. For any constant reward function R, we will take its canonicalized representation to be ~0. Otherwise we note, by way of Theorem 2, that any R can be translated and re-scaled so that maxsR(s) = 1 and minsR(s) = 0. More carefully, for any non-constant R, we take its canonicalized representation to be (R \u2212 minsR(s))/(maxsR(s) \u2212 minsR(s)) \u2208 [R]. This canonicalization is consistent with behavioral equivalence, and we state the following Theorem whose proof can be found in the appendix. As a consequence of this Theorem, we can use the notation [R] interchangeably to refer to the equivalence class of R, or the the unique canonical element of [R].\nTheorem 3. For any R,R\u2032 \u2208 Rd, R \u2261 R\u2032 if and only if they have the same canonicalized representation.\nWe next consider the issue of trivial/constant rewards [~0]. Since the IRL problem was first formulated, it has been observed that no single experiment can ever determine that the agent\u2019s reward function is not a constant reward function. The algebraic reason for this is the fact that ~0 is always a solution to the linear system K(E, \u03c0), for any E and \u03c0. The intuitive reason for this is the fact that any \u03c0 on some E is as optimal as any other policy for an agent whose reward is ~0. Therefore, if we consider an agent whose true reward is some R \u2208 Rd, R 6= ~0, then even in the policy observation setting, both R,~0 \u2208 K(E, \u03c0). Furthermore, this will not disappear with multiple experimentation. After any sequence of experiments E , it also remains that both R,~0 \u2208 K(E).\nConsider an agent whose true reward function is ~0. A crucial consequence of the above is that if an IRL algorithm guarantees that it will identify ~0, then it necessarily misidentifies non-trivial reward functions. This is because an agent with a trivial reward function is allowed to behave arbitrarily, and therefore may choose to behave consistently with some non-trivial reward R. An IRL algorithm that guarantees identification of trivial rewards will therefore misidentify the agent whose true reward is R.\nThis leads us to the following revised definition of identification, which accounts for what we call representational unidentifiability:\nDefinition 2. We say that an IRL algorithm succeeds at identification if for any R \u2208 Rd, after observing behavior 4We get (0, 1/3, 2/3, 1) from (1, 2, 3, 4) by subtracting 1 from every state and dividing by 3"}, {"heading": "No amount of experimentation can remove the representational unidentifiability from the setting, depicted here by the darker shaded region. (c) Nevertheless, adding the constraints K(E\u2032, \u03c0\u2032)", "text": "induced by a second experiment disproves the original selection., removing some experimental unidentifiability.\nfrom an agent with true reward R, the algorithm outputs a R\u0302 such that R\u0302 \u2261 R whenever R 6\u2208 [~0].\nNotice that this definition accomplishes two things. First, it excuses an algorithm for decisions about how R is represented. In other words, it asserts that the salient task in IRL is computing a member of [R], not the literal R. Secondly, if the true reward function R is not constant (i.e. R 6\u2208 [~0]), it demands the that algorithm identify R (up to representational decisions). However, if the agent really does have a reward function of ~0, the algorithm is allowed to output anything. In other words, the Algorithm is only allowed to behave arbitrarily if the agent behaves arbitrarily.5\nWe also note that Definition 2 can be relaxed to give a notion of approximate identification, which we state here:\nDefinition 3. We say that an IRL algorithm -identifies a reward function if for any R \u2208 Rd, after observing behavior from an agent with true reward R, the algorithm outputs a R\u0302 such that ||[R]\u2212 [R\u0302]||\u221e \u2264 whenever R 6\u2208 [~0].\nEven Definition 2 may not be attainable from a single experiment, as K(E, \u03c0) may contain multiple behavioral classes [R]. We call this phenonmenon experimental unidentifiability, due to the fact that the experiment (E, \u03c0) may simply be insufficient to distinguish between some [R] and [R\u2032]. In the next section, we will observe that this source of uncertainty in the reward function can be decreased with multiple experimentation, as depicted in Figure 1 (see Caption for details). In other words, by distinguishing representational unidentifiability from experimental unidentifiability, we can formally resolve the latter.\nA more concrete example is given in Figure 2, which depicts a grid-world with each square representing a state. In each of the figures, thick lines represent impenetrable walls, and an agent\u2019s policy is depicted by arrows, with a circle indicating the agent deciding to stay at a grid location. The goal of the learner is to infer the reward of each state. Figures 2(a) and 2(b), depict the same agent policy, which takes the shortest path to the location labeled x from any starting location. One explanation for such behavior, depicted in\n5We comment that, as a practical matter, one is usually interested in rationalizing the behavior of an agent believed to be non-trivial.\nFigure 2(a), is that the agent has large reward for state x, and zero reward for every other state. However, an equally possible explanation is that the state y also gives positive reward (but smaller than that of x) such that if there exists a shortest path to x that also passes through y, the agent will take it (depicted in Figure 2(b)). Without additional information, these two explanations cannot be distinguished.\nThis is an example of experimental unidentifiability that can nevertheless be resolved with additional experimentation. By observing the same agent in the environment depicted in Figure 2(c), the learner infers that y is indeed a rewarding state. Finally, observing the agent\u2019s behavior in the environment of Figure 2(d) reveals that the agent will prefer traveling to state y if getting to x requires 11 steps or more, while getting to y requires 4 steps of fewer. These subsequent observations allow the learner to relate the agent\u2019s reward at state x with the agent\u2019s reward at state y."}, {"heading": "4. OMNIPOTENT EXPERIMENTER SETTING", "text": "We now consider a repeated experimentation setting in which the environments available for selection by the experimenter are completely unrestricted. Formally, each environment E selected by the experimenter belongs to a class U\u2217 containing an environment (S,A, P, \u03b3) for every feasible set of transition dynamics P on S. We call this the omnipotent experimenter setting.\nWe will describe an algorithm for the omnipotent experimenter setting that -identifies R, using just O(log(d/ )) experiments. While the omnipotent experimenter is extremely powerful, the result demonstrates that the guarantee obtained in a repeated IRL setting can be far stronger than available in a standard single-environment IRL setting. Furthermore, it clarifies the distinction between experimental unidentifiability and representational unidentifiability."}, {"heading": "4.1 Omnipotent Identification Algorithm", "text": "The algorithm proceeds in two stages, both of which involve simple binary searches. The first stage will identify states smin, smax such that R(smin) = Rmin and R(smax) = Rmax. The second stage identifies for each s \u2208 S an \u03b1s such that R(s) = \u03b1sRmin + (1 \u2212 \u03b1s)Rmax. Throughout, the algorithm only makes use of two agent actions which we will denote a1, a2. Therefore, in describing the algorithm, we will assume that |A| = 2, and the environment selected by the algorithm is fully determined by its choices for Pa1 and Pa2 . If in fact |A| > 2, in the omnipotent experimenter setting, one can reduce to the two-action setting by making the remaining actions in A equivalent to either a1 or a2. 6\nWe first address the task of identifying smax. Suppose we have two candidates s and s\u2032 for smax. The key idea in this first stage of the algorithm is to give the agent an absolute choice between the two states by setting Pa1(s, s) = 1, Pa1(s \u2032, s\u2032) = 1, while setting Pa2(s, s \u2032) = 1 and Pa2(s\n\u2032, s) = 1. An agent selecting \u03c0(s) = a1 reveals (for any \u03b3) that R(s) \u2265 R(s\u2032), while an agent selecting \u03c0(s) = a2 reveals that R(s) \u2264 R(s\u2032). This test can be conducted for up to d/2 distinct pairs of states in a single experiment. Thus given k candidates for smax, in a single experiment, we can narrow the set of candidates to k/2, and are guaranteed that one of the remaining states s satisfies R(s) = Rmax. After log(d) such experiments we can identify a single state smax which satisfies R(smax) \u2265 R(s) for all s. Conducting an analogous procedure identifies a state smin.\nOnce smin and smax are identified, take s1, ..., sd\u22122 to be the remaining states, and consider an environment with transition dynamics parameterized by \u03b1 = (\u03b1s1 , ..., \u03b1sd\u22122). A typical environment in this phase is depicted in Figure 3. The environment sets smin, smax to be sinks with Pa1(smin, smin) = Pa1(smax, smax) = Pa2(smin, smin) = Pa2(smax, smax) = 1. For each remaining si, Pa1(si, smin) = \u03b1si and Pa1(si, smax) = (1\u2212 \u03b1si), so that taking action a1 in state si represents an \u03b1i probability gamble between the best and worst state. Finally, P\u03b1 also sets Pa2(s, s) = 1, and so taking action a2 in state si represents receiving R(si) for sure. By selecting \u03c0(s) = a1, the agent reveals \u03b1sRmin + (1 \u2212 \u03b1s)Rmax \u2265 R(s), while a choice \u03c0(s) = a2 reveals that \u03b1sRmin + (1 \u2212 \u03b1s)Rmax \u2264 R(s). Thus, a binary search can be conducted on each \u03b1s \u2208 [0, 1] independently in order to determine an approximation of the \u03b1\u2217s such that R(s) = \u03b1 \u2217 sRmin + (1\u2212 \u03b1\u2217s)Rmax. The algorithm succeeds at -identification, summarized in the following theorem. The proof of the theorem is a straightforward analysis of binary search.\n6Doing so is possible in this setting because transition dynamics can be set arbitrarily.\nTheorem 4. Let R\u0302 be defined by letting R\u0302(smin) = 0, R\u0302(smax) = 1, and R\u0302(s) = 1 \u2212 \u03b1s for all other s (where smin, smax, and \u03b1s are identified as described above). For any true reward function R 6\u2208 [~0] with canonical form [R], ||[R]\u2212 R\u0302||\u221e \u2264 .\nThe takeaway of this setting is that the problems regarding identification in IRL can be circumvented with repeated experimentation. It is thought that even with policy observations, the IRL question is fundamentally ill-posed. However, here we see that with repeated experimentation it is in fact possible to identify R to arbitrary precision in a welldefined sense. While these results are informative, we believe that it is unrealistic to imagine that the learner can arbitrarily influence the environment of the agent. In the next section, we develop a theory for repeated experimentation when the learner is restricted to select environments from some restricted subset of all possible transition dynamics."}, {"heading": "5. RESTRICTED EXPERIMENTER SETTING", "text": "We now consider a setting in which the experimenter has a restricted universe U of environments to choose from. U need not contain every possible transition dynamic, an assumption required to execute the binary search algorithm of the previous section. The best the experimenter could ever hope for is to try every environment in U . This gives the experimenter all the available information about the agent\u2019s reward function R. Thus, we will be more interested in maximizing the information gained by the experimenter while minimizing the number of experiments conducted. In practice, observing an agent may be expensive, or hard to come by, and so for even a small budget of experiments B, the learner would like select the environments from U which maximally reduce experimental unidentifiability.\nOnce a sequence of experiments E has been observed, we know that R is consistent with the observed sequence if and only if R \u2208 K(E). Thus, the value of repeated experimentation is allowing the learner to select environments so that K(E) is as informative as possible. In contrast, we note that previous work on IRL has largely been focused on designing heuristics for the selection problem of picking some R from a fixed set (of equally possible reward functions). Thus, we will be interested in making K(E) \u201csmall,\u201d while IRL has traditionally been focused on selecting R from exogenously fixed K(E). Before defining what we mean by \u201csmall\u201d, we will review preexisting methods for selecting R \u2208 K(E)."}, {"heading": "5.1 Generalized Selection Heuristics", "text": "In the standard (single-environment) setting, given an environment E and observed policy \u03c0, the learner must make a selection among one of the rewards in K(E, \u03c0). The heuristic suggested by [10] is motivated by the idea that for a given state s, the reward function that maximizes the difference in Q-value between the observed action in state s, \u03c0(s), and any other action a 6= \u03c0(s), gives the strongest explanation of the behavior observed from the agent. Thus, a reasonable linear selection criterion is to maximize the sum of these differences across states. Adding a regularization term, encourages the selection of reward functions that are also sparse. Putting these together, the standard selection heuristic for single-environment IRL is to select the R which maximizes:\n\u2211 s\u2208S ( min a6=\u03c0(s) (P\u03c0(s)\u2212 Pa(s))(I \u2212 \u03b3P\u03c0)\u22121R ) \u2212 \u03bb|R(s)| (1)\nThere are two natural candidates for generalizing this selection rule to the repeated experimentation setting, where now instead of a single experiment, the experimenter has encountered a sequence of observations E . The first is to sum over all (environment, state), pairs, the minimum difference in Q-value between the action selected by the agent and any other action. The second is to sum over states, taking the minimum over all (environment, action), pairs. While one could make arguments motivating each of these, ultimately any such objective is heuristic. However, we do argue that there is a strong algorithmic reason for preferring the latter objective. In particular, the former objective grows in dimensionality as environments are added, quickly resulting in an intractable LP. The dimension of the objective in the latter (Equation 2), however, remains constant.7\nmaximize R\u2208K(E) \u2211 s\u2208S  min (Ei,\u03c0i)\u2208E a 6=\u03c0i(s) (P i\u03c0(s)\u2212 P ia(s))(I \u2212 \u03b3P i\u03c0)\u22121R \u2212\u03bb|R(s)| (2)\nThere are other selection rules for the single-environment setting, which are generalizable to the repeated experimentation setting, including heuristics for the infinite state setting, trajectory heuristics, as well as approaches already adapted to multiple environments [12]. Due to space constraints, we discuss only the foundational approach of [10]. Our goal here is simply to emphasize the dichotomy between adapting pre-existing IRL methods to data gathered from multiple environments (however that data was generated), and the problem of how to best select those environments to begin with, this latter problem being the focus of the next section."}, {"heading": "5.2 Adaptive Experimentation", "text": "Given a universe U of candidate environments, we now ask how to select a small number of environments from U so that the environments are maximally informative. We must first decide what we mean by \u201cinformative.\u201d We propose that for a set of experiments E (either in the policy or trajectory setting), a natural objective is to minimize the mass of the resulting space of possible rewards K(E) with respect to some measure (or distribution) \u00b5. Under the Lebesgue measure (or uniform distribution), this corresponds to the natural goal of reducing the volume of the K(E) as much as possible. Thus we define:\nVol\u00b5(K(E)) = \u222b Rd 1[R \u2208 K(E)]d\u00b5(R)\n= PR\u223c\u00b5 [R \u2208 K(E)]\nWe will find it convenient to cast this as a maximization problem, and therefore also define f(E) = V \u2212 Vol\u00b5(K(E)), 7Writing Equation 2 as an LP in standard form requires translating the min into constraints, and thus the number of constraints grows with the number of experiments, but as we demonstrate in our experimental results, this is tractable for most LP solvers.\nwhere V is an upper bound on the volume of [\u2212Rmax, Rmax]d, and our goal to maximize f(E).\nThis objective has several desirable properties. First and foremost, by reducing the volume of K(E) we eliminate the space of possible reward functions (i.e. experimental unidentifiability). Secondly, the repeated experimentation setting is fundamentally an active learning setting. We can think of the true, unknown, R as a function that labels environments E with either a corresponding policy \u03c0 or trajectory T . Thus, the volume operator corresponds to reducing the version space of possible rewards. Furthermore, as we will see later in this section, the objective is a monotone submodular function, an assumption well-studied in the active learning literature [7, 6], allowing us to prove guarantees for a greedy algorithm.\nFinally, we will normally think of \u00b5 as being the Lebesgue measure, and Vol(\u00b7) as volume in d-dimensional Euclidean space (or the uniform distribution on [\u2212Rmax, Rmin]d). However, the choice of \u00b5 makes the objective quite general. For example, by making \u00b5 uniform on an -net on Rd, Vol corresponds to counting the number of rewards that are -apart with respect to some metric. In many settings, R naturally comes from some discrete space, such as the corners of the hypercube {0, 1}d. Again, this is readily modeled by the correct choice of \u00b5. In fact, \u00b5 can be thought of simply as any prior on [\u2212Rmax, Rmax]d.\nWe are now ready to describe a simple algorithm that adaptively selects environments E \u2208 U , attempting to greedily maximize f(\u00b7), depicted as Algorithm 1.\nAlgorithm 1 Greedy Environment Selection\n1: Input B 2: i := 1 3: E := \u2205 4: while i \u2264 B do 5: Ei := arg max\nE min R\u2208K(E) min \u03c0\u2208OPT(E,R) f(E \u222a (E, \u03c0))\u2212 f(E)\n6: Observe policy \u03c0i for Ei. 7: E := (E, (Ei, \u03c0i)) 8: i := i+ 1 9: end while\n10: return E\nIn order to state a performance guarantee about Algorithm 1, we will use the fact that f(\u00b7) is a submodular, nondecreasing, function on subsets of environment, observation pairs, 2U\u00d7O, where O is the set of possible observations.\nLemma 1. f is a submodular, non-decreasing function.\nProof. Given a set S and component s, we use S + s to denote the union of the singleton set {s} with S. Let O be the set of possible observations, so that o is a trajectory in the trajectory setting, and a policy in the policy setting. Let U be the space of possible environments.\nFix any E\u0302 \u2282 E \u2282 2U\u00d7O, and (E, o) 6\u2208 E . By definition of K(\u00b7), we have that K(E + (E, o)) = K(E) \u2229K(E, o) and K(E) \u2282 K(E\u0302), and so: f((E , (E, o)))\u2212 f(E) = Vol(K(E))\u2212 Vol(K(E , (E, o))) = \u222b Rd 1[R \u2208 K(E), R 6\u2208 K(E, o)]d\u00b5(R)\n\u2264 \u222b Rd 1[R \u2208 K(E\u0302), R 6\u2208 K(E, o)]d\u00b5(R) = f((E\u0302 , (E, o))) \u2212 f(E\u0302) This establishes submodularity of f . Since E is arbitrary and the right-hand-side of the second equality is nonzero, f is also monotone.\nThe performance of any algorithm is a function of how many experiments are attempted, and thus our analysis must\ntake this into account. Let An be a deterministic algorithm that deploys at most n experiments. An has a worst-case performance, which depends on the true reward R and what policies were observed. We say a sequence of experiments E = ((E1, o1), ..., (En, on)) is consistent with An and R, if An chooses environment Ej+1 after observing the subsequence of experiments ((E1, o1), ..., (Ej , oj)), and oj is either a trajectory or policy consistent with (E,R). Denoting the set of consistent experiments C(An, R), the best performance that any algorithm can guarantee with n experiments is: OPTn = maxAn minR minE\u2208C(An,R) f(E)\nThe submodularity of f , allows us to prove that for any n, the Greedy Environment Selection Algorithm8 needs slightly more than n experiments (by a logarithmic factor) to attain f(E) \u2248 OPTn.\nTheorem 5. E returned by the Greedy Environment Selection algorithm satisfies f(E) \u2265 OPTn \u2212 when B = n ln(OPTn/ ) \u2264 n ln(V/ ).\nThe proof of Theorem 5 uses many of the same techniques used by Guillory et. al ([7]), in their work on interactive set cover. For technical reasons, we cannot state our theorem directly as a corollary of these results, which assume a finite hypothesis class, whereas we have an infinite space of possible rewards. Nevertheless, these proofs are easily adapted to our setting, and the full proofs are given in the appendix.\nFinally we note that Line (5) is not computable exactly without parametric assumptions on the class of environments or space of rewards. In practice, and as we will describe in the next section, we approximate the exact maximization by sampling environments and rewards from K(E), and optimizing on the sampled sets."}, {"heading": "6. EXPERIMENTAL ANALYSIS", "text": "We now deploy the techniques discussed in a setting, demonstrating that maximizing f(\u00b7) is indeed effective for identifying R. We imagine that we have an agent that will be\n8n.b. in the trajectory setting, one would replace the minimization over \u03c0 \u2208 OPT(E,R) in line 5 of the algorithm, with a minimization over T consistent with \u03c0, \u03c0 \u2208 OPT(E,R).\ndropped into a grid world. The experimenter would like to infer the agent\u2019s reward for each space in the grid. We imagine that the experimenter has the power to construct walls in the agent\u2019s environment, and so we will alternatively refer to an environment as a maze. To motivate the value of repeated experimentation, recall Figure 2.\nThis is a restricted environment for the learner. The learner cannot, for example, make it so that an action causes the agent to travel from a bottom corner of the maze to a top corner. However, the learner can modify the dynamics of the environment in so far as it can construct maze walls.\nWe evaluate Algorithm 1 on grids of size 10 \u00d7 10. An agent\u2019s reward is given by a vector R \u2208 R100, with ||R||\u221e \u2264 Rmax, where Rmax is taken to be 10 in all that follows. In each simulation we randomly assign some state in R to have reward Rmax, and assign 5 states to have reward 1.\n9 The remaining states give reward 0. The agent\u2019s discount rate is taken to be 0.8. The goal of the learner is not just to determine which states are rewarding, but to further determine that the latter states yield 1/10 the reward of the former.\nIn Figure 4a, we display our main experimental results for four different algorithms in the policy observation setting, and in Figure 4b for the trajectory setting. Error represents ||R\u2212 R\u0302||\u221e, where R\u0302 is an algorithm\u2019s prediction, with error bars representing standard error over 20 simulations.\nIn Figure 4a, the horizontal line displays the best results we achieved without repeated experimentation. If the learner only selects a single environment E, observing policy \u03c0, it is stuck with whatever experimental unidentifiability exists in K(E, \u03c0). In such a scenario, we can select a K(E, \u03c0) according to a classic IRL heuristic, given by LP (1) in Section 5.1, for some choice of \u03bb in LP (1). Since the performance of this method depends both on which environment is used, and the choice of \u03bb, we randomly generated 100 different environments, and for each of those environments selected \u03bb \u2208 {0.05, .1, .5, 1, 5, 6, 7, 8, 9, 10}. We then evaluated each of these single-environment approaches with\n9For motivation, one might think of the agent as being a mouse, with these rewards corresponding to food pellets or various shiny objects in a mouse\u2019s cage.\n20 simulations, the best error among these 1300 different single-environment algorithms is displayed by the horizontal line. Immediately we see that the experimental unidentifiability from using a single environment makes it difficult to distinguish the actual reward function, with err for the best choice of E and \u03bb greater than 5.\nThe remaining algorithms \u2014 which we will describe in greater detail below \u2014 conduct repeated experimentation. Each of these algorithms uses a different rule to select a new environment on each round. Given the sequence of (environment, policy) pairs E generated by each of these algorithms, we solve the LP (2) on K(E) at the end of each round. This is done with the same choice of \u03bb(= 0.5) for each of the algorithms.\nBesides the Greedy algorithm of the previous section, we implement two other algorithms, which conduct repeated experiments, but do so non-adaptively. RandUniform, in each round, selects a maze uniformly at random from the space of possible mazes (each wall is present with probability 0.5). Note that RandUniform will tend to select mazes where roughly half of the walls are present. Thus, we also consider RandVaried which, in each round, selects a maze from a different distribution D. Mazes drawn from D are generated by a two-step process. First, for each row r and column c, we select numbers dr, dc i.i.d. from the uniform distribution on [0, 1]. Then each wall along row r (column c respectively) is created with probability dr (dc respectively). Although the probability any particular wall is present is still 0.5, the correlations in D creates more variable mazes (e.g. allowing an entire row to be sparsely populated with walls).\nWe implement Algorithm 1, Greedy, of the previous section, by approximating the maximization in Line 5 in Algorithm 1. This approximation is done by sampling 10 environments fromD, the same distribution used by RandVaried. In the policy observation setting, 1000 samples are first drawn from the consistent set K(E) using a hit-and-run sampler [9], which is an MCMC method for uniformly sampling highdimensional convex sets in polynomial time. These same samples are also used to estimate the volume f(\u00b7). In the trajectory setting, we first sample trajectories T on an environment E, then we use K(E, \u03c0\u0302) for an arbitrary \u03c0\u0302, \u03c0\u0302 \u2261D(T ) \u03c0T , as a proxy for K(E, T ).\nExamining the results, we see that Greedy converges significantly quicker than either of the non-adaptive approaches. After 25 rounds of experimentation in the policy observation setting, Greedy attains error 0.2687(\u00b10.0302), while the best non-adaptive approach attains 0.9691(\u00b10.24310). Greedy only requires 16 rounds to reach a similar error of 0.9678(\u00b10.0701). We note further that the performance of Greedy seems to continue to improve, while the nonadaptive approaches appear to stagnate. This could be due to the fact that after a certain number of rounds, the nonadaptive approaches have received all the information available from the environments typically sampled from their distributions. In order to make progress they must receive new information, in contrast to Greedy, which is designed to actively select the environments that will do just that.\nFinally, Greedy runs by selecting a sequence of environments, resulting in observations E . It then selects R from K(E) using LP (2). Thus, the regularization parameter \u03bb in LP (2) is a free parameter for Greedy that we took to be equal to 0.5 for results (Figure 4a). We conclude by experimentally analyzing the sensitivity of Greedy to the choice of\nthis parameter, as well as of RandUniform, and RandVaried, which also select R according to LP (2). As \u03bb is increased, eventually the LP over-regularizes, and is optimized taking R = ~0. In our setting, once \u03bb \u2248 1 this begins to occur, and we begin to see pathological behavior (Figure 5a). This problem occurs in standard IRL, and one approach ([10]) is to select a large lambda before this transition, hence our choice of \u03bb = 0.5. However, even for significantly smaller \u03bb, the results are qualitatively similar (Figure 5b) to those in Figure 4a. We find that as long as \u03bb is not too large, the results are not sensitive to the choice of \u03bb."}, {"heading": "7. CONCLUSIONS", "text": "We provide a number of contributions in this work. First, we separate the causes of unidentifiability in IRL problems into two classes: representational, and experimental. We argue that representational unidentifiability is superficial, leading us to redefine the problem of identification in IRL according to Definition 2. While previous work does not distinguish between these two classes, we demonstrate that, by doing so, algorithms can be designed to eliminate experimental unidentifiability while providing formal guarantees.\nAlong the way, we derive a new model for IRL where the learner can observe behavior in multiple environments, a model which we believe is interesting in its own right, but also is key to eliminating experimental unidentifiability. We give an algorithm for a very powerful learner who can observe agent behavior in any environment, and show that the algorithm -identifies an agent reward defined on d states, while observing behavior on only O(log(d/ )) environments. We then weaken this learner to model more realistic settings where the learner might be restricted in the types of environments it may choose, and where it may only be able to elicit a small number of demonstrations from the agent. We derive a simple adaptive greedy algorithm which will select a nearly optimal (with respect to reducing the volume of possible reward function) set of environments. The value of the solution found by this greedy algorithm will be a comparable to the optimal algorithm which uses a logarithmic factor fewer number of experiments.\nFinally, we implement the algorithm in a simple maze environment that nevertheless demonstrates the value of eliminating experimental unidentifiability, significantly outperforming methods that attempt to perform IRL from a single environment."}, {"heading": "A. PROOF OF THEOREM 3", "text": "Theorem 6. For any R,R\u2032 \u2208 Rd, R \u2261 R\u2032 if and only if they have the same canonicalized representation.\nProof. By definition, the canonicalized representation of any reward function is attained by scaling and translation. Therefore, by Theorem 2, if R and R\u2032 are both canonicalized as Rc, we have that R \u2261 Rc and R\u2032 \u2261 Rc, and therefore R \u2261 R\u2032.\nIn the other direction, suppose R and R\u2032 are canonicalized to Rc and R \u2032 c respectively, where Rc 6= R\u2032c. Again, by Theorem 2, we have that R \u2261 Rc and R\u2032 \u2261 R\u2032c. Thus, to prove the theorem, it is sufficient to argue that Rc and R \u2032 c are not behaviorally equivalent. If one of Rc, R \u2032 c is ~0 and the other is not, then it is straightforward to show that they are not behaviorally equivalent. Thus, we focus on the case where both Rc and R \u2032 c are not ~0. We consider three cases. First, suppose that Rc 6= R\u2032c because they have different minimally-rewarding states. Without loss of generality suppose that there is some s0 with Rc(s0) = 0 but R \u2032 c(s0) > 0. Furthermore, let s\u20320 be any state such that R \u2032 c(s \u2032 0) = 0. Consider an environment E with two actions a and a\u2032. Action a deterministically transitions to state s0 from any other state, while action a\u2032 determininstically transitions to state s\u20320 from any other state. Let \u03c0a be the policy that always takes action a. OPT(E,R\u2032c) = {\u03c0a}. However, if \u03c0a \u2208 OPT(E,Rc), this means that Rc(s \u2032 0) = 0, and therefore all policies are in OPT(E,Rc). Thus, OPT(E,Rc) 6= OPT(E,R\u2032c), and Rc, R \u2032 c are not behaviorally equivalent.\nNext, suppose that Rc 6= R\u2032c because they have different maximally-rewarding states. Analagously to the previous case, suppose without loss of generality there is some s0 with Rc(s0) = 1 by R \u2032 c(s0) < 0, and let s \u2032 0 be any state such that R\u2032c(s \u2032 0) = 1 (which exists since R \u2032 c 6= ~0). Define the environment E in the same way as the previous case. This time, OPT(E,R\u2032c) = {\u03c0a\u2032}, while OPT(E,Rc) 6= {\u03c0a\u2032}.\nFinally, suppose that Rc and R \u2032 c share the same maximally and minimally rewarding states, but there exists some s such that Rc(s) 6= R\u2032c(s). Let s0 be any state such that Rc(s0) = R\u2032c(s0) = 0 and let s1 be any state such that Rc(s1) = R\u2032c(s1) = 1. Without loss of generality suppose that Rc(s) < R\u2032c(s). Let E be the environment with two actions a and ap. Let p be any real number 0 \u2264 Rc(s) < p < R\u2032c(s) \u2264 1. From every state, action ap transitions to state s1 with probabiity p and to state s0 with the remaining probability. From every state action a transtions to state s deterministically. The reward for taking action ap in any state under either reward function is p, while action a gives a reward of Rc(s) < p\nunder Rc and R \u2032 c(s) > p under R \u2032 c. Thus, OPT(E,Rc) = {\u03c0ap} 6= {\u03c0a} = OPT(E,R\u2032c), concluding the proof."}, {"heading": "B. PROOF OF GREEDY\u2019S PERFORMANCE", "text": "Given a set S and component s, we use S + s to denote the union of the singleton set {s} with S. We begin by redefining:\nVol\u00b5(K(E)) = \u222b Rd 1[R \u2208 K(E)]d\u00b5(R)\nf(E) = V \u2212Vol\u00b5(K(E))\nwhere V is an upper bound Vol\u00b5([\u2212Rmax, Rmax]d). Let O be the set of possible observations, so that o is a trajectory in the trajectory setting, and a policy in the policy setting. Let U be the space of possible environments. WWe first establish that f is indeed submodular.\nLemma 2. f is a submodular, non-decreasing function on 2U\u00d7O.\nProof. Fix any E\u0302 \u2282 E \u2282 2U\u00d7O, and (E, o) 6\u2208 E . By definition of K(\u00b7), we have that K(E + (E, o)) = K(E) \u2229 K(E, o) and K(E) \u2282 K(E\u0302), and so:\nf((E , (E, o)))\u2212 f(E) = Vol(K(E))\u2212Vol(K(E , (E, o)))\n= \u222b Rd 1[R \u2208 K(E), R 6\u2208 K(E, o)]d\u00b5(R)\n\u2264 \u222b Rd 1[R \u2208 K(E\u0302), R 6\u2208 K(E, o)]d\u00b5(R) = f((E\u0302 , (E, o)))\u2212 f(E\u0302)\nThis establishes submodularity of f . Since E is arbitrary and the right-hand-side of the second equality is non-zero, f is also monotone.\nLet T = {T : U \u2192 O} denote the set of functions mapping environments to observations. For any T \u2208 T and S \u2282 U , overload T , so that T (S) = \u222aE\u2208S(E, T (E)).\nNow suppose that environments where labeled according to some T \u2208 T , and consider an algorithm which knowing T , selects the fewest number of environments S, so that f(T (S)) \u2265 \u03b1. Given such an algorithm, we can now define the General Identification Cost, which identifies the worstpossible labelling strategy in T . In particular:\nGIC\u03b1 = max T\u2208T min S\u2282U:f(T (S))\u2265\u03b1\n|S|\nRecall the definition from the main body:\nOPTn = max An min R min E\u2208C(An,R)\nf(E)\nThis is the largest that an algorithm can guarantee to make f(\u00b7) with n environments, when environments are consistently labeled by some R. Let A\u2217 be the algorithm satisfying the max.\nLemma 3. GICOPTn \u2264 n\nProof. Fix any T \u2208 T . Consider two cases. First suppose that there exists some S \u2282 U such that |S| \u2264 n, but T (S) is inconsistent with the labeling of any R. By defintion\nof f , f(T (S)) = V \u2265 OPTn, and since |S| \u2264 n, the Lemma is proven.\nOtherwise, it must be that all S \u2282 U , |S| \u2264 n, T (S) is consistent with the labeling of some R. By definition of OPTn, running A\u2217 against the labels provided by T is guaranteed to result in a sequence of environments S\u2217, |S\u2217| \u2264 n, satisfying f(T (S\u2217)) \u2265 OPTn. S\u2217 is a witness that minS\u2282U:f(T (S))\u2265OPTn |S| is at most n.\nGiven an environment E and true reward R, let O(E,R) denote the set of possible observations (in either the policy or trajectory setting).\nLemma 4. For any E, such that f(E) \u2264 OPTn, there exists an environment E such that:\nmin R\u2208K(E) min o\u2208O(E,R)\nf(E+(E, o))\u2212f(E) \u2265 (OPTn\u2212f(E))/GICOPTn\nProof. Suppose not. Then for every environment E, there exists some R \u2208 K(E) and o \u2208 O(E,R) such that:\nf(E + (E, o))\u2212 f(E) < (OPTn \u2212 f(E))/GICOPTn Now let T \u2032 \u2208 T be defined so that:\nT \u2032(E) , arg min R,o\u2208O(E,R) f(E + (E, o))\u2212 f(E) (3)\n< (OPTn \u2212 f(E))/GICOPTn (4)\nBy definition of GIC, we have that:\nmin S\u2282U:f(T \u2032(S))\u2265OPTn\n|S| \u2264 GICOPTn\nSo there exists a set of environments S, with |S| \u2264 GICOPTn , such that f(T \u2032(S)) \u2265 OPTn, and by monotonicity of f , we know that f(T \u2032(S) \u222a E) \u2265 OPTn. Let \u03b3 = |S|/GICOPTn .\nHowever, despite f(T \u2032(S) \u222a E) \u2265 OPTn, repeatedly applying the submodularity of f , then applying equation (4) implies:\nf(T \u2032(S) \u222a E) \u2264 f(E) + \u2211 E\u2208S (f(E + (E, T \u2032(E)))\u2212 f(E)\n< f(E) + |S|(OPTn \u2212 f(E))/GICOPTn = f(E) + \u03b3(OPTn \u2212 f(E)) = (1\u2212 \u03b3)f(E) + \u03b3OPTn \u2264 OPTn\nThis establishes a contradiction.\nWe can now prove the main theorem:\nTheorem 7. E returned by the Greedy Environment Selection algorithm satisfies f(E) \u2265 OPTn \u2212 when B = n ln(OPTn/ ).\nProof. Let Ei denote the subsequence consisting of the first i environment, observation pairs. If for some i \u2264 B, f(Ei) \u2265 OPTn, then there is nothing to prove. Otherwise, by applying Lemma 3, and the definition of the algorithm, we know that:\nf(Ei)\u2212 f(Ei\u22121) \u2265 (OPTn \u2212 f(Ei\u22121))/GICOPTn which implies:\nOPTn \u2212 f(Ei) \u2264 (OPTn \u2212 f(Ei\u22121))(1\u2212 1/GICOPTn)\nUsing the fact 1\u2212 x \u2264 e\u2212x, we can conclude:\nOPTn \u2212 f(E) \u2264 OPTn exp(\u2212B/GICOPTn))\nApplying Lemma 4 and substitutingB completes the proof."}], "references": [{"title": "An application of reinforcement learning to aerobatic helicopter flight", "author": ["P. Abbeel", "A. Coates", "M. Quigley", "A.Y. Ng"], "venue": "Advances in neural information processing systems,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "Apprenticeship learning via inverse reinforcement learning", "author": ["P. Abbeel", "A.Y. Ng"], "venue": "In Proceedings of the twenty-first international conference on Machine learning,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2004}, {"title": "Making rational decisions using adaptive utility elicitation", "author": ["U. Chajewska", "D. Koller", "R. Parr"], "venue": "In AAAI/IAAI,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2000}, {"title": "Learning for control from multiple demonstrations", "author": ["A. Coates", "P. Abbeel", "A.Y. Ng"], "venue": "In Proceedings of the 25th international conference on Machine learning,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "Apprenticeship learning for helicopter control", "author": ["A. Coates", "P. Abbeel", "A.Y. Ng"], "venue": "Communications of the ACM,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2009}, {"title": "Adaptive submodularity: A new approach to active learning and stochastic optimization", "author": ["D. Golovin", "A. Krause"], "venue": "In COLT, pages 333\u2013345,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2010}, {"title": "Interactive submodular set cover", "author": ["A. Guillory", "J. Bilmes"], "venue": "In Proceedings of the International Conference on Machine Learning,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Active learning for reward estimation in inverse reinforcement learning", "author": ["M. Lopes", "F. Melo", "L. Montesano"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2009}, {"title": "Hit-and-run mixes fast", "author": ["L. Lov\u00e1sz"], "venue": "Mathematical Programming,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1999}, {"title": "Algorithms for inverse reinforcement learning", "author": ["A.Y. Ng", "S.J. Russell"], "venue": "In Icml,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2000}, {"title": "Bayesian inverse reinforcement learning", "author": ["D. Ramachandran", "E. Amir"], "venue": "Urbana, 51:61801,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2007}, {"title": "Maximum margin planning", "author": ["N.D. Ratliff", "J.A. Bagnell", "M.A. Zinkevich"], "venue": "In Proceedings of the 23rd International Conference on Machine Learning,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2006}, {"title": "Regret-based reward elicitation for markov decision processes", "author": ["K. Regan", "C. Boutilier"], "venue": "In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "Robust policy computation in reward-uncertain mdps using nondominated policies", "author": ["K. Regan", "C. Boutilier"], "venue": "In AAAI,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Eliciting additive reward functions for markov decision processes", "author": ["K. Regan", "C. Boutilier"], "venue": "In IJCAI Proceedings-International Joint Conference on Artificial Intelligence,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "Preference elicitation and inverse reinforcement learning", "author": ["C.A. Rothkopf", "C. Dimitrakakis"], "venue": "In Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2011}, {"title": "Effective reinforcement learning for mobile robots", "author": ["W.D. Smart", "L.P. Kaelbling"], "venue": "In Robotics and Automation,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2002}, {"title": "A game-theoretic  approach to apprenticeship learning", "author": ["U. Syed", "R.E. Schapire"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}, {"title": "Theory of games and economic behavior (60th Anniversary Commemorative Edition)", "author": ["J. Von Neumann", "O. Morgenstern"], "venue": "Princeton university press,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2007}, {"title": "Maximum entropy inverse reinforcement learning", "author": ["B.D. Ziebart", "A.L. Maas", "J.A. Bagnell", "A.K. Dey"], "venue": "In AAAI,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2008}], "referenceMentions": [{"referenceID": 9, "context": "Inverse reinforcement learning (IRL), first introduced by Ng and Russell ([10]), is concerned with the problem of inferring the (unknown) reward function of an agent behaving optimally in a Markov decision process.", "startOffset": 74, "endOffset": 78}, {"referenceID": 16, "context": "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy \u03c0, can we deduce the reward function R which makes \u03c0 optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].", "startOffset": 397, "endOffset": 410}, {"referenceID": 1, "context": "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy \u03c0, can we deduce the reward function R which makes \u03c0 optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].", "startOffset": 397, "endOffset": 410}, {"referenceID": 0, "context": "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy \u03c0, can we deduce the reward function R which makes \u03c0 optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].", "startOffset": 397, "endOffset": 410}, {"referenceID": 4, "context": "The most basic formulation of the problem asks: given a known environment E, and an optimal agent policy \u03c0, can we deduce the reward function R which makes \u03c0 optimal for the MDP (E,R)? IRL has seen a number of applications in the development of autonomous systems, such as autonomous vehicle operation, where even a cooperative (human) agent might have great difficultly describing her incentives [17, 2, 1, 5].", "startOffset": 397, "endOffset": 410}, {"referenceID": 9, "context": "Since the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11].", "startOffset": 228, "endOffset": 240}, {"referenceID": 19, "context": "Since the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11].", "startOffset": 228, "endOffset": 240}, {"referenceID": 10, "context": "Since the true reward function is fundamentally unidentifiable, much of the previous work in IRL has been concerned with the development of heuristics which prefer certain rewards as better explanations for behavior than others [10, 20, 11].", "startOffset": 228, "endOffset": 240}, {"referenceID": 9, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 1, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 3, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 19, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 10, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 17, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 13, "context": "Prior work in IRL has mostly focused on inferring an agent\u2019s reward function from data acquired from a fixed environment [10, 2, 4, 20, 11, 18, 14].", "startOffset": 121, "endOffset": 147}, {"referenceID": 7, "context": "Previous applications of active learning to IRL have considered settings where, in a single environment, the learner can query the agent for its action in some state [8], or for information about its reward [13].", "startOffset": 166, "endOffset": 169}, {"referenceID": 12, "context": "Previous applications of active learning to IRL have considered settings where, in a single environment, the learner can query the agent for its action in some state [8], or for information about its reward [13].", "startOffset": 207, "endOffset": 211}, {"referenceID": 11, "context": "There is prior work on using data collected from multiple \u2014 but exogenously fixed \u2014 environments to predict agent behavior [12].", "startOffset": 123, "endOffset": 127}, {"referenceID": 19, "context": "There are also applications where methods for single-environment MDPs have been adapted to multiple environments [20].", "startOffset": 113, "endOffset": 117}, {"referenceID": 2, "context": "In the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].", "startOffset": 164, "endOffset": 187}, {"referenceID": 18, "context": "In the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].", "startOffset": 164, "endOffset": 187}, {"referenceID": 14, "context": "In the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].", "startOffset": 164, "endOffset": 187}, {"referenceID": 15, "context": "In the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].", "startOffset": 164, "endOffset": 187}, {"referenceID": 12, "context": "In the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].", "startOffset": 164, "endOffset": 187}, {"referenceID": 14, "context": "In the economics literature, the problem of inferring an agent\u2019s utility from behavior has long been studied under the heading of utility or preference elicitation [3, 19, 15, 16, 13, 15].", "startOffset": 164, "endOffset": 187}, {"referenceID": 9, "context": "Theorem 1 (Ng, Russell [10]).", "startOffset": 23, "endOffset": 27}, {"referenceID": 0, "context": "Thus, a binary search can be conducted on each \u03b1s \u2208 [0, 1] independently in order to determine an approximation of the \u03b1\u2217 s such that R(s) = \u03b1 \u2217 sRmin + (1\u2212 \u03b1\u2217 s)Rmax.", "startOffset": 52, "endOffset": 58}, {"referenceID": 9, "context": "The heuristic suggested by [10] is motivated by the idea that for a given state s, the reward function that maximizes the difference in Q-value between the observed action in state s, \u03c0(s), and any other action a 6= \u03c0(s), gives the strongest explanation of the behavior observed from the agent.", "startOffset": 27, "endOffset": 31}, {"referenceID": 11, "context": "There are other selection rules for the single-environment setting, which are generalizable to the repeated experimentation setting, including heuristics for the infinite state setting, trajectory heuristics, as well as approaches already adapted to multiple environments [12].", "startOffset": 272, "endOffset": 276}, {"referenceID": 9, "context": "Due to space constraints, we discuss only the foundational approach of [10].", "startOffset": 71, "endOffset": 75}, {"referenceID": 6, "context": "Furthermore, as we will see later in this section, the objective is a monotone submodular function, an assumption well-studied in the active learning literature [7, 6], allowing us to prove guarantees for a greedy algorithm.", "startOffset": 161, "endOffset": 167}, {"referenceID": 5, "context": "Furthermore, as we will see later in this section, the objective is a monotone submodular function, an assumption well-studied in the active learning literature [7, 6], allowing us to prove guarantees for a greedy algorithm.", "startOffset": 161, "endOffset": 167}, {"referenceID": 6, "context": "al ([7]), in their work on interactive set cover.", "startOffset": 4, "endOffset": 7}, {"referenceID": 0, "context": "from the uniform distribution on [0, 1].", "startOffset": 33, "endOffset": 39}, {"referenceID": 8, "context": "In the policy observation setting, 1000 samples are first drawn from the consistent set K(E) using a hit-and-run sampler [9], which is an MCMC method for uniformly sampling highdimensional convex sets in polynomial time.", "startOffset": 121, "endOffset": 124}, {"referenceID": 9, "context": "This problem occurs in standard IRL, and one approach ([10]) is to select a large lambda before this transition, hence our choice of \u03bb = 0.", "startOffset": 55, "endOffset": 59}], "year": 2016, "abstractText": "We consider a setting for Inverse Reinforcement Learning (IRL) where the learner is extended with the ability to actively select multiple environments, observing an agent\u2019s behavior on each environment. We first demonstrate that if the learner can experiment with any transition dynamic on some fixed set of states and actions, then there exists an algorithm that reconstructs the agent\u2019s reward function to the fullest extent theoretically possible, and that requires only a small (logarithmic) number of experiments. We contrast this result to what is known about IRL in single fixed environments, namely that the true reward function is fundamentally unidentifiable. We then extend this setting to the more realistic case where the learner may not select any transition dynamic, but rather is restricted to some fixed set of environments that it may try. We connect the problem of maximizing the information derived from experiments to active submodular function maximization, and demonstrate that a greedy algorithm is near optimal (up to logarithmic factors). Finally, we empirically validate our algorithm on an environment inspired by behavioral psychology.", "creator": "LaTeX with hyperref package"}}}