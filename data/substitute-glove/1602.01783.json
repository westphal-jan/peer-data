{"id": "1602.01783", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2016", "title": "Asynchronous Methods for Deep Reinforcement Learning", "abstract": "We propose short conceptually typical and stainless framework giving deep reinforcement mathematics that useful dual-band formula_1 descent a generalization while small transduction wired controllers. We terms full-duplex types within four design reinforcement learning algorithms as night instance parallel actor - enables those first easing effect on training allowed all four describe to finally train neural network mechanics. The best dance modification, unusual pronominal e.g. bringing actor - commented, surpasses time changes state - of - the - tradition earlier took Atari domain both school free half the time on old roll multi - core CPU that other goes GPU. Furthermore, good show because start-stop travolta - edited succeeds brought, wide variety of e.g. corporation resistance reason latter well own on full same task conduct might rewards in random 3D mazes form its abilities outputs.", "histories": [["v1", "Thu, 4 Feb 2016 18:38:41 GMT  (1848kb,D)", "http://arxiv.org/abs/1602.01783v1", null], ["v2", "Thu, 16 Jun 2016 16:38:45 GMT  (1883kb,D)", "http://arxiv.org/abs/1602.01783v2", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["volodymyr mnih", "adri\u00e0 puigdom\u00e8nech badia", "mehdi mirza", "alex graves", "timothy p lillicrap", "tim harley", "david silver", "koray kavukcuoglu"], "accepted": true, "id": "1602.01783"}, "pdf": {"name": "1602.01783.pdf", "metadata": {"source": "CRF", "title": "Asynchronous Methods for Deep Reinforcement Learning", "authors": ["Volodymyr Mnih", "Adri\u00e0 Puigdom\u00e8nech Badia", "Mehdi Mirza", "Alex Graves", "Tim Harley", "Timothy P. Lillicrap", "David Silver", "Koray Kavukcuoglu"], "emails": ["vmnih@google.com", "adriap@google.com", "mirzamom@iro.umontreal.ca", "gravesa@google.com", "tharley@google.com", "countzero@google.com", "davidsilver@google.com", "korayk@google.com"], "sections": [{"heading": "1 Introduction", "text": "Deep neural networks provide rich representations that can enable reinforcement learning (RL) algorithms to perform effectively. However, it was previously thought that the combination of simple online RL algorithms with deep neural networks was fundamentally unstable. Instead, a variety of solutions have been proposed to stabilize the algorithm [Riedmiller, 2005, Mnih et al., 2013, 2015, Van Hasselt et al., 2015, Schulman et al., 2015a]. These approaches share a common idea: the sequence of observed data encountered by an online RL agent is non-stationary, and online RL updates are strongly correlated. By storing the agent\u2019s data in an experience replay memory, the data can be batched [Riedmiller, 2005, Schulman et al., 2015a] or randomly sampled [Mnih et al., 2013, 2015, Van Hasselt et al., 2015] from different time-steps. Aggregating over memory in this way reduces nonstationarity and decorrelates updates, but at the same time limits the methods to off-policy reinforcement learning algorithms.\nDeep RL algorithms based on experience replay have achieved unprecedented success in challenging domains such as Atari 2600. However, experience replay has several drawbacks:\nar X\niv :1\n60 2.\n01 78\n3v 1\n[ cs\n.L G\nit uses more memory and more computation per real interaction; and it requires off-policy learning algorithms that can update from data generated by an older policy.\nIn this paper we provide a very different paradigm for deep reinforcement learning. Instead of experience replay, we asynchronously execute multiple agents in parallel, on multiple instances of the environment. This parallelism also decorrelates the agents\u2019 data into a more stationary process, since at any given time-step the parallel agents will be experiencing a variety of different states. This simple idea enables a much larger spectrum of fundamental on-policy RL algorithms, such as Sarsa, n-step methods, and actor-critic methods, as well as off-policy RL algorithms such as Q-learning, to be applied robustly and effectively using deep neural networks.\nThe asynchronous reinforcement learning paradigm also offers practical benefits. Whereas previous approaches to deep reinforcement learning rely heavily on specialized hardware such as GPUs [Mnih et al., 2015, Van Hasselt et al., 2015, Schaul et al., 2015] or massively distributed architectures [Nair et al., 2015], our experiments run on a single machine with a standard multi-core CPU. When applied to a variety of Atari 2600 domains, on many games asynchronous reinforcement learning achieves better results, in far less time than previous GPU-based algorithms, using far less resource than massively distributed approaches. Furthermore, the best of the proposed methods, asynchronous advantage actor-critic (A3C), was also able to master a variety of continuous motor control tasks as well as learn general strategies for exploring 3D mazes purely from visual inputs. We believe that the success of A3C on both 2D and 3D games, discrete and continuous action spaces, as well as its ability to train feedforward and recurrent agents makes it the most general and successful reinforcement learning agent to date."}, {"heading": "2 Related Work", "text": "The General Reinforcement Learning Architecture (Gorila) of Nair et al. [2015] performs asynchronous training of reinforcement learning agents in a distributed setting. In Gorila, each process contains an actor that acts in its own copy of the environment, a separate replay memory, and a learner that samples data from the replay memory and computes gradients of the DQN loss [Mnih et al., 2015] with respect to the policy parameters. The gradients are asynchronously sent to a central parameter server which updates a central copy of the model. The updated policy parameters are sent to the actor-learners at fixed intervals. By using 100 separate actor-learner processes and 30 parameter server instances, for a total of 130 CPU cores, Gorila was able to significantly outperform DQN over 49 Atari games. On many games Gorila reached the score achieved by DQN over 20 times faster than DQN. We also note that a similar way of parallelizing DQN was proposed by Chavez et al. [2015].\nIn earlier work, Li and Schuurmans [2011] applied the Map Reduce framework to parallelizing batch reinforcement learning methods with linear function approximation. Parallelism was used to speed up large matrix operations but not to parallelize the collection of experience or stabilize learning. Grounds and Kudenko [2008] proposed a parallel version of the Sarsa algorithm that uses multiple separate actor-learners to accelerate training. Each actor-learner learns separately and periodically sends updates to weights that have changed significantly to the other learners using peer-to-peer communication.\nTsitsiklis [1994] studied convergence properties of Q-learning in the asynchronous optimization setting. These results show that Q-learning is still guaranteed to converge when some of the information is outdated as long as outdated information is always eventually discarded and several other technical assumptions are satisfied. Even earlier, Bertsekas [1982] studied the related problem of distributed dynamic programming.\nAnother related area of work is in evolutionary methods, which are often straightforward to parallelize by distributing fitness evaluations over multiple machines or threads [Tomassini, 1999]. Such parallel evolutionary approaches have recently been applied to some visual reinforcement learning tasks. In one example, Koutn\u0301\u0131k et al. [2014] evolved convolutional neural network controllers for the TORCS driving simulator by performing fitness evaluations on 8 CPU cores in parallel."}, {"heading": "3 Background", "text": ""}, {"heading": "3.1 Reinforcement Learning", "text": "We consider the standard reinforcement learning setting where an agent interacts with an environment E over a number of discrete time steps. At each time step t, the agent receives a state st and selects an action at from some set of possible actions A according to its policy \u03c0, where \u03c0 is a mapping from states st to actions at. In return, the agent receives the next state st+1 and receives a scalar reward rt. The process continues until the agent reaches a terminal state after which the process restarts. The return Rt = \u2211\u221e k=0 \u03b3\nkrt+k is the total accumulated return from time step t with discount factor \u03b3 \u2208 (0, 1]. The goal of the agent is to maximize the expected return from each state st.\nThe action value Q\u03c0(s, a) = E [Rt|st = s, a] is the expected return for selecting action a in state s and following policy \u03c0. The optimal value function Q\u2217(s, a) = max\u03c0 Q\n\u03c0(s, a) gives the maximum action value for state s and action a achievable by any policy. Similarly, the value of state s under policy \u03c0 is defined as V \u03c0(s) = E [Rt|st = s] and is simply the expected return for following policy \u03c0 from state s.\nIn value-based model-free reinforcement learning methods, the action value function is represented using a function approximator, such as a neural network. Let Q(s, a; \u03b8) be an approximate action-value function with parameters \u03b8. The updates to \u03b8 can be derived from a variety of reinforcement learning algorithms. One example of such an algorithm is Qlearning, which aims to directly approximate the optimal action value function: Q\u2217(s, a) \u2248 Q(s, a; \u03b8). In one-step Q-learning, the parameters \u03b8 of the action value function Q(s, a; \u03b8) are learned by iteratively minimizing a sequence of loss functions, where the ith loss function defined as\nLi(\u03b8i) = E ( r + \u03b3max\na\u2032 Q(s\u2032, a\u2032; \u03b8i\u22121)\u2212Q(s, a; \u03b8i)\n)2 , (1)\nwhere s\u2032 is the state encountered after state s. Alternatively, Sarsa [Rummery and Niranjan, 1994, Sutton and Barto, 1998] is a widely used on-policy algorithm where the approximate action value function Q is updated by minimizing the following loss function during the ith iteration\nLi(\u03b8i) = E ( r + \u03b3Q(s\u2032, a\u2032; \u03b8i\u22121)\u2212Q(s, a; \u03b8i) )2 , (2)\nwhere a\u2032 is the action taken by the agent in state s\u2032. In tabular environments, where Q(s, a; \u03b8) is a lookup table, both Q-learning and Sarsa are known to converge to the optimal value function Q\u2217 under certain conditions [Jaakkola et al., 1994, Tsitsiklis, 1994, Singh et al., 2000].\nWe refer to the above methods as one-step Q-learning and one-step Sarsa because they update the action value Q(s, a) toward one-step returns r + \u03b3maxa\u2032 Q(s\n\u2032, a\u2032; \u03b8) and r + \u03b3Q(s\u2032, a\u2032; \u03b8) respectively. One drawback of using one-step methods is that obtaining a reward r only directly affects the value of the state action pair s, a that led to the reward. The values of other state action pairs are affected only indirectly through the updated value Q(s, a). This can make the learning process slow since many updates are required the propagate a reward to the relevant preceding states and actions.\nOne way of propagating rewards faster is by using n-step returns [Watkins, 1989, Peng and Williams, 1996]. In n-step Q-learning, Q(s, a) is updated toward the n-step return defined as\nrt + \u03b3rt+1 + \u00b7 \u00b7 \u00b7+ \u03b3n\u22121rt+n + max a \u03b3nQ(st+n+1, a). (3)\nThis results in a single reward r directly affecting the values of n preceding state action pairs. This makes the process of propagating rewards to relevant state-action pairs potentially much more efficient.\nIn contrast to value-based methods, policy-based model-free methods directly parameterize the policy \u03c0(a|s; \u03b8) and update the parameters \u03b8 by performing, typically approximate, gradient ascent on E[Rt]. One example of such a method is the REINFORCE family of algorithms due to Williams [1992]. Standard REINFORCE updates the policy parameters \u03b8 in the direction \u2207\u03b8 log \u03c0(at|st; \u03b8)Rt, which is an unbiased estimate of \u2207\u03b8E[Rt]. It is possible to reduce the variance of this estimate while keeping it unbiased by subtracting a learned function of the state bt(st), known as a baseline [Williams, 1992], from the return\n\u2207\u03b8 log \u03c0(at|st; \u03b8) (Rt \u2212 bt(st)) . (4)\nA learned estimate of the value function is commonly used as the baseline bt(st) \u2248 V \u03c0(st) leading to a much lower variance estimate of the policy gradient. When an approximate value function is used as the baseline, the quantity Rt\u2212 bt used to scale the policy gradient can be seen as an estimate of the advantage of action at in state st, or A(at, st) = Q(at, st)\u2212 V (st), because Rt is an estimate of Q \u03c0(at, st) and bt is an estimate of V \u03c0(st). This approach can be viewed as an actor-critic architecture where the policy \u03c0 is the actor and the baseline bt is the critic [Sutton and Barto, 1998, Degris et al., 2012]."}, {"heading": "3.2 Deep Q Networks", "text": "Temporal difference learning methods, such as Q-learning, have been known to diverge when used with nonlinear function approximators [Tsitsiklis and Roy, 1997]. The recently introduced variant of Q-learning for training Deep Q Networks [Mnih et al., 2015] made use of two techniques for avoiding such divergences in practice. First, an experience replay memory mechanism due to Lin [1993] was used to perform Q-learning updates on random samples of past experience instead on the most recent samples of experience. Experience replay reduces the correlations between successive updates applied to the network thereby\nmaking the training data less non-stationary. Second, the network used for computing Q-learning targets was held fixed for intervals of several thousand updates, after which it would be updated with the current weights of Q(s, a; \u03b8). This technique of employing a target network reduces the correlations between the target and the predicted Q-values, again making the training problem less non-stationary. The loss function minimized by DQN then takes the form\nL(\u03b8) = Es,a,r,s\u2032\u223cD ( r + \u03b3max\na\u2032 Q(s\u2032, a\u2032; \u03b8\u2212)\u2212Q(s, a; \u03b8)\n)2 , (5)\nwhere D is the experience replay memory and \u03b8\u2212 are the parameters of the target network. Both experience replay and the target network were empirically shown to be important for obtaining the best policies on a number of Atari games, but as discussed earlier, the replay memory can have substantial memory requirements."}, {"heading": "4 Asynchronous Lock-Free Reinforcement Learning", "text": "We now present multi-threaded asynchronous variants of one-step Sarsa, one-step Q-learning, n-step Q-learning, and advantage actor-critic. The aim in designing these methods was to find RL algorithms that can train deep neural network policies reliably and without large resource requirements. While the underlying RL methods are quite different, with actorcritic being an on-policy policy search method and Q-learning being an off-policy valuebased method, we use two main ideas to make all four algorithms practical given our design goal.\nFirst, we use asynchronous actor-learners as proposed in the Gorila framework [Nair et al., 2015], but instead of using separate machines and a parameter server, we use multiple threads on a single machine. Keeping the learners on a single machine removes the communication costs incurred by sending gradients and parameters and enables us to use Hogwild! [Recht et al., 2011] style updates for training the controllers.\nSecond, we make the observation that multiple actors-learners running in parallel are likely to be exploring different parts of the environment. Moreover, one can explicitly use different exploration policies in each actor-learner to maximize this diversity. By running different exploration policies in different threads, the overall changes being made to the parameters by multiple actor-learners applying online updates in parallel are likely to be less correlated in time than a single agent applying online updates. Hence, we do not use a replay memory and rely on parallel actors employing different exploration policies to perform the stabilizing role undertaken by experience replay in the DQN training algorithm.\nIn addition to stabilizing learning, using multiple parallel actor-learners has multiple practical benefits. First, we obtain a reduction in training time that is roughly linear in the number of parallel actor-learners. Second, since we no longer rely on experience replay for stabilizing learning we are able to use on-policy reinforcement learning methods such as Sarsa and actor-critic to train neural networks in a stable way. We now describe our variants of one-step Q-learning, one-step Sarsa, n-step Q-learning and advantage actorcritic, discussing design choices specific to each algorithm.\nAlgorithm 1 Asynchronous one-step Q-learning - pseudocode for each actor-learner thread.\n// Assume global shared parameter vector \u03b8. // Assume global shared target parameter vector \u03b8\u2212. // Assume global shared counter T = 0. Initialize thread step counter t\u2190 0 Initialize target network weights \u03b8\u2212 \u2190 \u03b8 Initialize network gradients d\u03b8 \u2190 0 Get initial state s repeat\nTake action a according to the -greedy policy based on Q(s, a; \u03b8) Receive new state s\u2032 and reward r\ny =\n{ r for terminal s\u2032\nr + \u03b3maxa\u2032 Q(s \u2032, a\u2032; \u03b8\u2212) for non-terminal s\u2032\nAccumulate gradients wrt \u03b8: d\u03b8 \u2190 d\u03b8 + \u2202(y\u2212Q(s,a;\u03b8)) 2 \u2202\u03b8 s = s\u2032 T \u2190 T + 1 t\u2190 t+ 1 if T mod Itarget == 0 then\nUpdate the target network \u03b8\u2212 \u2190 \u03b8 end if if t mod IAsyncUpdate == 0 or s is terminal then\nPerform asynchronous update of \u03b8 using d\u03b8. Clear gradients d\u03b8 \u2190 0.\nend if until T > Tmax"}, {"heading": "4.1 Asynchronous one-step Q-learning", "text": "Pseudocode for our variant of Q-learning, which we call Asynchronous one-step Q-learning, is shown in Algorithm 1. Each thread interacts with its own copy of the environment and at each step computes a gradient of the Q-learning loss. We use a shared and slowly changing target network in computing the Q-learning loss, as was proposed in the DQN training method. We also accumulate gradients over multiple timesteps before they are applied, which is similar to using minibatches. This reduces the chances of multiple actors learners overwriting each other\u2019s updates in the Hogwild! setting. Accumulating updates over several steps also provides some ability to trade off computational efficiency for data efficiency.\nFinally, we found that giving each thread a different exploration policy helps improve robustness. Adding diversity to exploration in this manner also generally improves performance through better exploration. While there are many possible ways of making the exploration policies differ we experiment with using -greedy exploration with that is periodically sampled from some distribution of values by each thread.\nWhile Algorithm 1 gives the pseudocode for the method used in our experiments, we also experimented with a number of variants. For example, we experimented with using thread-\nspecific target networks instead of using a single shared target network as in Algorithm 1. Another choice is which network is used for selecting actions, the model network with parameters \u03b8 or the target network with parameters \u03b8\u2212. However, we found that these modification led to slightly worse results on a subset of games on the Atari domain."}, {"heading": "4.2 Asynchronous one-step Sarsa", "text": "The asynchronous one-step Sarsa algorithm is the same as asynchronous one-step Q-learning as given in Algorithm 1 except that it uses a different target value for Q(s, a). The target value used by one-step Sarsa is\ny =\n{ r for terminal s\u2032\nr + \u03b3Q(s\u2032, a\u2032; \u03b8\u2212) for non-terminal s\u2032 (6)\nwhere a\u2032 is the action taken in state s\u2032 [Sutton and Barto, 1998]. We again use a target network and updates accumulated over multiple timesteps to stabilize learning."}, {"heading": "4.3 Asynchronous n-step Q-learning", "text": "Pseudocode for our variant of multi-step Q-learning is shown in Algorithm 2. The algorithm is somewhat unusual because it operates in the forward view by explicitly computing n-step returns, as opposed to the more common backward view used by techniques like eligibility traces [Sutton and Barto, 1998]. We found that using the forward view is easier when training neural networks with momentum-based methods and backpropagation through time. In order to compute a single update, the algorithm first selects actions using its exploration policy for up to tmax steps or until a terminal state is reached. This process results in the agent receiving up to tmax rewards from the environment since its last update. The algorithm then computes gradients for n-step Q-learning updates for each of the stateaction pairs encountered since the last update. Each n-step update uses the longest possible n-step return resulting in a one-step update for the last state, a two-step update for the second last state, and so on for a total of up to tmax updates. The accumulated updates are then applied in a single gradient step."}, {"heading": "4.4 Asynchronous advantage actor-critic", "text": "Our asynchronous variant of actor-critic is presented in Algorithm 3. The algorithm, which we call asynchronous advantage actor-critic (A3C), maintains a policy \u03c0(at|st; \u03b8) and an estimate of the value function V (st; \u03b8v). Like our variant of n-step Q-learning, our variant of actor-critic also operates in the forward view and uses the same mix of n-step returns to update both the policy and the value-function. The policy and the value function are updated after every tmax actions or when a terminal state is reached. The update performed by the algorithm can be seen as \u2207\u03b8\u2032 log \u03c0(at|st; \u03b8\u2032)A(st, at; \u03b8, \u03b8v) where A(st, at; \u03b8, \u03b8v) is an estimate of the advantage function given by \u2211k\u22121 i=0 \u03b3 irt+i + \u03b3 kV (st+k; \u03b8v)\u2212 V (st; \u03b8v), where k varies from state to state and is upper-bounded by tmax. As with the value-based methods we rely on parallel actor-learners and accumulated updates for improving training stability. Note that while the parameters \u03b8 of the policy and \u03b8v of the value function are shown as being separate for generality, we always share some\nAlgorithm 2 Asynchronous n-step Q-learning - pseudocode for each actor-learner thread.\n// Assume global shared parameter vector \u03b8. // Assume global shared target parameter vector \u03b8\u2212. // Assume global shared counter T = 0. Initialize thread step counter t\u2190 1 Initialize target network parameters \u03b8\u2212 \u2190 \u03b8 Initialize thread-specific parameters \u03b8\u2032 = \u03b8 Initialize network gradients d\u03b8 \u2190 0 repeat\nClear gradients d\u03b8 \u2190 0 Synchronize thread-specific parameters \u03b8\u2032 = \u03b8 tstart = t Get state st repeat\nTake action at according to the -greedy policy based on Q(st, a; \u03b8 \u2032) Receive reward rt and new state st+1 t\u2190 t+ 1 T \u2190 T + 1\nuntil terminal st or t\u2212 tstart == tmax R = { 0 for terminal st maxaQ(st, a; \u03b8\n\u2212) for non-terminal st for i \u2208 {t\u2212 1, . . . , tstart} do\nR\u2190 ri + \u03b3R Accumulate gradients wrt \u03b8\u2032: d\u03b8 \u2190 d\u03b8 + \u2202(R\u2212Q(si,ai;\u03b8 \u2032))2\n\u2202\u03b8\u2032\nend for Perform asynchronous update of \u03b8 using d\u03b8. if T mod Itarget == 0 then\n\u03b8\u2212 \u2190 \u03b8 end if\nuntil T > Tmax\nof the parameters in practice. We typically use a convolutional neural network that has one softmax output for the policy \u03c0(at|st; \u03b8) and one linear output for the value function V (st; \u03b8v), with all non-output layers shared.\nWe also found that adding the entropy of the policy \u03c0 to the objective function improved exploration by discouraging premature convergence to suboptimal deterministic policies. This technique was originally proposed by [Williams and Peng, 1991], who found that it was particularly helpful on tasks requiring hierarchical behavior. The gradient of the full objective function including the entropy regularization term with respect to the policy parameters takes the form\n\u2207\u03b8\u2032 log \u03c0(at|st; \u03b8\u2032)(Rt \u2212 V (st; \u03b8v) + \u03b2\u2207\u03b8\u2032H(\u03c0(st; \u03b8\u2032)) (7)\nwhere H is the entropy. The hyperparameter \u03b2 controls the strength of the entropy regularization term.\nAlgorithm 3 Asynchronous advantage actor-critic - pseudocode for each actor-learner thread.\n// Assume global shared parameter vectors \u03b8 and \u03b8v and global shared counter T = 0 // Assume thread-specific parameter vectors \u03b8\u2032 and \u03b8\u2032v Initialize thread step counter t\u2190 1 repeat\nReset gradients: d\u03b8 \u2190 0 and d\u03b8v \u2190 0. Synchronize thread-specific parameters \u03b8\u2032 = \u03b8 and \u03b8\u2032v = \u03b8v tstart = t Get state st repeat\nPerform at according to policy \u03c0(at|st; \u03b8\u2032) Receive reward rt and new state st+1 t\u2190 t+ 1 T \u2190 T + 1\nuntil terminal st or t\u2212 tstart == tmax R = { 0 for terminal st V (st, \u03b8 \u2032 v) for non-terminal st// Bootstrap from last state for i \u2208 {t\u2212 1, . . . , tstart} do R\u2190 ri + \u03b3R Accumulate gradients wrt \u03b8\u2032: d\u03b8 \u2190 d\u03b8 +\u2207\u03b8\u2032 log \u03c0(ai|si; \u03b8\u2032)(R\u2212 V (si; \u03b8\u2032v)) Accumulate gradients wrt \u03b8\u2032v: d\u03b8v \u2190 d\u03b8v + \u2202 (R\u2212 V (si; \u03b8\u2032v))\n2/\u2202\u03b8\u2032v end for Perform asynchronous update of \u03b8 using d\u03b8 and of \u03b8v using d\u03b8v.\nuntil T > Tmax"}, {"heading": "4.5 Optimization", "text": "We investigated two different optimization algorithms with our asynchronous framework \u2013 stochastic gradient descent and RMSProp. Our implementations of these algorithms do not use any locking in order to maximize throughput when using a large number of threads.\nMomentum SGD: The implementation of SGD in an asynchronous setting is relatively straightforward and well studied [Recht et al., 2011]. Let \u03b8 be the parameter vector that is shared across all threads and let \u2206\u03b8i be the accumulated gradients of the loss with respect to parameters \u03b8 computed by thread number i. Each thread i independently applies the standard momentum SGD update mi = \u03b1mi + (1 \u2212 \u03b1)\u2206\u03b8i followed by \u03b8 \u2190 \u03b8 \u2212 \u03b7mi with learning rate \u03b7, momentum \u03b1 and without any locks. Note that in this setting, each thread maintains its own separate gradient and momentum vector.\nRMSProp: While RMSProp [Tieleman and Hinton, 2012] has been widely used in the deep learning literature, it has not been extensively studied in the asynchronous optimization setting. The standard non-centered RMSProp update is given by\ng = \u03b1g + (1\u2212 \u03b1)\u2206\u03b82 (8)\n\u03b8 \u2190 \u03b8 \u2212 \u03b7 \u2206\u03b8\u221a g + , (9)\nwhere all operations are performed elementwise. In order to apply RMSProp in the asynchronous optimization setting one must decide whether the moving average of elementwise squared gradients g is shared or per-thread. We experimented with two versions of the algorithm. In one version, which we refer to as RMSProp, each thread maintains its own g shown in Equation 8. In the other version, which we call Shared RMSProp, the vector g is shared among threads and is updated asynchronously and without locking. We will show that this way of sharing the statistics greatly improves the stability of the method. Additionally, sharing statistics among threads reduces memory requirements by using one fewer copy of the parameter vector per thread."}, {"heading": "5 Experiments", "text": "We use four different platforms for assessing the properties of the proposed framework. First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games. This is one of the most commonly used benchmark environments for RL algorithms. We compare against state of the art results on this environment as reported by Van Hasselt et al. [2015], Wang et al. [2015], Schaul et al. [2015], Nair et al. [2015] and Mnih et al. [2015]. The second environment we use is the TORCS car racing simulator [Wymann et al., 2013]. TORCS is a 3D simulator where the graphics are more realistic compared to Atari and, additionally, understanding the physics of the car is an important component. The third environment we use to report results is the MuJoCo [Todorov, 2015] physics simulator for evaluating agents on continuous motor control tasks with contact dynamics. The last domain, which was only used to evaluate our best-performing agent, is a new 3D environment called Labyrinth where the agent must learn to find rewards in randomly generated mazes from a visual input. Finally, we have carried out a detailed stability and scalability analysis of the proposed methods."}, {"heading": "5.1 Experimental Setup", "text": "The experiments performed on a subset of Atari games (Figures 1, 6, 7 and Table 2) as well as the TORCS experiments (Figure 2) used the following setup. Each experiment used 16 actor-learner threads running on a single machine and no GPUs. All methods performed updates after every 5 actions (tmax = 5 and IUpdate = 5) and shared RMSProp was used for optimization. The three asynchronous value-based methods used a shared target network that was updated every 40000 frames. The Atari experiments used the same input preprocessing as Mnih et al. [2015] and an action repeat of 4. The agents used the network architecture from Mnih et al. [2013]. The network used a convolutional layer with 16 filters of size 8 \u00d7 8 with stride 4, followed by a convolutional layer with with 32 filters of size 4 \u00d7 4 with stride 2, followed by a fully connected layer with 256 hidden units. All three hidden layers were followed by a rectifier nonlinearity. The value-based methods had a single linear output unit for each action representing the action-value. The model used by actor-critic agents had two set of outputs \u2013 a softmax output with one entry per action representing the probability of selecting the action, and a single linear output representing the value function.\nThe value based methods sampled the exploration rate from a distribution taking\nBeamrider\nBreakout\nPong\nQ*bert\nSpace Invaders\nthree values 1, 2, 3 with probabilities 0.4, 0.3, 0.3. The values of 1, 2, 3 were annealed from 1 to 0.1, 0.01, 0.5 respectively over the first four million frames. Advantage actor-critic used entropy regularization with a weight \u03b2 = 0.01 for all Atari and TORCS experiments. We performed a set of 50 experiments for five Atari games and every TORCS level, each using a different random initialization and initial learning rate. The initial learning rate was sampled from a LogUniform(10\u22124, 10\u22122) distribution and annealed to 0 over the course of training. We analyze the sensitivity of the methods to the choice of learning rate in Section 5.3.2. Note that in comparisons to prior work (Tables 1 and 3) we followed standard evaluation protocol and used fixed hyperparameters."}, {"heading": "5.2 Results", "text": ""}, {"heading": "5.2.1 Atari 2600 Games", "text": "We first present results on a subset of Atari 2600 games to demonstrate the training speed of the new methods. Figure 1 compares the learning speed of the DQN algorithm trained on an Nvidia K40 GPU with the asynchronous methods trained using 16 CPU cores on five Atari 2600 games. The results show that all four asynchronous methods we presented can successfully train neural network controllers on the Atari domain. The asynchronous methods tend to learn faster than DQN, with significantly faster learning on some games, while training on only 16 CPU cores. Additionally, the results suggest that n-step methods do indeed learn faster than one-step methods. Overall, the policy-based advantage actorcritic method significantly outperforms all three value-based methods.\nWe then evaluated asynchronous advantage actor-critic on 57 Atari games. In order to compare with the state of the art in Atari game playing, we largely followed the training and evaluation protocol of Van Hasselt et al. [2015]. Specifically, we tuned hyperparameters\n(learning rate and amount of gradient norm clipping) using a search on six Atari games (Beamrider, Breakout, Pong, Q*bert, Seaquest and Space Invaders) and used the best hyperparameters for all 57 games. We trained both a feedforward agent with the same architecture as [Mnih et al., 2015, Nair et al., 2015, Van Hasselt et al., 2015] as well as a recurrent agent with an additional 256 LSTM [Hochreiter and Schmidhuber, 1997] cells after the final hidden layer. We additionally used the final network weights for evaluation to make the results more comparable to the original results from Bellemare et al. [2012]. We trained our agents for four days using 16 CPU cores, while the other agents were trained for 8 to 10 days on Nvidia K40 GPUs. Table 1 shows the average and median human-normalized scores obtained by our agents trained by asynchronous advantage actor-critic (A3C) as well as the current state-of-the art while Table 3 shows the scores on all games. A3C significantly improves on state-of-the-art the average score over 57 games in half the training time of the other methods while using only 16 CPU cores and no GPU. Furthermore, after just one day of training, A3C matches the average human normalized score of Dueling Double DQN as well as the median human normalized score of DQN. We note that many of the improvements that are presented in Double DQN [Van Hasselt et al., 2015] and Dueling Double DQN [Wang et al., 2015] can be incorporated to 1-step Q and n-step Q methods presented in this work with similar potential improvements."}, {"heading": "5.2.2 TORCS Car Racing Simulator", "text": "We also compared the four asynchronous methods on the TORCS 3D car racing game [Wymann et al., 2013]. TORCS not only has more realistic graphics than Atari 2600 games, but also requires the agent to learn the dynamics of the car it is controlling. At each step, an agent received only a visual input in the form of an RGB image of the current frame as well as a reward proportional to the agent\u2019s velocity along the center of the track at the agent\u2019s current position. This reward structure differs considerably from most Atari games, where the rewards are usually very sparse. We used the same neural network architecture as the one used in the Atari experiments specified in Section 5.1. We performed experiments using four different settings \u2013 the agent controlling a slow car with and without opponent bots, and the agent controlling a fast car with and without opponent bots. The\nresults for the different game configurations comparing all four algorithms are shown in Figure 2. Multi-step algorithms learn much faster and reach better policies on all four configurations. Moreover, the best method, Async Advantage Actor-Critic approached its best performance after roughly 12 hours of training. Its performance reached between roughly 75% and 90% of the score obtained by a human tester on all four game configurations. A video showing the learned driving behavior of the best performing agent can be found at https://youtu.be/0xo1Ldx3L5Q."}, {"heading": "5.2.3 Continuous Action Control Using the MuJoCo Physics Simulator", "text": "Finally, we also examined a set of tasks where the action space is continuous. In particular, we look at a set of rigid body physics domains with contact dynamics where the tasks\ninclude many examples of manipulation and locomotion. These tasks were simulated in the Mujoco physics engine. The action space for the Atari domains is naturally discrete and for TORCS a small discretization of the action space is straightforward and was found to be successful. However, there are many problems for which discretization of the action space is unlikely to be a good strategy. If, for example, a problem requires controlling a system with 10 independently controlled joint torques, then even very coarse discretization of the action space into 5 values for each joint leads to 510 discrete actions. Because of this fact, the DQN algorithm (or any algorithm that relies on a max operator over actions) cannot\neasily be applied to continuous control problems with even moderately sized action spaces. However, one of the algorithms examined here, the asynchronous advantage actor-critic, is straightforward to apply in continuous action spaces. Since this algorithm does not rely on the max operator over actions, all that is required to apply it to the Mujoco domains is to ensure that the actor network outputs a vector sampled from a continuous distribution in the appropriately sized space. Thus, in the context of the continuous action control problems we examined only the asynchronous advantage actor-critic algorithm. Since most of the design choices for the algorithm were made with discrete control problems in mind, these results serve as a proof-of-concept application and could likely be improved by further adapting the method to continuous control tasks.\nTo apply the asynchronous advantage actor-critic algorithm to the Mujoco tasks the necessary setup is nearly identical to that used in the discrete action domains, so here we enumerate only the differences required for the continuous action domains. The essential elements for many of the tasks (i.e. the physics models and task objectives) are near identical to the tasks examined in [Lillicrap et al., 2015]. However, the rewards and thus performance are not comparable for most of the tasks due to changes made by the developers of Mujoco which altered the contact model.\nFor all the domains we attempted to learn the task using the physical state as input. The physical state consisted of the joint positions and velocities as well as the target position if the task required a target. In addition, for three of the tasks (pendulum, pointmass2D, and gripper) we also examined training directly from RGB pixel inputs. In the low dimensional physical state case, the inputs are mapped to a hidden state using one hidden layer with 200 ReLU units. In the cases where we used pixels, the input was passed through two layers of spatial convolutions without any non-linearity or pooling. In either case, the output of the encoder layers were fed to a single layer of 128 LSTM cells. The most important difference in the architecture is in the the output layer of the policy network. Unlike the discrete action domain where the action output is a Softmax, here the two outputs of the policy network are two real number vectors which we treat as the mean vector \u00b5 and scalar variance \u03c32 of a multidimensional normal distribution with a spherical covariance. To act, the input is passed through the model to the output layer where we sample from the normal distribution determined by \u00b5 and \u03c32. In practice, \u00b5 is modeled by a linear layer and \u03c32 by a SoftPlus operation, log(1 + exp(x)), as the activation computed as a function of the output of a linear layer. In our experiments with continuous control problems the networks for policy network and value network do not share any parameters, though this detail is unlikely to be crucial. Finally, since the episodes were typically at most several hundred time steps long, we did not use any bootstrapping in the policy or value function updates and batched each episode into a single update.\nAs in the discrete action case, we included an entropy cost which encouraged exploration. In the continuous case the we used a cost on the differential entropy of the normal distribution defined by the output of the actor network, \u221212(log(2\u03c0\u03c3\n2) + 1), we used a constant multiplier of 10\u22124 for this cost across all of the tasks examined. The asynchronous advantage actor-critic algorithm finds solutions for all the domains. Figure 4 shows learning curves against wall-clock time, and demonstrates that most of the domains from states can be solved within a few hours. All of the experiments, including those done from pixel based observations, were run on CPU. Even in the case of solving the domains directly from pixel inputs we found that it was possible to reliably discover solutions within 24 hours. Figure 3 shows scatter plots of the top scores against the sampled learning rates. In most of the domains there is large range of learning rates that consistently achieve good performance on the task.\nSome of the successful policies learned by our agent can be seen in the following video https://youtu.be/Ajjc08-iPx8."}, {"heading": "5.2.4 Labyrinth", "text": "We performed an additional set of experiments with A3C on a new 3D environment called Labyrinth. The specific task we considered involved the agent learning to find rewards in randomly generated mazes. At the beginning of each episode the agent was placed in a new randomly generated maze consisting of rooms and corridors. Each maze contained two types of objects that the agent was rewarded for finding \u2013 apples and portals. Picking up the agent lead to a reward of 1. Entering a portal lead to a reward of 10 after which the agent was respawned in a new random location in the maze and all previously collected apples were regenerated. An episode terminated after 60 seconds after which a new episode would begin. The aim of the agent is to collect as many points as possible in the time limit and the optimal strategy involves first finding the portal and then repeatedly going back to it after each respawn. This task is much more challenging than the TORCS driving domain because the agent is faced with a new maze in each episode and must learn a general strategy for exploring random mazes.\nWe trained an A3C LSTM agent on this task using only 84\u00d7 84 RGB images as input. Figure 5 shows an averaged training curve for the best 5 agents we trained. The final average score of around 50 indicates that the agent learned a reasonable strategy for exploring random 3D maxes using only a visual input. A video showing one of the agents exploring previously unseen mazes is included at https://youtu.be/nMR5mjCFZCw."}, {"heading": "5.3 Analysis", "text": ""}, {"heading": "5.3.1 Scalability and Data Efficiency", "text": "We now analyze the effectiveness of our proposed framework by looking at how the training time and data efficiency changes with the number of parallel actor-learners. When using multiple workers in parallel and updating a shared model, one would expect that in an ideal case, for a given task and algorithm, the total number of training steps to achieve a certain\nscore would remain the same with varying numbers of workers. Therefore, the advantage would be solely due to the ability of the system to consume more data in the same amount of wall clock time and possibly improved exploration. Table 2 shows the training speed-up achieved by using increasing numbers of parallel actor-learners averaged over seven Atari games. These results show that all four methods achieve substantial speedups from using multiple worker threads, with 16 threads leading to at least an order of magnitude speedup. This confirms that our proposed framework scales well with the number of parallel workers, making efficient use of resources.\nSomewhat surprisingly, asynchronous one-step Q-learning and Sarsa algorithms exhibit superlinear speedups that cannot be explained by purely computational gains. These effects are shown more clearly in Figure 6, which shows plots of the average score against the total number of training frames for different numbers of actor-learners and training methods on five Atari games, and Figure 7, which shows plots of the average score against wall-clock time. Figure 6 shows that one-step methods (one-step Q and one-step Sarsa) often require less data to achieve a particular score when using more parallel actor-learners. While a similar effect exists for n-step Q-learning it is less dramatic. When these gains in data efficiency are combined with a sublinear computational speedup, n-step Q-learning achieves a linear speedup from using multiple actor-learners while one-step Q-learning and Sarsa achieve superlinear gains shown in Table 2. The data efficiency of asynchronous advantage actor-critic seems to be largely unaffected by the number of parallel actor-learners. Nevertheless, asynchronous actor-critic still exhibits a substantial speedup, training over 12 times faster using 16 actor-learners."}, {"heading": "5.3.2 Robustness and Stability", "text": "We first analyze three asynchronous optimization algorithms by inspecting their sensitivity to different learning rates and random network initializations. Stochastic gradient descent is still widely used for training neural networks due to its simplicity and computational efficiency. Although there are many extensions such as ADAGRAD [Duchi et al., 2011],\n0 10 20 30 40 Training epochs\n0\n2000\n4000\n6000\n8000\n10000\nS co\nre\nBeamrider\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 10 20 30 40 Training epochs\n0\n50\n100\n150\n200\n250\n300 350 S co re Breakout 1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 10 20 30 40 Training epochs\n25\n20\n15\n10\n5\n0\n5\n10\n15\n20\nS co\nre\nPong\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 10 20 30 40 Training epochs\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n4000\n4500\nS co\nre\nQ*bert\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 10 20 30 40 Training epochs\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\nSpace Invaders\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 10 20 30 40 Training epochs\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nBeamrider\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 10 20 30 40 Training epochs\n0\n50\n100\n150\n200\n250\n300\n350\nS co\nre\nBreakout\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 10 20 30 40 Training epochs\n25\n20\n15\n10\n5\n0\n5\n10\n15 20 S co re\nPong\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 10 20 30 40 Training epochs\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n4000\n4500\nS co\nre\nQ*bert\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 10 20 30 40 Training epochs\n100\n200\n300\n400\n500\n600\n700\n800\n900\nS co\nre\nSpace Invaders\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 10 20 30 40 Training epochs\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nBeamrider\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 10 20 30 40 Training epochs\n0\n50\n100\n150\n200\n250\n300\n350\nS co\nre\nBreakout\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 10 20 30 40 Training epochs\n25\n20\n15\n10\n5\n0\n5\n10\n15\n20\nS co\nre\nPong\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 10 20 30 40 Training epochs\n0\n1000\n2000\n3000\n4000\n5000\n6000\nS co\nre\nQ*bert\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 10 20 30 40 Training epochs\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\nSpace Invaders\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 10 20 30 40 Training epochs\n0\n2000\n4000\n6000\n8000\n10000\n12000\n14000\n16000\nS co\nre\nBeamrider\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 10 20 30 40 Training epochs\n0\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\nBreakout\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 10 20 30 40 Training epochs\n30\n20\n10\n0\n10\n20\n30\nS co\nre\nPong\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 10 20 30 40 Training epochs\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nQ*bert\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 10 20 30 40 Training epochs\n0\n200\n400\n600\n800\n1000\n1200\n1400\nS co\nre\nSpace Invaders\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\nFigure 6: Data efficiency comparison of different numbers of actor-learners for all four asynchronous methods on five Atari games. The x-axis shows the total number of training epochs where an epoch corresponds to four million frames (across all threads). The y-axis shows the average score. Each curve shows the average of the three best performing agents from a search over 50 random learning rates. Single step methods show increased data efficiency with increased numbers of parallel workers.\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n1000\n2000\n3000\n4000\n5000\n6000\n7000\n8000\n9000\nS co\nre\nBeamrider\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n50\n100\n150\n200\n250\n300\nS co\nre\nBreakout\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n25\n20\n15\n10\n5\n0\n5\n10\n15\n20\nS co\nre\nPong\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n4000\nS co\nre\nQ*bert\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\nSpace Invaders\n1-step Q, 1 threads 1-step Q, 2 threads 1-step Q, 4 threads 1-step Q, 8 threads 1-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nBeamrider\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n50\n100\n150\n200\n250\n300\n350\nS co\nre\nBreakout\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n25\n20\n15\n10\n5\n0\n5\n10\n15 20 S co re Pong 1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\nS co\nre\nQ*bert\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\nSpace Invaders\n1-step SARSA, 1 threads 1-step SARSA, 2 threads 1-step SARSA, 4 threads 1-step SARSA, 8 threads 1-step SARSA, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nBeamrider\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n50\n100\n150\n200\n250\n300\n350\nS co\nre\nBreakout\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n25\n20\n15\n10\n5\n0\n5\n10\n15\n20\nS co\nre\nPong\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n4000 4500 S co re\nQ*bert\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\nSpace Invaders\nn-step Q, 1 threads n-step Q, 2 threads n-step Q, 4 threads n-step Q, 8 threads n-step Q, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n2000\n4000\n6000\n8000\n10000\n12000\n14000\n16000\nS co\nre\nBeamrider\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n100\n200\n300\n400\n500\n600\nS co\nre\nBreakout\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n30\n20\n10\n0\n10\n20\n30\nS co\nre\nPong\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nQ*bert\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\n0 2 4 6 8 10 12 14 Training time (hours)\n0\n200\n400\n600\n800\n1000\n1200\n1400\n1600\nS co\nre\nSpace Invaders\nA3C, 1 threads A3C, 2 threads A3C, 4 threads A3C, 8 threads A3C, 16 threads\nFigure 7: Training speed comparison of different numbers of actor-learners for all four asynchronous methods on five Atari games. The x-axis shows training time in hours while the y-axis shows the average score. Each curve shows the average of the three best performing agents from a search over 50 random learning rates. All asynchronous methods show significant speedups from using greater numbers of parallel actor-learners.\n10 20 30 40 50 Model Rank\n0\n50\n100\n150\n200\n250\n300\n350\n400\nS co\nre\nBreakout\nn-step Q, SGD n-step Q, RMSProp n-step Q, Shared RMSProp\n10 20 30 40 50 Model Rank\n0\n5000\n10000\n15000\n20000\n25000\nS co\nre\nBeamrider\nn-step Q, SGD n-step Q, RMSProp n-step Q, Shared RMSProp\n10 20 30 40 50 Model Rank\n0\n1000\n2000\n3000\n4000\n5000\n6000\nS co\nre\nSeaquest\nn-step Q, SGD n-step Q, RMSProp n-step Q, Shared RMSProp\n10 20 30 40 50 Model Rank\n0\n200\n400\n600\n800\n1000\n1200\n1400\n1600\n1800\nS co\nre\nSpace Invaders\nn-step Q, SGD n-step Q, RMSProp n-step Q, Shared RMSProp\n10 20 30 40 50 Model Rank\n0\n100\n200\n300\n400\n500\n600\n700\n800\n900\nS co\nre\nBreakout\nA3C, SGD A3C, RMSProp A3C, Shared RMSProp\n10 20 30 40 50 Model Rank\n0\n5000\n10000\n15000\n20000\n25000\nS co\nre\nBeamrider\nA3C, SGD A3C, RMSProp A3C, Shared RMSProp\n10 20 30 40 50 Model Rank\n200\n400\n600\n800\n1000\n1200\n1400\n1600\n1800\nS co\nre\nSeaquest\nA3C, SGD A3C, RMSProp A3C, Shared RMSProp\n10 20 30 40 50 Model Rank\n0\n500\n1000\n1500\n2000\n2500\n3000\n3500\n4000\nS co\nre\nSpace Invaders\nA3C, SGD A3C, RMSProp A3C, Shared RMSProp\nFigure 8: Comparison of three different optimization methods (Momentum SGD, RMSProp, Shared RMSProp) tested using two different algorithms (Async n-step Q and Async Advantage Actor-Critic) on four different Atari games (Breakout, Beamrider, Seaquest and Space Invaders). Each curve shows the final scores for 50 experiments sorted in descending order that covers a search over 50 random initializations and learning rates. The top row shows results using Async n-step Q algorithm and bottom row shows results with Async Advantage Actor-Critic. Each individual graph shows results for one of the four games and three different optimization methods. Shared RMSProp tends to be more robust to different learning rates and random initializations than Momentum SGD and RMSProp without sharing.\nADADELTA [Zeiler, 2012], RMSProp [Tieleman and Hinton, 2012] and ADAM [Kingma and Ba, 2014], there is no consensus as to which method is the best. In Figure 8 we compare three different asynchronous optimization algorithms (Momentum SGD, RMSProp, Shared RMSProp) combined with two different reinforcement learning methods (Async n-step Q and Async Advantage Actor-Critic) on four different tasks (Breakout, Beamrider, Seaquest and Space Invaders). Each curve shows the scores for 50 experiments that correspond to 50 different random learning rates and initializations. The x-axis shows the rank of the model after sorting in descending order by final average score and the y-axis shows the final average score achieved by the corresponding model. In this representation, the algorithm that performs better would achieve higher maximum rewards on the y-axis and the algorithm that is most robust would have its slope closest to horizontal, thus maximizing the area under the curve. RMSProp with shared statistics tends to be more robust than\nRMSProp with per-thread statistics, which is in turn more robust than Momentum SGD.\nNext, we look at the stability and robustness of the asynchronous algorithms. We trained models on five games (Breakout, Beamrider, Pong, Q*bert, Space Invaders) using four different algorithms (one-step Q, one-step Sarsa, n-step Q and Advantage Actor-Critic) using 50 different learning rates and random initializations. Scatter plots of scores are shown for all algorithms and tasks in Figure 10. There is usually a range of learning rates for each method and game combination that leads to a high score, indicating that all methods are quite robust to the choice of learning rate. The fact that there are virtually no points with scores of 0 in regions with good learning rates indicates that the methods are stable and do not collapse or diverge once they are learning. Similarly, in Figure 9 we show scatter plots of scores obtained by training Advantage Actor-Critic for 50 combinations of random initialization, learning rate and entropy cost on four games. These results show that using entropy regularization with advantage actor-critic does lead to better scores on some games."}, {"heading": "6 Conclusions and Discussion", "text": "We have presented asynchronous versions of four standard reinforcement learning algorithms and showed that they are able to train neural network controllers on a variety of domains in a stable manner. Our results show that in our proposed framework stable training of neural networks through reinforcement learning is possible with both value-based and policy-based methods, off-policy as well as on-policy methods, and in discrete as well as continuous domains. When trained on the Atari domain using 16 CPU cores, the proposed asynchronous algorithms train faster than DQN trained on an Nvidia K40 GPU, with A3C surpassing the current state-of-the-art in half the training time.\nOne of our main findings is that using parallel actor-learners to update a shared model had a stabilizing effect on the learning process of the three value-based methods we considered. While this shows that stable online Q-learning is possible without experience replay, which was used for this purpose in DQN, it does not mean that experience replay is not\n10-4 10-3 10-2\nLearning rate\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\n1-step Q, Beamrider\n10-4 10-3 10-2\nLearning rate\n50\n0\n50\n100\n150\n200\n250\n300\n350\n400\nS co\nre\n1-step Q, Breakout\n10-4 10-3 10-2\nLearning rate\n30\n20\n10\n0\n10\n20\n30\nS co\nre\n1-step Q, Pong\n10-4 10-3 10-2\nLearning rate\n1000\n0\n1000\n2000\n3000\n4000\n5000\nS co\nre\n1-step Q, Q*bert\n10-4 10-3 10-2\nLearning rate\n100\n200\n300\n400\n500\n600\n700\n800\nS co\nre\n1-step Q, Space Invaders\n10-4 10-3 10-2\nLearning rate\n2000\n0\n2000\n4000\n6000\n8000\n10000\n12000\n14000\nS co\nre\n1-step SARSA, Beamrider\n10-4 10-3 10-2\nLearning rate\n50\n0\n50\n100\n150\n200\n250\n300\n350\n400\nS co\nre\n1-step SARSA, Breakout\n10-4 10-3 10-2\nLearning rate\n25\n20\n15\n10\n5\n0\n5\n10\n15\n20\nS co\nre\n1-step SARSA, Pong\n10-4 10-3 10-2\nLearning rate\n1000\n0\n1000\n2000\n3000\n4000\n5000\nS co\nre\n1-step SARSA, Q*bert\n10-4 10-3 10-2\nLearning rate\n100\n200\n300\n400\n500\n600\n700\n800\n900\nS co\nre\n1-step SARSA, Space Invaders\n10-4 10-3 10-2\nLearning rate\n2000\n0\n2000\n4000\n6000\n8000\n10000\n12000\n14000\n16000\nS co\nre\nn-step Q, Beamrider\n10-4 10-3 10-2\nLearning rate\n50\n0\n50\n100\n150\n200\n250\n300\n350\n400\nS co\nre\nn-step Q, Breakout\n10-4 10-3 10-2\nLearning rate\n30\n20\n10\n0\n10\n20\n30\nS co\nre\nn-step Q, Pong\n10-4 10-3 10-2\nLearning rate\n1000\n0\n1000\n2000\n3000\n4000\n5000\nS co\nre\nn-step Q, Q*bert\n10-4 10-3 10-2\nLearning rate\n300\n400\n500\n600\n700\n800\n900\n1000\nS co\nre\nn-step Q, Space Invaders\n10-4 10-3 10-2\nLearning rate\n2000\n0\n2000\n4000\n6000\n8000\n10000\n12000\n14000\n16000\nS co\nre\nA3C, Beamrider\n10-4 10-3 10-2\nLearning rate\n200\n0\n200\n400\n600\n800\n1000\nS co\nre\nA3C, Breakout\n10-4 10-3 10-2\nLearning rate\n30\n20\n10\n0\n10\n20\n30\nS co\nre\nA3C, Pong\n10-4 10-3 10-2\nLearning rate\n2000\n0\n2000\n4000\n6000\n8000\n10000\n12000\nS co\nre\nA3C, Q*bert\n10-4 10-3 10-2\nLearning rate\n0\n200\n400\n600\n800\n1000\n1200\n1400\nS co\nre\nA3C, Space Invaders\nFigure 10: Scatter plots of scores obtained by four different algorithms (one-step Q, onestep Sarsa, n-step Q and Advantage Actor-Critic) on five games (Beamrider, Breakout, Pong, Q*bert, Space Invaders) for 50 different learning rates and random initializations. All algorithms exhibit some level of robustness to the choice of learning rate.\nuseful. Incorporating experience replay into the asynchronous reinforcement learning framework could substantially improve the data efficiency of these methods by reusing old data. This could in turn lead to much faster training times in domains like TORCS where interacting with the environment is more expensive than updating the model for the architecture we used.\nCombining other existing reinforcement learning methods or recent advances in deep reinforcement learning with our asynchronous framework presents many possibilities for immediate improvements to the methods we presented. While our n-step methods operate\nin the forward view [Sutton and Barto, 1998] by using corrected n-step returns directly as targets, it has been more common to use the backward view to implicitly combine different returns through eligibility traces [Watkins, 1989, Sutton and Barto, 1998, Peng and Williams, 1996]. The asynchronous advantage actor-critic method could be potentially improved by using other ways of estimating the advantage function, such as generalized advantage estimation of Schulman et al. [2015b]. All of the value-based methods we investigated could benefit from different ways of reducing over-estimation bias of Q-values [Van Hasselt et al., 2015, Bellemare et al., 2016]. Yet another, more speculative, direction is to try and combine the recent work on true online temporal difference methods [van Seijen et al., 2015] with nonlinear function approximation.\nIn addition to these algorithmic improvements, a number of complementary improvements to the neural network architecture are possible. The dueling architecture of Wang et al. [2015] has been shown to produce more accurate estimates of Q-values by including separate streams for the state value and advantage in the network. The spatial softmax proposed by Levine et al. [2015] could improve both value-based and policy-based methods by making it easier for the network to represent feature coordinates."}, {"heading": "Acknowledgments", "text": "We thank Thomas Degris, Remi Munos, Marc Lanctot, Sasha Vezhnevets and Joseph Modayil for many helpful discussions, suggestions and comments on the paper. We also thank the DeepMind evaluation team for setting up the environments used to evaluate the agents in the paper."}], "references": [{"title": "The arcade learning environment: An evaluation platform for general agents", "author": ["Marc G Bellemare", "Yavar Naddaf", "Joel Veness", "Michael Bowling"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Bellemare et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bellemare et al\\.", "year": 2012}, {"title": "Increasing the action gap: New operators for reinforcement learning", "author": ["Marc G. Bellemare", "Georg Ostrovski", "Arthur Guez", "Philip S. Thomas", "R\u00e9mi Munos"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence,", "citeRegEx": "Bellemare et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bellemare et al\\.", "year": 2016}, {"title": "Distributed dynamic programming", "author": ["Dimitri P Bertsekas"], "venue": "Automatic Control, IEEE Transactions on,", "citeRegEx": "Bertsekas.,? \\Q1982\\E", "shortCiteRegEx": "Bertsekas.", "year": 1982}, {"title": "Distributed deep q-learning", "author": ["Kevin Chavez", "Hao Yi Ong", "Augustus Hong"], "venue": "Technical report,", "citeRegEx": "Chavez et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Chavez et al\\.", "year": 2015}, {"title": "Model-free reinforcement learning with continuous action in practice", "author": ["Thomas Degris", "Patrick M Pilarski", "Richard S Sutton"], "venue": "In American Control Conference (ACC),", "citeRegEx": "Degris et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Degris et al\\.", "year": 2012}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["John Duchi", "Elad Hazan", "Yoram Singer"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Duchi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2011}, {"title": "Parallel reinforcement learning with linear function approximation. In Proceedings of the 5th, 6th and 7th European Conference on Adaptive and Learning Agents and Multi-agent Systems: Adaptation and Multi-agent Learning, pages 60\u201374", "author": ["Matthew Grounds", "Daniel Kudenko"], "venue": null, "citeRegEx": "Grounds and Kudenko.,? \\Q2008\\E", "shortCiteRegEx": "Grounds and Kudenko.", "year": 2008}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "J\u00fcrgen Schmidhuber"], "venue": "Neural computation,", "citeRegEx": "Hochreiter and Schmidhuber.,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter and Schmidhuber.", "year": 1997}, {"title": "On the convergence of stochastic iterative dynamic programming algorithms", "author": ["Tommi Jaakkola", "Michael I Jordan", "Satinder P Singh"], "venue": "Neural computation,", "citeRegEx": "Jaakkola et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Jaakkola et al\\.", "year": 1994}, {"title": "Adam: A method for stochastic optimization", "author": ["Diederik Kingma", "Jimmy Ba"], "venue": "arXiv preprint arXiv:1412.6980,", "citeRegEx": "Kingma and Ba.,? \\Q2014\\E", "shortCiteRegEx": "Kingma and Ba.", "year": 2014}, {"title": "Evolving deep unsupervised convolutional networks for vision-based reinforcement learning", "author": ["Jan Kout\u0144\u0131k", "J\u00fcrgen Schmidhuber", "Faustino Gomez"], "venue": "In Proceedings of the 2014 conference on Genetic and evolutionary computation,", "citeRegEx": "Kout\u0144\u0131k et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kout\u0144\u0131k et al\\.", "year": 2014}, {"title": "End-to-end training of deep visuomotor policies", "author": ["Sergey Levine", "Chelsea Finn", "Trevor Darrell", "Pieter Abbeel"], "venue": "arXiv preprint arXiv:1504.00702,", "citeRegEx": "Levine et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Levine et al\\.", "year": 2015}, {"title": "Mapreduce for parallel reinforcement learning", "author": ["Yuxi Li", "Dale Schuurmans"], "venue": "EWRL", "citeRegEx": "Li and Schuurmans.,? \\Q2011\\E", "shortCiteRegEx": "Li and Schuurmans.", "year": 2011}, {"title": "Continuous control with deep reinforcement learning", "author": ["Timothy P Lillicrap", "Jonathan J Hunt", "Alexander Pritzel", "Nicolas Heess", "Tom Erez", "Yuval Tassa", "David Silver", "Daan Wierstra"], "venue": "arXiv preprint arXiv:1509.02971,", "citeRegEx": "Lillicrap et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lillicrap et al\\.", "year": 2015}, {"title": "Reinforcement learning for robots using neural networks", "author": ["Long-Ji Lin"], "venue": "Technical report, DTIC Document,", "citeRegEx": "Lin.,? \\Q1993\\E", "shortCiteRegEx": "Lin.", "year": 1993}, {"title": "Playing atari with deep reinforcement learning", "author": ["Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Alex Graves", "Ioannis Antonoglou", "Daan Wierstra", "Martin Riedmiller"], "venue": "In NIPS Deep Learning Workshop", "citeRegEx": "Mnih et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2013}, {"title": "Human-level control through deep reinforcement learning", "author": ["Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Andrei A. Rusu", "Joel Veness", "Marc G. Bellemare", "Alex Graves", "Martin Riedmiller", "Andreas K. Fidjeland", "Georg Ostrovski", "Stig Petersen", "Charles Beattie", "Amir Sadik", "Ioannis Antonoglou", "Helen King", "Dharshan Kumaran", "Daan Wierstra", "Shane Legg", "Demis Hassabis"], "venue": "Nature, 518(7540):529\u2013533,", "citeRegEx": "Mnih et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2015}, {"title": "Massively parallel methods for deep reinforcement learning", "author": ["Arun Nair", "Praveen Srinivasan", "Sam Blackwell", "Cagdas Alcicek", "Rory Fearon", "Alessandro De Maria", "Vedavyas Panneershelvam", "Mustafa Suleyman", "Charles Beattie", "Stig Petersen", "Shane Legg", "Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver"], "venue": "In ICML Deep Learning Workshop", "citeRegEx": "Nair et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2015}, {"title": "Incremental multi-step q-learning", "author": ["Jing Peng", "Ronald J Williams"], "venue": "Machine Learning,", "citeRegEx": "Peng and Williams.,? \\Q1996\\E", "shortCiteRegEx": "Peng and Williams.", "year": 1996}, {"title": "Hogwild: A lock-free approach to parallelizing stochastic gradient descent", "author": ["Benjamin Recht", "Christopher Re", "Stephen Wright", "Feng Niu"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Recht et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Recht et al\\.", "year": 2011}, {"title": "Neural fitted q iteration\u2013first experiences with a data efficient neural reinforcement learning method", "author": ["Martin Riedmiller"], "venue": "In Machine Learning: ECML", "citeRegEx": "Riedmiller.,? \\Q2005\\E", "shortCiteRegEx": "Riedmiller.", "year": 2005}, {"title": "On-line q-learning using connectionist systems", "author": ["Gavin A Rummery", "Mahesan Niranjan"], "venue": null, "citeRegEx": "Rummery and Niranjan.,? \\Q1994\\E", "shortCiteRegEx": "Rummery and Niranjan.", "year": 1994}, {"title": "Prioritized experience replay", "author": ["Tom Schaul", "John Quan", "Ioannis Antonoglou", "David Silver"], "venue": "arXiv preprint arXiv:1511.05952,", "citeRegEx": "Schaul et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Schaul et al\\.", "year": 2015}, {"title": "Trust region policy optimization", "author": ["John Schulman", "Sergey Levine", "Philipp Moritz", "Michael I Jordan", "Pieter Abbeel"], "venue": "In International Conference on Machine Learning (ICML),", "citeRegEx": "Schulman et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Schulman et al\\.", "year": 2015}, {"title": "Highdimensional continuous control using generalized advantage estimation", "author": ["John Schulman", "Philipp Moritz", "Sergey Levine", "Michael Jordan", "Pieter Abbeel"], "venue": "arXiv preprint arXiv:1506.02438,", "citeRegEx": "Schulman et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Schulman et al\\.", "year": 2015}, {"title": "Convergence results for single-step on-policy reinforcement-learning algorithms", "author": ["Satinder Singh", "Tommi Jaakkola", "Michael L Littman", "Csaba Szepesv\u00e1ri"], "venue": "Machine Learning,", "citeRegEx": "Singh et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Singh et al\\.", "year": 2000}, {"title": "Reinforcement Learning: an Introduction", "author": ["R. Sutton", "A. Barto"], "venue": null, "citeRegEx": "Sutton and Barto.,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto.", "year": 1998}, {"title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude", "author": ["Tijmen Tieleman", "Geoffrey Hinton"], "venue": "COURSERA: Neural Networks for Machine Learning,", "citeRegEx": "Tieleman and Hinton.,? \\Q2012\\E", "shortCiteRegEx": "Tieleman and Hinton.", "year": 2012}, {"title": "MuJoCo: Modeling, Simulation and Visualization of Multi-Joint Dynamics with Contact (ed 1.0)", "author": ["E Todorov"], "venue": "Roboti Publishing,", "citeRegEx": "Todorov.,? \\Q2015\\E", "shortCiteRegEx": "Todorov.", "year": 2015}, {"title": "Parallel and distributed evolutionary algorithms: A review", "author": ["Marco Tomassini"], "venue": "Technical report,", "citeRegEx": "Tomassini.,? \\Q1999\\E", "shortCiteRegEx": "Tomassini.", "year": 1999}, {"title": "An analysis of temporal-difference learning with function approximation", "author": ["J. Tsitsiklis", "B. Van Roy"], "venue": "IEEE Transactions on Automatic Control,", "citeRegEx": "Tsitsiklis and Roy.,? \\Q1997\\E", "shortCiteRegEx": "Tsitsiklis and Roy.", "year": 1997}, {"title": "Asynchronous stochastic approximation and q-learning", "author": ["John N Tsitsiklis"], "venue": "Machine Learning,", "citeRegEx": "Tsitsiklis.,? \\Q1994\\E", "shortCiteRegEx": "Tsitsiklis.", "year": 1994}, {"title": "Deep reinforcement learning with double q-learning", "author": ["Hado Van Hasselt", "Arthur Guez", "David Silver"], "venue": "arXiv preprint arXiv:1509.06461,", "citeRegEx": "Hasselt et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Hasselt et al\\.", "year": 2015}, {"title": "True Online Temporal-Difference Learning", "author": ["H. van Seijen", "A. Rupam Mahmood", "P.M. Pilarski", "M.C. Machado", "R.S. Sutton"], "venue": null, "citeRegEx": "Seijen et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Seijen et al\\.", "year": 2015}, {"title": "Dueling Network Architectures for Deep Reinforcement Learning", "author": ["Z. Wang", "N. de Freitas", "M. Lanctot"], "venue": "ArXiv e-prints,", "citeRegEx": "Wang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2015}, {"title": "Learning from delayed rewards", "author": [], "venue": "PhD thesis,", "citeRegEx": "Watkins.,? \\Q1989\\E", "shortCiteRegEx": "Watkins.", "year": 1989}, {"title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "author": ["R.J. Williams"], "venue": "Machine Learning,", "citeRegEx": "Williams.,? \\Q1992\\E", "shortCiteRegEx": "Williams.", "year": 1992}, {"title": "Function optimization using connectionist reinforcement learning algorithms", "author": ["Ronald J Williams", "Jing Peng"], "venue": "Connection Science,", "citeRegEx": "Williams and Peng.,? \\Q1991\\E", "shortCiteRegEx": "Williams and Peng.", "year": 1991}, {"title": "Adadelta: An adaptive learning rate method", "author": ["Matthew D Zeiler"], "venue": "arXiv preprint arXiv:1212.5701,", "citeRegEx": "Zeiler.,? \\Q2012\\E", "shortCiteRegEx": "Zeiler.", "year": 2012}], "referenceMentions": [{"referenceID": 17, "context": ", 2015] or massively distributed architectures [Nair et al., 2015], our experiments run on a single machine with a standard multi-core CPU.", "startOffset": 47, "endOffset": 66}, {"referenceID": 16, "context": "In Gorila, each process contains an actor that acts in its own copy of the environment, a separate replay memory, and a learner that samples data from the replay memory and computes gradients of the DQN loss [Mnih et al., 2015] with respect to the policy parameters.", "startOffset": 208, "endOffset": 227}, {"referenceID": 12, "context": "The General Reinforcement Learning Architecture (Gorila) of Nair et al. [2015] performs asynchronous training of reinforcement learning agents in a distributed setting.", "startOffset": 60, "endOffset": 79}, {"referenceID": 3, "context": "We also note that a similar way of parallelizing DQN was proposed by Chavez et al. [2015]. In earlier work, Li and Schuurmans [2011] applied the Map Reduce framework to parallelizing batch reinforcement learning methods with linear function approximation.", "startOffset": 69, "endOffset": 90}, {"referenceID": 3, "context": "We also note that a similar way of parallelizing DQN was proposed by Chavez et al. [2015]. In earlier work, Li and Schuurmans [2011] applied the Map Reduce framework to parallelizing batch reinforcement learning methods with linear function approximation.", "startOffset": 69, "endOffset": 133}, {"referenceID": 3, "context": "We also note that a similar way of parallelizing DQN was proposed by Chavez et al. [2015]. In earlier work, Li and Schuurmans [2011] applied the Map Reduce framework to parallelizing batch reinforcement learning methods with linear function approximation. Parallelism was used to speed up large matrix operations but not to parallelize the collection of experience or stabilize learning. Grounds and Kudenko [2008] proposed a parallel version of the Sarsa algorithm that uses multiple separate actor-learners to accelerate training.", "startOffset": 69, "endOffset": 415}, {"referenceID": 29, "context": "Another related area of work is in evolutionary methods, which are often straightforward to parallelize by distributing fitness evaluations over multiple machines or threads [Tomassini, 1999].", "startOffset": 174, "endOffset": 191}, {"referenceID": 2, "context": "Even earlier, Bertsekas [1982] studied the related problem of distributed dynamic programming.", "startOffset": 14, "endOffset": 31}, {"referenceID": 2, "context": "Even earlier, Bertsekas [1982] studied the related problem of distributed dynamic programming. Another related area of work is in evolutionary methods, which are often straightforward to parallelize by distributing fitness evaluations over multiple machines or threads [Tomassini, 1999]. Such parallel evolutionary approaches have recently been applied to some visual reinforcement learning tasks. In one example, Kout\u0144\u0131k et al. [2014] evolved convolutional neural network controllers for the TORCS driving simulator by performing fitness evaluations on 8 CPU cores in parallel.", "startOffset": 14, "endOffset": 436}, {"referenceID": 36, "context": "It is possible to reduce the variance of this estimate while keeping it unbiased by subtracting a learned function of the state bt(st), known as a baseline [Williams, 1992], from the return \u2207\u03b8 log \u03c0(at|st; \u03b8) (Rt \u2212 bt(st)) .", "startOffset": 156, "endOffset": 172}, {"referenceID": 36, "context": "One example of such a method is the REINFORCE family of algorithms due to Williams [1992]. Standard REINFORCE updates the policy parameters \u03b8 in the direction \u2207\u03b8 log \u03c0(at|st; \u03b8)Rt, which is an unbiased estimate of \u2207\u03b8E[Rt].", "startOffset": 74, "endOffset": 90}, {"referenceID": 30, "context": "Temporal difference learning methods, such as Q-learning, have been known to diverge when used with nonlinear function approximators [Tsitsiklis and Roy, 1997].", "startOffset": 133, "endOffset": 159}, {"referenceID": 16, "context": "The recently introduced variant of Q-learning for training Deep Q Networks [Mnih et al., 2015] made use of two techniques for avoiding such divergences in practice.", "startOffset": 75, "endOffset": 94}, {"referenceID": 14, "context": "First, an experience replay memory mechanism due to Lin [1993] was used to perform Q-learning updates on random samples of past experience instead on the most recent samples of experience.", "startOffset": 52, "endOffset": 63}, {"referenceID": 17, "context": "First, we use asynchronous actor-learners as proposed in the Gorila framework [Nair et al., 2015], but instead of using separate machines and a parameter server, we use multiple threads on a single machine.", "startOffset": 78, "endOffset": 97}, {"referenceID": 19, "context": "Keeping the learners on a single machine removes the communication costs incurred by sending gradients and parameters and enables us to use Hogwild! [Recht et al., 2011] style updates for training the controllers.", "startOffset": 149, "endOffset": 169}, {"referenceID": 26, "context": "where a\u2032 is the action taken in state s\u2032 [Sutton and Barto, 1998].", "startOffset": 41, "endOffset": 65}, {"referenceID": 26, "context": "The algorithm is somewhat unusual because it operates in the forward view by explicitly computing n-step returns, as opposed to the more common backward view used by techniques like eligibility traces [Sutton and Barto, 1998].", "startOffset": 201, "endOffset": 225}, {"referenceID": 37, "context": "This technique was originally proposed by [Williams and Peng, 1991], who found that it was particularly helpful on tasks requiring hierarchical behavior.", "startOffset": 42, "endOffset": 67}, {"referenceID": 19, "context": "Momentum SGD: The implementation of SGD in an asynchronous setting is relatively straightforward and well studied [Recht et al., 2011].", "startOffset": 114, "endOffset": 134}, {"referenceID": 27, "context": "RMSProp: While RMSProp [Tieleman and Hinton, 2012] has been widely used in the deep learning literature, it has not been extensively studied in the asynchronous optimization setting.", "startOffset": 23, "endOffset": 50}, {"referenceID": 0, "context": "First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games.", "startOffset": 39, "endOffset": 63}, {"referenceID": 28, "context": "The third environment we use to report results is the MuJoCo [Todorov, 2015] physics simulator for evaluating agents on continuous motor control tasks with contact dynamics.", "startOffset": 61, "endOffset": 76}, {"referenceID": 0, "context": "First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games. This is one of the most commonly used benchmark environments for RL algorithms. We compare against state of the art results on this environment as reported by Van Hasselt et al. [2015], Wang et al.", "startOffset": 40, "endOffset": 297}, {"referenceID": 0, "context": "First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games. This is one of the most commonly used benchmark environments for RL algorithms. We compare against state of the art results on this environment as reported by Van Hasselt et al. [2015], Wang et al. [2015], Schaul et al.", "startOffset": 40, "endOffset": 317}, {"referenceID": 0, "context": "First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games. This is one of the most commonly used benchmark environments for RL algorithms. We compare against state of the art results on this environment as reported by Van Hasselt et al. [2015], Wang et al. [2015], Schaul et al. [2015], Nair et al.", "startOffset": 40, "endOffset": 339}, {"referenceID": 0, "context": "First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games. This is one of the most commonly used benchmark environments for RL algorithms. We compare against state of the art results on this environment as reported by Van Hasselt et al. [2015], Wang et al. [2015], Schaul et al. [2015], Nair et al. [2015] and Mnih et al.", "startOffset": 40, "endOffset": 359}, {"referenceID": 0, "context": "First, the Arcade Learning Environment [Bellemare et al., 2012] that provides a simulator for Atari 2600 games. This is one of the most commonly used benchmark environments for RL algorithms. We compare against state of the art results on this environment as reported by Van Hasselt et al. [2015], Wang et al. [2015], Schaul et al. [2015], Nair et al. [2015] and Mnih et al. [2015]. The second environment we use is the TORCS car racing simulator [Wymann et al.", "startOffset": 40, "endOffset": 382}, {"referenceID": 15, "context": "The Atari experiments used the same input preprocessing as Mnih et al. [2015] and an action repeat of 4.", "startOffset": 59, "endOffset": 78}, {"referenceID": 15, "context": "The Atari experiments used the same input preprocessing as Mnih et al. [2015] and an action repeat of 4. The agents used the network architecture from Mnih et al. [2013]. The network used a convolutional layer with 16 filters of size 8 \u00d7 8 with stride 4, followed by a convolutional layer with with 32 filters of size 4 \u00d7 4 with stride 2, followed by a fully connected layer with 256 hidden units.", "startOffset": 59, "endOffset": 170}, {"referenceID": 32, "context": "In order to compare with the state of the art in Atari game playing, we largely followed the training and evaluation protocol of Van Hasselt et al. [2015]. Specifically, we tuned hyperparameters", "startOffset": 133, "endOffset": 155}, {"referenceID": 17, "context": "Method Training Time Mean Median DQN (from [Nair et al., 2015]) 8 days on GPU 121.", "startOffset": 43, "endOffset": 62}, {"referenceID": 17, "context": "5% Gorila [Nair et al., 2015] 4 days, 100 machines 215.", "startOffset": 10, "endOffset": 29}, {"referenceID": 34, "context": "9% Dueling Double DQN [Wang et al., 2015] 8 days on GPU 343.", "startOffset": 22, "endOffset": 41}, {"referenceID": 22, "context": "1% Prioritized DQN [Schaul et al., 2015] 8 days on GPU 463.", "startOffset": 19, "endOffset": 40}, {"referenceID": 7, "context": ", 2015] as well as a recurrent agent with an additional 256 LSTM [Hochreiter and Schmidhuber, 1997] cells after the final hidden layer.", "startOffset": 65, "endOffset": 99}, {"referenceID": 34, "context": ", 2015] and Dueling Double DQN [Wang et al., 2015] can be incorporated to 1-step Q and n-step Q methods presented in this work with similar potential improvements.", "startOffset": 31, "endOffset": 50}, {"referenceID": 0, "context": "We additionally used the final network weights for evaluation to make the results more comparable to the original results from Bellemare et al. [2012]. We trained our agents for four days using 16 CPU cores, while the other agents were trained for 8 to 10 days on Nvidia K40 GPUs.", "startOffset": 127, "endOffset": 151}, {"referenceID": 13, "context": "the physics models and task objectives) are near identical to the tasks examined in [Lillicrap et al., 2015].", "startOffset": 84, "endOffset": 108}, {"referenceID": 5, "context": "Although there are many extensions such as ADAGRAD [Duchi et al., 2011],", "startOffset": 51, "endOffset": 71}, {"referenceID": 38, "context": "ADADELTA [Zeiler, 2012], RMSProp [Tieleman and Hinton, 2012] and ADAM [Kingma and Ba, 2014], there is no consensus as to which method is the best.", "startOffset": 9, "endOffset": 23}, {"referenceID": 27, "context": "ADADELTA [Zeiler, 2012], RMSProp [Tieleman and Hinton, 2012] and ADAM [Kingma and Ba, 2014], there is no consensus as to which method is the best.", "startOffset": 33, "endOffset": 60}, {"referenceID": 9, "context": "ADADELTA [Zeiler, 2012], RMSProp [Tieleman and Hinton, 2012] and ADAM [Kingma and Ba, 2014], there is no consensus as to which method is the best.", "startOffset": 70, "endOffset": 91}, {"referenceID": 26, "context": "in the forward view [Sutton and Barto, 1998] by using corrected n-step returns directly as targets, it has been more common to use the backward view to implicitly combine different returns through eligibility traces [Watkins, 1989, Sutton and Barto, 1998, Peng and Williams, 1996].", "startOffset": 20, "endOffset": 44}, {"referenceID": 15, "context": "in the forward view [Sutton and Barto, 1998] by using corrected n-step returns directly as targets, it has been more common to use the backward view to implicitly combine different returns through eligibility traces [Watkins, 1989, Sutton and Barto, 1998, Peng and Williams, 1996]. The asynchronous advantage actor-critic method could be potentially improved by using other ways of estimating the advantage function, such as generalized advantage estimation of Schulman et al. [2015b]. All of the value-based methods we investigated could benefit from different ways of reducing over-estimation bias of Q-values [Van Hasselt et al.", "startOffset": 256, "endOffset": 485}, {"referenceID": 0, "context": ", 2015, Bellemare et al., 2016]. Yet another, more speculative, direction is to try and combine the recent work on true online temporal difference methods [van Seijen et al., 2015] with nonlinear function approximation. In addition to these algorithmic improvements, a number of complementary improvements to the neural network architecture are possible. The dueling architecture of Wang et al. [2015] has been shown to produce more accurate estimates of Q-values by including separate streams for the state value and advantage in the network.", "startOffset": 8, "endOffset": 402}, {"referenceID": 0, "context": ", 2015, Bellemare et al., 2016]. Yet another, more speculative, direction is to try and combine the recent work on true online temporal difference methods [van Seijen et al., 2015] with nonlinear function approximation. In addition to these algorithmic improvements, a number of complementary improvements to the neural network architecture are possible. The dueling architecture of Wang et al. [2015] has been shown to produce more accurate estimates of Q-values by including separate streams for the state value and advantage in the network. The spatial softmax proposed by Levine et al. [2015] could improve both value-based and policy-based methods by making it easier for the network to represent feature coordinates.", "startOffset": 8, "endOffset": 597}, {"referenceID": 17, "context": "DQN scores taken from Nair et al. [2015]. Double DQN scores taken from Van Hasselt et al.", "startOffset": 22, "endOffset": 41}, {"referenceID": 17, "context": "DQN scores taken from Nair et al. [2015]. Double DQN scores taken from Van Hasselt et al. [2015], Dueling scores from Wang et al.", "startOffset": 22, "endOffset": 97}, {"referenceID": 17, "context": "DQN scores taken from Nair et al. [2015]. Double DQN scores taken from Van Hasselt et al. [2015], Dueling scores from Wang et al. [2015] and Prioritized scores taken from Schaul et al.", "startOffset": 22, "endOffset": 137}, {"referenceID": 17, "context": "DQN scores taken from Nair et al. [2015]. Double DQN scores taken from Van Hasselt et al. [2015], Dueling scores from Wang et al. [2015] and Prioritized scores taken from Schaul et al. [2015]", "startOffset": 22, "endOffset": 192}], "year": 2016, "abstractText": "We propose a conceptually simple and lightweight framework for deep reinforcement learning that uses asynchronous gradient descent for optimization of deep neural network controllers. We present asynchronous variants of four standard reinforcement learning algorithms and show that parallel actor-learners have a stabilizing effect on training allowing all four methods to successfully train neural network controllers. The best performing method, an asynchronous variant of actor-critic, surpasses the current state-of-the-art on the Atari domain while training for half the time on a single multi-core CPU instead of a GPU. Furthermore, we show that asynchronous actor-critic succeeds on a wide variety of continuous motor control problems as well as on a new task involving finding rewards in random 3D mazes using a visual input.", "creator": "LaTeX with hyperref package"}}}