{"id": "1602.02706", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Feb-2016", "title": "Decoy Bandits Dueling on a Poset", "abstract": "We adress the extent of dueling bandits dimensions with enlarged ordered open, . posets. In this rather, arms may wanted they comparable, all almost soon sure later (unsurpassed) efficiency cutting. We consider response solver, UnchainedBandits, nothing efficiently finds the set an optimal brought it considering nullary hard when pairs though comparable secret impossible nothing all-district been pairs fact fearlessness armed, with given putting well minimal contrary. This algorithm product tuesday the concept of heat-seeking, which roots to environment psychology. For the difficult finding for the incomparability according decided why accessible, 'll provisions without second algorithm, SlicingBandits, which takes leads major instance information however incredible on very significant gain part performance comparison to UnchainedBandits. We facilities perspective guarantees two technique evaluation that rather non-standard.", "histories": [["v1", "Mon, 8 Feb 2016 19:32:18 GMT  (276kb,D)", "https://arxiv.org/abs/1602.02706v1", null], ["v2", "Thu, 9 Jun 2016 06:57:28 GMT  (581kb,D)", "http://arxiv.org/abs/1602.02706v2", null]], "reviews": [], "SUBJECTS": "cs.LG cs.AI", "authors": ["julien audiffren", "ralaivola liva"], "accepted": false, "id": "1602.02706"}, "pdf": {"name": "1602.02706.pdf", "metadata": {"source": "CRF", "title": "Decoy Bandits Dueling on a Poset", "authors": ["Julien Audiffren", "Liva Ralaivola"], "emails": ["audiffren@cmla.ens-cachan.fr", "liva.ralaivola@lif.univ-mrs.fr"], "sections": [{"heading": "1 Introduction", "text": "Chasing the optimal set for cold-start recommendation. Today\u2019s recommendation systems heavily rely on machine learning. Dedicated techniques may indeed be designed to extract statistical regularities from a set of collected behaviors and provide users with relevant recommendations. One of the main challenges a recommendation system has to deal with is cold-start, i.e. the situation where recommendations must be computed for a user for whom no information has been collected. A common strategy to get around this problem is to have at hand a set of default items to recommend to any new customer. The design of such a set is then paramount to the user experience with the recommendation system and to his willingness to rely on it for future movie suggestions. A natural goal is therefore to try to form a set of best movies. Identifying the best movies is a task that requires a proper handling of two features: a) the variety of existing film genres (documentary, drama, comedy. . . ) and b) the uncertainty with which one film may be considered better than another. The variety of genres induces the issue of incomparability: there are pairs of movies \u2014comparison of pairs is evidently at the core of the best movie selection process\u2014 that cannot be compared such as, e.g., a documentary and a horror movie. This means that movies are only partially ordered and it suggests that the set of best movies must contain incomparable movies. Said otherwise, each movie from the set is the best in its category. The uncertainty issue mentioned above then arises within a single genre as it might be complex to assert that a film is better than another. A way to bypass this difficulty is to rely on a committee of critics and to aggregate the (noisy) opinions of its members on pairs of comparable movies. This might be implemented as follows: for each pair of films, committee members are chosen at random and asked which of the two movies is the better, and the movie that wins the most among the random probes is decided to be the best. This introduction provides a practical motivation for the present paper where we study the question of deriving strategies for dueling bandits defined on partially ordered sets, or posets. We are in particular interested in being able to find the set of best arms among all the (possibly incomparable) arms at hand.\nDueling Bandits on Posets. Dueling bandits were introduced by Yue et al. [2012]. The setting, pertaining to the K-armed bandit framework, assumes there is no direct access to the reward provided\nar X\niv :1\n60 2.\n02 70\n6v 2\n[ cs\n.L G\n] 9\nJ un\n2 01\nby any single arm and the only information that can be gained is through the simultaneous pull of two arms: when such a pull is performed the agent gets access to the winner of the two arms, thus the name of dueling bandits. Here, we extend the framework of dueling bandits to the situation where there exist pairs of arms that are not comparable, that is, we study the case where there might be no natural order that could help decide the winner of a duel between two arms. A problem induced by such a framework is then to identify among the set of all available K arms the set of maximal incomparable arms, or the Pareto front, through a minimal number of pairwise pulls. To carry out our study, we propose to make use of tools from the theory of posets and we take inspiration from works dedicated to selection and sorting on posets Daskalakis et al. [2011].\nKeys: Indistinguishability and Decoys. We make the assumption that the underlying poset or, more precisely, the incomparability structure, is not known. A pivotal issue that we have to face in this case is that of indistinguishability. In the bandit setting we assume, the draw of two arms that are comparable and that have close values \u2014and hence a probability for either arm to win a duel close to 0.5\u2014 is essentially driven by the same random process, i.e. an unbiased coin flip, as the draw of two arms that are not comparable. Hence, if we denote by \u03b5 the distances between those two processes, we can have \u03b5 arbitrary small, and thus this pairs of arms cannot be distinguished from an incomparable pair of arm on the sole basis of pulls and a well-thought strategy. Such pair of arm will be referred as \u03b5-indistinguishable. This problem has led us to make use of decoy arms. The idea of decoy originates from social psychology, and was originally intended to \u2019force\u2019 an agent (e.g., a customer) towards a specific good/action (e.g. a product) by presenting her a choice between the targetted good and a degraded version of it. Here, we use decoys to help solve the problem of indistinguishability\nContributions. Our main contribution, the UnchainedBandits algorithm, implements a strategy based on decoys and a peeling approach that finds the Pareto front1 of a poset S with probability at least 1\u2212\u03b4 after at most T \u2264 O ( K width(S)\u22062 log(NK 2/\u03b4) )\npairwise pulls, while incurring a regret upper bounded by\nR \u2264 2K \u03b32 log\n( 2NK2\n\u03b4 ) K\u2211 i=1 1 \u2206i C\u03b1,\u03b3(Ni) +Kwidth(S) log ( 2NK2 \u03b4 ) \u2211 i,\u2206i<\u03b5N\u22121,i/\u2208P 1 \u2206i ,\nwhere \u2206 is the parameter of the decoys, \u2206i the regret associated with arm i, K is the size of the poset, width(S) its width, N is the number of peeling iterations, \u03b3 is the peeling rate, \u03b5N\u22121 is the maximum peeling and C\u03b1,\u03b3(Ni) \u2264 1 defined in Section 3 encodes the complexity of the poset with respect to arm i.\nThe paper is organized as follows. Section 2 presents the setting of dueling bandits on posets and formally states the problem we address. In Section 3, we formally introduce the notion of decoys and show how they can be constructed, both mathematically and practically, we then present our algorithm, UnchainedBandits, which relies on decoys, to find the exact Pareto front of the poset and we provide theoretical guarantees on their performances. In Section 4, we discuss how the present work relates to recent papers from the dueling bandits literature. Section 5 reports results on the empirical performances of our algorithm in different settings."}, {"heading": "2 Problem Statement: Dueling Bandits on Posets", "text": ""}, {"heading": "2.1 Reminders on Posets", "text": "We here recall base notions and properties about posets that are relevant to the present contribution. Definition 2.1 (Poset). Let S be a set of elements. (S,<) is a partially ordered or poset if < is a reflexive, antisymmetric and transitive binary relation on S: \u2200a, b, c \u2208 S\n\u2022 a < a (reflexivity);\n\u2022 if a < b and b < a then a = b (antisymmetry); 1 We discuss in the supplementary material the easier setting where the incomparability information is known and we provide a dedicated algorithm, SlicingBandits, that takes advantage of this addiditional information.\n\u2022 if a < b and b < c then a < c (transitivity). Remark 2.2. In the following, we will use S to denote indifferently the set S or the poset (S,<), the distinction being clear from the context. We make use of the additional notation: \u2200a, b \u2208 S\n\u2022 a \u2016 b if a and b are incomparable (i.e. neither a < b nor b < a);\n\u2022 a b if a < b and a 6= b;\nThroughout, we limit our study to finite posets, i.e., posets such that |S| < +\u221e. Definition 2.3 (Maximal element and Pareto front). An element a \u2208 S is said to be a maximal element of S if \u2200b \u2208 S, a < b or a \u2016 b. We denote by\nP(S) .= {a : a < b or a \u2016 b,\u2200b \u2208 S},\nthe set of maximal elements or Pareto front of the poset.\nSince there is no intrinsic reason to favor a particular maximal element, throughout this work we chose to focus on the task of finding the entire Pareto front P(S) or P , for short. To this end, the notions of chain and antichain are key.\nDefinition 2.4 (Chain and antichain). C \u2282 S is a chain (resp. an antichain) if \u2200a, b \u2208 C, a < b or a < b (resp. a \u2016 b). C is said to be maximal if \u2200a \u2208 S \\ C, C \u2228 a is not a chain (resp. an antichain).\nNote that P is by definition a maximal antichain. Finally, the notion of width and height of a poset are important to characterize (the complexity of) a poset.\nDefinition 2.5 (Width and height). The width (resp. height) of a poset S is the size of its longest antichain (resp. chain)."}, {"heading": "2.2 Dueling Bandits on Posets", "text": "K-armed Dueling Bandit. The K-armed dueling bandit problem [Yue et al., 2012] assumes the existence of K2 parameters {\u03b3ij}1\u2264i,j\u2264K , with \u03b3ij \u2208 (\u22121/2, 1/2) and the following sampling procedure. At each time step, the agent pulls a pair of arms (i, j) and she gets in return the value of an independent realization of Bij , a Bernouilli random variable with expectation E(Bij) = 1/2 + \u03b3ij where Bij = 1 means that i is the winner of the duel between i and j and, conversely, Bij = 0 means that j is the winner. The objective of the agent is to find the Condorcet winner c\u2014the arm such that \u03b3cj > 0, \u2200j 6= c\u2014 among the K arms, whose existence is assumed, while minimizing the accumulated regret, defined for a sequence ((i1, j1), . . . , (iT , jT )) of T pairs of pulls by 1 2 \u2211T t=1(\u03b3cit + \u03b3cjt). Remark 2.6. Note that: \u2200i, j, Bji = 1\u2212Bij and, thus, \u03b3ji = \u2212\u03b3ij and \u03b3ii = 0.\nThe implicit assumption of traditional dueling bandits is that the set S = {1, . . . ,K} of arms is totally ordered: for any pair i, j \u2208 S of arms, i and j must be comparable and \u03b3ij unequivocally says which of the two is better.\nIssues induced by working on posets. Now consider a dueling bandit problem defined on a poset S. Compared to the usual setting where a total order on the arms exists, there are two main differences which arise when S is a poset: first, the situation where the agent pulls a pair of arms that are not comparable has to be handled with care and, second, there might be multiple maximal elements.\nWorking on bandits with a poset S = {1, . . . ,K} of arms might be formalized as follows. For all chains {i1, . . . , im} of m arms there exist a family {\u03b3ipiq}1\u2264p,q\u2264m of parameters such that \u03b3ij \u2208 (\u22121/2, 1/2); the pull of a pair of arms (ip, iq) from the same chain provides the realization of a Bernoulli random variable Bipiq with expectation E(Bipiq ) = 1/2 + \u03b3ipiq . Regarding the incomparability, i.e. the situation where the pair of arms (ip, iq) selected by the agent correspond to arms such that ip \u2016 iq , then there are two frameworks we propose to consider: one the one hand, the fully observable posets, where the draw from an incomparable pair of arms provides the agent with the information regarding the comparability of the arms2. On the other hand, that of partially\n2This easier setting is analysed in depth in the supplementary materials.\nobservable posets, where such a draw is modeled as the toss of an unbiased coin flip\u2014as we shall discuss, this framework poses the problem of indistinguishability mentioned in the introduction.\nRegret on posets. In order to extend the notion of regret associated to an arm i, \u2206i, in the poset setting, we use the notion of distance to the Pareto front, noted d(i,P) defined as follows :\n\u2206i = d(i,P) = min{\u03b3ij ,\u2200j \u2208 P such that j < i}.\nWe then define the regret occurred by comparing two arms i and j by d(i,P) + d(j,P). It is important to remark that the regret of a comparison is zero if and only if the agent is comparing two element of the Pareto front.\nProblem statement. Given the issues induced by working on a poset S of arms, we may state that the problem that we want to tackle is to identify the Pareto front P(S) of S as efficiently as possible. More precisely, we want to devise pulling strategies for both poset observability frameworks such that for any given \u03b4 \u2208 (0, 1), we are ensured that the agent is capable, with probability 1 \u2212 \u03b4 to identify P(S) with controlled number of pulls and regret. Assumption 1 (Order Compatibility).\n\u2200i, j \u2208 S, (i j) if and only if \u03b3ij > 0.\nWe will not require any further hypothesis on how the \u03b3ij relate to each other and, therefore, no assumption on strong stochastic transitivity [Yue et al., 2012] is required."}, {"heading": "2.3 Poset Observability", "text": "We consider the following setting, where the uncomparability information is not accessible.\nPartially observable posets. A K-armed Dueling bandits on a partially observable poset S = {1, . . . ,K} is a dueling bandit problem such that if i \u2016 j, then \u03b3ij = 0. This property is referred as Partial Observability.\nThis property reflects the fact that neither of the two incomparable arms has a distinct advantage over the other: when the agent asks to compare two intrinsically incomparable arms, the results will only depend upon circumstances independent from the arms (like luck or personal tastes). Our encoding of such framework makes us assume that when considered over many pulls, the effects of those circumstances cancel out, so that no specific arm is favored, whence \u03b3ij = 0.\nConsequences of partial observability. Note that partial observability entails the problem of indistinguishability evoked previously. Indeed, given two arms i and j, regardless of the number of comparisons, an agent may never be sure if either the two arms are very close to each other (\u03b3ij \u2248 0 and i and j are comparable) or if they are not comparable (\u03b3ij = 0). Since all the elements of the Pareto set must be incomparable with each other, this renders the problem of identifying P intractable as well if no additional information is provided.\nThis problem motivates the following definition, which quantifies the notion of indistinguishability : Definition 2.7 (\u03b5\u2212indistinguishability). Let a, b \u2208 S and \u03b5 > 0. a and b are said to be \u03b5indistinguishable, noted a \u2016\u03b5 b, if |\u03b3ab| \u2264 \u03b5.\nAs the notation \u2016\u03b5 implies, the \u03b5\u2212indistinguishability of two arms can be seen as a weaker form of incomparability, and note that as \u03b5-decreases, previously indistinguishable pairs of arms become distinguishable, and the only 0\u2212indistinguishable pair of arms are the incomparable pairs. The classical notions of a poset related to incomparability can easily be extended to fit the \u03b5\u2212indistinguishability : Definition 2.8 (\u03b5-antichain, \u03b5-width and \u03b5-approximation of P). Let \u03b5 > 0. C \u2282 S is called an \u03b5-antichain if \u2200a 6= b \u2208 C, we have a \u2016\u03b5 b. Additionally, P \u2032 \u2282 S is called an \u03b5\u2212approximation of P if P \u2282 P \u2032 and P \u2032 is an \u03b5-antichain. Finally we denote by width\u03b5(S) the size of the largest \u03b5\u2212 antichain of S.\nInterestingly, to find a \u03b5\u2212approximation of P , it is only needed to remove the elements of S which are \u03b5\u2212distinguishable fromP . Thus, whileP cannot be recovered in the partially observable setting,\nAlgorithm 1 Direct comparison Given (S, ) a poset, \u03b4, \u03b5 > 0, a, b \u2208 S Initialisation Maintains pab the average number of victory of a over b and Iab its 1 \u2212 \u03b4 confidence interval, Direct comparison: while 0.5 + \u03b5 \u2208 I or 0.5\u2212 \u03b5 \u2208 I do\nCompare a and b, Update pab and I . If 0.5 /\u2208 Iab and pab > 0.5, Return a b; Else If 0.5 /\u2208 Iab and pab < 0.5, Return b a.\nend while Return a \u2016\u03b5 b\na \u03b5\u2212approximation of P can be obtained. Consequently, if the agent knows the minimum distance of any arm to the Pareto set, defined as d(P) = min{\u03b3ij ,\u2200i \u2208 P, j \u2208 S \\ P, such that i j}, she can recover the Pareto front, since for any \u03b5 < d(P), the unique \u03b5\u2212approximation of P is P itself. This information is however unavailable in practice and we choose not to rely on external information to solve the problem at hand. In the case where an \u03b5 approximation of the Pareto front is not enough, and the exact Pareto front is required, we devise an alternative strategy which rests on the idea of decoys, already mentioned in the introduction and fully developed in Section 3."}, {"heading": "3 Contributions", "text": "Here, we introduce our algorithm, UnchainedBandits, that solves the problem of dueling bandits on partially observable posets, and we provide theoretical performance guarantees."}, {"heading": "3.1 Decoys and Posets", "text": "As said in Section 2, deciding if two arms are incomparable or very close is intractable in the partially observable poset, and so is that of finding the exact Pareto front.\nStill, without any additional device, the agent is able to find if two arms a and b, are \u03b5indistinguishable. using the direct comparison process provided by Algorithm 1. Yet, as previously discussed, this only produces an \u03b5-approximation of the Pareto front, of whom P is only guaranteed to be a subset. To evade this shortcoming, we introduce a new tool, decoys, inspired by works from social psychology [Huber et al., 1982]. We formally define decoys for posets, and we prove that it is a sufficient tool to solve the incomparability problem (Algorithm 2). We also present methods for building those decoys, both for the purely formal model of posets and for real-life problems.\nDefinition 3.1 (\u2206-decoy). Let a \u2208 S. Then b \u2208 S is said to be a \u2206-decoy of a if :\n1. a < b and \u03b3a,b \u2265 \u2206\n2. \u2200c \u2208 S, a \u2016 c implies b \u2016 c\n3. \u2200c \u2208 S such that c < a, \u03b3c,b \u2265 \u2206\nInterestingly, when S satisfies the strong stochastic transitivity hypothesis, the third point of the previous definition in an immediate consequence of the first. The following proposition illustrates how decoys can be used to determine the incomparability of two arms.\nProposition 3.2 (Decoys and incomparability). Let a and b \u2208 S . Let a\u2032 (resp. b\u2032) be a \u2206-decoy of a (resp. b). Then a and b are comparable if and only if max(\u03b3b,a\u2032 , \u03b3a,b\u2032) \u2265 \u2206.\nProof. Let us assume than a < b. The transitivity of < implies that a < b\u2032, and the third point of Definition 3.1 implies that \u03b3a,b\u2032 \u2265 \u2206. The rest follows from point 2 of Definition 3.1.\nAlgorithm 2 is derived from this result. The next proposition, an immediate consequence of Proposition 3.2, gives a theoretical guarantee on its performances.\nAlgorithm 2 Decoy comparison Given (S, ) a poset, \u03b4, \u03b5 > 0, a, b \u2208 S Initialisation Create a\u2032, b\u2032 the respective \u03b5- decoy of a, b. Maintains pab the average number of victory of a over b and Iab its 1\u2212 \u03b4/2 confidence interval, Decoy comparisons: while 0.5 + \u03b5 \u2208 I do\nCompare a and b\u2032, b and a\u2032, Update p, and I . If 0.5 /\u2208 Iab\u2032 and pab\u2032 > 0.5, Return a b. Else If 0.5 /\u2208 Iba\u2032 and pba\u2032 > 0.5, Return b a.\nend while Return a \u2016 b\nProposition 3.3. Algorithm 2 returns the correct incomparability result with probability at least 1\u2212 \u03b4 after at most n comparisons, where n = 4log(4/\u03b4)/\u22062.\nAdding decoys to a poset. A poset S may not contain all the necessary decoys. To alleviate this, the following proposition states that it is always possible to add relevant decoys to a poset. Proposition 3.4 (Extending a poset with a decoy.). Let (S,<, \u03b3) be a dueling bandit problem on a partially observable poset, and a \u2208 S. Define a\u2032, S\u2032, \u2032, \u03b3\u2032 as follows:\n\u2022 S \u2032 = S \u222a {a\u2032}\n\u2022 \u2200b, c \u2208 S, b < c i.f.f. b <\u2032 c,, and \u03b3\u2032b,c = \u03b3b,c\n\u2022 \u2200b \u2208 S, if b < a then b < a\u2032 and \u03b3\u2032b,a\u2032 = max(\u03b3b,a,\u2206). Otherwise, b \u2016 a\u2032.\nThen (S\u2032,<\u2032) is a poset and (S \u2032,<\u2032, \u03b3\u2032) defines a dueling bandit problem on a partially observable poset, \u03b3\u2032|S = \u03b3, and a \u2032 is a \u2206-decoy of a.\nProof. The result naturally follows from the definition of a poset and Definition 3.1.\nDecoys in real-life problems. The intended goal of a decoy a\u2032 of a is to have at hand an arm that is known to be lesser than a. Creating such a decoy in real-life can be done by using a degraded version of a: for the case of a movie, a decoy can be obtain by e.g. decreasing the resolution of a film. Note that while for large values of the \u2206 parameter of the decoys Algorithm 2 requires less comparisons (see Proposition 3.3), in real-life problems, the second point of Definition 3.1 tends to becomes false: the new option is actually so worse than the original that the decoy becomes comparable (and inferior) to all the other arms, including previously non comparable arms (example: the decoy of a film for a very large \u2206 > 0 could be in very low resolution such as 32 \u00d7 24; this film cannot be actually seen and is clearly worse than all the others, regardless of the genre). In that case, the use of decoys of arbitrarily large \u2206 can lead to erroneous conclusions about the Pareto front and should be avoided.\n3.2 UnchainedBandits\nWe now present our algorithm, UnchainedBandits, that uses decoys to efficiently find the Pareto front of S. UnchainedBandits is inspired by the ideas developed by Daskalakis et al. [2011], who address the problem of sorting a poset in a noiseless environment.\nBy Proposition 3.3, Algorithm 2 can be used to establish the exact relation between two arms. But this process can be very costly, as the number of required comparison is proportional to 1/\u22062, even for strongly suboptimal arms. To avoid this possibility, UnchainedBandits implements a peeling technique: given N > 0 and a decreasing sequence (\u03b5i) N\u22121 i=1 it computes and refines an \u03b5i-approximation of the Pareto front P\u0302i, using a subroutine (Algorithm 4), which considers \u03b5iindistinguishable arms as incomparable. Then, at the N -th epoch, it uses Algorithm 4 one final time where it uses Algorithm 2 with \u2206-decoys for comparisons, and then returns the Pareto front.\nAlgorithm subroutine. Algorithm 4 called on S\u0302 with parameter \u03b5 > 0, \u03b4 > 0 and A works as follows. It chooses a single initial pivot\u2014an arm to which other arms are compared\u2014and successively\nAlgorithm 3 UnchainedBandits Given S = {s1, . . . , sK} a poset, \u03b4 > 0, \u2206 > 0, N > 0, (\u03b5i)N\u22121i=1 \u2208 RN+ Initialisation Set S1 = S, \u03b5N = \u2206. Peel P\u0302 for t = 1 to N \u2212 1 do St+1 = UBS Routine (St, \u03b5t, \u03b4/N,A = Algorithm 3). end for Use decoys P\u0302 = UBS Routine (SN ,\u2206, \u03b4/N,A = Algorithm 2). RETURN P\u0302\nAlgorithm 4 UBS Routine Given St a poset, \u03b5t > 0 a precision criterion, \u03b4\u2032 an error parameter, A a comparison algorithm Initialisation Choose p \u2208 St at random. Define P\u0302 = {p} the set of pivots. Construct P\u0302 for c \u2208 St \\ {p} do\nfor c\u2032 \u2208 P\u0302 do Compare c and c\u2032 using A(\u03b4 = \u03b4\u2032/|St|2, \u03b5 = \u03b5t). If c c\u2032, Then remove c\u2032 from P\u0302 . end for If \u2200c\u2032 \u2208 P\u0302 , c \u2016 c\u2032, Then add c to P\u0302\nend for Return P\u0302\nexamines all the elements of S\u0302. Each of the examined element p is compared to all the pivots. Each pivot that is dominated by p is removed from the pivot set. Then if after being compared to all the pivots, p was dominated by none, it is added to the pivot set. At the end, the set of remaining pivot is returned. During the first N \u2212 1 epochs, the comparisons are done with Algorithm 1. In the last epoch, the agent uses Algorithm 2 to get exact information on the relations between the remaining arms.\nReuse of informations. To optimize the efficiency of the peeling process, UnchainedBandits reuses previous comparison results. At the beginning of each direct comparison process between arms a and b, the empirical estimate pab and its confidence interval Iab are initialized using the results of the previous direct comparisons of a and b. However, no information can be reused in the last epoch for the remaining arms, as the indirect comparison algorithm does not compare a to b directly.\nThe following theorem gives a high probability bound on the performances of UnchainedBandits. Theorem 1. The UnchainedBandits algorithm applied on S with parameters \u03b4,\u2206,N and with a decreasing sequence (\u03b5i)N\u22121i=1 lower bounded by \u2206 \u221a K\nwidth(S) , returns the Pareto front P of S with probability at least 1\u2212 \u03b4 after at most T comparisons, with\nT \u2264 O ( Kwidth(S)log(NK2/\u03b4)/\u22062 ) (1)\nThis is a consequence of the following intermediate result, whose proof can be found in the supplementary materials. Proposition 3.5. Algorithm 4 called on St with parameter \u03b5t > 0, \u03b4\u2032 > 0 and A = Algorithm 2 returns the Pareto front of St with probability at least 1\u2212 \u03b4\u2032 after at most\nT \u2264 4|St|width(St)log(4|St|2/\u03b4\u2032)/\u22062\ncomparisons. Alternatively, when Algorithm 4 uses A = Algorithm 1, it returns an \u03b5t\u2212approximation of the Pareto front of St with probability at least 1\u2212 \u03b4\u2032 after at most\nT \u2264 2|St|width\u03b5t(St)log(2|St|2/\u03b4\u2032) ( 1\n\u03b52t \u2212 1t>1\n1\n\u03b52t\u22121 ) additional comparisons, where 1 is the indicator function.\nProof of Theorem 1. Note that \u2200S \u2032 \u2282 S such that P \u2282 S \u2032, P(S \u2032) = P . The result is obtained by summing the upper bound in Proposition 3.5 over the different epochs, rearranging the sum and using the fact that |St|width\u03b5t(St)log(N |St|2/\u03b4) is decreasing in t while 1/\u03b52t is increasing in t. The detailed proof can be found in the supplementary materials.\nPeeling rate. Note that even if width(S) is unknown, it suffices to choose\n\u03b5N\u22121 \u2265 \u2206 \u221a K (2)\nto satisfy the hypotheses of Theorem 1. Although the previous result is valid for any decreasing sequence of (\u03b5t) satisfying (2), we focus on geometrically decreasing sequences, i.e. \u2203\u03b3 > 0 such that \u03b5t = \u03b3t\u03b50. For the sake of simplicity, we set \u03b50 = 0.5 but all the following results can easily be extended for any \u03b50 > 0.\nBefore we present our regret upper bound, we need to introduce a few notations. In order to characterise the efficiency of the peeling approach associated to \u03b3, we define \u03b1(\u03b3, \u03b50, N) \u2208]0, 1], or \u03b1 for short, as follows :\n\u03b1 = inf { a \u2208 [0, 1], s.t. \u22001 \u2264 t \u2264 N, \u2200St \u2282 S an \u03b50\u03b3t-approximation of P, |St| \u2264 at|S| } . (3)\nIt is important to note that the previous inequality is always true for a = 1, so \u03b1 is always defined. \u03b1 characterise how efficient is the peeling for the chosen parameters by quantifying the reduction in size between the successive St. We can now introduce the following Theorem which gives an upper bound on the regret incurred by Unchained Bandit. Theorem 2. LetR0 (resp. R1) be the regret generated by Algorithm 3 applied on S with parameters \u03b4,\u2206,N and with a decreasing sequence (\u03b5i)N\u22121i=1 such that \u03b5N\u22121 \u2264 \u2206 \u221a K during the peeling phase (resp. the decoy phase). Let \u03b1 as defined by (3). Then R = R0 +R1 and with probability at least 1\u2212 \u03b4,\nR0 \u2264 2K\n\u03b32 log(\n2NK2\n\u03b4 ) K\u2211 i=1 1 \u2206i C\u03b1,\u03b3(Ni) (4)\nR1 \u2264 Kwidth(S) log( 2NK2\n\u03b4 ) \u2211 i,\u2206i<\u03b5N\u22121,i/\u2208P 1 \u2206i , (5)\nwhere\nNi = min\n( d log(\u2206i)\nlog(\u03b3) e, N \u2212 1\n) and C\u03b1,\u03b3(n) =  n\u03b1n\u22121 if \u03b1 = \u03b3,\n\u03b32n(1\u2212 \u03b1) + \u03b1n(\u03b32 \u2212 1) \u03b32 \u2212 \u03b1 otherwise.\nIn the previous theorem, Ni represent the number of peeling step where the arm i is present, while C\u03b1,\u03b3(Ni) represent the cost of doing the peeling for arm i. It is worth noting that C\u03b1,\u03b3(n) \u2264 1 and is increasing in \u03b1. This reflect the fact that small \u03b1 are representative of an efficient pruning (many arms removed at each step).\nOpposite constraints on \u03b5. Theorem 1 is an upper bound on the number of comparisons required to find the Pareto front. This bound is tight in the (worst-case) scenario where all the arms are \u2206- indistinguishable, i.e. peeling cannot eliminate any arm. In that case, any comparison done during the peeling is actually wasted, and the lower bound on \u03b5t (2) allows to upper bound the number of comparisons made during the peeling step to recover a Kwidth(S) dependency in the upper bound, instead of K2. On the other hand, a significant amount of peeling is required to obtain a reasonable upper bound on the incurred regret: the number of comparisons using decoys is very high (\u2248 1/\u22062) and is the same for every arm, regardless of its regret. So it is important that only near-optimal arms remain during the decoy step, hence the upper bound on \u03b5t. In order to satisfy both constraints, \u03b5N must be chosen in [\u221a K/width(S)\u2206, \u221a K\u2206 ] ."}, {"heading": "4 Related Works", "text": "There is an actual connection between our work and studies from social psychology. In particular, Tversky and Kahneman [1981] issued one of the reference papers on the choice problem\u2014 which pertains to comparisons, in our framework\u2014 for real-life problems; they introduced the idea that alternatives may influence the perceived value of items. This idea had been taken one step further by Huber et al. [1982], who introduced and formalized the idea of decoys. They specifically argued that introducing dominated alternatives, i.e. decoys, may increase the probability of\nthe original item to be selected: if A,B and A\u2032 are alternatives, then P (select A among A,B) < P (select A among A,A\u2032, B). This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields.\nFrom the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets. Their results come down to classical results when totally ordered sets are used. Also, there might be yet other connections to draw between our work and that of Feige et al. [1994] who tackle the problem of sorting with noisy comparisons; note however that they assume there is a total order on the items they work on and the connection to be made with the present work would be to identify how this assumption may be weakened, if not removed.\nFinally, we must discuss how our contribution separates from papers on dueling bandits. If the seminal paper of Yue et al. [2012] promotes algorithms, namely the Interleaved Filter algorithms, that exhibit optimal information-theoretic regret bounds, the authors assume the existence of a total order between the arms together as strong stochastic transitivity and (relaxed) stochastic triangle inequality. Since then, numerous methods have been proposed to relax those additional assumptions, including [Yue and Joachims, 2011, Ailon et al., 2014, Zoghi et al., 2014, 2015b]. Other approaches exist that do not assume the existence of a Condorcet winner, such as [Urvoy et al., 2013, BusaFekete et al., 2013, Zoghi et al., 2015a] but, to the best of our knowledge, we provide the first contribution that studies the framework where arms may be incomparable."}, {"heading": "5 Numerical Simulations", "text": "In this section we experimentally evaluate UnchainedBandits. We did not compare our algorithm to dueling bandits algorithms from the literature, as a) they fail to consider the incomparability information and b) they are generally designed to return only one best element. Instead, we studied the performances of UnchainedBandits on simulated data (Section 5.1), and we applied it to an existing film rating database (Section 5.2)."}, {"heading": "5.1 Simulated Poset", "text": "First we confront UnchainedBandits with randomly generated posets, with different sizes, widths and heights. In order to give a baseline value, we use a simple algorithm, UniformSampling inspired from the successive elimination algorithm Even-Dar et al. [2006], which simultaneously compares all possible pairs of arms until one of the arms appears suboptimal, at which point it is removed from the set of selected arms. When only \u2206-indistinguishable elements remain, it uses \u2206-decoys.\nGiven the size p > 0 of the Pareto front, the desired width w \u2265 p and the height h > 0, the posets are generated as follows: first, a Pareto front of size p is created. Then w chains of length h\u22121 with no common elements are added. Finally, the top of the chains are connected to a random number of elements of the Pareto front. This creates the structure of the poset (i.e. the partial order ). Finally, the exact values of the \u03b3ij\u2019s are obtained from a uniform distribution, conditioned to satisfy\nthe partially (or fully) observable framework. When needed, \u2206-decoys are created according to Proposition 3.4. For each experiment reported on Figure 1, we changed the value of one parameter, and left the other to their default values (p = 5, w = 2p, h = 10). The results are averaged over ten runs. By default, we use \u03b4 = 1/1000 and \u2206 = 1/100. We also set \u03b3 = 0.9, \u03b50 = 0.5 and \u03b5N = \u221a K\u2206.\nWe note that for partially observable posets, UnchainedBandits produces much better results than UniformSampling and its advantage increases with the complexity of the problem."}, {"heading": "5.2 MovieLens Dataset", "text": "To illustrate the example of the films recommendation system developed in the introduction, we chose to apply UnchainedBandits to the 20 millions items MovieLens dataset (Harper and Konstan [2015]).\nTo simulate a dueling bandit on a poset we proceed as follows: we remove all films with less than 50000 evaluations, thus obtaining 159 films, represented as arms. Then, when comparing two arms, we picke at random a user which has evaluated both films, and compare those evaluations (ties are broken with an unbiased coin toss). Since the decoy tool cannot be used in an already existing dataset, we restrict ourselves to finding an \u03b5-approximation of the Pareto front, with \u03b5 = 0.05. Then, UnchainedBandits is run with parameters \u03b3 = 0.9, \u03b50 = 0.5, \u03b5N = \u03b5, \u03b4 = 0.001.\nThere is no known ground truth for this experiments, so no regret estimation can be provided. Instead, the resulting Pareto front, which contains 5 films, is listed in Table 5.2, and compared to the five films among the original 159 with the highest average score. It is interesting to note that three films are present in both list, which reflects the fact that the best films in term of average score have a high chance of being in the Pareto Front. On the other hand, the films contained in the Pareto front are more diverse in term of genre, which is expected of a Pareto front. For instance, the sequel of the film \u201dThe Godfather\u201d (hence very close to the original regarding genre) has been replaced by a a film of a totally different genre. It is important to remember that UnchainedBandits does not have access to any information about the genre of a film and its results are based solely on the pairwise evaluation of the user, and thus this result illustrates the effectiveness of our approach for the learning of the hidden poset."}, {"heading": "6 Conclusion", "text": "We studied an extension of the dueling bandit problem to the poset framework, which raised the problem of \u03b5-indistinguishability. We presented a new algorithm, UnchainedBandits, which tackles the partially observable settings, and we provided theoretical performance guarantee for its ability to identify the Pareto front. Future work might include the study of the influence of additional hypothesis on the structure of the poset, such as when the poset is actually a lattice or upper semilattice. In this case, different strategies of sampling might lead to even more efficient algorithms."}, {"heading": "B Additional Numerical Simulations", "text": "The following experiments evaluate the relative efficiency of SlicingBandits and UnchainedBandits, we confront them with randomly generated posets, with different sizes, widths and heights.\nGiven the size p > 0 of the Pareto front, the desired width w \u2265 p and the height h > 0, the posets are generated as follows: first, a Pareto front of size p is created. Then w chains of length h\u22121 with\nno common elements are added. Finally, the top of the chains are connected to a random number of elements of the Pareto front. This creates the structure of the poset (i.e. the partial order ). Finally, the exact values of the \u03b3ij\u2019s are obtained from a uniform distribution, conditioned to satisfy the partially (or fully) observable framework. When needed, \u2206-decoys are created according to Proposition 3.4.\nFor each experiment reported on Figure B, we changed the value of one parameter, and left the other to their default values (p = 5, w = 2p, h = 10). The results are averaged over ten runs. By default, we use \u03b4 = 1/1000 and \u2206 = 1/100. The (\u03b5t)t are generated following the procedure presented in Section 3 with \u22060 = 0.25.\nWe did not compare our algorithms to dueling bandits algorithms from the literature, as a) they fail to consider the incomparability information and b) they are generally designed to return only one best element. Instead, we use a baseline algorithm, UniformSampling inspired from the successive elimination algorithm Even-Dar et al. [2006], which simultaneously compares all possible pairs of arms until one of the arms appears suboptimal, at which point it is removed from the set of selected arms. When only \u2206-indistinguishable elements remain, it uses \u2206-decoys.\nWe note that SlicingBandits clearly outperforms the other algorithms by a wide margin, thanks to the access to the comparability information and the careful management of chains. For partially observable posets, UnchainedBandits produces much better results than UniformSampling and its advantage increases with the complexity of the problem."}, {"heading": "C Appendix : Extended Proofs", "text": ""}, {"heading": "Proof of Lemma 3.1", "text": "Existence: Since C is a finite totally ordered set, it admits an unique maximal element. Let c \u2208 C be the maximal element of C. We use reductio ad absurdum. Suppose that c is not a maximal element of S. By definition of maximal element, \u2203c\u2032 \u2208 S such that c\u2032 c. But \u2200c\u2032\u2032 \u2208 C, we have c < c\u2032\u2032, then by transitivity c\u2032 c\u2032\u2032. Hence C \u2228 {c\u2032} is a chain which strictly contains C, which contradicts the fact the C is a maximal chain. Uniqueness: let c, c\u2032 \u2208 C be two maximal element of S. Since C is a chain, c and c\u2032 are comparable. Since c is a maximal element, we have c < c\u2032. The same is true for c\u2032, hence the conclusion."}, {"heading": "Proof of Theorem 1", "text": "Let E1 be the event where during the execution of Algorithm 1, each call to A(C, \u03b4/K) return the correct answer (the maximal element of C). The proof is divided into two steps : First, we are going to prove that on E1, Theorem 1 is correct. Then, using an upper bound of the number of call to A done on the event E1, we will prove that P(EC1 ) \u2264 \u03b4, hence the conclusion. On E1,consider the following invariant : Invariant : At the beginning of each iteration of the while loop, we have\nP\u0302 \u2282 P (7)\n\u2200p \u2208 P\u0302, \u2200q \u2208 S\u0302, p \u2016 q (8)\nP \u2282 P\u0302 \u222a S\u0302 (9)\nIt is easy to see that the invariant is true at the beginning of the algorithm, because at the initialisation,"}, {"heading": "P\u0302 = \u2205 and S\u0302 = S.", "text": "Assume that the invariant is true at the beginning of the loop t+ 1, and denote by S\u0302t,P\u0302t the value of S\u0302, P\u0302 at the end of loop t.\nSince the algorithm has not stopped, S\u0302t is not empty. By definition, the subset C constructed by the algorithm is a maximal chain of S\u0302. Since C is a non empty finite totally ordered set, it admits an unique maximum element c.\nWe prove that c \u2208 P (10)\nwith reductio ad absurdum (RAA for short). Assume that c /\u2208 P . Then \u2203c\u2032 \u2208 P such that c\u2032 c. Since C is a maximal chain of S\u0302, it implies that c\u2032 /\u2208 S\u0302. Hence (9) implies that c\u2032 \u2208 P\u0302 . But then c\u2032 c contradicts (8), which concludes the RAA. Note that (10) and (8) implies\nc \u2208 P \\ P\u0302. (11)\nThen, on E1, A(C, \u03b4/K) = c, and\nP\u0302t P\u0302t \u222a {c} = P\u0302t+1 \u2282 P. (12)\nNow by construction we have\nS\u0302t+1 = {p \u2208 S\u0302t, p c or p \u2016 c} = {p \u2208 S\u0302t, p \u2016 c}\nsince c \u2208 P. Then (8) implies that\n\u2200p \u2208 P\u0302t+1, \u2200q \u2208 S\u0302t+1, p \u2016 q. (13)\nFinally, we prove with RAA that P \u2282 P\u0302t+1 \u222a S\u0302t+1 (14)\nLet p \u2208 P such that p /\u2208 P\u0302t+1 \u222a S\u0302t+1. (9) implies that p \u2208 P\u0302t \u222a S\u0302t. Since P\u0302t+1 \u2283 P\u0302t, we have p \u2208 S\u0302t+1 \\ S\u0302t. Then, by definition of S\u0302t+1, we have c p, which contradicts p \u2208 P and conclude the RAA.\nFinally, (12)(13) and (14) implies that the invariant is true at the beginning of the loop t+ 2.\nWhen the algorithm stops, we have S\u0302 = \u2205, hence (7) and (9) implies that\nP\u0302 \u2282 P \u2282 P\u0302 \u222a \u2205 = P\u0302\nthat is to say P\u0302 = P . Hence on E1, Algorithm 5 reaches the correct conclusion.\nA consequence of (11) is that P\u0302t increases by exactly one element at each iteration of of the while loop, and thus the A is called exactly |P| times. Hence, if we denote by Ct the chain constructed at the loop t,\nP(EC1 ) \u2264 |P|\u2211 t=1 P ({A(Ct, \u03b4/K) failed })\n\u2264 \u2211 c\u2208P \u03b4/K \u2264 \u03b4,\nAdditionally, the number of additional comparisons required to build all the chains is upper bounded by K2, as all pair of elements have to be compared at most once. Hence, the upper bound of T is derived from the fact due to (11), at each iteration, a chain with a different element of c \u2208 P is considered."}, {"heading": "Proof of Corollary 3.1", "text": "Let Ct be the chain considered by Algorithm 1 during the loop t, and we denote by ct the maximal element of Ct, which is the unique element of P \u2229 Ct (consequence of (11)). Theorem 2 from\n[Yue et al., 2012] implies that in this case, T (A (Ct, \u03b4/K)) \u2264 O ( |Ct|\nlog(|Ct|2K/\u03b4) (minc\u2032\u2208Ct \u03b3ctc\u2032) 2 ) \u2264 O ( |Ct| log(K3/\u03b4)\n(minc\u2208P,c\u2032\u2208S,c c\u2032 \u03b3cc\u2032)2\n) .\nUsing that by construction, \u2200t < t\u2032, Ct \u2229 C\u2032t = \u2205, and \u22c3 t Ct = S, we have\n|P|\u2211 t=1 T (A (Ct, \u03b4/K)) \u2264 O  |P|\u2211 t=1 |Ct| log(K3/\u03b4) (minc\u2208P,c\u2032\u2208S,c c\u2032 \u03b3cc\u2032)2  \u2264 O ( K log(K3/\u03b4)\n(minc\u2208P,c\u2032\u2208S,c c\u2032 \u03b3cc\u2032)2 ) Hence the conclusion."}, {"heading": "Proof of Proposition 3.7", "text": ""}, {"heading": "Case A = Algorithm 3", "text": "In this setting, the arms are compared using decoys.\nWe are going to proceed as in the proof of Theorem 1.\nLet E1 be the event where during the execution of Algorithm 5, each call to Algorithm 3 returns the correct answer. We are going to prove the following invariant for the principal loop of the Algorithm on E1.\nInvariant: At the iteration n, Let Snt the set of element of St already considered, P\u0302n the current set of pivot. Then\n\u2200c\u2032 \u2208 Snt \u2203c \u2208 P\u0302n, c < c\u2032 (15) \u2200c, c\u2032 \u2208 P\u0302t, c \u2016 c\u2032 (16)\nIt is easy to see that the invariant is true at the beginning of the algorithm because S0t = P\u03020 and |P\u03020| = 1. Suppose that the invariant is true at the n-th iteration. Let p be the new element considered, i.e. Sn+1t = Snt \u222a {p}, and define \u0393 p \u2212 . = {q \u2208 P\u0302n, p q}\n1. Case 1. \u2203q \u2208 P\u0302n s.t. q p. In this case, P\u0302n+1 = P\u0302n \\ \u0393p\u2212, hence (16) at iteration n immediatly implies (16) at iteration n+ 1. Since q p, we have \u2200q\u2032 \u2208 \u0393p\u2212, we have q q\u2032 by transitivity.Hence (15) at iteration n implies (15) at iteration n+1.\n2. Case 2. \u2200q \u2208 P\u0302n, p q or p \u2016 q. Then\nP\u0302n+1 = {p} \u222a P\u0302n \\ \u0393p\u2212, and is it easy to see that (15) is still true iteration n + 1. Now we are going to prove that (16) is still true by RAA. Assume that \u2203q \u2208 P\u0302n+1 s.t. q is comparable to p. By definition of \u0393p\u2212, it implies that q p, which contradicts the initial assumption of the case.\nAfter the last iteration n, we have Sn+1t = St, since all the elements have been examined. We now prove by RAA that the invariant implies that P\u0302n+1 = P. We drop the n+ 1 in P\u0302n+1 for the sake of alleviating the notations.\nSuppose that P\u0302 6\u2282 P and let p \u2208 P\u0302 \\ P . Since p /\u2208 P,\u2203q \u2208 P s.t. q p. If q \u2208 P\u0302 , (16) is contracted. Then q /\u2208 P\u0302. Hence q p contradicts (15). So P\u0302 \u2282 P .\nNow assume that P 6\u2282 P\u0302 and let p \u2208 P \\P\u0302 . Since p /\u2208 P\u0302, (15) implies that \u2203q \u2208 P\u0302 s.t. q < p. Since p /\u2208 P\u0302 and q \u2208 P\u0302 , q 6= p hence q p, which contradicts p \u2208 P . So P \u2282 P\u0302. Hence P\u0302 = P.\nA consequence of (16) is that at each step, P\u0302n is an antichain. Since during the execution of the algorithm all the elements of St are compared to all the element of the current P\u0302 , the algorithm do at most\n|St|max n |P\u0302n| \u2264 |St|width(St)\ncomparisons, and as a consequence\nP(EC1 ) \u2264 |St|width(St) \u03b4\n|St|2 \u2264 \u03b4.\nThe upper bound on the number of comparisons results with the same remark combined with Proposition 3.5."}, {"heading": "Case A = Algorithm 2.", "text": "During the epochs t < N , the arms are compared directly to each other, i.e. Algorithm 2 is used for comparisons purpose. We first tackle the case t = 1, i.e. the first epoch, since in this case, there is no previous observations, and thus no negative term in the upper bound. Case t = 1. The proof for t = 1 unfolds similarly to the previous case, with a different invariant.\nLet E1 be the event where during the execution of Algorithm 5, each call to Algorithm 2 returns the correct answer e.g. i j (resp j i) if and only if \u03b3ij > \u03b5 (resp \u03b3ji > \u03b5). We are going to prove the following invariant for the principal loop of the Algorithm on E1.\nInvariant: At the iteration n, Let Snt the subset of element of St already considered, P\u0302n the current set of pivot. Then\n\u2200c\u2032 \u2208 Snt \u2203c \u2208 P\u0302n, c < c\u2032 (17) \u2200c, c\u2032 \u2208 P\u0302t, c \u2016\u03b5 c\u2032 (18)\nIt is easy to see that the invariant is true at the beginning of the algorithm because S0t = P\u03020 and |P\u03020| = 1. Suppose that the invariant is true at the n-th iteration. Let p be the new element considered, i.e. Sn+1t = Snt \u222a {p}.\n1. Case 1. \u2203q \u2208 P\u0302n s.t. q p and \u03b3qp > \u03b5. In this case, P\u0302n+1 = P\u0302n \\ \u0393p\u2212, hence (18) at iteration n immediatly implies (18) at iteration n+ 1. Since q p, we have \u2200q\u2032 \u2208 \u0393p\u2212, we have q q\u2032 by transitivity. Hence (17) at iteration n implies (17) at iteration n+ 1.\n2. Case 2. \u2200q \u2208 P\u0302n, (p q and \u03b3pq > \u03b5 ) or |\u03b3pq| < \u03b5. Then\nP\u0302n+1 = {p} \u222a P\u0302n \\ \u0393p\u2212, and is it easy to see that (15) is still true iteration n + 1. Now we are going to prove that (16) is still true by RAA. Assume that \u2203q \u2208 P\u0302n+1 s.t. q is comparable to p and |\u03b3qp| > \u03b5. By definition of \u0393p\u2212, it implies that q p, and the order compatibility of the poset implies that \u03b3qp > \u03b5 which contradicts the initial assumption of the case.\nAfter the last iteration n, we have Sn+1t = St, since all the elements have been examined. We now prove by RAA that the invariant implies that P\u0302n+1 is an \u03b5-approximation of P . We drop the n + 1 in P\u0302n+1 for the sake of alleviating the notations.\nNow assume that P 6\u2282 P\u0302 and let p \u2208 P \\P\u0302 . Since p /\u2208 P\u0302, (15) implies that \u2203q \u2208 P\u0302 s.t. q < p. Since p /\u2208 P\u0302 and q \u2208 P\u0302 , q 6= p hence q p, which contradicts p \u2208 P . So P \u2282 P\u0302.\nNow suppose that \u2203q \u2208 P\u0302 such that \u2203p \u2208 P s.t. p q and \u03b3pq > \u03b5. Since P \u2282 P\u0302 , we have p \u2208 P\u0302 and thus \u03b3pq > \u03b5. contradicts (18). Hence P\u0302 is a \u03b5-approximation of P.\nA consequence of (18) is that at each step, P\u0302n is an \u03b5-antichain. Since during the execution of the algorithm all the elements of St are compared to all the element of the current P\u0302 , the algorithm do at most\n|St|max n |P\u0302n| \u2264 |St|width\u03b5(St)\ncomparisons, and as a consequence\nP(EC1 ) \u2264 |St|width\u03b5(St) \u03b4\n|St|2 \u2264 \u03b4.\nThe upper bound on the number of comparisons results with the same remark combined with the fact that Algorithm 2 uses Hoeffding inequality.\nCase 1 < t < N . To conclude, we only need to lower bound the number of previous comparisons that can be reused. Once again, consider the event E1 be the event where during the execution of Algorithm 5, each call to Algorithm 2 returns the correct answer e.g. i j (resp j i) if and only if \u03b3ij > \u03b5 (resp \u03b3ji > \u03b5). Let i and j \u2208 St such that i and j are compared at epoch t (i.e. during the call number t of Algorithm 3). Note that St = P\u0302nt\u22121 and let assume without any loss of generality that i was added before j into P\u0302nt\u22121. Since i is a pivot at the end of the epoch t \u2212 1, it was compared to all the arm considered after i, including j.\nSince both i and j are pivots at the end of epoch t \u2212 1, it implies that i \u2016 j or \u03b3ij < \u03b5t\u22121. In both cases, Algorithm the algorithm does exactly log(K\n2/\u03b4\u2032) \u03b52t\u22121\ncomparisons to reach this conclusion. The result follows from the reuse of information."}, {"heading": "Proof of Theorem 2.", "text": "First note that if P \u2032 is a \u03b5- approximation of P , then P \u2282 P \u2032. Additionally, it is easy to see that if S is a poset and P is its Pareto set, then \u2200S \u2032 \u2282 S such that P \u2282 S \u2032, the Pareto front of S \u2032 is P. Hence, Proposition 3.7 implies that with probability at least 1\u2212N\u03b4/N = 1\u2212\u03b4, Algorithm 4 returns the pareto front of S. in at most T comparisons, where T \u2264 2 N\u22121\u2211 t=1 |St|width\u03b5t(St)log(2N |St|2/\u03b4) ( 1 \u03b52t \u2212 1t>1 1 \u03b52t\u22121 ) + 4|SN |width(SN ) log(4N |SN |2/\u03b4) \u22062\n\u2264 2 N\u22122\u2211 t=1 1 \u03b52t ( |St|width\u03b5t(St)log(2N |St|2/\u03b4)\u2212 |St+1|width\u03b5t+1(St+1)log(2N |St+1|2/\u03b4) ) + 2\n\u03b52N\u22121 |SN\u22121|width\u03b5N\u22121(SN\u22121)log(2N |SN\u22121|2/\u03b4) + 4|SN |width(SN ) log(4N |SN |2/\u03b4) \u22062\nwhere the second inequality is obtained by rearranging the sum. Now, by hypothesis we have\n\u03b5t > \u03b5N\u22121 \u2265 \u2206\n\u221a |S|\nwidth(S)\nHence, since the |St|width\u03b5t(St)log(N |St|2/\u03b4) is decreasing in t we have\nT \u2264 2 N\u22122\u2211 t=1 width(S) |S|\u22062 ( |St|width\u03b5t(St)log(2N |St|2/\u03b4)\u2212 |St+1|width\u03b5t+1(St+1)log(2N |St+1|2/\u03b4) ) +\n2width(S) |S|\u22062 |SN\u22121|width\u03b5N\u22121(SN\u22121)log(2N |SN\u22121|2/\u03b4) + 4|SN |width(SN ) log(N |SN |2/\u03b4) \u22062\n\u2264 2 \u22062 |S|width\u03b51(S) |S| width(S)log(2N |S|2/\u03b4) + 4|SN |width(SN ) log(4N |SN |2/\u03b4) \u22062\n\u2264 O ( Kwidth(S) log(NK 2/\u03b4)\n\u22062\n)"}, {"heading": "Proof of Theorem 3.", "text": "We know from Proposition 3.5, with probability at least 1 \u2212 \u03b4, the algorithm does not reach an incorrect result the comparison. For the rest of the proof, we restrict ourselves to this event.\nFirst we consider the regretR0 induced by the peeling process. Let i be an arm, and Ni be the last peeling step before ip is eliminated. If i is not eliminated at the end of the peeling, then we set Ni = N \u2212 1. In other words,\nNi = max{1 \u2264 t \u2264 N \u2212 1, i \u2208 P\u0302t}\n= min ( d log(\u2206i)\nlog(\u03b3) e, N \u2212 1\n) .\nLet j \u2264 Ni. During the j-th phase of peeling, the arm i is compared to at most |Sj \u2212 1| other arms. Hence, with the same argument as in Proposition 3.5, we have\nR0 \u2264 2 K\u2211 i=1 \u2206i Ni\u2211 t=1 |St|log(2N |St|2/\u03b4) ( 1 \u03b52t \u2212 1t>1 1 \u03b52t\u22121 ) .\nNow since \u03b5t < \u03b5t\u22121, and by hypothesis, |St| \u2264 \u03b1t\u22121K, we have\nR0 \u2264 2K log( 2NK2\n\u03b4 ) K\u2211 i=1 \u2206i Ni\u2211 t=1 \u03b1t\u22121 ( 1 \u03b52t \u2212 1t>1 1 \u03b52t\u22121 )\n\u2264 2K log(2NK 2\n\u03b4 ) K\u2211 i=1 \u2206i ( Ni\u22121\u2211 t=1 \u03b1t\u22121 \u03b52t (1\u2212 \u03b1) + \u03b1 Ni\u22121 \u03b52Ni ) .\nSince by construction, we have \u03b5t+1 = \u03b3\u03b5t, then\nR0 \u2264 2K log( 2NK2\n\u03b4 ) K\u2211 i=1 \u2206i \u03b52Ni ( Ni\u22121\u2211 t=1 \u03b32(Ni\u2212t)\u03b1t\u22121 (1\u2212 \u03b1) + \u03b1Ni\u22121 )\n\u2264 2K log(2NK 2\n\u03b4 ) K\u2211 i=1 \u2206i \u03b52Ni\n( \u03b32(Ni\u22121)\nNi\u22121\u2211 t=1 ( \u03b1 \u03b32 )t\u22121 (1\u2212 \u03b1) + \u03b1Ni\u22121\n)\n\u2264 2K \u03b32 log( 2NK2 \u03b4 ) K\u2211 i=1 1 \u2206i\n( \u03b32(Ni\u22121)\nNi\u22121\u2211 t=1 ( \u03b1 \u03b32 )t\u22121 (1\u2212 \u03b1) + \u03b1Ni\u22121\n) ,\nsince by definition of Ni, we have \u2206i < \u03b5Ni\u22121 = \u03b3\u03b5Ni . Now we have to consider two cases.\nCase \u03b32 6= \u03b1:\nR0 \u2264 2K\n\u03b32 log(\n2NK2\n\u03b4 ) K\u2211 i=1 1 \u2206i ( \u03b32(Ni\u22121) (1\u2212 \u03b1) 1\u2212 (\u03b1/\u03b3 2)Ni\u22121 1\u2212 (\u03b1/\u03b32) + \u03b1Ni\u22121 )\n\u2264 2K \u03b32 log( 2NK2 \u03b4 ) K\u2211 i=1 1 \u2206i \u03b32Ni(1\u2212 \u03b1) + \u03b1Ni(\u03b32 \u2212 1) \u03b32 \u2212 \u03b1\n\u2264 2K \u03b32 log( 2NK2 \u03b4 ) K\u2211 i=1 1 \u2206i C\u03b1,\u03b3(Ni),\nand\nCase \u03b32 = \u03b1:\nR0 \u2264 2K\n\u03b32 log(\n2NK2\n\u03b4 ) K\u2211 i=1 1 \u2206i ( \u03b1Ni\u22121 (1\u2212 \u03b1) (Ni \u2212 1) + \u03b1Ni\u22121 ) \u2264 2K\n\u03b32 log(\n2NK2\n\u03b4 ) K\u2211 i=1 1 \u2206i \u03b1Ni\u22121Ni\n\u2264 2K \u03b32 log( 2NK2 \u03b4 ) K\u2211 i=1 1 \u2206i C\u03b1,\u03b3(Ni),\nhence the conclusion.\nNow letR1 be the regret generated by the decoy step. To reach this step, an arm i must be such that \u2206i < \u03b5N\u22121. If i \u2208 P , then pulling the arm i produces no regret. Otherwise, it is easy to see that the arm is compared to at most width(S) other arms before being eliminated.\nR1 \u2264 width(S) log( 2NK2\n\u03b4 ) \u2211 i,\u2206i<\u03b5N\u22121,i/\u2208P \u2206i \u22062\n\u2264 (\u03b5N\u22121 \u2206 )2width(S) log( 2NK2 \u03b4 ) \u2211 i,\u2206i<\u03b5N\u22121,i/\u2208P 1 \u2206i\n\u2264 Kwidth(S) log(2NK 2\n\u03b4 ) \u2211 i,\u2206i<\u03b5N\u22121,i/\u2208P 1 \u2206i ."}], "references": [{"title": "Reducing dueling bandits to cardinal bandits", "author": ["Nir Ailon", "Zohar Karnin", "Thorsten Joachims"], "venue": "In Proceedings of The 31st International Conference on Machine Learning,", "citeRegEx": "Ailon et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Ailon et al\\.", "year": 2014}, {"title": "Seeking subjective dominance in multidimensional space: An explanation of the asymmetric dominance effect", "author": ["Dan Ariely", "Thomas S Wallsten"], "venue": "Organizational Behavior and Human Decision Processes,", "citeRegEx": "Ariely and Wallsten.,? \\Q1995\\E", "shortCiteRegEx": "Ariely and Wallsten.", "year": 1995}, {"title": "Top-k selection based on adaptive sampling of noisy preferences", "author": ["R\u00f3bert Busa-Fekete", "Balazs Szorenyi", "Weiwei Cheng", "Paul Weng", "Eyke H\u00fcllermeier"], "venue": "In Proceedings of The 30th International Conference on Machine Learning,", "citeRegEx": "Busa.Fekete et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Busa.Fekete et al\\.", "year": 2013}, {"title": "Sorting and selection in posets", "author": ["Constantinos Daskalakis", "Richard M Karp", "Elchanan Mossel", "Samantha J Riesenfeld", "Elad Verbin"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Daskalakis et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Daskalakis et al\\.", "year": 2011}, {"title": "Action elimination and stopping conditions for the multi-armed bandit and reinforcement learning problems", "author": ["Eyal Even-Dar", "Shie Mannor", "Yishay Mansour"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Even.Dar et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Even.Dar et al\\.", "year": 2006}, {"title": "Computing with noisy information", "author": ["Uriel Feige", "Prabhakar Raghavan", "David Peleg", "Eli Upfal"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Feige et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Feige et al\\.", "year": 1994}, {"title": "The movielens datasets: History and context", "author": ["F Maxwell Harper", "Joseph A Konstan"], "venue": "ACM Transactions on Interactive Intelligent Systems (TiiS),", "citeRegEx": "Harper and Konstan.,? \\Q2015\\E", "shortCiteRegEx": "Harper and Konstan.", "year": 2015}, {"title": "Adding asymmetrically dominated alternatives: Violations of regularity and the similarity hypothesis", "author": ["Joel Huber", "John W Payne", "Christopher Puto"], "venue": "Journal of consumer research,", "citeRegEx": "Huber et al\\.,? \\Q1982\\E", "shortCiteRegEx": "Huber et al\\.", "year": 1982}, {"title": "Contextual and procedural determinants of partner selection: Of asymmetric dominance and prominence", "author": ["Constantine Sedikides", "Dan Ariely", "Nils Olsen"], "venue": "Social Cognition,", "citeRegEx": "Sedikides et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Sedikides et al\\.", "year": 1999}, {"title": "Generic exploration and karmed voting bandits", "author": ["Tanguy Urvoy", "Fabrice Clerot", "Raphael F\u00e9raud", "Sami Naamane"], "venue": "In Proceedings of the 30th International Conference on Machine Learning", "citeRegEx": "Urvoy et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Urvoy et al\\.", "year": 2013}, {"title": "Beat the mean bandit", "author": ["Yisong Yue", "Thorsten Joachims"], "venue": "In Proceedings of the 28th International Conference on Machine Learning", "citeRegEx": "Yue and Joachims.,? \\Q2011\\E", "shortCiteRegEx": "Yue and Joachims.", "year": 2011}, {"title": "The k-armed dueling bandits problem", "author": ["Yisong Yue", "Josef Broder", "Robert Kleinberg", "Thorsten Joachims"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Yue et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Yue et al\\.", "year": 2012}, {"title": "Relative upper confidence bound for the k-armed dueling bandit problem", "author": ["Masrour Zoghi", "Shimon Whiteson", "Remi Munos", "Maarten D Rijke"], "venue": "In Proceedings of the 31st International Conference on Machine Learning", "citeRegEx": "Zoghi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zoghi et al\\.", "year": 2014}, {"title": "Copeland dueling bandits", "author": ["Masrour Zoghi", "Zohar S Karnin", "Shimon Whiteson", "Maarten de Rijke"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Zoghi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Zoghi et al\\.", "year": 2015}, {"title": "Mergerucb: A method for large-scale online ranker evaluation", "author": ["Masrour Zoghi", "Shimon Whiteson", "Maarten de Rijke"], "venue": "In Proceedings of the Eighth ACM International Conference on Web Search and Data Mining,", "citeRegEx": "Zoghi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Zoghi et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 11, "context": "Dueling bandits were introduced by Yue et al. [2012]. The setting, pertaining to the K-armed bandit framework, assumes there is no direct access to the reward provided", "startOffset": 35, "endOffset": 53}, {"referenceID": 3, "context": "To carry out our study, we propose to make use of tools from the theory of posets and we take inspiration from works dedicated to selection and sorting on posets Daskalakis et al. [2011]. Keys: Indistinguishability and Decoys.", "startOffset": 162, "endOffset": 187}, {"referenceID": 11, "context": "The K-armed dueling bandit problem [Yue et al., 2012] assumes the existence of K parameters {\u03b3ij}1\u2264i,j\u2264K , with \u03b3ij \u2208 (\u22121/2, 1/2) and the following sampling procedure.", "startOffset": 35, "endOffset": 53}, {"referenceID": 11, "context": "We will not require any further hypothesis on how the \u03b3ij relate to each other and, therefore, no assumption on strong stochastic transitivity [Yue et al., 2012] is required.", "startOffset": 143, "endOffset": 161}, {"referenceID": 7, "context": "To evade this shortcoming, we introduce a new tool, decoys, inspired by works from social psychology [Huber et al., 1982].", "startOffset": 101, "endOffset": 121}, {"referenceID": 3, "context": "UnchainedBandits is inspired by the ideas developed by Daskalakis et al. [2011], who address the problem of sorting a poset in a noiseless environment.", "startOffset": 55, "endOffset": 80}, {"referenceID": 7, "context": "This idea had been taken one step further by Huber et al. [1982], who introduced and formalized the idea of decoys.", "startOffset": 45, "endOffset": 65}, {"referenceID": 0, "context": "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al.", "startOffset": 43, "endOffset": 70}, {"referenceID": 0, "context": "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields.", "startOffset": 43, "endOffset": 95}, {"referenceID": 0, "context": "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields. From the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets.", "startOffset": 43, "endOffset": 287}, {"referenceID": 0, "context": "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields. From the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets. Their results come down to classical results when totally ordered sets are used. Also, there might be yet other connections to draw between our work and that of Feige et al. [1994] who tackle the problem of sorting with noisy comparisons; note however that they assume there is a total order on the items they work on and the connection to be made with the present work would be to identify how this assumption may be weakened, if not removed.", "startOffset": 43, "endOffset": 621}, {"referenceID": 0, "context": "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields. From the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets. Their results come down to classical results when totally ordered sets are used. Also, there might be yet other connections to draw between our work and that of Feige et al. [1994] who tackle the problem of sorting with noisy comparisons; note however that they assume there is a total order on the items they work on and the connection to be made with the present work would be to identify how this assumption may be weakened, if not removed. Finally, we must discuss how our contribution separates from papers on dueling bandits. If the seminal paper of Yue et al. [2012] promotes algorithms, namely the Interleaved Filter algorithms, that exhibit optimal information-theoretic regret bounds, the authors assume the existence of a total order between the arms together as strong stochastic transitivity and (relaxed) stochastic triangle inequality.", "startOffset": 43, "endOffset": 1014}, {"referenceID": 4, "context": "In order to give a baseline value, we use a simple algorithm, UniformSampling inspired from the successive elimination algorithm Even-Dar et al. [2006], which simultaneously compares all possible pairs of arms until one of the arms appears suboptimal, at which point it is removed from the set of selected arms.", "startOffset": 129, "endOffset": 152}, {"referenceID": 6, "context": "To illustrate the example of the films recommendation system developed in the introduction, we chose to apply UnchainedBandits to the 20 millions items MovieLens dataset (Harper and Konstan [2015]).", "startOffset": 171, "endOffset": 197}], "year": 2016, "abstractText": "We adress the problem of dueling bandits defined on partially ordered sets, or posets. In this setting, arms may not be comparable, and there may be several (incomparable) optimal arms. We propose an algorithm, UnchainedBandits, that efficiently finds the set of optimal arms of any poset even when pairs of comparable arms cannot be distinguished from pairs of incomparable arms, with a set of minimal assumptions. This algorithm relies on the concept of decoys, which stems from social psychology. For the easier case where the incomparability information may be accessible, we propose a second algorithm, SlicingBandits, which takes advantage of this information and achieves a very significant gain of performance compared to UnchainedBandits. We provide theoretical guarantees and experimental evaluation for both algorithms.", "creator": "LaTeX with hyperref package"}}}