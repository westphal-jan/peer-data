{"id": "1603.06217", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Mar-2016", "title": "An Approximation Approach for Solving the Subpath Planning Problem", "abstract": "The subpath effort changes problem just branch of, narrow process though, created once widespread functionality now metering electrical process as so in jeep took robot connectivity. This problem is to everyone then circuitous path from time follow for ferry single taking whose would subpaths. The current understanding giving dealing with only subpath military thought several all based on beri - on-the-fly analysis. It now that - one that alborz - recursive based approaches have hundreds deficiencies. To call without, go propose given novel lagrangian initialization but during O (formula_4 ^ 3) time complexity example, as guarantees to solve any subpath government problem or with the fixed ratio flying own 28. Also, through submit footnotes of still contended, our empirical evaluation shows referring wish amplitude particular acts much look mostly for governor - of - the - fine variations, both months result and hearing not.", "histories": [["v1", "Sun, 20 Mar 2016 14:22:26 GMT  (1815kb,D)", "http://arxiv.org/abs/1603.06217v1", null]], "reviews": [], "SUBJECTS": "cs.RO cs.AI cs.DS", "authors": ["masoud safilian", "s mehdi tashakkori", "sepehr eghbali", "aliakbar safilian"], "accepted": false, "id": "1603.06217"}, "pdf": {"name": "1603.06217.pdf", "metadata": {"source": "CRF", "title": "An Approximation Approach for Solving the Subpath Planning Problem", "authors": ["Masoud Safilian", "S. Mehdi Tashakkori Hashemi", "Sepehr Eghbali", "Aliakbar Safilian"], "emails": ["ma.safilian@gmail.com,", "hashemi@aut.ac.ir", "sepehr.eghbali@uwaterloo.ca", "safiliaa@mcmaster.ca"], "sections": [{"heading": null, "text": "Note to Practitioners\u2014In some real world applications such as robot and vehicle navigation in structured and industrial environments as well as some of the manufacturing processes such as electronic printing and polishing, it is required for the agent to travel a set of predefined paths. Automating this process includes three steps: 1) capturing the environment of the actual problem and formulating it as a subpath planning problem; 2) solving subpath planning problem to find the near optimal path or tour; 3) command the robot to follow the output. The most challenging phase is the second one that this paper tries to tackle it. To design an effective automation for the aforementioned applications, it is essential to make use of methods with low computational cost but near optimal outputs in the second phase. According to the fact that the length of the final output has a direct effect on the cost of performing the task, it is desirable to incorporate methods with low complexity that can guarantee a bound for the difference between length of the optimal path and\nar X\niv :1\n60 3.\n06 21\n7v 1\n[ cs\n.R O\n] 2\nthe output. Current approaches for solving subpath planning problem are all meta-heuristic based. These methods do not provide such a bound. And plus, they are usually very time consuming. They may find promising results for some instances of problems, but there is no guarantee that they always exhibit such a good behaviour. In this paper, in order to avoid the issues of metaheuristics methods, we present an approximation algorithm, which provides an appropriate bound for the optimality of its solution. To gauge the performance of proposed methods, we conducted a set of experiments the results of which show that our proposed method finds shorter paths in less time in comparison with a state-of-the-art method."}, {"heading": "1 Introduction", "text": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36]. Due to various applications, different types of this problem have been proposed including the subpath planning problem (SPP). SPP has widespread applications such as navigation of robots and vehicles as well as automated manufacturing process [16, 37]. The goal of SPP is to find the shortest tour, which travels all given subpaths. SPP is an NP-hard problem [13, 19]. As an example, Fig. 1.a shows a workspace and Fig. 1.b represents its corresponding optimal result. Also, Fig 1.a represents the corresponding graph constructed based on the workspace.\nThere have been proposed a few approaches for solving SPP, all of which are meta-heuristic based. Recently, Ying et al. [37] and Gyorfi et al. [16] proposed some algorithms based on Genetic Algorithm (GA) [15] for solving SPP in polishing robots and electronic printing, respectively.\nLike other meta-heuristic methods [4], GA cannot guarantee any bound on its final result. It may produce some promising results on some given instances, while it has a tendency to converge to local optima for some other instances. In addition, GA needs considerable amount of time in order to return a result. This problem becomes more severe as the number of subpaths grows.\nThe current paper aims at overcoming the problems of meta-heuristic methods in solving SPP by proposing an approximation algorithm [3] with a fixed ratio bound and efficient polynomial complexity. Our method includes three stages described as follows.\nThe first stage is transforming SPP to Travelling Salesman Problem (TSP) [18] with an O(n2) time complexity algorithm. TSP is a well-known combinatorial optimization problem. Since TSP is an NP-hard problem [19], proposing a precise algorithm for solving TSP does not make sense. Thus, several attempts have been done to propose approximation algorithms for solving this problem. In the recent decades,\nvarious approximation methods have been proposed for solving this problem. Once an SPP instance is transformed to a suitable TSP one, it may seem easy to apply the existing fixed-ratio bound approximation algorithms for TSP for solving SPP. However, this is not the case and there are some crucial challenging issues in this way. Christofides in [6] argues that there is no polynomial approximation algorithm with a fixed ratio bound for general TSP. Literally, we cannot propose any fixed ratio bound approximation algorithm on a general graph, in which the triangle inequality does not hold in all triangles [6] (this observation is also due to Sahni and Gonzale [33]). However, there are some fixed-ratio bound approximation algorithms such as Christofides\u2019 algorithm [6], for solving TSP over constrained graphs, which satisfy triangle inequality. Here is the point where we face a crucial problem: the output graph of transforming of SPP to TSP for a given instance definitely violates the triangle inequality condition, as shown in Section 3. Thus, it is not feasible to apply existing fixed-ratio bound TSP approximation algorithms for solving SPP. We address this shortcoming in a two next stages.\nIn the second stage, we propose an algorithm, called Imperfectly Establish the Triangle Inequality (IETI), which establishes the triangle inequality in a main subset of violating triangles 1. The output of the first stage, i.e., transforming SPP to TSP, is considered as the input graph of the IETI algorithm. The algorithm outputs a new graph by changing the edges\u2019 weight of the input such that the triangle inequality condition holds on all triangles except for some special triangles (those that one and only one of their edges does have the infinity weight). Let G\u2032 be the result of transforming an SPP instance graph G and G\u2032\u2032 be the output graph of the IETI algorithm for G\u2032. We formally show that solving SPP on G would be equivalent to solving TSP on G\u2032\u2032. The IETI algorithm is in O(n2) complexity class and should be seen as a fundamental step for introducing and applying a fixed-ratio bound approximation algorithm for solving SPP. This is because, as discussed already, the main requirement of applying such an algorithm for solving SPP is holding triangle inequality in the given graph.\nNonetheless, some special triangles still violate the triangle inequality in the output graph of the IETI algorithm. To tackle this problem, in the third stage, we propose an approximation algorithm with the fixed-ratio bound of 2 and O(n3) complexity, called Christofides for SPP (CSPP) . Indeed, the CSPP algorithm is a modified version of the Christofides\u2019 algorithm [6] to make it able to work for all outputs of the IETI algorithm. The Christofides\u2019 algorithm is a polynomial approximation algorithm with fixed-ratio bound of 1.5 2 for solving TSP instances in which edge\n1As it may be clear, a violating triangle is a triangle which violates the triangle inequality condition.\n2The fixed ratio bound of 1.5 is the minimum among the existing methods proposed for solving TSP.\nweights are metric 3. Thus, any input graphs of this algorithm must satisfy the triangle inequality condition. Therefore, it is not feasible to apply Christofides to our problem. In other words, the CSPP algorithm aims at solving TSP for given graphs in which the triangle inequality holds in all triangles except for those that one of their edges has the infinity weight.\nIn addition to complexity analysis and proving the ratio bound of CSPP, it is empirically compared with the method proposed by Gyorfi et al. [16] over various workspaces with different number of subpaths. The results illustrate that CSPP is more efficient than the state-of-the-art method in terms of both result and running time.\nThe rest of the paper is organized as follows. Section 2 discusses the related work. Section 3, presents transformation of SPP to TSP. We discusses the IETI algorithm in Section 4. In Section 5, we propose the CSPP algorithm and describe its characteristics and the related theorems. The experimental comparison of CSPP and the method proposed by Gyorfi et al. [16] is presented in Section 6. Finally, the conclusions and future work are discussed in Section 7."}, {"heading": "2 Related Work", "text": "There exist some graph problems, which are relevant to SPP. This set of problems includes Travelling Salesman Problem with Neighbours (TSPN) and those that are in the context of Arc Routing Problems (ARP) [9, 10]. Bellow, we discuss their similar-\n3like other fixed-ratio bound algorithms for solving the TSP\nities and differences with SPP.\nTravelling Salesman Problem with Neighbours: Travelling Salesman Problem with Neighbours (TSPN) is introduced by Arking and Hassin [2]. It is a generalization of TSP in which the constraint is to visit the neighbourhood of each node instead of the node itself. In TSPN, each node is represented as a polygon instead of a single point and an optimal solution is the shortest path such that it intersects all polygons. Since TSPN is a generalization of TSP, it is also NP-hard [26, 28]. Besides, Safra and Schwartz [32] showed that it is NP-hard to approximate within any constant bound. For the general case of connected polygons, Mata and Mitchell [24] proposed an O(log n) approximation bound with O(N5) time complexity based on \u201dguillotine rectangular subdivisions\u201d, where N is the total number of vertices of the polygons. If all the polygons have the same diameter, then an O(1) algorithm also exists [8]. Even if we represent each subpath with a polygon of two vertices, then SPP is different from TSPN. This is because an SPP solution requires to traverse all the subpaths, while a solution for TSPN can only have intersections with each subpaths.\nRural Postman Problem: Consider a graph G(V,E), where V is the set of vertices and E is the set of edges. In the Chinese Postman Problem (CPP), we are interested in finding the shortest closed path such that it travels all the edges. An optimal solution is an Eulerian tour, if exists any. Thus, whenever the degree of each node is even, CPP can be reduced to finding an Eulerian tour. Note that it is well-known that an Eulerian tour always exists in such a graph. If G is either purely directed or purely undirected, CPP has a polynomial time solution. Otherwise (the given graph is neither purely directed nor undirected), the problem would be NP-hard [10].\nRural Postman Problem (RPP) is a variant of CPP. A CPP problem is called RPP, if a subset of edges must be covered instead of covering all the edges. RPP was first introduced by Orloff [27]. The undirected, directed and mixed versions of RPP are all proven to be NP-hard [11, 22]. Frederickson [11] proposed a polynomial time solution for RPP with the worst case ratio bound of 1.5 for given graphs, which satisfy the triangle inequality condition. This solution is known as the best one for RPP.\nThere are many similarities between RPP and SPP. Indeed, RPP is a generalization of SPP. An SPP instance is an RPP instance in which the subpaths are the edges that must be covered. As Fig. 2 shows, there are additional constraints in SPP. The number of vertices is twice the number of edges that must be covered (subpaths). Thus, the must-be-covered edges in an SPP instance cannot share a common vertex. Besides, the graph is an undirected complete one. Although SPP and RPP have many similarities, fixed-ratio bounds algorithms for RPP cannot be applied for SPP. This is because given graphs for SPP do not satisfy the triangle inequality condition.\nStacker Crane Problem: The Stacker Crane Problem (SCP) [12] is another relevant problem in the context of routing. SCP is defined on a graph consisting of directed and undirected edges. The problem is to find the shortest circuit, which covers all the directed edges (which can be the deliveries that to be made by a vehicle). SCP is also an NP-hard problem, since it is a generalization of TSP. Coja-Oghlan et al. [7] proposed an approximation approach for a special case of SCP. In this solution, given graphs must be trees. Even in such a restricted case, the problem is NP-hard. Fredrickson et al. [12] proposed a polynomial algorithm for this problem with the ratio bound of 1.8 in the worst case. The Fredrickson\u2019s solution for SCP is known to be the best approximation algorithm [38]. The difference between SCP and SPP is that, in SPP, subpaths, which must be covered, are indirected edges."}, {"heading": "3 Transformation of SPP to TSP", "text": "In this section, we show how to transform SPP to TSP. Feasible solutions for an SPP instance are the tours that travel all the subpaths. A tour with the minimum length is a desired solution. Each feasible solution is a sequence of connected subpaths. In a fixed sequence with n subpaths, the ith (i < n) subpath can be connected to the (i+ 1)th subpath (the nth subpath is connected to the first one) in two different ways (either to head or tail). Now, consider an SPP instance with n subpaths. Obviously, the number of possible sequences of these n subpaths is n!. Thus, due to two different ways of connections between two consecutive subpaths, the total number of feasible solutions would be n!2n.\nTSP is one of the classical NP-hard problems of combinatorial optimization. In the recent decades, various approximation [21] and combinatorial optimization methods [18] have been proposed for solving this problem. Thus, transformation of SPP to TSP facilitates applying such methods for solving SPP. The rest of the section is organized as follows. The subsection 3.1 discusses the transformation procedure of SPP to TSP and in the subsection 3.2, we discuss the complexity analysis of the procedure on its corresponding pseudo code."}, {"heading": "3.1 TSP model of SPP: Transformation Procedure", "text": "Consider an SPP instance with n subpaths indexed with the set I = {1, ..., n}. The procedure includes two stages. In the first stage, a complete graph G is built, according to the following stages.\nStage 1:\n1. For each subpath, say ith (i \u2208 I), consider two nodes si and ei corresponding to its starting and end points, respectively.\n2. For each i \u2208 I, consider an edge between si and ei with the weight equal to the length of ith subpath in the workspace. Let us call this edge the ith subpath edge.\n3. For each pair of two distinct subpaths i and j (i 6= j), we add edges siej, eisj, sisj and eiej to the graph. We also consider the weights of these newly added edges equal to the corresponding Euclidean distances in the workspace. Let us call these edges the connecting edges.\nFig. 2.a depicts the graph G generated according to Stage 1 for the given workspace in Fig. 1.a.\nThe TSP tour of G (the graph generated in the above procedure) is not necessarily equivalent to the solution of the given SPP instance. This is because the solution of SPP is a tour traveling all the subpaths, while the TSP tour of G may not cover all the subpath edges (such as siei). To make sure that the TSP tour travels all the subpaths, a complete graph G\u2032 is generated based on G as follows:\nStage 2:\n1. For each subpath, say ith subpath, a node mi is added to the graph, called the middle node of ith subpath.\n2. For each subpath, say ith, two edges simi and miei are added to the graph, the weights of which are equal to the half of the subpath length. These edges are called ith double subpath edges.\n3. For each middle node mi, the edge miv, where v /\u2208 {si, ei}, is added to the graph with the infinity weight.\nFig. 2.b depicts the graph G\u2032 generated according to Stage 2 for the given graph G in Fig. 2.a.\nTheorem 1 The result of solving SPP on a given instance is equivalent to finding the TSP tour in G\u2032 generated according to the above procedures (Stage 1 + Stage 2) on the instance.\nProof: According to Fig. 2.b, there is a finite Hamiltonian tour in G\u2032. [s1-m1-e1-s2m2-e2-s3 . . . sn,mn-en] is a sample of finite hamiltonian tours in G\n\u2032 with n subpaths. The TSP tour over G\u2032 is a Hamiltonian tour with the minimum weight. Therefore, The TSP tour over G\u2032 is finite. The TSP tour of G\u2032 must visits all the middle nodes, since, for each i, it contains two edges crossing the node mi. There are only two finite edges si-mi and mi-ei connecting to mi. Hence, the TSP tour over G\n\u2032 must contain ith double subpath edges for each i. Since simi and miei together are equivalent to ith subpath in the workspace, the TSP tour of G\u2032 is a minimum tour, which travels all subpaths. Hence, solving SPP is equivalent to finding the TSP tour in G\u2032.\nThroughout the rest of the paper, we use the notation G\u2032 to denote the graph generated in the above procedure for a given SPP instance."}, {"heading": "3.2 Pseudo Code and Complexity Analysis of Transforming", "text": "Algorithm 1 presents a pseudo code for the SPP to TSP transformation procedure. The algorithm takes a workspace as input and returns a graph G\u2032 as output. It includes the following two phases:\n1) Generating a graph G, according to Stage 1 (Line 1) 2) Generating a graph G\u2032 by adding middle nodes to G, according to Stage 2 (Lines 2 to 9) Time complexity of generating the graph G is in O(n2), where n is the number of subpaths. Lines 2 to 9 add middle nodes to the graph within a loop of n iterations. In each iteration, there is another loop (lines 6-8), which requires O(n) running time. Therefore, adding middle nodes requires O(n2) running time. Thus, the total complexity of the algorithm is O(n2).\nAlgorithm 1 : SPP to TSP\n1: Construct G with the adjacency matrix w 2: for i = 1 to n do 3: add middle node mi 4: w(mi, si)\u2190 w(ei,si)2 5: w(mi, ei)\u2190 w(ei,si)2 6: for each node d \u2208 G where d /\u2208 {si, ei} do 7: w(mi, d)\u2190\u221e 8: end for 9: end for"}, {"heading": "4 Imperfectly Establish the Triangle Inequality", "text": "As discussed already, using any existing approximation method for TSP requires triangle inequality to be hold over given graphs. Two kinds of triangles in G\u2032 (Fig. 2.b) may violate triangle inequality:\nV-1) Triangles with a subpath edge as one of their edges, i.e, triangles in the form of 4sieiv 4, where v 6= mi.\nV-2) Triangles with one and only one infinity edge. In such a triangle, one of its edges is either simj or eimj (i 6= j).\nOther triangles in G\u2032 that are not in one of the above kinds do not violate the triangle inequality condition. Such triangles can be grouped into the following kinds:\n1) Triangles that have more than one infinity edge. 2) Triangles in which all of the edges\u2019 weights are equal to their corresponding Euclidean distances. 3) Triangles that are of the form 4simiei. As mentioned in the introduction, we tackle the triangle inequality violation in G\u2032 in two stages. The first stage is proposing an algorithm, called Imperfectly Establish the Triangle Inequality (IETI). We discuss how the algorithm works in the subsection 4.1. The subsection 4.2 discusses the complexity analysis of the procedure on its corresponding pseudo code."}, {"heading": "4.1 IETI: The Procedure", "text": "The IETI algorithm is given the output of the transformation procedure (G\u2032) and deals with the first category of violating triangles, i.e., V-1. Indeed, this algorithm makes some modifications to the edges\u2019 weight of G\u2032 to make a graph, denoted by G\u2032\u2032, such that TSP tours in G\u2032 and G\u2032\u2032 are the same (see Theorem 3) and there is no violating triangles of kind V-1 in G\u2032\u2032 (see Theorem 2).\n44abc denotes the triangle with a, b, and c as its vertices.\nThe IETI algorithm is an iterative method. Indeed, it iterates over all subpaths, for each of which it updates the weight of edges in a same way. Indeed, each iteration corresponds to a subpath. Below, we describe how it works.\nFor each iteration, say ith (corresponding to the ith subpath), we define a variable called ith degree of violation, denoted by dvi. We apply this variable to formally recognize what triangles in V-1 violate the triangle inequality condition. We also use it to resolve such violations. The equation (1) shows how to compute dvi.\nRemark 1 For a given graph H, the notations V (H) and w(a, b) denote the set of vertices and the weight of the edge ab, respectively.\n\u2200 d \u2208 V (G\u2032)\u2212 {si, ei} dvi = 0.5(min\n\u2200d (w(si, d) + w(ei, d))\u2212 w(si, ei))\n(1)\ndvi < 0 implies that at least one of the triangles in which one of their edges is eisi violates the triangle inequality condition. Otherwise, i.e., dvi \u2265 0, none of such triangles violates the condition. In the former case, the weight of edges are updated by the following equations:\nw(si, ei)\u2190 w(si, ei)\u2212 |dvi| w(si,mi)\u2190 w(si,mi)\u2212 | dvi 2 | w(ei,mi)\u2190 w(ei,mi)\u2212 | dvi 2 |\n(2)\n\u2200q \u2208 V (G\u2032)\u2212 {si, ei,mi} w(q, ei)\u2190 w(q, ei) + |dvi|\n2\nw(q, si)\u2190 w(q, si) + |dvi|\n2\n(3)\nNote that, in equation 3, the added weights to the edges, which are connected to the subpaths, are equal and symmetric, i.e., the weights of edges connected to si and ei are increased equally. This property makes the TSP tour over G\n\u2032 to be equivalent to one over G\u2032\u2032 (proven in Theorem 3).\nThese changes make the triangles containing the ith subpath to satisfy the triangle inequality. Note that it does not make other triangles, which already satisfy the triangle inequality, to violate the condition. This claim is proven in Theorem 2.\nTheorem 2 shows that IETI establishes the triangle inequality in all V-1 triangles in G\u2032\u2032 such that other triangles except for those in V-2 still satisfy the triangle inequality. Throughout the rest of the paper, we use the notation G\u2032\u2032 to denote the graph generated in the above procedure (IETI) for G\u2032.\nTheorem 2 After the execution of IETI, all the triangles in G\u2032\u2032 satisfy the triangle inequality except for those in V-2.\nProof: Let n be the number of subpaths of the original workspace. Consider the ith step of IETI. If dvi < 0 (computed in the equation 1), then, according to the equations (2) and (3), the weights of the corresponding edges change. Let G\u2032\u2032i denote the result graph after the execution of the ith step of IETI on G\u2032. It is also natural to consider G\u2032\u20320 and G \u2032\u2032 n equal to G\n\u2032 and G\u2032\u2032, respectively. Now, we are going to prove the following statement:\nStatement: A violating triangles in G\u2032\u2032i is either in: g-1) V-2 or g-2) V-1 such that it is a triangle 4sjejv with j > i.\nWe use an inductive reasoning to prove the above statement, as follows. (base case): It follows obviously that the above statement holds in G\u2032\u20320 (which is equal to G\u2032). (hypothesis): Assume that, for some t with 1 \u2264 t < i, the statement holds for G\u2032\u20320, ..., G \u2032\u2032 t\u22121, now it suffices to show that the statement also holds for G \u2032\u2032 t . This is shown in the inductive step. (inductive step): There exists the two following possible cases for G\u2032\u2032t\u22121. We show in each case the G\u2032\u2032t satisfies the statement.\n1. \u201cIn G\u2032\u2032t\u22121, the triangles with the edge stet do not violate the triangle inequality condition.\u201d\nThus, for any j \u2264 t, the triangles in G\u2032\u2032t\u22121 with an edge sjej do not violate the triangle inequality. In this case, during the tth step, no modification will be made to the graph G\u2032\u2032t\u22121 and G \u2032\u2032 t would be equal to G \u2032\u2032 t\u22121. Thus, for any j \u2264 t, the triangles in G\u2032\u2032t with an edge sjej do not violate the triangle inequality. Hence the statement holds for G\u2032\u2032t .\n2. \u201cThere are some triangles in G\u2032\u2032t\u22121 with an edge stet, which violates the triangle inequality.\u201d\nConsider a violating triangle in G\u2032\u2032t\u22121 with an edge stet. Let us see what would happen in the tth step. According to the equation (2), the weight of the edge stet must decrease by |dvt|. Moreover, for any q, the weights of the edges stq and qet increase by |dvt| 2 (equation 3). Each triangle in G\u2032\u2032t , say4abc, can fall into one of the seven following categories. The validity of triangle inequality in all categories will be investigated. In other words, the validity of the inequalities wt(a, c) + wt(b, c) \u2265 wt(a, b) and\nwt(a, b)+wt(b, c) \u2265 wt(a, c), where wt is the adjacency matrix of G\u2032\u2032t and wt(a, b) denotes the weight of the edge ab in G\u2032\u2032t 5.\n(a) \u201cThe triangle edge ab is equal to stet.\u201d\nIn this case, the weight of the edge ab decreases by |dvt| and the weights of the edges ac and bc increases by |dvt|\n2 . The equations (5) and (9) show that\nthe triangles in this category satisfy the triangle inequality after modifications:\nwt(a, c) + wt(b, c)\n= wt(st, c) + wt(et, c) = wt\u22121(st, c) + |dvt|\n2 + wt\u22121(et, c) + |dvt| 2\n= wt\u22121(st, c) + wt\u22121(et, c) + 2|dvt| \u2212 |dvt|\n(4)\nBy replacing 2|dvt| with wt\u22121(st, et) \u2212 min\u2200d[wt\u22121(st, d) + wt\u22121(et, d)], we would have:\nwt(a, c) + wt(b, c)\n= wt\u22121(st, c) + wt\u22121(et, c) + wt\u22121(st, et) \u2212min \u2200d [wt\u22121(st, d) + wt\u22121(et, d)]\u2212 |dvt| \u2265 wt\u22121(st, et)\u2212 |dvt| = wt(st, et) = wt(a, b)\n(5)\nwt(a, b) + wt(b, c)\n= wt(st, et) + wt(et, c) = wt\u22121(st, et)\u2212 |dvt|+ wt\u22121(et, c) + |dvt|\n2\n(6)\nBy replacing |dvt| with 12(wt\u22121(st, et)\u2212min\u2200d[wt\u22121(st, d) +wt\u22121(et, d))], we\n5Validity investigation of wt(a, b)+wt(a, c) \u2265 wt(b, c) is similar to of wt(a, b)+wt(b, c) \u2265 wt(a, c). So, there is no need to investigate the validity of the former inequality in the proof.\nwould have:\nwt(a, b) + wt(b, c) = wt\u22121(st, et) + wt\u22121(et, c)\n\u2212 wt\u22121(st, et)\u2212min\u2200d[st\u22121(st, d) + st\u22121(et, d)] 2 + |dvt|\n2\n= wt\u22121(st, et)\n2\n+ min\u2200d[wt\u22121(st, d) + wt\u22121(et, d)]\n2\n+ wt\u22121(et, c) + |dvt|\n2\n(7)\nThe weight of the edge stet has not changed before the t th step. Thus, wt\u22121(st, et) = w0(st, et). In other words, it is equal to the length of t th subpath. Hence, wt\u22121(st, et) > ed(st, et), where ed(st, et) is the Euclidean distance between st and et in the workspace. Also, any node such as d satisfies the inequality wt\u22121(st, d) +wt\u22121(et, d) \u2265 ed(st, d)+ed(et, d) > ed(st, et).\n6 As a consequence, the inequality min\u2200d[wt\u22121(st, d)+ wt\u22121(et, d)] > ed(st, et) holds, which results in:\nwt(a, b) + wt(b, c)\n\u2265 ed(st, et) + wt\u22121(et, c) + |dvt|\n2\n(8)\nIf the weights of subpaths, which pass through the node c change before the tth step, then the values of wt\u22121(st, c) and wt\u22121(et, c) would be equal to ed(st, c) + \u03b1 2 and ed(c, et) + \u03b1 2 , respectively, where \u03b1 is equal to the parameter dv (degree of violation) of the subpath, which passes through the node c. Otherwise (if the value of such subpaths are not updated), the values of wt\u22121(st, c) and wt\u22121(et, c) would be ed(st, c) and ed(c, et), respectively. Hence, the inequality ed(st, et)+wt\u22121(c, et) > wt\u22121(st, c) turns to ed(st, et)+ ed(c, et) > ed(st, c) that always holds. Consequently, the following inequal-\n6The weights of edges std and etd either have not changed before t th step or are modified by\nequation (3). Therefore, wt\u22121(st, d) \u2265 w0(st, d) \u2265 ed(st, d) and wt\u22121(et, d) \u2265 w0(st, d) \u2265 ed(et, d).\nity holds:\nwt(a, b) + wt(b, c)\n\u2265 wt\u22121(st, c) + |dvt| 2 \u2265 wt(st, c) \u2265 wt(a, c)\n(9)\n(b) \u201cThe edge ab is sjej (i.e., a = sj and b = ej), where j < t\u201d.\nIn this case, 4abc in G\u2032\u2032t\u22121 satisfies the triangle inequality. Two following scenarios are possible during the step tth: 1) The edges\u2019 weight of 4abc do not change in tth step. In this case, obviously, 4abc still satisfies the triangle inequality in tth step. 2) The weights of the edges ac and bc increase by |dvt|\n2 (Note that this\nscenario happens when c is either st or et). In this case, the following equations show that 4abc still satisfies the triangle inequality:\nwt(a, c) + wt(b, c)\n= wt(sj, c) + wt(ej, c) = wt\u22121(sj, c) + |dvt|\n2\n+ wt\u22121(ej, c) + |dvt| 2 \u2265 wt\u22121(sj, c) + wt\u22121(ej, c) \u2265 wt\u22121(sj, ej) = wt(sj, ej) = wt(a, b)\n(10)\nand\nwt(a, b) + wt(b, c) = wt(sj, ej) + wt(ej, c)\n= wt\u22121(sj, ej) + wt\u22121(ej, c) + |dvt|\n2\n\u2265 wt\u22121(sj, c) + |dvt| 2 = wt(sj, c)\n= wt(a, c)\n(11)\n(c) \u201cThe edge ab is sjej, where j > t\u201d.\nIn this case, the triangle 4abc may violate the triangle inequality in the graph G\u2032\u2032t\u22121. Hence, it may violate the triangle inequality in G \u2032\u2032 t too.\n(d) \u201c4abc does not have any edge in the form of sjej for some j (i.e., it does not have any subpath edge), and the weights of the edges ac and bc change during the tth step\u201d. 7\nIn this case, the triangle 4abc satisfies the triangle inequality condition in the graph G\u2032\u2032t\u22121 . During the t\nth step, the weights of the edges ac and bc increase by dvt\n2 . The following equations show that this triangle still\nsatisfies the triangle inequality in G\u2032\u2032t :\nwt(a, c) + wt(b, c) = wt\u22121(a, c) + dvt 2\nwt\u22121(b, c) + |dvt|\n2 \u2265 wt\u22121(a, c) + wt\u22121(b, c) \u2265 wt\u22121(a, b) = wt(a, b)\n(12)\nwt(a, b) + wt(b, c) = wt\u22121(a, b) + wt\u22121(b, c)\n+ |dvt|\n2 \u2265 wt\u22121(a, c)\n+ |dvt|\n2 = wt(a, c)\n(13)\n(e) \u201c4abc does not have any edge in the form of sjej for some j (i.e., it does not have any subpath edge) and the weight of no edge of the triangle change during the tth step\u201d.\nSince 4abc satisfies the triangle inequality condition in G\u2032\u2032t\u22121, it also satisfies the inequality in G\u2032\u2032t . (f) \u201c4abc has one edge with the infinity weight\u201d. The triangle violates the triangle inequality condition in both G\u2032\u2032t\u22121 and G\u2032\u2032t . (g) \u201c4abc has two or three edges with the infinity weight\u201d. It follows obviously that 4abc satisfies the triangle inequality condition in both G\u2032\u2032t\u22121 and G \u2032\u2032 t\nThus, after the execution of the tth step, only the triangles with one infinity weight edge (category f) or with edges in the form of sjej for some j greater than t (category c) may violate the triangle inequality in G\u2032\u2032t . Therefore, the statement holds in G \u2032\u2032 t .\nThe statement was proven, which means that it holds in G\u2032\u2032n = G \u2032\u2032.\n7Note that during each step of IETI for each triangle either no weight is updated (category e) or two weights are updated (category d).\nAs a result, the triangle inequality condition is satisfied by every triangle in the graph G\u2032\u2032 (the output graph of IETI) except for those with an infinity edge. These triangles are either in the form of4simid or4eimid, where the edge mid is an infinite edge. The theorem is proven.\nThe following theorem shows that the TSP tours in a given graph of IETI, i.e., G\u2032 (the result of SPP to TSP transformation for a given SPP workspace) and the output graph of IETI, i.e., G\u2032\u2032, are the same. This implies that the TSP tour in G\u2032\u2032 is equivalent to the SPP solution of the given workspace.\nTheorem 3 The TSP tours in G\u2032 and G\u2032\u2032 are the same.\nProof: To prove this theorem, we show that the TSP tours of G\u2032 and G\u2032\u2032 are the same in terms of length and sequence of nodes. In other words, we show that the length of each finite Hamiltonian tour of G\u2032 is equal to the length of its corresponding finite Hamiltonian tour of G\u2032\u2032 (A Hamilton tour over G\u2032 and another one over G\u2032\u2032 corresponds to each other, if they have the same sequence of nodes). As already stated, any finite Hamiltonian tours in both G\u2032 and G\u2032\u2032 include all edges is the form of simi and miei (for any possible index i). Note that in such a tour, for any i, miei and simi happen consecutively and are connected through mi (as a sequence in the form of either si-mi-ei or ei-mi-si). Let us call these two consecutive edges \u201dpair of edges of ith subpath\u201d. As a result, each finite Hamiltonian tour in either G\u2032 or G\u2032\u2032 is a sequence of pairs of edges connected via some edges. Fig. 3 presents an example of Hamiltonian tour over G\u2032 and G\u2032\u2032.\nNote that the graph G\u2032 differs from the graph G\u2032\u2032 in their weights of the edges. Let H be a finite Hamiltonian tour over G\u2032 and H \u2032 be its corresponding finite Hamiltonian tour over G\u2032\u2032 (suppose that the number of subpaths is n). Without loss of generality,\nwe let the pairs of edges occur in H (also in H \u2032) according the usual order of their indices, i.e., for any index i less than n, the (i + 1)th pair happens exactly after the ith pair of edges. Suppose that the corresponding node p in G\u2032 is p\u2032 in G\u2032\u2032.\nH : e1m1,m1s1, s1e2, ..., si\u22121ei, eimi,misi, siei+1, ...,\nen\u22121sn, snmn,mnen\nand H \u2032 : e\u20321m \u2032 1,m \u2032 1s \u2032 1, s \u2032 1e \u2032 2, ..., s \u2032 i\u22121e \u2032 i, e \u2032 im \u2032 i,m \u2032 is \u2032 i, s \u2032 ie \u2032 i+1, ...,\ne\u2032n\u22121s \u2032 n, s \u2032 nm \u2032 n,m \u2032 ne \u2032 n\nDuring the ith of the IETI procedure over G\u2032, only the weights of the edges in H, which are in the form of eimi, misi, siei, eisi\u22121, and siei+1, may change and others are left without any changes. Thus, the following equations hold:\nw(eimi) + w(mi, si) = w(e \u2032 i,m \u2032 i) + w(m \u2032 i, s \u2032 i) + |dvi| (14)\nw(si\u22121, ei) = w(s \u2032 i\u22121, e \u2032 i)\u2212 |dvi|\n2\nw(si, ei+1) = w(si, ei+1)\u2212 |dvi|\n2\n(15)\nThe above equations show that changes made in weights in each step of IETI do not make the length of the corresponding tours H and H \u2032 unequal. Therefore, the length of each finite Hamilton tour in G\u2032 is equal to its corresponding tour in G\u2032\u2032."}, {"heading": "4.2 Pseudo Code and Complexity Analysis of IETI", "text": "Algorithm 2 presents the pseudo code of the IETI algorithm. This algorithm takes a graph G\u2032 (the output of the SPP to TSP transformation) and returns a graph G\u2032\u2032.\nThe loop of n iterations in lines 1 to 13 updates the weights of the subpath edges. There exist two loops within these lines each of which iterates 2n times (lines 2 and 8 to 11). Thus, the time complexity of the algorithm is in the O(n2) class."}, {"heading": "5 A 2-approximation Algorithm", "text": "The Christofides\u2019 algorithm [6] is one the most efficient approximation algorithms for solving TSP, which works for given graphs satisfying the triangle inequality condition. This algorithm has time complexity of O(n3) and the ratio bound of 1.5. Due to its complexity and ratio bound, the Christofides\u2019 algorithm is a popular approximation method for TSP.\nAlgorithm 2 : TSP Transformation and IETI\n1: for each subpath edge siei do 2: Find node d \u2208 G that minimizes R = w(si, d) + w(d, ei) 3: dv \u2190 R\u2212w(si,ei)\n2\n4: if dv < 0 then 5: w(si, ei)\u2190 w(si, ei)\u2212 |dv| 6: w(si,mi)\u2190 w(si,ei)2 7: w(ei,mi)\u2190 w(si,ei)2 8: for each node q \u2208 G where q /\u2208 {si, ei,mi} do 9: w(si, q)\u2190 w(si, q)\u2212 |dv|2\n10: w(ei, q)\u2190 w(ei, q)\u2212 |dv|2 11: end for 12: end if 13: end for\nAccording to Theorem 3, the TSP tour in G\u2032\u2032 is equivalent to the solution of SPP. However, G\u2032\u2032 violates the triangle inequality condition. Therefore, it is not feasible to use Christofides\u2019 algorithm (or any other existing fixed-ratio bound approximation algorithms) to find the TSP tour in G\u2032\u2032. Nonetheless, the triangle inequality is violated by some special triangles in G\u2032\u2032. By using this special feature, an approximation algorithm for finding the TSP tour over G\u2032\u2032, called Christofides for SPP (CSPP), is proposed with O(n3) time complexity and ratio bound of 2. CSPP can be seen as a modified version of Christofides\u2019 algorithm.\nThe CSPP algorithm contains one additional step in comparison with the Christofides\u2019 algorithm. Moreover, one step of Christofides is modified in CSPP.\nThe plan of this section is as follows. In 5.1, we discuss the CSPP algorithm. In 5.2, we show that the ratio bound of the CSPP algorithm is 2. We finally discuss the time complexity of the algorithm in 5.3."}, {"heading": "5.1 CSPP: the procedure", "text": "CSPP takes G\u2032\u2032 (the output of the IETI algorithm) as input and returns a Hamiltonian tour as output. This algorithm consists of five steps as follows:\nStep 1: Finding the Minimum Spanning Tree This step finds the minimum spanning tree (MST) over G\u2032\u2032 (one of the nodes is arbitrarily chosen as the root of the tree). This step is the same as the first step of the Christofides\u2019 algorithm [6].\nStep 2: Modify MST by Adding Subpath Edges The MST (the result of the first step) does not include an edge with infinity weight. As a consequence, a middle node of the graph G\u2032\u2032, say mi for some i, can be either\na two-degree node in the MST connected to si and ei or a leaf node in the MST connected to si or ei. In this step, for each middle node as a leaf such as mi (suppose si is the parent of mi), the edge miei is added to the MST to form a graph denoted by G\u2217. In G\u2217, the degree of any middle node is even. Fig 4 shows how this step works. As a natural consequence of this step, the overall weight of the MST increases by the sum of w(mi, ei) for any i such that mi is a leaf middle node.\nStep 3: Minimum Perfect Matching over Odd-degree Nodes This step, which is identical to one of the Christofides\u2019 steps [6], performs minimum perfect matching in G\u2032\u2032 between all odd-degree nodes in G\u2217 8 and adds the edges involved in perfect matching to G\u2217 to build a graph denoted by G\u0302. Since there is no odd-degree middle node in G\u2217, no middle node is involved in perfect matching. As a result, no infinity weight edge is added to G\u2217. Thus G\u0302 is still without any infinity weight edges.\nStep 4: Finding an Eulerian Tour Over G\u0302 The final output graph of Step 3, i.e., G\u0302, is an Eulerian graph 9. Thus, it has an Eulerian tour. An Eulerian tour is a sequence of nodes, which visits every edge exactly once. The current step (similar to Christofides\u2019) finds an Eulerian tour of G\u0302. We call the output of this step trail.\nStep 5: Confined Shortcut on trail As defined above, trail is an Eulerian tour. It is possible for an Eulerian tour to visit some nodes more than once. In order to turn an Eulerian tour into a Hamiltonian tour, the extra occurrences of nodes have to be removed. An operation, called shortcut, is used in Christofides\u2019 algorithm [6] to do such a transformation. However, G\u2032\u2032 contains some infinity weight edges and so it is not feasible to do shortcuts like in\n8Number of these nodes is even because the total degrees of nodes in a graph is even. 9a connected graph with even-degree nodes\nthe Christofides\u2019 algorithm. This is because it may add infinity edges to the tour. To address this problem, we introduce a new operation, called confined shortcut. The procedure of this operation is discussed in the following.\nConsider a node v such that it is visited more than once in trail. Let w and u denote the predecessor and successor in one of v\u2019s occurrences in the tour, respectively. In this case, it is feasible to add an edge uw to the tour and remove the edges uv and vw to decrease the number of occurrences of v by one. We keep doing this process until the number of occurrences of v in the tour get to one. If one of the nodes u and w is a middle node, then the weight of the edge uw is infinity and so performing the confined shortcut operation would result in adding an infinity edge to the tour. To resolve this problem, we avoid performing the confined shortcut operation over u-v-w and in place of that the operation is done over other occurrences of v. Lemma 1 shows that performing confined shortcut over at most one of the occurrences of v in trail may lead to adding an infinity edge. Thus, in order to build a finite Hamiltonian tour, confined shortcuts can be performed over other occurrences to avoid adding infinity weight edges. In fact, differences between shortcut in [6] and confined shortcut are in the two following issues: 1) Performing confined shortcuts in only three consecutive nodes in the tour; 2) avoiding performing confined shortcut whenever it leads to adding an infinity weight edge.\nIn step 5, it is possible to have a sequence like x-p0-p1- . . . - pm-y in which, for all i (0 \u2264 i \u2264 m), pi is already visited. In Christofieds\u2019 shortcut, all nodes pi are removed in one step and then edge x-y is added to the tour. On the other hand, in each step of confined shortcut, only one node is removed. Lemma 2 shows that doing confined shortcut on such cases is doable.\nLemma 1 For each node v in trail (the Eulerian tour generated by step 4 of the CSPP algorithm), doing confined shortcut (step 5 of the algorithm) adds infinity wight edges for at most one of the v\u2019s occurrences.\nProof: According to the steps 2, 3, and 4, G\u0302 does not have any infinity edges. The node v in G\u0302 can be either head or tail of a subpath (i.e. si or ei for some i) or a middle node (i.e., mi for some i). In the former case, v (equal to si or ei) is not a neighbour of a middle node in G\u0302, unless the neighbour middle node is mi (if v is a neighbour of mj where j 6= i, then the edge vmj has the infinity weight in G\u0302). In the latter case, v is a middle node, say mi. In this case, v cannot have any other middle nodes, say mj for j 6= i, as its neighbour in G\u0302, since the weight of mimj is infinity. Therefore, only one neighbour of v in G\u0302 would be a middle node.\nMoreover, according to operations involved in steps 1 to 4, no middle node has a multiple edge in G\u0302 10. As a result, at most one occurence of v can appear next to a\n10A node x has multiple edge in a graph, if there exists another node y such that there are two or more edges between x and y.\nmiddle node in trail and doing shortcut over that specific occurence leads to adding an infinity weight edge.\nIn G\u0302 no middle node has a multiple edge. It is worth pointing out that if G\u0302 includes a multiple edge connected to a middle node, then there exist some cases like one shown in Fig. 5, where trail over graph includes sequences like simisi. In this case, removing each of the occurrences of si (by using confined shortcut) leads to adding an infinity weight edge. Therefore, the step 5 of CSPP is not feasible in such cases, since it may add infinity weight edges to the Hamiltonian tour of CSPP.\nLemma 2 Consider an Eulerian tour with a subsequence x-p0-p1-. . .-pm-y in which each node pi, for any i (0 \u2264 i \u2264 m), has been already visited. Multiple applying of confined shortcut (according to step 5) on this Eulerian tour makes the number of occurrences of nodes pi (for all i) to reduced to 1 and also it does not add any infinity edge to the tour.\nProof: Since each pi has been visited already before x in the Eulerian tour, the number of its occurrences in the tour would be more than 1. The degree of each middle node in G\u0302 is 2. Therefore, the number of occurrences of middle nodes in an Eulerian tour of this graph would be 1. This implies that none of the nodes pi (1 \u2264 i \u2264 m) is a middle node (note the premise in the lemma stating that pi has been already visited). Thus, only one of the following cases would be possible:\n1. x is a middle node and y is not:\nIn this case, confined shortcut acts in the way as follows. First, the sequence with the first three nodes, i.e., x-p0-p1, is investigated. Since x is a middle node, removing p0 results in adding the edge x-p1, which has infinity weight. Thus, confined shortcut is not applicable on this sequence, which means p0 is not removed. In the next sequence, i.e., p0-p1-p2, confined shortcut is applicable, since the nodes p0 and p1 are not middle nodes. Applying confined shortcut on this sequence, p1 is removed, the edge p0-p2 is added into the tour, and the subsequence would be turned into x-p0-p2-\u00b7 \u00b7 \u00b7 -pm-y. Similarly, in the next step, confined shortcut is applied on p0-p2-p3 and p2 is removed. This procedure is continued until the subseqeunce is turned into x-p0-y. Since, according to Lemma 1, applying confined shortcut on at most one of the p0\u2019s occurrences makes adding an infinity edge (in this case, x-p0-p1), confined shortcut can be applied on other occurrences of p0 to make the number of its occurrences equal to 1.\n2. y is a middle node and x is not:\nLike the case 1, multiple applying of confined shortcut, the subsequence would be turned into x-pm-y. Since y is a middle node, applying confined shortcut\n1 2 43\n..\u2026 . ..\u2026 .\n..\u2026 .\nc\n..\u2026 .\na\n43\nsi ei\nmib d\nAs we saw above, in all cases, the number of occurrences of each of the nodes p0, \u00b7 \u00b7 \u00b7 , pm is reduced to 1 by multiple applying of confined shortcut without adding any infinity edge.\nAfter the fifth step, according to Lemma 1, the resulting Hamiltonian tour, denoted by h-trail, does not include any infinity weight edge."}, {"heading": "5.2 Ratio Bound of CSPP Algorithm", "text": "In this section, it is shown that the ratio bound of CSPP is 2. Lemmas 3 and 5 are adapted from [6]. The proofs of them can be found in Appendix. A.\nLemma 3 The weight of MST is less than the weight of T \u2217, where T \u2217 is the optimal TSP tour in G\u2032\u2032.\nRemark 2 The notation W (H) denotes the sum of edge weights of a given graph H. T \u2217 and PM\u2217 denote the TSP tour in G\u2032\u2032 and edges of perfect matching in step 3, respectively.\nLemma 4 The total added weight to MST during the second step is less than the half of the weight of T \u2217.\nProof: During the second step, for each middle leaf node mi (for some i) in MST, w(ei,mi) is added to the weight of MST. Therefore, W (E2) \u2264 \u2211n i=1w(ei,mi) = 1 2 \u2211n i=1w(si,mi) + w(ei,mi), where W (E2) is the total weights of added edges to MST during this step. T \u2217 does not include any infinity weight edge. Thus, for each subpath, say ith, T \u2217 includes the edges simi and eimi, which implies W (T\n\u2217) >\u2211n i=1w(si,mi) +w(ei,mi). Therefore, the inequality W (E2) < 0.5W (T\n\u2217) holds. The lemma is proven.\nLemma 5 PM\u2217\u2019s weight is less than half of T \u2217\u2019s.\nTheorem 4 The ratio bound of CSPP is 2.\nProof: The graph G\u0302 is composed of the edges of the MST and the edges added in steps 2 and 3 (perfect matching). According to Lemmas 3, 4 and 5,\nW (G\u0302) = W (MST) +W (E2) +W (PM \u2217)\n\u2264 2W (T \u2217) (16)\n, where G\u0302 denotes the graph generated in step 3 of CSPP, MST denotes the output tree of step 1, E2 denotes the set of edges which are added to MST in step 2, and PM\u2217 denotes edges of perfect matching in step 3. Thus, the length of trail over G\u0302 (found in step 4) is less than 2 times of the optimal TSP tour.\ntrail does not contain any infinity weight edges, since the edges of G\u0302 are not infinity weight edges. Moreover, based on Lemma 1, performing shortcuts during step 5 does not add any infinity edge. Accordingly, the triangles used in performing confined shortcut (for each confined shortcut two edges of tour corresponding to a triangle are replaced with the third edge of triangle) do not include any infinity edge.\nThus, based on Theorem 2, triangle inequality is not violated in these triangles. Thus, for each execution of confined shortcuts (during step 5), the length of the tour decreases. Hence, the length of the Hamiltonian tour, h-trail, returned by CSPP is less than the length of trail and the following statement holds:\nW (h-trail) \u2264 W (trail) = W (G\u0302) \u2264 2W (T \u2217) (17)\nHence, the solution produced by CSPP is within 2 of optimum. Therefore, the ratio bound of CSPP is 2."}, {"heading": "5.3 Pseudo Code and Complexity Analysis of CSPP", "text": "In this section, the time complexity of the approximation algorithm CSPP is discussed in term of the number of subpaths. Algorithm 3 is a pseudo code for this algorithm, which takes G\u2032\u2032 (the output of the IETI algorithm) as input and returns a Hamiltonian tour called h-trail. Let the number of subpaths in the given workspace be n. Then the graph G\u2032\u2032 has 3n nodes and 9n2 edges.\nComplexity analysis of Step 1 (line 1): MST can be found using Kruskal\u2019s algorithm [20] or Prim\u2019s algorithm [31]. Two implementations of these algorithms are Improved Implementation of Kruskal Algorithm and Fibonacci Heap Implementation of Prim\u2018s Algorithm [1], respectively, which both are in O(|E|+|V | log |V |) complexity class. Since the numbers of nodes and edges are 3n and 9n2, respectively, the total complexity of this step would be in O(n2).\nComplexity analysis of Step 2 (lines 2 to 9): This step includes a loop of n iterations, where each iteration takes O(1) time. Thus, the total complexity of this step is in O(n).\nComplexity analysis of Step 3 (lines 10 and 11): The modified version of Edmond\u2019s Blossom Shrinking algorithm in [25] can be used to do perfect matching, which requires O(|V |3) running time. The total number of odd-degree nodes in G\u2217 is in the O(n) class. Thus, complexity of perfect matching would be in the O(n3) class. Furthermore, the number of nodes involved in perfect matching is in O(n). Therefore, adding the perfect matching edges to G\u2217 (line 11) is in O(n). As a result, step 3 requires O(n3) running time.\nComplexity of Step 4 (line 12): One can use Fleury algorithm [29] to find Eulerian tour, which has the running time complexity of O(|E|). G\u0302 includes the following kinds of edges: 1) the edges of MST (O(n) edges) 2) the edges between misi or miei, which are added in step 2 (O(n) edges) 3) the edges of perfect matching (O(n) edges). Thus, the total number of the edges in G\u0302 is in the O(n) class. This implies that the running time of Fleury algorithm on G\u0302 is in the O(n) class.\nComplexity analysis of Step 5 (lines 13 to 34): trail in line 12 is the output of step 4. In line 13, trail is copied into h-trail. Hence, according to Lemma 1, confined shortcut (step 5) can be applied on h-trail in order to produce a finite Hamiltonian\nAlgorithm 3 CSPP\n1: Find the minimum spanning tree, MST 2: for all subpaths such as i do 3: if mi is a leaf node and si is the parent of mi then 4: Add edge miei 5: end if 6: if mi is a leaf node and ei is the parent of mi then 7: Add edge misi 8: end if 9: end for\n10: Do perfect matching over odd-degree nodes in G\u2217 11: Add perfect matching edges to G \u2217 and construct G\u0302\n12: Find Eulerian tour, trail, in G\u0302 13: h-trail \u2190 trail 14: Make visit zero for all nodes in G\u2032\u2032 15: while has not reached the end of h-trail do 16: select the next node in t in forward order 17: visit(t)\u2190 visit(t) + 1 18: if visit(t) \u2265 2 then 19: t0 \u2190 the node appears before t in h-trail 20: t1 \u2190 the node appears after t in h-trail 21: if w(t0, t1) is finite then 22: Delete node t 23: visit(t)\u2190 visit(t)\u2212 1 24: end if 25: end if 26: end while 27: while has not reached the end of h-trail do 28: Select the next node t in h-trail forward order 29: if visit(t) == 2 then 30: Delete node t 31: visit(t)\u2190 visit(t)\u2212 1 32: end if 33: end while 34: return h-trail\ntour. The procedure of confined shortcut is shown in lines 14 to 33. In order to perform confined shortcut, h-trail is explored two times from head to tail (lines 15 to 26 and lines 27 to 33). If during an exploration (moving along all members of h-trail) performing a confined shortcut leads to adding an edge with infinity weight, that particular shortcut will not be performed.\nOne can think of h-trail as a list of nodes. Lines 16 to 25 iterates over all members of this list. At each iteration, visit(t) shows the number of occurrences of node t in h-trail up to the current index of the list. If the number of occurrences of a node is more than 1 (line 18), its current occurrence is removed (line 22) provided that performing confined shortcut (t0-t-t1) does not add an infinity edge (line 21). As a result, only the first occurrence of a node is kept and the rest are removed. According to Lemma 1, two scenarios can happen for a node t in h-trail: 1) performing confined shortcut over one of its occurrences adds an infinity edge, 2) performing confined shortcut over each occurrence never adds an infinity edge. Therefore, after executing the loop in lines 15 to 26, one of the three following cases can occur for a node t:\n1. Performing confined shortcut over each occurrence of t does not add an infinity edge. In this case, only the first occurrence of t remains in h-trail and the others are removed. This makes the value of visit(t) equal to 1.\n2. Performing confined shortcut over the first occurrence of t adds an infinity edge. Similar to the previous case, only the first occurrence is kept in the list and the others are removed. Therefore, the value of visit(t) would be 1 after executing the loop.\n3. Performing confined shortcut over one of the t\u2019s occurrences (not the first one) adds an infinity edge. In this case, two occurrences are kept and the others are removed. The kept occurrences are the first one and the occurrence that results in adding an infinity edge. In this case, the value of visit(t) would be 2.\nAs already mentioned, to turn an Eulerian tour to a Hamiltonian one, the occurrences of each node must be reduced to one. To this end, the execution of lines 27 to 33 reduces the value of visit for those nodes that are visited more than once (nodes in the case 3 above).\nPerforming confined shortcut on the second occurrence of nodes belonging to the case 3 leads to adding an infinity edge. Therefore, confined shortcut must be performed over the first occurrence of nodes. Lines 28 to 32 iterate over each element of h-trail. Line 29 detects the first occurrence of nodes belonging to the case 3. Then, confined shortcut is performed on the first occurrence and the number of visits is reduced to one (line 30).\nAt the end of the first exploring, the number of occurrences of each node can be up to two, while at the end of the second exploring, this number is exactly one. These explorations can prevent us from moving constantly back and forth over h-trail.\nThe time of exploring h-trail is linearly dependent to the number of its edges, which is equal to the number of G\u0302\u2019s edges (the number of edges in G\u0302 is in the O(n) class). As a consequence, the complexity of each exploration is in O(n) and, hence, the overall complexity of this step would be in O(n).\nAccording to the complexity class of each step (discussed above), the total complexity of CSPP would be in the O(n3) class."}, {"heading": "6 Experiments and Results", "text": "In this section, we empirically gauge the performance of CSPP by comparing it with the method proposed by Gyorfi et al. [16], which uses GA. For simplicity, throughout this section, this method is referred by Gyorfi GA. For comparison, we use different sets of workspaces including 3 workspaces with 20 subpaths, 3 workspaces with 50 subpaths and 3 workspaces with 80 subpaths. The subpaths of each workspace were built randomly in different lengths and different locations. Any of the 9 randomly generated workspaces can be seen as a sample for a real work application. For instance, they can be a scratch on a surface that a robot should smooth.\nIn the Gyorfi GA method, each feasible solution of the problem is shown with a fixed length augmented chromosome with length of n. Each augmented chromosome such as e, consists two chromosomes such as c and d shown in Fig. 6. Each gene of chromosome d can take value 0 or 1, which indicates the connection between two subpath. For any i, d(i) = 0 shows that the head of the subpath c(i) is connected to the subpath c(i + 1). Similarly, d(i) = 1 shows that the tail of c(i) is connected to c(i + 1). Five different genetic operations are used in the Gyorfi GA method. \u201cThe crossover operator produces an offspring chromosome by combining genes from two parent chromosomes. The inversion operator changes a region of a parent chromosome by inverting the order of the genes in the region. The rotation operator changes a region of a parent chromosome by rotating the genes in the region in manner similar to a circular shift register. The mutation operator exchanges two genes in a parent chromosome. The subpath reversal operator changes the direction flag of randomly chosen genes within a parent chromosome\u201d[16].\nParameter setting for the operation rates of Gyorfi GA were chosen to be 0.5 for\ncrossover, 0.25 for inversion, 0.25 for rotation, 0.5 for mutation and 0.5 for subpath reversal. These parameters are fixed during all experiments and seem to be near optimal set of parameters, according to the results of different parameter settings. Each of the methods were executed 30 times over each environment.\nTable 1 compares means and standard deviations (in parenthesis) of 30 executions of CSPP and Gyorfi GA (population size is 100) in three environments with 20 supaths. Gyorfi GA iterates until it converges (all of the executions converged at 150 iteratios at most). The results indicate that Gyorfi GA returns longer outputs with more time consumption (in average CSPP is more than 8.55 times efficient than Gyorfi GA in terms of time consumption).\nLikewise, both methods were executed in the workspaces with 50 and 80 subpaths over 30 iteratios the results of which are shown in Tables 2 and 3. The population sizes for these experiments are 200 and 300, respectively. Roughly, the Gyorfi GA converges after 300 and 500 iteratios for workspaces with 50 and 80 subpaths. According to Tables 2 and 3, Gyorfi GA leads to less efficient results both in terms of length of output and time. Technically speaking, the time that the Gyorfi GA method spends is more than 7.28 and 2.97 times than CSPP uses to generate the final results.\nAccording to Table 4, using CSPP in place of Gyorfi GA provides an average improvement of 86.7% and 0.33% in execution time and result\u2019s length, respectively. Note that these improvements happen while the average rate of deviation in both execution time and result\u2019s length in Gyorfi GA (0.13 and 32.2, respectively) are reduced to 0 in CSPP.\nSimilarly, according to Tables 5 and 6, CSPP improves the average execution time\n85.5% and 66.8% in workspaces with 50 and 80 subpaths, respectively. Also, result\u2019s length is improved 4.43% and 6.13% in average, respectively. The average rate of deviation in both execution time and result\u2019s length in Gyorfi GA are reduced to 0 in CSPP. Note that the average rate of deviation in time and length in Gyorfi GA are, respectively, 3.73 and 49.4 in workspaces with 50 subpaths and 8.6, 77 in workspaces with 80 subpaths.\nComparing the outputs of the two algorithm, we get the following results:\n1. Increasing the number of subpaths causes a pretty huge increase in the rate of deviation in both execution time and result\u2019s length in Gyorfi GA. This implies that uncertainty in Gyorfi GA increases by increasing the number of subpaths in the same environment, whereas this is not the case in CSPP. Since the rate of deviation is 0 for both execution time and result\u2019s length in CSPP, it always delivers a certain result in a certain time for a given input.\n2. As we see in the third columns of the Tables 4, 5, and 6, the CSPP algorithm delivers better results than Gyorfi GA does. Also, it is more intriguing that the efficiency of CSPP remarkably increases in comparison with Gyorfi GA by increasing the number of subpaths: the average length improvement increases from 0.33% to 6.13% by increasing the number of subpaths from 20 to 80.\n3. The CSPP algorithm is much more faster than the Gyorfi GA algorithm to solve SPP in all above experiments."}, {"heading": "7 Conclusion and Future Works", "text": "In this paper, we have proposed a method to transform SPP to TSP. Transforming SPP to TSP allows us to use existing algorithms for solving TSP in the subpath planning context. However, violation of triangle inequality hinders applying existing fixed-ratio bound approximation algorithms such as Christofides for SPP. To address this problem, we have proposed the algorithm IETI, which makes a main subset of violating triangles to satisfy the triangle inequality condition. The IETI algorithm should be seen as a fundamental step in proposing and applying fixed-ratio bound approximation algorithms for solving SPP. Using this method, a fixed-ratio bound approximation algorithm, called CSPP, has been proposed to find a near optimal solution for SPP. CSPP Solves TSP over the output graph of IETI algorithm. CSPP is similar to the Christofides\u2019 algorithm regarding time complexity, but its ratio bound (the fixed ratio bound of 2) is more than the Christofides\u2019 algorithm. This is natural, since CSPP can be executed over some graphs, which cannot be in the domain of Christofides\u2019 algorithm.\nAlthough we theoretically showed that CSPP has reasonable time complexity with a small fixed ratio bound, experiments also indicate that the algorithm is a fast algorithm with more efficient results in comparison with a state-of-the-art method Gyorfi GA. Moreover, the differences between efficiency of these algorithms becomes much more significant as the number of subpaths increases.\nWe think that it would be possible to improve the results of the CSPP method using some improvement methods such as Lin-Kernighan [23] and Helsgaun [17].\nWe plan to propose some algorithms with smaller ratio bounds. Indeed, we try to improve the ratio bound of the CSPP algorithm using some heuristic-based methods. One important guide line could be using the graph generated by the IETI algorithm as an input for a modified version of the RPP algorithm [11].\nOur algorithms solve SPP without considering any constraints, say some priorities over subpaths or environments with obstacles. We also plan to solve SPP for some certain applications with some constraints.\nCSPP is neither a meta-heuristic nor a stochastic method. It may be possible to propose some meta-heuristic based methods such as tabu search and simulated annealing based on the TSP model of a given SPP to generate more efficient results in the case of offline tasks. We can initialize such algorithms with the solutions found by CSPP to improve the output of such meta-heuristic methods."}, {"heading": "A Proofs of Lemma 3 and Lemma 5", "text": "The proofs of Lemmas 3 and 5 are adapted from [6].\nProof: [Proof of Lemma 3] Suppose H is a Hamiltonian tour which is constructed by subtracting an arbitrary edge of T \u2217. Note that H is a spanning tree of G. Hence:\nW (MST ) \u2264 W (H) < W (T \u2217) (18)\nProof: [Proof of Lemma 5] For an n-city TSP, consider T \u2217 = (xi1 , xi2 , ..., xin). Starting from vertex xi1 and travelling round the circuit T\n\u2217, allocate the links traversed in an alternating manner to two sets M1 and M2. Starting with M1, for example: M1 = {(xi1 , xi2), (xi3 , xi4), ..., (xin\u22121 , xin)} and M2 = {(xi2 , xi3), (xi4 , xi5), ..., (xin , xi1)}. M1 and M2 are matching of G and W (M1) + W (M2) = W (T\n\u2217). Since M1 and M2 are defined arbitrarily we can assume W (M1) \u2264 W (M2) without loss of generality, and so we have: W (PM) \u2264 W (M1) \u2264 12W (T \u2217). Hence, the lemma is proved."}], "references": [{"title": "Network flows: Theory", "author": ["R. Ahuja", "T. Magnanti", "J. Orlin"], "venue": "algorithms, and applications", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1993}, {"title": "Approximation algorithms for the geometric covering salesman problem", "author": ["E.M. Arkin", "R. Hassin"], "venue": "Discrete Applied Mathematics, 55(3):197\u2013218", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1994}, {"title": "Complexity and approximation: Combinatorial optimization problems and their approximability properties", "author": ["G. Ausiello"], "venue": "Springer Verlag", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1999}, {"title": "Metaheuristics in combinatorial optimization: Overview and conceptual comparison", "author": ["C. Blum", "A. Roli"], "venue": "ACM Computing Surveys (CSUR), 35(3):268\u2013308", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "Coupled path planning", "author": ["D. Chen", "S. Luan", "C. Wang"], "venue": "region optimization, and applications in intensity-modulated radiation therapy. Algorithmica, 60(1):152\u2014174", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Worst-Case analysis of a new heuristic for the travelling salesman problem", "author": ["N. Christofides"], "venue": "Technical report, DTIC Document", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1976}, {"title": "A heuristic for the stacker crane problem on trees which is almost surely exact", "author": ["A. Coja-Oghlan", "S.O. Krumke", "T. Nierhoff"], "venue": "Journal of Algorithms, 61(1):1\u201319", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2006}, {"title": "Approximation algorithms for tsp with neighborhoods in the plane", "author": ["A. Dumitrescu", "J.S. Mitchell"], "venue": "Proceedings of the twelfth annual ACM-SIAM symposium on Discrete algorithms, pages 38\u201346. Society for Industrial and Applied Mathematics", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2001}, {"title": "Arc routing problems", "author": ["H.A. Eiselt", "M. Gendreau", "G. Laporte"], "venue": "part i: The chinese postman problem. Operations Research, 43(2):231\u2013242", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1995}, {"title": "Arc routing problems", "author": ["H.A. Eiselt", "M. Gendreau", "G. Laporte"], "venue": "part ii: The rural postman problem. Operations Research, 43(3):399\u2013414", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1995}, {"title": "Approximation algorithms for some postman problems", "author": ["G.N. Frederickson"], "venue": "Journal of the ACM (JACM), 26(3):538\u2013554", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1979}, {"title": "Approximation algorithms for some routing problems", "author": ["G.N. Frederickson", "M.S. Hecht", "C.E. Kim"], "venue": "Foundations of Computer Science, 1976., 17th Annual Symposium on, pages 216\u2013227. IEEE", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1976}, {"title": "Computers and intractability. a guide to the theory of np-completeness. a series of books in the mathematical sciences, ed", "author": ["M. Garey", "D. Johnson"], "venue": "v. klee", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1979}, {"title": "The corridor map method: a general framework for real-time high-quality path planning", "author": ["R. Geraerts", "M. Overmars"], "venue": "Computer Animation and Virtual Worlds, 18(2):107\u2014119", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "Genetic algorithms in search", "author": ["D. Goldberg"], "venue": "optimization, and machine learning. Addison-wesley", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1989}, {"title": "Evolutionary path planning with subpath constraints", "author": ["J. Gyorfi", "D. Gamota", "S. Mok", "J. Szczech", "M. Toloo", "J. Zhang"], "venue": "IEEE Transactions on Electronics Packaging Manufacturing, 33(2):143\u2014151", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2010}, {"title": "An effective implementation of the Lin-Kernighan traveling salesman heuristic", "author": ["K. Helsgaun"], "venue": "European Journal of Operational Research, 126(1):106\u2014130", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2000}, {"title": "The traveling salesman problem: A case study in local optimization", "author": ["D. Johnson", "L. McGeoch"], "venue": "Local search in combinatorial optimization, pages 215\u2014310", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1997}, {"title": "Reducibility among combinatorial problems", "author": ["R. Karp"], "venue": "volume 40. Springer", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1972}, {"title": "On the shortest spanning subtree of a graph and the traveling salesman problem", "author": ["J. Kruskal"], "venue": "Proceedings of the American Mathematical society, 7(1):48\u201450", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1956}, {"title": "The traveling salesman problem: An overview of exact and approximate algorithms", "author": ["G. Laporte"], "venue": "European Journal of Operational Research, 59(2):231\u2014247", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1992}, {"title": "Complexity of vehicle routing and scheduling problems", "author": ["J.K. Lenstra", "A. Kan"], "venue": "Networks, 11(2):221\u2013227", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1981}, {"title": "An effective heuristic algorithm for the travelingsalesman problem", "author": ["S. Lin", "B. Kernighan"], "venue": "Operations research, pages 498\u2014516", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1973}, {"title": "Approximation algorithms for geometric tour and network design problems", "author": ["C.S. Mata", "J.S. Mitchell"], "venue": "Proceedings of the eleventh annual symposium on Computational geometry, pages 360\u2013369. ACM", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1995}, {"title": "An o (v| v| c| e|) algoithm for finding maximum matching in general graphs", "author": ["S. Micali", "V. Vazirani"], "venue": "Foundations of Computer Science, 1980., 21st Annual Symposium on, pages 17\u201427", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1980}, {"title": "Computers and intractability: A guide to the theory of np-completeness", "author": ["R.G. Michael", "D.S. Johnson"], "venue": "WH Freeman & Co., San Francisco", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1979}, {"title": "A fundamental problem in vehicle routing", "author": ["C. Orloff"], "venue": "Networks, 4(1):35\u201364", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1974}, {"title": "The euclidean travelling salesman problem is np-complete", "author": ["C.H. Papadimitriou"], "venue": "Theoretical Computer Science, 4(3):237\u2013244", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1977}, {"title": "Computational discrete mathematics: combinatorics and graph theory with Mathematica", "author": ["S. Pemmaraju", "S. Skiena"], "venue": "Cambridge Univ Pr", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2003}, {"title": "Reliable robust path planning with application to mobile robots", "author": ["R. Pepy", "M. Kieffer", "E. Walter"], "venue": "International Journal of Applied Mathematics and Computer Science, 19(3):413\u2013424", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2009}, {"title": "Shortest connection networks and some generalizations", "author": ["R. Prim"], "venue": "Bell system technical journal, 36(6):1389\u20141401", "citeRegEx": "31", "shortCiteRegEx": null, "year": 1957}, {"title": "On the complexity of approximating tsp with neighborhoods and related problems", "author": ["S. Safra", "O. Schwartz"], "venue": "computational complexity, 14(4):281\u2013307", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2006}, {"title": "P-complete approximation problems", "author": ["S. Sahni", "T. Gonzalez"], "venue": "Journal of the ACM (JACM), 23(3):555\u2013565", "citeRegEx": "33", "shortCiteRegEx": null, "year": 1976}, {"title": "Tool path planning for compound surfaces in spray forming processes", "author": ["W. Sheng", "H. Chen", "N. Xi", "Y. Chen"], "venue": "Automation Science and Engineering, IEEE Transactions on, 2(3):240\u2013249", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2005}, {"title": "A path planning-based study of protein folding with a case study of hairpin formation in protein g and l", "author": ["G. Song", "S. Thomas", "K. DILL", "J. Scholtz", "N. Amato"], "venue": "Proc. Pacific Symposium of Biocomputing (PSB), pages 240\u2014251", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2002}, {"title": "A motion planning approach to studying molecular motions", "author": ["L. Tapia", "S. Thomas", "N. Amato"], "venue": "Communications in Information & Systems, 10(1):53\u201468", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2010}, {"title": "Research of path planning for polishing robot based on improved genetic algorithm", "author": ["G. Tong-ying", "Q. Dao-kui", "D. Zai-li"], "venue": "Robotics and Biomimetics, 2004. ROBIO 2004. IEEE International Conference on, pages 334\u2014338", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2004}, {"title": "Asymptotically optimal algorithms for one-to-one pickup and delivery problems with applications to transportation systems", "author": ["K. Treleaven", "M. Pavone", "E. Frazzoli"], "venue": "For an n-city TSP,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2013}], "referenceMentions": [{"referenceID": 29, "context": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36].", "startOffset": 79, "endOffset": 83}, {"referenceID": 13, "context": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36].", "startOffset": 168, "endOffset": 172}, {"referenceID": 4, "context": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36].", "startOffset": 186, "endOffset": 189}, {"referenceID": 34, "context": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36].", "startOffset": 206, "endOffset": 210}, {"referenceID": 33, "context": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36].", "startOffset": 234, "endOffset": 238}, {"referenceID": 35, "context": "Path planning is a challenging problem in artificial intelligence and robotics [30] with applications also in other areas such as computer animation and computer games [14], therapeutic [5] protein folding [35], manufacturing process [34] and computational biology [36].", "startOffset": 265, "endOffset": 269}, {"referenceID": 15, "context": "SPP has widespread applications such as navigation of robots and vehicles as well as automated manufacturing process [16, 37].", "startOffset": 117, "endOffset": 125}, {"referenceID": 36, "context": "SPP has widespread applications such as navigation of robots and vehicles as well as automated manufacturing process [16, 37].", "startOffset": 117, "endOffset": 125}, {"referenceID": 12, "context": "SPP is an NP-hard problem [13, 19].", "startOffset": 26, "endOffset": 34}, {"referenceID": 18, "context": "SPP is an NP-hard problem [13, 19].", "startOffset": 26, "endOffset": 34}, {"referenceID": 36, "context": "[37] and Gyorfi et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16] proposed some algorithms based on Genetic Algorithm (GA) [15] for solving SPP in polishing robots and electronic printing, respectively.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[16] proposed some algorithms based on Genetic Algorithm (GA) [15] for solving SPP in polishing robots and electronic printing, respectively.", "startOffset": 62, "endOffset": 66}, {"referenceID": 3, "context": "Like other meta-heuristic methods [4], GA cannot guarantee any bound on its final result.", "startOffset": 34, "endOffset": 37}, {"referenceID": 2, "context": "The current paper aims at overcoming the problems of meta-heuristic methods in solving SPP by proposing an approximation algorithm [3] with a fixed ratio bound and efficient polynomial complexity.", "startOffset": 131, "endOffset": 134}, {"referenceID": 17, "context": "The first stage is transforming SPP to Travelling Salesman Problem (TSP) [18] with an O(n) time complexity algorithm.", "startOffset": 73, "endOffset": 77}, {"referenceID": 18, "context": "Since TSP is an NP-hard problem [19], proposing a precise algorithm for solving TSP does not make sense.", "startOffset": 32, "endOffset": 36}, {"referenceID": 5, "context": "Christofides in [6] argues that there is no polynomial approximation algorithm with a fixed ratio bound for general TSP.", "startOffset": 16, "endOffset": 19}, {"referenceID": 5, "context": "Literally, we cannot propose any fixed ratio bound approximation algorithm on a general graph, in which the triangle inequality does not hold in all triangles [6] (this observation is also due to Sahni and Gonzale [33]).", "startOffset": 159, "endOffset": 162}, {"referenceID": 32, "context": "Literally, we cannot propose any fixed ratio bound approximation algorithm on a general graph, in which the triangle inequality does not hold in all triangles [6] (this observation is also due to Sahni and Gonzale [33]).", "startOffset": 214, "endOffset": 218}, {"referenceID": 5, "context": "However, there are some fixed-ratio bound approximation algorithms such as Christofides\u2019 algorithm [6], for solving TSP over constrained graphs, which satisfy triangle inequality.", "startOffset": 99, "endOffset": 102}, {"referenceID": 5, "context": "Indeed, the CSPP algorithm is a modified version of the Christofides\u2019 algorithm [6] to make it able to work for all outputs of the IETI algorithm.", "startOffset": 80, "endOffset": 83}, {"referenceID": 15, "context": "[16] over various workspaces with different number of subpaths.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16] is presented in Section 6.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "This set of problems includes Travelling Salesman Problem with Neighbours (TSPN) and those that are in the context of Arc Routing Problems (ARP) [9, 10].", "startOffset": 145, "endOffset": 152}, {"referenceID": 9, "context": "This set of problems includes Travelling Salesman Problem with Neighbours (TSPN) and those that are in the context of Arc Routing Problems (ARP) [9, 10].", "startOffset": 145, "endOffset": 152}, {"referenceID": 1, "context": "Travelling Salesman Problem with Neighbours: Travelling Salesman Problem with Neighbours (TSPN) is introduced by Arking and Hassin [2].", "startOffset": 131, "endOffset": 134}, {"referenceID": 25, "context": "Since TSPN is a generalization of TSP, it is also NP-hard [26, 28].", "startOffset": 58, "endOffset": 66}, {"referenceID": 27, "context": "Since TSPN is a generalization of TSP, it is also NP-hard [26, 28].", "startOffset": 58, "endOffset": 66}, {"referenceID": 31, "context": "Besides, Safra and Schwartz [32] showed that it is NP-hard to approximate within any constant bound.", "startOffset": 28, "endOffset": 32}, {"referenceID": 23, "context": "For the general case of connected polygons, Mata and Mitchell [24] proposed an O(log n) approximation bound with O(N) time complexity based on \u201dguillotine rectangular subdivisions\u201d, where N is the total number of vertices of the polygons.", "startOffset": 62, "endOffset": 66}, {"referenceID": 7, "context": "If all the polygons have the same diameter, then an O(1) algorithm also exists [8].", "startOffset": 79, "endOffset": 82}, {"referenceID": 9, "context": "Otherwise (the given graph is neither purely directed nor undirected), the problem would be NP-hard [10].", "startOffset": 100, "endOffset": 104}, {"referenceID": 26, "context": "RPP was first introduced by Orloff [27].", "startOffset": 35, "endOffset": 39}, {"referenceID": 10, "context": "The undirected, directed and mixed versions of RPP are all proven to be NP-hard [11, 22].", "startOffset": 80, "endOffset": 88}, {"referenceID": 21, "context": "The undirected, directed and mixed versions of RPP are all proven to be NP-hard [11, 22].", "startOffset": 80, "endOffset": 88}, {"referenceID": 10, "context": "Frederickson [11] proposed a polynomial time solution for RPP with the worst case ratio bound of 1.", "startOffset": 13, "endOffset": 17}, {"referenceID": 11, "context": "Stacker Crane Problem: The Stacker Crane Problem (SCP) [12] is another relevant problem in the context of routing.", "startOffset": 55, "endOffset": 59}, {"referenceID": 6, "context": "[7] proposed an approximation approach for a special case of SCP.", "startOffset": 0, "endOffset": 3}, {"referenceID": 11, "context": "[12] proposed a polynomial algorithm for this problem with the ratio bound of 1.", "startOffset": 0, "endOffset": 4}, {"referenceID": 37, "context": "The Fredrickson\u2019s solution for SCP is known to be the best approximation algorithm [38].", "startOffset": 83, "endOffset": 87}, {"referenceID": 20, "context": "In the recent decades, various approximation [21] and combinatorial optimization methods [18] have been proposed for solving this problem.", "startOffset": 45, "endOffset": 49}, {"referenceID": 17, "context": "In the recent decades, various approximation [21] and combinatorial optimization methods [18] have been proposed for solving this problem.", "startOffset": 89, "endOffset": 93}, {"referenceID": 5, "context": "The Christofides\u2019 algorithm [6] is one the most efficient approximation algorithms for solving TSP, which works for given graphs satisfying the triangle inequality condition.", "startOffset": 28, "endOffset": 31}, {"referenceID": 5, "context": "This step is the same as the first step of the Christofides\u2019 algorithm [6].", "startOffset": 71, "endOffset": 74}, {"referenceID": 5, "context": "Step 3: Minimum Perfect Matching over Odd-degree Nodes This step, which is identical to one of the Christofides\u2019 steps [6], performs minimum perfect matching in G\u2032\u2032 between all odd-degree nodes in G\u2217 8 and adds the edges involved in perfect matching to G\u2217 to build a graph denoted by \u011c.", "startOffset": 119, "endOffset": 122}, {"referenceID": 5, "context": "An operation, called shortcut, is used in Christofides\u2019 algorithm [6] to do such a transformation.", "startOffset": 66, "endOffset": 69}, {"referenceID": 5, "context": "In fact, differences between shortcut in [6] and confined shortcut are in the two following issues: 1) Performing confined shortcuts in only three consecutive nodes in the tour; 2) avoiding performing confined shortcut whenever it leads to adding an infinity weight edge.", "startOffset": 41, "endOffset": 44}, {"referenceID": 5, "context": "Lemmas 3 and 5 are adapted from [6].", "startOffset": 32, "endOffset": 35}, {"referenceID": 19, "context": "Complexity analysis of Step 1 (line 1): MST can be found using Kruskal\u2019s algorithm [20] or Prim\u2019s algorithm [31].", "startOffset": 83, "endOffset": 87}, {"referenceID": 30, "context": "Complexity analysis of Step 1 (line 1): MST can be found using Kruskal\u2019s algorithm [20] or Prim\u2019s algorithm [31].", "startOffset": 108, "endOffset": 112}, {"referenceID": 0, "context": "Two implementations of these algorithms are Improved Implementation of Kruskal Algorithm and Fibonacci Heap Implementation of Prim\u2018s Algorithm [1], respectively, which both are in O(|E|+|V | log |V |) complexity class.", "startOffset": 143, "endOffset": 146}, {"referenceID": 24, "context": "Complexity analysis of Step 3 (lines 10 and 11): The modified version of Edmond\u2019s Blossom Shrinking algorithm in [25] can be used to do perfect matching, which requires O(|V |) running time.", "startOffset": 113, "endOffset": 117}, {"referenceID": 28, "context": "Complexity of Step 4 (line 12): One can use Fleury algorithm [29] to find Eulerian tour, which has the running time complexity of O(|E|).", "startOffset": 61, "endOffset": 65}, {"referenceID": 15, "context": "Figure 6: An augmented chromosome used in Gyorfi GA which consists of two arrays (adapted from [16]).", "startOffset": 95, "endOffset": 99}, {"referenceID": 15, "context": "[16], which uses GA.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "The subpath reversal operator changes the direction flag of randomly chosen genes within a parent chromosome\u201d[16].", "startOffset": 109, "endOffset": 113}, {"referenceID": 22, "context": "We think that it would be possible to improve the results of the CSPP method using some improvement methods such as Lin-Kernighan [23] and Helsgaun [17].", "startOffset": 130, "endOffset": 134}, {"referenceID": 16, "context": "We think that it would be possible to improve the results of the CSPP method using some improvement methods such as Lin-Kernighan [23] and Helsgaun [17].", "startOffset": 148, "endOffset": 152}, {"referenceID": 10, "context": "One important guide line could be using the graph generated by the IETI algorithm as an input for a modified version of the RPP algorithm [11].", "startOffset": 138, "endOffset": 142}], "year": 2016, "abstractText": "The subpath planning problem is a branch of the path planning problem, which has widespread applications in automated manufacturing process as well as vehicle and robot navigation. This problem is to find the shortest path or tour subject for travelling a set of given subpaths. The current approaches for dealing with the subpath planning problem are all based on meta-heuristic approaches. It is well-known that meta-heuristic based approaches have several deficiencies. To address them, we propose a novel approximation algorithm in the O(n3) time complexity class, which guarantees to solve any subpath planning problem instance with the fixed ratio bound of 2. Beside the formal proofs of the claims, our empirical evaluation shows that our approximation method acts much better than a state-of-the-art method, both in result and execution time. Note to Practitioners\u2014In some real world applications such as robot and vehicle navigation in structured and industrial environments as well as some of the manufacturing processes such as electronic printing and polishing, it is required for the agent to travel a set of predefined paths. Automating this process includes three steps: 1) capturing the environment of the actual problem and formulating it as a subpath planning problem; 2) solving subpath planning problem to find the near optimal path or tour; 3) command the robot to follow the output. The most challenging phase is the second one that this paper tries to tackle it. To design an effective automation for the aforementioned applications, it is essential to make use of methods with low computational cost but near optimal outputs in the second phase. According to the fact that the length of the final output has a direct effect on the cost of performing the task, it is desirable to incorporate methods with low complexity that can guarantee a bound for the difference between length of the optimal path and 1 ar X iv :1 60 3. 06 21 7v 1 [ cs .R O ] 2 0 M ar 2 01 6 the output. Current approaches for solving subpath planning problem are all meta-heuristic based. These methods do not provide such a bound. And plus, they are usually very time consuming. They may find promising results for some instances of problems, but there is no guarantee that they always exhibit such a good behaviour. In this paper, in order to avoid the issues of metaheuristics methods, we present an approximation algorithm, which provides an appropriate bound for the optimality of its solution. To gauge the performance of proposed methods, we conducted a set of experiments the results of which show that our proposed method finds shorter paths in less time in comparison with a state-of-the-art method.", "creator": "LaTeX with hyperref package"}}}