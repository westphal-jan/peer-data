{"id": "1603.09545", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Mar-2016", "title": "Characterizing Realizability in Abstract Argumentation", "abstract": "Realizability for ability defined formalisms faculty been before anything: without instead quadratic and a stand by interpretations, \u201d there a information base whose semantics earier really over into given concept set? We proposing no head integrated taken theoretical realizability although abstract bayesian contexts (ADFs) and consist of its subclasses. In particular, now supports applies way Dung consequentialist frameworks, SETAFs after Nielsen and Parsons, besides schizophrenia ADFs. We not time worn characterization method for the valid, made, less include model / stable perceptual. We tend this alternative give devise an algorithm possibility intend realizability other form sources anilines and semantics; moreover though algorithm allows for constructing short adjust teaching air wish one exception. The algorithm way built then a interchangeable way such rather able metadata set well workarounds like cosmological. We believe also steps come attitude he answer set programmers, and various place transition supposed license several works this on has relative theatricality of the abovementioned simplifications.", "histories": [["v1", "Thu, 31 Mar 2016 12:05:34 GMT  (29kb)", "http://arxiv.org/abs/1603.09545v1", "Contribution to the 16h International Workshop on Non-Monotonic Reasoning, 2016, Cape Town"]], "COMMENTS": "Contribution to the 16h International Workshop on Non-Monotonic Reasoning, 2016, Cape Town", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["thomas linsbichler", "j\\\"org p\\\"uhrer", "hannes strass"], "accepted": false, "id": "1603.09545"}, "pdf": {"name": "1603.09545.pdf", "metadata": {"source": "CRF", "title": "Characterizing Realizability in Abstract Argumentation", "authors": ["Thomas Linsbichler", "Hannes Strass"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n60 3.\n09 54\n5v 1\n[ cs\n.A I]\n3 1\nM ar\n2 01"}, {"heading": "1 Introduction", "text": "The abstract argumentation frameworks (AFs) introduced by Dung (1995) have garnered increasing attention in the recent past. In his seminal paper, Dung showed how an abstract notion of argument (seen as an atomic entity) and the notion of individual attacks between arguments together could reconstruct several established KR formalisms in argumentative terms. Despite the generality of those and many more results in the field that was sparked by that paper, researchers also noticed that the restriction to individual attacks is often overly limiting, and devised extensions and generalizations of Dung\u2019s frameworks: directions included generalizing individual attacks to collective attacks (Nielsen and Parsons, 2006), leading to so-called SETAFs; others started offering a support relation between arguments (Cayrol and LagasquieSchiex, 2005), preferences among arguments (Amgoud and Cayrol, 2002; Modgil, 2009), or attacks on attacks into arbitrary depth (Baroni et al., 2011). This is only the tip of an iceberg, for a more comprehensive overview we refer to the work of Brewka, Polberg, and Woltran (2014).\n\u2217This research has been supported by DFG (project BR 1817/7- 1) and FWF (projects I1102 and P25518).\nOne of the most recent and most comprehensive generalizations of AFs has been presented by Brewka and Woltran (2010) (and later continued by Brewka et al., 2013) in the form of abstract dialectical frameworks (ADFs). These ADFs offer any type of link between arguments: individual attacks (as in AFs), collective attacks (as in SETAFs), and individual and collective support, to name only a few. This generality is achieved through so-called acceptance conditions associated to each statement. Roughly, the meaning of relationships between arguments is not fixed in ADFs, but is specified by the user for each argument in the form of Boolean functions (acceptance functions) on the argument\u2019s parents. However, this generality comes with a price: Strass and Wallner (2015) found that the complexity of the associated reasoning problems of ADFs is in general higher than in AFs (one level up in the polynomial hierarchy). Fortunately, the subclass of bipolar ADFs (defined by Brewka and Woltran, 2010) is as complex as AFs (for all considered semantics) while still offering a wide range of modeling capacities (Strass and Wallner, 2015). However, there has only been little concerted effort so far to exactly analyze and compare the expressiveness of the abovementioned languages.\nThis paper is about exactly analyzing means of expression for argumentation formalisms. Instead of motivating expressiveness in natural language and showing examples that some formalisms seem to be able to express but others do not, we tackle the problem in a formal way. We use a precise mathematical definition of expressiveness: a set of interpretations is realizable by a formalism under a semantics if and only if there exists a knowledge base of the formalism whose semantics is exactly the given set of interpretations. Studying realizability in AFs has been started by Dunne et al. (2013, 2015), who analyzed realizability for extensionbased semantics, that is, interpretations represented by sets where arguments are either accepted (in the extension set) or not accepted (not in the extension set). While their initial work disregarded arguments that are never accepted, there have been continuations where the existence of such \u201cinvisible\u201d arguments is ruled out (Baumann et al., 2014; Linsbichler, Spanring, and Woltran, 2015). Dyrkolbotn (2014) began to analyze realizability for labeling-based semantics of AFs, that is, three-valued semantics where arguments can be accepted (mapped to true), rejected (mapped to false) or neither (mapped to unknown). Strass (2015) started to ana-\nlyze the relative expressiveness of two-valued semantics for ADFs (relative with respect to related formalisms). Most recently, Pu\u0308hrer (2015) presented precise characterizations of realizability for ADFs under several three-valued semantics, namely admissible, grounded, complete, and preferred. The term \u201cprecise characterizations\u201d means that he gave necessary and sufficient conditions for an interpretation set to be ADF-realizable under a semantics.\nThe present paper continues this line of work by lifting it to a much more general setting. We combine the works of Dunne et al. (2015), Pu\u0308hrer (2015), and Strass (2015) into a unifying framework, and at the same time extend them to formalisms and semantics not considered in the respective papers: we treat several formalisms, namely AFs, SETAFs, and (B)ADFs, while the previous works all used different approaches and techniques. This is possible because all of these formalisms can be seen as subclasses of ADFs that are obtained by suitably restricting the acceptance conditions.\nAnother important feature of our framework is that we uniformly use three-valued interpretations as the underlying model theory. In particular, this means that arguments cannot be \u201cinvisible\u201d any more since the underlying vocabulary of arguments is always implicit in each interpretation. Technically, we always assume a fixed underlying vocabulary and consider our results parametric in that vocabulary. In contrast, for example, Dyrkolbotn (2014) presents a construction for realizability that introduces new arguments into the realizing knowledge base; we do not allow that. While sometimes the introduction of new arguments can make sense, for example if new information becomes available about a domain or a debate, it is not sensible in general, as these new arguments would be purely technical with an unclear dialectical meaning. Moreover, it would lead to a different notion of realizability, where most of the realizability problems would be significantly easier, if not trivial.\nThe paper proceeds as follows. We begin with recalling and introducing the basis and basics of our work \u2013 the formalisms we analyze and the methodology with which we analyze them. Next we introduce our general framework for realizability; the major novelty is our consistent use of so-called characterization functions, firstly introduced by Pu\u0308hrer (2015), which we adapt to further semantics. The main workhorse of our approach will be a parametric propagate-and-guess algorithm for deciding whether a given interpretation set is realizable in a formalism under a semantics. We then analyze the relative expressiveness of the considered formalisms, presenting several new results that we obtained using an implementation of our framework. We conclude with a discussion."}, {"heading": "2 Preliminaries", "text": "We make use of standard mathematical concepts like functions and partially ordered sets. For a function f : X \u2192 Y we denote the update of f with a pair (x, y) \u2208 X \u00d7 Y by f |xy : X \u2192 Y with z 7\u2192 y if z = x, and z 7\u2192 f(z) otherwise. For a function f : X \u2192 Y and y \u2208 Y , its preimage is f\u22121(y) = {x \u2208 X | f(x) = y}. A partially ordered set is a pair (S,\u2291) with \u2291 a partial order on S. A partially ordered set (S,\u2291) is a complete lattice if and only if every\nS\u2032 \u2286 S has both a greatest lower bound (glb) d S\u2032 \u2208 S and a least upper bound (lub) \u2294\nS\u2032 \u2208 S. A partially ordered set (S,\u2291) is a complete meet-semilattice iff every non-empty subset S\u2032 \u2286 S has a greatest lower bound d S\u2032 \u2208 S (the meet) and every ascending chain C \u2286 S has a least upper bound \u2294 C \u2208 S.\nThree-Valued Interpretations Let A be a fixed finite set of statements. An interpretation is a mapping v : A \u2192 {t, f ,u} that assigns one of the truth values true (t), false (f ) or unknown (u) to each statement. An interpretation is two-valued if v(A) \u2286 {t, f}, that is, the truth value u is not assigned. Two-valued interpretations v can be extended to assign truth values v(\u03d5) \u2208 {t, f} to propositional formulas \u03d5 as usual.\nThe three truth values are partially ordered according to their information content: we have u <i t and u <i f and no other pair in <i, which intuitively means that the classical truth values contain more information than the truth value unknown. As usual, we denote by \u2264i the partial order associated to the strict partial order <i. The pair ({t, f ,u} ,\u2264i) forms a complete meet-semilattice with the information meet operation \u2293i. This meet can intuitively be interpreted as consensus and assigns t \u2293i t = t, f \u2293i f = f , and returns u otherwise.\nThe information ordering \u2264i extends in a straightforward way to interpretations v1, v2 over A in that v1 \u2264i v2 iff v1(a) \u2264i v2(a) for all a \u2208 A. We say for two interpretations v1, v2 that v2 extends v1 iff v1 \u2264i v2. The set V of all interpretations over A forms a complete meet-semilattice with respect to the information ordering \u2264i. The consensus meet operation \u2293i of this semilattice is given by (v1 \u2293i v2)(a) = v1(a) \u2293i v2(a) for all a \u2208 A. The least element of (V ,\u2264i) is the valuation vu : A \u2192 {u} mapping all statements to unknown \u2013 the least informative interpretation. By V2 we denote the set of two-valued interpretations; they are the \u2264i-maximal elements of the meet-semilattice (V ,\u2264i). We denote by [v]2 the set of all two-valued interpretations that extend v. The elements of [v]2 form an \u2264iantichain with greatest lower bound v = d i[v]2.\nAbstract Argumentation Formalisms An abstract dialectical framework (ADF) is a tuple D = (A,L,C) where A is a set of statements (representing positions one can take or not take in a debate), L \u2286 A\u00d7A is a set of links (representing dependencies between the positions), C = {Ca}a\u2208A is a collection of functions Ca : 2par(a) \u2192 {t, f}, one for each statement a \u2208 A. The function Ca is the acceptance condition of a and expresses whether a can be accepted, given the acceptance status of its parents par(a) = {b \u2208 S | (b, a) \u2208 L}. We usually represent each Ca by a propositional formula\u03d5a over par(a). To specify an acceptance condition, then, we takeCa(M \u2229 par (a)) = t to hold iff M is a model for \u03d5a.\nBrewka and Woltran (2010) introduced a useful subclass of ADFs: an ADF D = (A,L,C) is bipolar iff all links in L are supporting or attacking (or both). A link (b, a) \u2208 L is supporting in D iff for all M \u2286 par (a), we have that Ca(M) = t implies Ca(M \u222a {b}) = t. Symmetrically, a link (b, a) \u2208 L is attacking in D iff for all M \u2286 par(a), we\nhave that Ca(M \u222a {b}) = t implies Ca(M) = t. If a link (b, a) is both supporting and attacking then b has no actual influence on a. (But the link does not violate bipolarity.) We write BADFs as D = (A,L+ \u222a L\u2212, C) and mean that L+ contains all supporting links and L\u2212 all attacking links. The semantics of ADFs can be defined using an operator \u0393D over three-valued interpretations (Brewka and Woltran, 2010; Brewka et al., 2013). For an ADF D and a threevalued interpretation v, the interpretation \u0393D(v) is given by\na 7\u2192 d\ni {w(\u03d5a) | w \u2208 [v]2}\nThat is, for each statement a, the operator returns the consensus truth value for its acceptance formula \u03d5a, where the consensus takes into account all possible two-valued interpretations w that extend the input valuation v. If this v is two-valued, we get [v]2 = {v} and thus \u0393D(v)(a) = v(\u03d5a).\nThe standard semantics of ADFs are now defined as follows. For ADF D, an interpretation v : A \u2192 {t, f ,u} is\n\u2022 admissible iff v \u2264i \u0393D(v);\n\u2022 complete iff \u0393D(v) = v;\n\u2022 preferred iff it is \u2264i-maximal admissible;\n\u2022 a two-valued model iff it is two-valued and \u0393D(v) = v.\nWe denote the sets of interpretations that are admissible, complete, preferred, and two-valued models by adm(D), com(D), prf (D) and mod(D), respectively. These definitions are proper generalizations of Dung\u2019s notions for AFs: For an AF (A,R), where R \u2286 A \u00d7 A is the attack relation, the ADF associated to (A,R) is D(A,R) = (A,R,C) with C = {\u03d5a}a\u2208A and \u03d5a = \u2227\nb:(b,a)\u2208R \u00acb for all a \u2208 A. AFs inherit their semantics from the definitions for ADFs (Brewka et al., 2013, Theorems 2 and 4). In particular, an interpretation is stable for an AF (A,R) if and only if it is a two-valued model of D(A,R).\nA SETAF is a pair S = (A,X)whereX \u2286 (2A \\ {\u2205})\u00d7 A is the (set) attack relation. We define three-valued counterparts of the semantics introduced by Nielsen and Parsons (2006), following the same conventions as in three-valued semantics of AFs (Caminada and Gabbay, 2009) and argumentation formalisms in general. Given a statement a \u2208 A and an interpretation v we say that a is acceptable wrt. v if \u2200(B, a) \u2208 X\u2203a\u2032 \u2208 B : v(a\u2032) = f and a is unacceptable wrt. v if \u2203(B, a) \u2208 X\u2200a\u2032 \u2208 B : v(a\u2032) = t. For an interpretation v : A \u2192 {t, f ,u} it holds that\n\u2022 v \u2208 adm(S) iff for all a \u2208 A, a is acceptable wrt. v if v(a) = t and a is unacceptable wrt. v if v(a) = f ;\n\u2022 v \u2208 com(S) iff for all a \u2208 A, a is acceptable wrt. v iff v(a) = t and a is unacceptable wrt. v iff v(a) = f ;\n\u2022 v \u2208 prf (S) iff v is \u2264i-maximal admissible; and\n\u2022 v \u2208 mod(S) iff v \u2208 adm(F ) and \u2204a \u2208 A : v(a) = u.\nFor a SETAF S = (A,X) the corresponding ADF DS has acceptance formula\u03d5a = \u2227\n(B,a)\u2208X\n\u2228\na\u2032\u2208B \u00aca \u2032 for each state-\nment a \u2208 A. (Polberg, 2016)\nProposition 1. For any SETAF S = (A,X) it holds that \u03c3(S) = \u03c3(DS), where \u03c3 \u2208 {adm , com, prf ,mod}.\nProof. Given interpretation v and statement a, it holds that \u0393DS (v)(a) = t iff \u2200w \u2208 [v]2 : w(a) = t iff \u2200(B, a) \u2208 X \u2203a\u2032 \u2208 B : v(a\u2032) = f iff a is acceptable wrt. v and \u0393DS (v)(a) = f iff \u2200w \u2208 [v]2 : w(a) = f iff \u2203(B, a) \u2208 X \u2200a\u2032 \u2208 B : v(a\u2032) = t iff a is unacceptable wrt. v. Hence \u03c3(S) = \u03c3(DS) for \u03c3 \u2208 {adm , com, prf ,mod}.\nRealizability A set V \u2286 V of interpretations is realizable in a formalism F under a semantics \u03c3 if and only if there exists a knowledge base kb \u2208 F having exactly \u03c3(kb) = V . Pu\u0308hrer (2015) characterized realizability for ADFs under various three-valued semantics. We will reuse the central notions for capturing the complete semantics in this work.\nDefinition 1 (Pu\u0308hrer 2015). Let V be a set of interpretations. A function f : V2 \u2192 V2 is a com-characterization of V iff: for each v \u2208 V we have v \u2208 V iff for each a \u2208 A:\n\u2022 v(a) 6= u implies f(v2)(a) = v(a) for all v2 \u2208 [v]2 and \u2022 v(a) = u implies f(v\u20322)(a) = t and f(v \u2032\u2032 2 )(a) = f for\nsome v\u20322, v \u2032\u2032 2 \u2208 [v]2. N\nFrom a function of this kind we can build a corresponding ADF by the following construction. For a function f : V2 \u2192 V2, we define Df as the ADF where the acceptance formula for each statement a is given by\n\u03d5fa = \u2228\nw\u2208V2,\nf(w)(a)=t\n\u03c6w with \u03c6w = \u2227\nw(a\u2032)=t\na\u2032 \u2227 \u2227\nw(a\u2032)=f\n\u00aca\u2032\nObserve that we have v(\u03c6w) = t iff v = w by definition. Intuitively, the acceptance condition \u03d5fa is constructed such that v is a model of \u03d5fa if and only if we find f(v)(a) = t.\nProposition 2 (Pu\u0308hrer 2015). Let V \u2286 V be a set of interpretations. (1) For each ADF D with com(D) = V , there is a com-characterization fD for V ; (2) for each com-characterization f : V2 \u2192 V2 for V we have com(Df ) = V .\nThe result shows that V can be realized under complete semantics if and only if there is a com-characterization for V ."}, {"heading": "3 A General Framework for Realizability", "text": "The main underlying idea of our framework is that all abstract argumentation formalisms introduced in the previous section can be viewed as subclasses of abstract dialectical frameworks. This is clear for ADFs themselves and for BADFs by definition; for AFs and SETAFs it is fairly easy to see. However, knowing that these formalisms can be recast as ADFs is not everything. To employ this knowledge for realizability, we must be able to precisely characterize the corresponding subclasses in terms of restricting the ADFs\u2019 acceptance functions. Alas, this is also possible and paves the way for the framework we present in this section. Most importantly, we will make use of the fact that different formalisms and different semantics can be characterized modularly, that is, independently of each other.\nTowards a uniform account of realizability for ADFs under different semantics, we start with a new characterization of realizability for ADFs under admissible semantics that is based on a notion similar in spirit to com-characterizations.\nDefinition 2. Let V be a set of interpretations. A function f : V2 \u2192 V2 is an adm-characterization of V iff: for each v \u2208 V we have v \u2208 V iff for every a \u2208 A:\n\u2022 v(a) 6= u implies f(v2)(a) = v(a) for all v2 \u2208 [v]2. N\nNote that the only difference to Definition 1 is dropping the second condition related to statements with truth value u.\nProposition 3. Let V \u2286 V be a set of interpretations. (1) For each ADF D such that adm(D) = V , there is an adm-characterization fD for V ; (2) for each adm-characterization f : V2 \u2192 V2 for V we have adm(Df ) = V .\nProof. (1) We define the function fD : V2 \u2192 V2 as fD(v2)(a) = v2(\u03d5a) for every v2 \u2208 V2 and a \u2208 A where \u03d5a is the acceptance formula of a in D. We will show that fD is an adm-characterization for V = adm(D). Let v be an interpretation. Consider the case v \u2208 adm(D) and v(a) 6= u for some a \u2208 A and some v2 \u2208 [v]2. From v \u2264i \u0393D(v) we get v2(\u03d5a) = v(a). By definition of fD is follows that fD(v2)(a) = v(a). Now assume v 6\u2208 adm(D) and consequently v 6\u2264i \u0393D(v). There must be some a \u2208 A such that v(a) 6= u and v(a) 6= \u0393D(v)(a). Hence, there is some v2 \u2208 [v]2 with v2(\u03d5a) 6= v(a) and fD(v2)(a) 6= v(a) by definition of fD. Thus, fD is an adm-characterization\n(2) Observe that for every two-valued interpretation v2 and every a \u2208 A we have f(v2)(a) = v2(\u03d5fa). (\u2286): Let v \u2208 adm(Df ) be an interpretation and a \u2208 A a statement such that v(a) 6= u. Let v2 be a two-valued interpretation with v2 \u2208 [v]2. Since v \u2264i \u0393Df (v) we have v(a) = v2(\u03d5 f a). Therefore, by our observation it must also hold that f(v2)(a) = v(a). Thus, by Definition 2, v \u2208 V . (\u2287): Consider an interpretation v such that v 6\u2208 adm(Df ). We show that v 6\u2208 V . From v 6\u2208 adm(Df ) we get v 6\u2264i \u0393Df (v). There must be some a \u2208 A such that v(a) 6= u and v(a) 6= \u0393Df (v)(a). Hence, there is some v2 \u2208 [v]2 with v2(\u03d5 f a) 6= v(a) and consequently f(v2)(a) 6= v(a). Thus, by Definition 2 we have v 6\u2208 V .\nWhen listing sets of interpretations in examples, for the sake of readability we represent three-valued interpretations by sequences of truth values, tacitly assuming that the underlying vocabulary is given and has an associated total ordering. For example, for the vocabulary A = {a, b, c} we represent the interpretation {a 7\u2192 t, b 7\u2192 f , c 7\u2192 u} by the sequence tfu.\nExample 1. Consider the sets V1 = {uuu, tff , ftu} and V2 = {tff , ftu} of interpretations over A = {a, b, c}. The mapping f = {ttt 7\u2192 ftt, ttf 7\u2192 tft, tft 7\u2192 ttt, tff 7\u2192 tff , ftt 7\u2192 ftf , ftf 7\u2192 ftt, f ft 7\u2192 ttf , f f f 7\u2192 ftf} is an adm-characterization for V1. Thus, the ADF Df has V1 as its admissible interpretations. Indeed, the realizing ADF has the following acceptance conditions:\n\u03d5fa \u2261 (a \u2227 b \u2227 \u00acc) \u2228 (a \u2227 \u00acb) \u2228 (\u00aca \u2227 \u00acb \u2227 c) \u03d5fb \u2261 (a \u2227 c) \u2228 (\u00aca \u2227 b) \u2228 (\u00aca \u2227 \u00acb \u2227 \u00acc) \u03d5fc \u2261 (a \u2227 b) \u2228 (\u00aca \u2227 b \u2227 \u00acc) \u2228 (\u00acb \u2227 c)\nFor V2 no adm-characterization exists because uuu 6\u2208 V2 but the implication of Definition 2 trivially holds for a, b, and c.\nWe have seen that the construction Df for realizing under complete semantics can also be used for realizing a set V of interpretations under admissible semantics. The only difference is that we here require f to be an adm-characterization instead of a com-characterization for V . Note that admissible semantics can be characterized by properties that are easier to check than existence of an adm-characterization (see the work of Pu\u0308hrer, 2015). However, using the same type of characterizations for different semantics allows for a unified approach for checking realizability and constructing a realizing ADF in case one exists.\nFor realizing under the model semantics, we can likewise present an adjusted version of com-characterizations.\nDefinition 3. Let V \u2286 V be a set of interpretations. A function f : V2 \u2192 V2 is a mod -characterization of V if and only if: (1) f is defined on V (that is, V \u2286 V2) and (2) for each v \u2208 V2, we have v \u2208 V iff f(v) = v. N\nAs we can show, there is a one-to-one correspondence between mod -characterizations and ADF realizations.\nProposition 4. Let V \u2286 V be a set of interpretations. (1) For each ADF D such thatmod(D) = V , there is a mod - characterization fD for V ; (2) vice versa, for each mod - characterization f : V2 \u2192 V2 for V we find mod(Df ) = V .\nProof. (1) Let D be an ADF with mod(D) = V . It immediately follows that V \u2286 V2. To define fD we can use the construction in the proof of Proposition 3. It follows directly that for any v \u2208 V2, we find fD(v) = v iff v \u2208 V . Thus fD is a mod -characterization for V .\n(2) Let V \u2286 V2 and f : V2 \u2192 V2 be a mod - characterization of V . For any v \u2208 V2 we have:\nv \u2208 V \u21d0\u21d2 v = f(v)\n\u21d0\u21d2 \u2200a \u2208 A : (v(a) = f(v)(a))\n\u21d0\u21d2 \u2200a \u2208 A : (v(a) = t \u2194 f(v)(a) = t)\n\u21d0\u21d2 \u2200a \u2208 A : (v(a) = t \u2194 (\u2203w \u2208 V2 : f(w)(a) = t\n\u2227 v = w))\n\u21d0\u21d2 \u2200a \u2208 A : (v(a) = t \u2194 (\u2203w \u2208 V2 : f(w)(a) = t\n\u2227 v(\u03c6w) = t))\n\u21d0\u21d2 \u2200a \u2208 A :\n\n \n\nv(a) = t \u2194 v\n\n \n\n\u2228\nw\u2208V2,\nf(w)(a)=t\n\u03c6w\n\n \n\n= t\n\n \n\n\u21d0\u21d2 \u2200a \u2208 A : v(a) = v\n\n \n\n\u2228\nw\u2208V2,\nf(w)(a)=t\n\u03c6w\n\n \n\n\u21d0\u21d2 \u2200a \u2208 A : v(a) = v(\u03d5fa) \u21d0\u21d2 v \u2208 mod(Df )\nA related result was given by Strass (2015, Proposition 10). The characterization we presented here fits into the general framework of this paper and is directly usable for our realizability algorithm. Wrapping up, the next result summarizes how ADF realizability can be captured by different types of characterizations for the semantics we considered so far.\nTheorem 5. Let V \u2286 V be a set of interpretations and consider \u03c3 \u2208 {adm, com,mod}. There is an ADF D such that \u03c3(D) = V if and only if there is a \u03c3-characterization for V .\nThe preferred semantics of an ADF D is closely related to its admissible semantics as, by definition, the preferred interpretations of D are its \u2264i-maximal admissible interpretations. As a consequence we can also describe preferred realizability in terms of adm-characterizations. We use the lattice-theoretic standard notationmax\u2264i V to select the \u2264imaximal elements of a given set V of interpretations.\nCorollary 6. Let V \u2286 V be a set of interpretations. There is an ADF D with prf (D) = V iff there is an adm-characterization for some V \u2032 \u2286 V with V \u2286 V \u2032 and max\u2264i V \u2032 = V .\nFinally, we give a result on the complexity of deciding realizability for the mentioned formalisms and semantics.\nProposition 7. Let F \u2208 {AF, SETAF,BADF,ADF} be a formalism and \u03c3 \u2208 {adm , com, prf ,mod} be a semantics. The decision problem \u201cGiven a vocabulary A and a set V \u2286 V of interpretations over A, is there a kb \u2208 F such that \u03c3(kb) = V ?\u201d can be decided in nondeterministic time that is polynomial in the size of V .1\nProof. For all considered F and \u03c3, computing all \u03c3interpretations of a given witness kb \u2208 F can be done in time that is linear in the size of V . Comparing the result to V can also be done in linear time."}, {"heading": "3.1 Deciding Realizability: Algorithm 1", "text": "Our main algorithm for deciding realizability is a propagateand-guess algorithm in the spirit of the DPLL algorithm for deciding propositional satisfiability (Gomes et al., 2008). It is generic with respect to (1) the formalism F and (2) the semantics \u03c3 for which should be realized. To this end, the propagation part of the algorithm is kept exchangeable and will vary depending on formalism and semantics. Roughly, in the propagation step the algorithm uses the desired set V of interpretations to derive certain necessary properties of the realizing knowledge base (line 2). This is the essential part of the algorithm: the derivation rules (propagators) used there are based on characterizations of realizability with respect to formalism and semantics. Once propagation of properties has reached a fixed point (line 7), the algorithm checks whether the derived information is sufficient to construct a knowledge base. If so, the knowledge base can be constructed and returned (line 9). Otherwise (no more information can be obtained through propagation and there is not enough information to construct a knowledge base yet), the algorithm guesses another assignment for the characterization (line 11) and calls itself recursively.\nThe main data structure that Algorithm 1 operates on is a set of triples (v, a,x) consisting of a two-valued interpretation v \u2208 V2, an atom a \u2208 A and a truth value x \u2208 {t, f}. This data structure is intended to represent the \u03c3-characterizations introduced in Definitions 1 to 3. There,\n1We assume here that the representation of any V over A has size \u0398(3|A|). There might be specific V with smaller representations, but we cannot assume any better for the general case.\nAlgorithm 1 realize(F , \u03c3, V, F )\nInput: \u2022 a formalism F \u2022 a semantics \u03c3 for F \u2022 a set V of interpretations v : A \u2192 {t, f ,u} \u2022 a relation F \u2286 V2 \u00d7A\u00d7 {t, f}, initially empty Output: a kb \u2208 F with \u03c3(kb) = V or \u201cno\u201d if none exists 1: repeat 2: set F\u2206 := \u22c3\np\u2208PF\u03c3\np(V, F ) \\ F\n3: set F := F \u222a F\u2206 4: if \u2203v \u2208 V2, \u2203a \u2208 A : {(v, a, t), (v, a, f)} \u2286 F then 5: return \u201cno\u201d 6: end if 7: until F\u2206 = \u2205 8: if \u2200v \u2208 V2, \u2200a \u2208 A, \u2203x \u2208 {t, f} : (v, a, x) \u2208 F then 9: return kbF\u03c3 (F )\n10: end if 11: choose v \u2208 V2, a \u2208 A with (v, a, t) /\u2208 F , (v, a, f) /\u2208 F 12: if realize(F , \u03c3, V, F \u222a {(v, a, t)}) 6= \u201cno\u201d then 13: return realize(F , \u03c3, V, F \u222a {(v, a, t)}) 14: else 15: return realize(F , \u03c3, V, F \u222a {(v, a, f)}) 16: end if\na \u03c3-characterization is a function f : V2 \u2192 V2 from twovalued interpretations to two-valued interpretations. However, as the algorithm builds the \u03c3-characterization step by step and there might not even be a \u03c3-characterization in the end (because V is not realizable), we use a set F of triples (v, a,x) to be able to represent both partial and incoherent states of affairs. The \u03c3-characterization candidate induced by F is partial if we have that for some v and a, neither (v, a, t) \u2208 F nor (v, a, f) \u2208 F ; likewise, the candidate is incoherent if for some v and a, both (v, a, t) \u2208 F and (v, a, f) \u2208 F . If F is neither partial nor incoherent, it gives rise to a unique \u03c3-characterization that can be used to construct the knowledge base realizing the desired set of interpretations. The correspondence to the characterizationfunction is then such that f(v)(a) = x iff (v, a,x) \u2208 F .\nIn our presentation of the algorithm we focused on its main features, therefore the guessing step (line 11) is completely \u201cblind\u201d. It is possible to use common CSP techniques, such as shaving (removing guessing possibilities that directly lead to inconsistency). Finally, we remark that the algorithm can be extended to enumerate all possible realizations of a given interpretation set \u2013 by keeping all choice points in the guessing step and thus exhaustively exploring the whole search space.\nIn the case where the constructed relation F becomes functional at some point, the algorithm returns a realizing knowledge base kbF\u03c3 (F ). For ADFs, this just means that we denote by f the \u03c3-characterization represented by F and set kbADF\u03c3 (F ) = D\nf . For the remaining formalisms we will introduce the respective constructions in later subsections.\nThe algorithm is parametric in two dimensions, namely with respect to the formalism F and with respect to the semantics \u03c3. These two aspects come into the algorithm via\nmod = {p \u2208 mod , p /\u2208 mod , p mod}).\nso-called propagators. A propagator is a formalism-specific or semantics-specific set of derivation rules. Given a set V of desired interpretations and a partial \u03c3-characterization F , a propagator p derives new triples (v, a,x) that must necessarily be part of any total \u03c3-characterization f for V such that f extends F . In the following, we present semantics propagators for admissible, complete and two-valued model (in (SET)AF terms stable) semantics, and formalism propagators for BADFs, AFs, and SETAFs."}, {"heading": "3.2 Semantics Propagators", "text": "These propagators (cf. Figure 1) are directly derived from the properties of \u03c3-characterizations presented in Definitions 1 to 3. While the definitions provide exact conditions to check whether a given function is a \u03c3-characterization, the propagators allow us to derive definite values of partial characterizations that are necessary to fulfill the conditions for being a \u03c3-characterization.\nFor admissible semantics, the condition for a function f to be an adm-characterization of a desired set of interpretations V (cf. Definition 2) can be split into a condition for desired interpretations v \u2208 V and two conditions for undesired interpretations v /\u2208 V . Propagator p\u2208adm derives new triples by considering interpretations v \u2208 V . Here, for all twovalued interpretations v2 that extend v, the value f(v2) has to be in accordance with v on v\u2019s Boolean part, that is, the algorithm adds (v2, a, v(a)) whenever v(a) 6= u. On the other hand, p/\u2208adm derives new triples for v /\u2208 V in order to ensure that there is a two-valued interpretation v2 extending v where f(v2) differs from v on a Boolean value of v. Note that while p\u2208adm immediately allows us to derive information about F for each desired interpretation v \u2208 V , propagator p/\u2208adm is much weaker in the sense that it only derives a triple of F if there is no other way to meet the conditions for an undesired interpretation. Special treatment is required for the interpretation vu that maps all statements to u and is admissible for every ADF. This is not captured by p\u2208adm and p/\u2208adm as these deal only with interpretations that have Boolean mappings. Thus, propagator p adm serves to check whether vu \u2208 V . If this is not the case, the propagator immediately makes the relation F incoherent and the algorithm\ncorrectly answers \u201cno\u201d. For complete semantics and interpretations v \u2208 V , propagator p\u2208,tfcom derives triples just like in the admissible case. Propagator p\u2208,ucom deals with statements a \u2208 A having v(a) = u for which there have to be at least two v2, v \u2032 2 \u2208 [v]2 having f(v2)(a) = t and f(v \u2032 2)(a) = f . Hence p\u2208,ucom derives triple (v2, a,\u00acx) if for all other v \u2032 2 \u2208 [v]2 we find a triple (v\u20322, a,x). For interpretations v /\u2208 V it must hold that there is some a \u2208 A such that (i) v(a) 6= u and f(v2)(a) 6= v(a) for some v2 \u2208 [v]2 or (ii) v(a) = u but for all v2 \u2208 [v]2, f(v2) assigns the same Boolean truth value x to a. Now if neither (i) nor (ii) can be fulfilled by any statement b \u2208 A \\ {a} due to the current contents of F , propagators p 6\u2208,tfcom and p 6\u2208,u com derive triple (v2, a,\u00acv(a)) for v(a) 6= u if needed for a to fulfill (i) and (v2, a,\u00acx) for v(a) = u if needed for a to fulfill (ii), respectively.\nExample 2. Consider the set V3 = {uuu, fuu,uuf , ftf}. First, we consider a run of realize(ADF, adm , V3, \u2205). In the first iteration, propagator p\u2208adm ensures that F\u2206 in line 2 contains (f f f , a, f), (ftf , a, f), (ftf , c, f), and (f f f , c, f). Based on the latter three tuples and fuf /\u2208 V3, propagator p/\u2208adm derives (f f f , a, t) in the second iteration which together with (f f f , a, f) causes the algorithm to return \u201cno\u201d. Consequently, V3 is not adm-realizable. A run of realize(ADF, com , V3, \u2205) on the other hand returns comcharacterization f for V3 that maps ttf to tff , ftt to f ft, ftf and f f f to ftf and all other v2 \u2208 V2 to f f f . Hence, ADF Df , given by the acceptance conditions\n\u03d5fa = a \u2227 b \u2227 \u00acc, \u03d5 f c = \u00aca \u2227 b \u2227 c, \u03d5fb = (\u00aca \u2227 b\u00ac \u2227 \u00acc) \u2228 (\u00aca \u2227 \u00acb \u2227 \u00acc)\nhas V3 as its complete semantics.\nFinally, for two-valued model semantics, propagator p\u2208mod derives new triples by looking at interpretations v \u2208 V . For those, we must find f(v) = v in each mod -characterization f by definition. Thus the algorithm adds (v, a, v(a)) for each a \u2208 A to the partial characterization F . Propagator p/\u2208mod looks at interpretations v \u2208 V2 \\ V , for which it must hold that f(v) 6= v. Thus there must be a statement a \u2208 A with v(a) 6= f(v)(a), which is exactly what this propagator\nAlgorithm 2 realizePrf (F , V )\nInput: \u2022 a formalism F \u2022 a set V of interpretations v : A \u2192 {t, f ,u} Output: Return some kb \u2208 F with prf (kb) = V if one exists or \u201cno\u201d otherwise.\n1: if max\u2264i V 6= V then 2: return \u201cno\u201d 3: end if 4: set V < := {v \u2208 V | \u2203v\u2032 \u2208 V : v <i v\u2032} 5: set X := \u2205 6: repeat 7: choose V \u2032 \u2286 V < with V \u2032 /\u2208 X 8: set X := X \u222a {V \u2032} 9: set V adm := V \u222a V \u2032\n10: if realize(F , adm , V adm , \u2205) 6= \u201cno\u201d then 11: return realize(F , adm , V adm , \u2205) 12: end if 13: until \u2200V \u2032 \u2286 V < : V \u2032 \u2208 X 14: return \u201cno\u201d\nderives whenever it is clear that there is only one statement candidate left. This, in turn, is the case whenever all b \u2208 A with the opposite truth value \u00acv(a) and all c \u2208 A with c 6= a cannot coherently become the necessary witness any more. The propagator p mod checks whether V \u2286 V2, that is, the desired set of interpretations consists entirely of two-valued interpretations. In that case this propagator makes the relation F incoherent, following a similar strategy as p adm .\nPreferred Semantics Realizing a given set of interpretations V under preferred semantics requires special treatment. We do not have a \u03c3-characterization function for \u03c3 = prf at hand to directly check realizability of V but have to find some V \u2032 \u2286 {v \u2208 V | \u2203v\u2032 \u2208 V : v <i v\u2032} such that V \u222a V \u2032 is realizable under admissible semantics (cf. Corollary 6). Algorithm 2 implements this idea by guessing such a V \u2032 (line 7) and then using Algorithm 1 to try to realize V \u222a V \u2032 under admissible semantics (line 11). If realize returns a knowledge base kb realizing V \u222a V \u2032 under adm we can directly use kb as solution of realizePrf since it holds that prf (kb) = V , given that V is an \u2264i-antichain (line 2)."}, {"heading": "3.3 Formalism Propagators", "text": "When constructing an ADF realizing a given set V of interpretations under a semantics \u03c3, the function kbADF\u03c3 (F ) makes use of the \u03c3-characterization given by F in the following way: v is a model of the acceptance condition \u03d5a if and only if we find (v, a, t) \u2208 F . Now as bipolar ADFs, SETAFs and AFs are all subclasses of ADFs by restricting the acceptance conditions of statements, these restrictions also carry over to the \u03c3-characterizations. The propagators defined below use structural knowledge on the form of acceptance conditions of the respective formalisms to reduce the search space or to induce incoherence of F whenever V is not realizable.\nBipolar ADFs For bipolar ADFs, we use the fact that each of their links must have at least one polarity, that is, must\nbe supporting or attacking. Therefore, if a link is not supporting, it must be attacking, and vice versa. For canonical realization, we obtain the polarities of links, i.e. the sets L+ and L\u2212, as defined in Figure 2.\nAFs To explain the AF propagators, we first need some more definitions. On the two classical truth values, we define the truth ordering f <t t, whence the operations \u2294t and \u2293t with f \u2294t t = t and f \u2293t t = f result. These operations can be lifted pointwise to two-valued interpretations as usual, that is, (v1 \u2294t v2)(a) = v1(a) \u2294t v2(a) and (v1 \u2293t v2)(a) = v1(a) \u2293t v2(a). Again, the reflexive version of <t is denoted by \u2264t. The pair (V2,\u2264t) of twovalued interpretations ordered by the truth ordering forms a complete lattice with glb \u2293t and lub \u2294t. This complete lattice has the least element vf : A \u2192 {f}, the interpretation mapping all statements to false, and the greatest element vt : A \u2192 {t} mapping all statements to true, respectively.\nAcceptance conditions of AF-based ADFs have the form of conjunctions of negative literals. In the complete lattice (V2,\u2264t), the model sets of AF acceptance conditions correspond to the lattice-theoretic concept of an ideal, a subset of V2 that is downward-closed with respect to \u2264t and upwardclosed with respect to \u2294t. The propagator directly implements these closure properties: application of pAF ensures that when a \u03c3-characterization F that is neither incoherent nor partial is found in line 8 of Algorithm 1, then there is, for each a \u2208 A, an interpretation va such that (va, a, t) \u2208 F and v \u2264t va for each (v, a, t) \u2208 F . Hence va is crucial for the acceptance condition, or in AF terms the attacks, of a and we can define kbAF\u03c3 (F ) = (A, {(b, a) | a, b \u2208 A, va(b) = f}).\nSETAFs The propagator for SETAFs, pSETAF, is a weaker version of that of AFs, since we cannot presume upwardclosure with respect to \u2294t. In SETAF-based ADFs the acceptance formula is in conjunctive normal form containing only negative literals. By a transformation preserving logical equivalence we obtain an acceptance condition in disjunctive normal form, again with only negative literals; in other words, a disjunction of AF acceptance formulas. Thus, the model set of a SETAF acceptance condition is not necessarily an ideal, but a union of ideals. For the canonical realization we can make use of the fact that, for each a \u2208 A, the set V ta = {v \u2208 V2 | (v, a, t) \u2208 F} is downward-closed with respect to \u2264t, hence the set of models of \u2228\nv\u2208max\u2264t V t\n\u2227\nv(b)=f \u00acb is exactly V t a . The clauses\nof its corresponding CNF-formula exactly coincide with the sets of arguments attacking a in kbSETAF\u03c3 (F )."}, {"heading": "3.4 Correctness", "text": "For a lack of space, we could not include a formal proof of soundness and completeness of Algorithm 1, but rather present arguments for termination and correctness.\nTermination With each recursive call, the set F can never decrease in size, as the only changes to F are adding the results of propagation in line 3 and adding the guesses in line 11. Also within the until-loop, the set F can never decrease in size; furthermore there is only an overall finite number of triples that can be added to F . Thus at some point\n\u03c3 \u222a { pF } with pF as defined above. L+ and L\u2212 define link polarities for kbBADF\u03c3 .\nwe must have F\u2206 = \u2205 and leave the until-loop. Since F always increases in size, at some point it must either become functional or incoherent, whence the algorithm terminates.\nSoundness If the algorithm returns a realizing knowledge base kbF\u03c3 (F ), then according to the condition in line 8 the relation F induced a total function f : V2 \u2192 V2. In particular, because the until-loop must have been run through at least once, there was at least one propagation step (line 2). Since the propagators are defined such that they enforce everything that must hold in a \u03c3-characterization, we conclude that the induced function f indeed is a \u03c3-characterization for V . By construction, we consequently find that \u03c3(kbF\u03c3 (F )) = V .\nCompleteness If the algorithm answers \u201cno\u201d, then the execution reached line 5. Thus, for the constructed set F , there must have been an interpretation v \u2208 V2 and a statement a \u2208 A such that {(v, a, t), (v, a, f)} \u2286 F , that is, F is incoherent. Since F is initially empty, the only way it could get incoherent is in the propagation step in line 2. (The guessing step cannot create incoherence, since exactly one truth value is guessed for v and a.) However, the propagators are defined such that they infer only assignments (triples) that are necessary for the given F . Consequently, the given interpretation set V is such that either there is no realization within the ADF fragment corresponding to formalism F (that is, the formalism propagator derived the incoherence) or there is no \u03c3-characterization for V with respect to general ADFs (that is, the semantics propagator derived the incoherence). In any case, V is not \u03c3-realizable for F ."}, {"heading": "4 Implementation", "text": "As Algorithm 1 is based on propagation, guessing, and checking it is perfectly suited for an implementation using answer set programming (ASP) (Niemela\u0308, 1999; Marek and Truszczyn\u0301ski, 1999) as this allows for exploiting conflict learning strategies and heuristics of modern ASP solvers. Thus, we developed ASP encodings in the Gringo language (Gebser et al., 2012) for our approach. Similar as the algorithm, our declarative encodings are modular, consisting of a main part responsible for constructing set F and separate encodings for the individual propagators. If one wants, e.g., to compute an AF realization under admissible semantics for a set V of interpretations, an input program encoding V is joined with the main encoding, the propagator encoding for admissible semantics as well as the propagator encoding for AFs. Every answer set of such a program encodes a respective characterization function. Our ASP encoding for preferred semantics is based on the admissible encoding and guesses further interpretations following the\nessential idea of Algorithm 2. For constructing a knowledge base with the desired semantics, we also provide two ASP encodings that transform the output to an ADF in the syntax of the DIAMOND tool (Ellmauthaler and Strass, 2014), respectively an AF in ASPARTIX syntax (Egly, Gaggl, and Woltran, 2010; Gaggl et al., 2015). Both argumentation tools are based on ASP themselves. The encodings for all the semantics and formalisms we covered in the paper can be downloaded from http://www.dbai.tuwien.ac. at/research/project/adf/unreal/. A selection of them is depicted in Figure 3 on the next page."}, {"heading": "5 Expressiveness Results", "text": "In this section we briefly present some results that we have obtained using our implementation. We first introduce some necessary notation to describe the relative expressiveness of knowledge representation formalisms (Gogic et al., 1995; Strass, 2015). For formalisms F1 and F2 with semantics \u03c31 and \u03c32, we say that F2 under \u03c32 is at least as expressive as F1 under \u03c31 and write F \u03c31 1 \u2264e F \u03c32 2 if and only if \u03a3\u03c31F1 \u2286 \u03a3 \u03c32 F2\n, where \u03a3\u03c3F = {\u03c3(kb) | kb \u2208 F} is the signature of F under \u03c3. As usual, we define F1 <e F2 iff F1 \u2264e F2 and F2 6\u2264e F1.\nWe now start by considering the signatures of AFs, SETAFs and (B)ADFs for the unary vocabulary {a}:\n\u03a3admAF = \u03a3 adm SETAF = {{u} , {u, t}} \u03a3comAF = \u03a3 com SETAF = {{u} , {t}}\n\u03a3prfAF = \u03a3 prf SETAF = {{u} , {t}}\n\u03a3modAF = \u03a3 mod SETAF = {\u2205, {t}}\n\u03a3admADF = \u03a3 adm BADF = \u03a3 adm AF \u222a {{u, f} , {u, t, f}} \u03a3comADF = \u03a3 com BADF = \u03a3 com AF \u222a {{f} , {u, t, f}}\n\u03a3prfADF = \u03a3 prf BADF = \u03a3 prf AF \u222a {{f} , {t, f}}\n\u03a3modADF = \u03a3 mod BADF = \u03a3 mod AF \u222a {{f} , {t, f}}\nThe following result shows that the expressiveness of the formalisms under consideration is in line with the amount of restrictions they impose on acceptance formulas.\nTheorem 8. For any \u03c3 \u2208 {adm , com , prf ,mod}:\n1. AF\u03c3 <e SETAF \u03c3 . 2. SETAF\u03c3 <e BADF \u03c3 . 3. BADF\u03c3 <e ADF \u03c3 . Proof. (1) AF\u03c3 \u2264e SETAF \u03c3 is clear (by modeling individual attacks via singletons). For SETAF\u03c3 6\u2264e AF \u03c3 the witnessing model sets over vocabulary A = {a, b, c} are {uuu, ttf , tft, ftt} \u2208 \u03a3\u03c3SETAF \\ \u03a3 \u03c3 AF and {ttf , tft, ftt} \u2208\n\u03a3\u03c4SETAF \\ \u03a3 \u03c4 AF with \u03c3 \u2208 {adm, com} and \u03c4 \u2208 {prf ,mod}. By each pair of arguments of A being t in at least one model, a realizing AF cannot feature any attack, immediately giving rise to the model ttt. The respective realizing SETAF is given by the attack relation R = {({a, b}, c), ({a, c}, b), ({b, c}, a)}.\n(2) It is clear that SETAF\u03c3 \u2264e BADF \u03c3 holds (all parents are always attacking). For BADF\u03c3 6\u2264e SETAF \u03c3 the respective counterexamples can be read off the signatures above: for \u03c3 \u2208 {adm , com} we find {u, t, f} \u2208 \u03a3\u03c3BADF \\ \u03a3 \u03c3 SETAF and for \u03c4 \u2208 {prf ,mod} we find {t, f} \u2208 \u03a3\u03c4BADF \\\u03a3 \u03c4 SETAF.\n(3) For \u03c3 = mod the result is known (Strass, 2015, Theorem 14); for the remaining semantics the model sets witnessing ADF\u03c3 6\u2264e BADF \u03c3 over vocabulary A = {a, b} are\n{uu, tu, tt, tf , fu} \u2208 \u03a3admADF \\ \u03a3 adm BADF {uu, tu, tt, tf , fu} \u2208 \u03a3comADF \\ \u03a3 com BADF\n{tt, tf , fu} \u2208 \u03a3prfADF \\ \u03a3 prf BADF\nA witnessing ADF is given by \u03d5a = a and \u03d5b = a \u2194 b.\nTheorem 8 is concerned with the relative expressiveness of the formalisms under consideration, given a certain semantics. Considering different semantics we find that for all formalisms the signatures become incomparable:\nProposition 9. F\u03c311 6\u2264e F \u03c32 2 and F \u03c32 2 6\u2264e F \u03c31 1 for all formalisms F1,F2 \u2208 {AF, SETAF,BADF,ADF} and all semantics \u03c31, \u03c32 \u2208 {adm , com, prf ,mod} with \u03c31 6= \u03c32.\nProof. First, the result for adm and com follows by {u, t} \u2208 \u03a3admAF , but {u, t} /\u2208 \u03a3 com ADF and {t} \u2208 \u03a3 com AF , but {t} /\u2208 \u03a3admADF . Moreover, taking into account that the set of preferred interpretations (resp. two-valued models) always forms a \u2264i-antichain while the set of admissible (resp. complete) interpretations never does, the result follows for \u03c31 \u2208 {adm, com} and \u03c32 \u2208 {prf ,mod}. Finally, since a kb \u2208 F may not have any two-valued models and a preferred interpretation is not necessarily two-valued, the result for prf and mod follows.\nDisregarding the possibility of realizing the empty set of interpretations under the two-valued model semantics, we\nobtain the following relation for ADFs.\nProposition 10. (\u03a3modADF \\ {\u2205}) \u2286 \u03a3 prf ADF.\nProof. Consider some V \u2208 \u03a3modADF with V 6= \u2205. Clearly V \u2286 V2 and by Proposition 4 there is a mod - characterization f : V2 \u2192 V2 for V , that is, f(v) = v iff v \u2208 V . Define f \u2032 : V2 \u2192 V2 such that f \u2032(v) = f(v) = v for all v \u2208 V and f \u2032(v)(a) = \u00acv(a) for all v \u2208 V \\ V and a \u2208 A. Now it holds that f \u2032 is an adm-characterization of V \u2032 = {v \u2208 V | \u2200v2 \u2208 [v]2 : v2 \u2208 V } \u222a {vu}. Since max\u2264i V\n\u2032 = V we get that the ADF D with acceptance formula \u03d5f \u2032\na for each a \u2208 A has prf (D) = V whence V \u2208 \u03a3prfADF.\nIn contrast, this relation does not hold for AFs, which was shown for extension-based semantics by Linsbichler, Spanring, and Woltran (2015) (Theorem 5) and immediately follows for the three-valued case."}, {"heading": "6 Discussion", "text": "We presented a framework for realizability in which AFs, SETAFs, BADFs and general ADFs can be treated in a uniform way. The centerpiece of our approach is an algorithm for deciding realizability of a given interpretation-set in a formalism under a semantics. The algorithm makes use of so-called propagators, by which it can be adapted to the different formalisms and semantics. We also presented an implementation of our framework in answer set programming and several novel expressiveness results that we obtained using our implementation. In related work, Polberg (2016) studies a wide range of abstract argumentation formalisms, in particular their relationship with ADFs. This can be the basis for including further formalisms into our realizability framework: all that remains to do is figuring out suitable ADF fragments and developing propagators for them, just like we did exemplarily for Nielsen and Parsons\u2019s SETAFs. For further future work, we could also streamline existing propagators such that they do not only derive absolutely necessary assignments, but also logically weaker conclusions, such as disjunctions of (non-)assignments."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "Realizability for knowledge representation formalisms studies the following question: Given a semantics and a set of interpretations, is there a knowledge base whose semantics coincides exactly with the given interpretation set? We introduce a general framework for analyzing realizability in abstract dialectical frameworks (ADFs) and various of its subclasses. In particular, the framework applies to Dung argumentation frameworks, SETAFs by Nielsen and Parsons, and bipolar ADFs. We present a uniform characterization method for the admissible, complete, preferred and model/stable semantics. We employ this method to devise an algorithm that decides realizability for the mentioned formalisms and semantics; moreover the algorithm allows for constructing a desired knowledge base whenever one exists. The algorithm is built in a modular way and thus easily extensible to new formalisms and semantics. We have also implemented our approach in answer set programming, and used the implementation to obtain several novel results on the relative expressiveness of the abovementioned formalisms.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}