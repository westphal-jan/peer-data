{"id": "1606.05316", "review": {"conference": "icml", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jun-2016", "title": "Learning Infinite-Layer Networks: Without the Kernel Trick", "abstract": "Infinite - - Layer Networks (ILN) have he having proposed as an developed taken hyperactive neural networks before importantly some of its expense made kernel strategies. ILN rest networks reason evolving it infinitely many nodes within followed hits stored polymer. It though been regard already in mentions much though cause of programs ILN this be usually be then filesystem pull, implying indeed whenever also difference integral can would computed tractable they are efficiently miserliness.", "histories": [["v1", "Thu, 16 Jun 2016 19:02:14 GMT  (20kb)", "http://arxiv.org/abs/1606.05316v1", null], ["v2", "Fri, 28 Jul 2017 04:13:58 GMT  (33kb,D)", "http://arxiv.org/abs/1606.05316v2", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["roi livni", "daniel carmon", "amir globerson"], "accepted": true, "id": "1606.05316"}, "pdf": {"name": "1606.05316.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["gamir@cs.tau.ac.il", "roi.livni@mail.huji.ac.il"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 6.\n05 31\n6v 1\n[ cs\n.L G\n] 1\n6 Ju\nn 20\nIn this work we give an online algorithm for ILN, which avoids the kernel trick assumption. More generally and of independent interest, we show that kernel methods in general can be exploited even when the kernel cannot be efficiently computed but can only be estimated via sampling.\nWe provide a regret analysis for our algorithm, showing that it matches the sample complexity of methods which have access to kernel values. Thus, our method is the first to demonstrate that the kernel trick is not necessary as such, and random features suffice to obtain comparable performance."}, {"heading": "1 Introduction", "text": "With the increasing success of highly non-convex and complex learning architectures such as neural networks, there is an increasing effort to further understand and explain the limits of training such hierarchical structures.\nRecently there have been attempts to draw mathematical insight from kernel methods in order to better understand deep learning as well as come up with new computationally learnable architectures. One such line of work consists on learning Infinite\u2013Layer Networks (ILN) [8, 16]. An infinite layer network can be thought of as a network with infinitely many nodes in a hidden layer. A target function in an ILN class will be of the form:\nx \u2192 \u222b \u03c8(x;w)f(w)d\u00b5(w), (1)\nHere \u03c8 is some function of the input x and parameters w, and d\u00b5(w) is a prior over the parameter space. For example, \u03c8(x;w) can be a single sigmoidal neuron or a complete\nconvolutional network. The integral can be thought of as an infinite sum over all such possible networks, and f(w) can be thought of as an infinite output weight vector to be trained.\nA Standard 1\u2013hidden layer network with a finite set of units can be obtained from the above formalism as follows. First, choose \u03c8(x;w) = \u03c3(x \u00b7w) where \u03c3 is an activation function (e.g., sigmoid or relu). Next, set d\u00b5(w) to be a discrete measure over a finite set w1, . . . ,wd.\n1 In this case, the integral results in a network with d hidden units, and the function f is the linear weights of the output layer. Namely:\nx \u2192 1 d\nd \u2211\ni=1\nf(wi) \u00b7 \u03c3(x \u00b7wi).\nThe main challenge when training 1\u2013hidden layer networks is of course to find the w1, . . . ,wd on which we wish to support our distribution. It is known [20], that due to hardness of learning intersection of halfspaces [19, 12], 1\u2013hidden layer neural networks are computationally hard for a wide class of activation functions. Therefore, as the last example illustrates, the choice of \u00b5 is indeed crucial for performance.\nFor a fixed prior \u00b5, the class of ILN functions is highly expressive, since f can be chosen to approximate any 1-hidden layer architecture to arbitrary precision (by setting f to delta functions around the weights of the network, as we did above for \u00b5). However, this expressiveness comes at a cost. As argued in [16], ILNs will generalize well when there is a large mass of w parameters that attain a small loss.\nThe key observation that makes certain ILN tractable to learn is that Eq. 1 is a linear functional in f . In that sense it is a linear classifier and enjoys the rich theory and algorithmic toolbox for such classifiers. In particular, one can use the fact that linear classifiers can be learned via the kernel trick. In other words, we can reduce learning ILN to the problem of computing the kernel function between two examples. Specifically the problem reduces to computing integrals of the following form:\nk(x1,x2) =\n\u222b\n\u03c8(x1;w) \u00b7 \u03c8(x2;w)d\u00b5(w) = E w\u0304\u223c\u00b5 [\u03c8(x1; w\u0304) \u00b7 \u03c8(x2; w\u0304)] . (2)\nIn this work we extend this result to the case where no closed form kernel is available, and thus the kernel trick is not directly applicable. We thus turn our attention to the setting where features (i.e., w vectors) can be randomly sampled. In this setting, our main result shows that for the square loss, we can efficiently learn the above class \u2013 and surprisingly with a comparable computational cost w.r.t standard kernel methods. Our approach can thus be applied to any random feature based method.\nThe observation we begin with is that sampling random neurons, i.e. sampling random w, leads to an estimate of the kernel in Eq. 2. Thus, if for example, we ignore complexity issues and can sample infinitely many w\u2019s, it is not surprising that we can avoid the need for exact computation of the kernel.\n1In \u03b4 function notation d\u00b5(w) = 1 d \u2211d i=1 \u03b4(w \u2212wi)dw\nOur results provide a much stronger and practical result. Given T training samples, the lower bound on achievable accuracy is O(1/ \u221a T ) (see [26]). We show that we can in fact achieve this rate, using O\u0303(T 2) calls2 to the random feature generator. For comparison, note that O(T 2) is the size of the kernel matrix, and is thus likely to be the cost of any algorithm that uses an explicit kernel matrix, where one is available (whether a kernel regression algorithm can use less than O(T 2) kernel entries is an open problem [5]. As we discuss later, our approach improves on previous random features based learning [9, 24] in terms of sample/computational complexity, and expressiveness."}, {"heading": "2 Problem Setup", "text": "We consider learning algorithms that learn a mapping from input instances x \u2208 X to labels y \u2208 Y. We focus on the regression case where Y is the interval [\u22121, 1]. Our starting point is a class of feature functions \u03c8(w;x) : \u2126\u00d7X \u2192 R, parametrized by vectors w \u2208 \u2126. The functions \u03c8(w;x) may contain highly complex non linearities, such as multi-layer networks consisting of convolution and pooling layers. Our only assumption on \u03c8(w;x) is that for all w \u2208 \u2126 and x \u2208 X it holds that |\u03c8(w;x)| < 1.\nGiven a distribution \u00b5 on \u2126, we denote by L2(\u2126, \u00b5) the class of square integrable functions over \u2126.\nL2(\u2126, \u00b5) =\n{\nf :\n\u222b f2(w)d\u00b5(w) < \u221e } .\nWe will use functions f \u2208 L2(\u2126, \u00b5) as mixture weights over the class \u2126, where each f naturally defines a new regression function from x to R as follows:\nx \u2192 \u222b \u03c8(w;x)f(w)d\u00b5(w). (3)\nOur key algorithmic assumption is that the learner can efficiently sample random w according to the distribution \u00b5. Denote the time to generate one such sample by \u03c1.\nIn what follows it will be simpler to express the integrals as scalar products. Define the following scalar product on functions f \u2208 L2(\u2126, \u00b5).\n\u3008f, g\u3009 = \u222b f(w)g(w)d\u00b5(w) (4)\nWe denote the corresponding \u21132 norm by \u2016f\u2016 = \u221a \u3008f, f\u3009. Also, given features x denote by \u03a6(x) the function in L2(\u2126, \u00b5) given by \u03a6(x)[w] = \u03c8(w;x). Then, the regression functions we are considering are of the form x \u2192 \u3008f,\u03a6(x)\u3009.\nA subclass of norm bounded elements in L2(\u2126, \u00b5) induces a natural subclass of regression functions. Namely, we consider the following class:\nHB\u00b5 = {x \u2192 \u3008f,\u03a6(x)\u3009 : \u2016f\u2016 < B} . 2We use O\u0303 notation to suppress logarithmic factors\nOur ultimate goal is to output a predictor f \u2208 L2(\u2126, \u00b5) that is competitive, in terms of prediction, with the best target function in the class HB\u00b5 .\nWe will consider an online setting, and use it to derive generalization bounds via standard online to batch conversion. In our setting, at each round a learner chooses a target function ft \u2208 L2(\u2126, \u00b5) and an adversary then reveals a sample xt and label yt. The learner then incurs a loss of\n\u2113t(ft) = 1\n2 (\u3008ft,\u03a6(xt)\u3009 \u2212 yt)2 . (5)\nThe objective of the learner is to minimize her T round regret w.r.t norm bounded elements in L2(\u2126, \u00b5). Namely:\nT \u2211\nt=1\n\u2113t(ft)\u2212 min f\u2217\u2208HB\u00b5\nT \u2211\nt=1\n\u2113t(f \u2217). (6)\nIn the statistical setting we assume that the sequence S = {(xi, yi}Ti=1 is generated IID according to some unknown distribution P. We then define the expected loss of a predictor as\nL(f) = E (x,y)\u223cP\n[\n1 2 (\u3008f,\u03a6(x)\u3009 \u2212 y)2\n]\n. (7)"}, {"heading": "3 Main Results", "text": "Theorem 1 states our result for the online model. The corresponding result for the statistical setting is given in Corollary 1. We will elaborate on the structure of the Algorithm later, but first provide the main result.\nAlgorithm 1: The SHRINKING GRADIENT algorithm.\nData: T, B > 1, \u03b7,m Result: Weights \u03b1(1), . . . , \u03b1(T+1) \u2208 R(T ). Functions ft \u2208 L2(\u2126, \u00b5) defined as\nft = \u2211t i=1 \u03b1 (t) i \u03a6(xi);\nInitialize \u03b1(1) = 0 \u2208 RT .; for t = 1, . . . , T do\nObserve xt, yt; Set Et = EST SCALAR PROD(\u03b1 (t),x1:t\u22121,xt,m); . if |Et| < 16B then \u03b1(t+1) = \u03b1(t);\n\u03b1 (t+1) t = \u03b7(Et \u2212 yt);\nelse\n\u03b1(t+1) = 14\u03b1 (t);\nAlgorithm 2: EST SCALAR PROD\nData: \u03b1, x1:t\u22121, x, m Result: Estimated scalar product E for k=1.. . . ,m do\nSample i from the distribution q(i) = |\u03b1i|\u2211 |\u03b1i| ; Sample parameter w\u0304 from \u00b5. Set E(k) = sgn(\u03b1i)\u03c8(xi; w\u0304)\u03c8(x; w\u0304);\nSet E = \u2016\u03b1\u20161m \u2211m k=1E (k)\nTheorem 1. Run Algorithm 1 with parameters T , B \u2265 1, \u03b7 = B\u221a T and m = O\n( B4T log (BT ) ) ."}, {"heading": "Then:", "text": "1. For every sequence of squared losses \u21131, . . . , \u2113T observed by the algorithm we have for f1, . . . , fT :\nE\n[\nT \u2211\nt=1\n\u2113t(ft)\u2212 min f\u2217\u2208HB\u00b5 \u2113t(f \u2217)\n]\n= O(B \u221a T )\n2. The run-time of the algorithm is O\u0303 ( \u03c1B4T 2 ) .3\n3. For each t = 1 . . . T and a new test example x, we can estimate \u3008ft,\u03a6(x)\u3009 within accuracy \u01eb0 by running Algorithm 2 with parameters \u03b1\n(t), {xi}ti=1, ,x and m = O(B\n4T \u01eb2 0 log 1/\u03b4). The resulting running time at test is then O(\u03c1m).\nWe next turn to the statistical setting, where we provide bounds on the expected performance. Following standard online to batch conversion and Theorem 1 we can obtain the following Corollary (e.g., [25]):\nCorollary 1 (Statistical Setting). Let S = {xt, yt}Tt=1, be an IID sample drawn from some unknown distribution P The following holds for any \u01eb > 0. Run Algorithm 1 as in Theorem 1, with T = O(B\n\u01eb2 ). Let fS = 1 T\n\u2211\nft. Then the expected loss satisfies:\nE S\u223cP [L(fS)] < inf f\u2217\u2208HB\u00b5\nL(f\u2217) + \u01eb.\nThe runtime of the algorithm, as well as estimation time on a test example are as defined in Theorem 1."}, {"heading": "4 Related Work", "text": "Learning random features can be traced to the early days of learning [22], and infinite networks have also been introduced more than 20 years ago [29, 17]. More recent works have considered learning neural nets (also multi-layer) with infinite hidden units using\n3Ignoring logarithmic factors in B and T .\nthe kernel trick [8, 13, 15, 16]. These works take a similar approach to ours but focus on computing the kernel for certain feature classes in order to invoke the kernel trick. Our work in contrast avoids using the kernel trick and applies to any feature class that can be randomly generated. All the above works are part of a broader effort of trying to circumvent hardness in deep learning by mimicking deep nets through kernels [21, 4, 2, 3], and developing general duality between neural networks and kernels [11].\nFrom a different perspective the relation between random features and kernels has been noted in [23] where the authors represent translation invariant kernels in terms of random features. This idea has been further studied in [1, 18] for other kernels as well. The focus of these works is mainly to allow scaling down of the feature space and representation of the final output classifier.\nThe idea is also present in [9], where the authors focus on tractability of large scale kernel methods. More relevant to our work is that one can show that the optimization method in [9] can be invoked whenever the kernel can be estimated using random features. In [9] the objective considered is of the regularized form:\u03b32\u2016f\u20162 + R(f), with a corresponding sample complexity of O(1/(\u03b32\u01eb2)) samples needed to achieve \u01eb approximation with respect to the risk of the optimum of the regularized objective.\nTo relate the above results to ours, we begin by emphasizing that the bound in [9] holds for fixed \u03b3, and refers to optimization of the regularized objective. Our objective is to minimize the risk R(f) which is the expected squared loss, for which we need to choose \u03b3 = O( \u01eb\nB2 ) in order to attain accuracy \u01eb [28]. Plugging this \u03b3 into the generalization\nbound in [9] we obtain that the algorithm in [9] needs O(B 4\n\u01eb4 ) samples to compete with\nthe optimal target function in the B-ball. Our algorithm needs O(B \u01eb2 ) examples. We note that their method does extends to a larger class of losses, whereas our is restricted to the quadratic loss.\nIn [24], the authors consider embedding the domain into the feature space x \u2192 (\u03c8(w1;x), . . . , \u03c8(wm;x), where w1, . . . ,wm are IID random variables sampled according to some prior \u00b5(w). They show that with O(B 2 log 1/\u03b4\n\u01eb2 ) random features estimated on\nO(B 2 log 1/\u03b4\n\u01eb2 ) samples they can compete with the class:\nHB\u00b5 max = { x \u2192 \u222b \u03c8(w;x)f(w)d\u00b5(w) : |f(w)| \u2264 B } . (8)\nOur algorithm relates to the mean square error cost function which does not meet the condition in [24], and is hence formally incomparable. Yet we can invoke our algorithm to compete against a larger class of target functions. Our main result shows that Algorithm 1, using O\u0303(B 8\n\u01eb4 ) estimated features and using O(B\n2\n\u01eb2 ) samples, will, in\nexpectation, output a predictor that is \u01eb close to the best in HB\u00b5 . Note that |f(w)| < B implies Ew\u223c\u00b5(f2(w)) < B2. Hence HB\u00b5 max \u2286 H B \u00b5 . Note howver, that the number of estimated features (as a function of B) is worse in our case. Our approach to the problem is to consider learning with a noisy estimate of the kernel. A related setting was studied in [7], where the authors considered learning with kernels when the data is corrupted. Noise in the data and noise in the scalar product\nestimation are not equivalent when there is non linearity in the kernel space embedding. There is also extensive research on linear regression with actively chosen attributes [6, 14]. The convergence rates and complexity of the algorithms are dimension dependent. It is interesting to see if their method can be extended from finite set of attributes to a continuum set of attributes."}, {"heading": "5 Algorithm", "text": "We next turn to present Algorithm 1, from which our main result is derived. The algorithm is similar in spirit to Online Gradient Descent (OGD) [31], but with some important modifications that are necessary for our analysis.\nWe first introduce the problem in the terminology of online convex optimization, as in [31]. At iteration t our algorithm outputs a hypothesis ft. It then receives as feedback (xt, yt), and suffers a loss \u2113t(ft) as in Eq. 5.\nThe objective of the algorithm is to minimize the regret against a benchmark of B-bounded functions, as in Eq. 6.\nA classic approach to the problem is to exploit the OGD algorithm. Its simplest version would be to update ft+1 \u2192 ft \u2212 \u03b7\u2207t where \u03b7 is a step size, and \u2207t is the gradient of the loss wrt f at ft. In our case, \u2207t is given by:\n\u2207t = (yt \u2212 \u3008ft,\u03a6(xt)\u3009) \u03a6(xt) (9)\nApplying this update would also result in a function ft = \u2211t\ni=1 \u03b1i\u03a6(xt) as we have in Algorithm 1 (but with different \u03b1i from ours). However, in our setting this update is not applicable since the scalar product \u3008ft,\u03a6(xt)\u3009 is not available.\nOne alternative is to use a stochastic unbiased estimate of the gradient that we denote by \u2207\u0304t. This induces an update step ft+1 \u2192 ft \u2212 \u03b7\u2207\u0304t. One can show that OGD with such an estimated gradient enjoys the following regret bound for every \u2016f\u2217\u2016 \u2264 B (see for example [25]):\nE\n[\n\u2211 \u2113t(ft)\u2212 \u2113t(f\u2217) ] \u2264 B 2\n\u03b7 + \u03b7\nT \u2211\ni=1\nE [ \u2016\u2207t\u20162 ] + \u03b7\nT \u2211\ni=1\nV [ \u2207\u0304t ] . (10)\nWhere V [ \u2207\u0304t ] = E [ \u2016\u2207\u0304t \u2212\u2207t\u20162 ]\n. We can bound the first two terms using standard techniques applicable for the squared loss (as appeared for example in [30] or [27]). The third term depends on our choice of gradient estimate. There are multiple possible choices for such an estimate, and we use a version which facilitates our analysis.\nAssume that at iteration t, our function ft is given by ft = \u2211t i=1 \u03b1 (t) i \u03a6(xt). We now want to use sampling to obtain an unbiased estimate of \u3008ft,\u03a6(xt)\u3009. We will do this via a two step sampling procedure, as described in Algorithm 2. First, sample an index i \u2208 [1, . . . , t] by sampling according to the distribution q(i) \u221d |\u03b1(t)i |. Next, for the chosen i, sample w\u0304 according to \u00b5, and use \u03c8(x; w\u0304)\u03c8(xi; w\u0304) to construct an estimate of\n\u3008\u03a6(xi),\u03a6(xt)\u3009. The resulting unbiased estimate of \u3008\u03a6(xi),\u03a6(xt)\u3009 is denoted by Et and given by:\nEt = \u2016\u03b1(t)\u20161\nm\nm \u2211\ni=1\nsgn(\u03b1 (t) i )\u03c8(xi; w\u0304)\u03c8(xt; w\u0304) (11)\nThe corresponding unbiased gradient estimate is:\n\u2207\u0304t = (Et \u2212 yt)xt (12) The variance of \u2207\u0304 affects the convergence rate and depends on both \u2016\u03b1\u20161 and m\u2013 the number of estimations. We wish to maintain m = O(T ) estimations per round, while achieving O( \u221a T ) regret.\nTo effectively regularize \u2016\u03b1\u20161, we modify the OGD algorithm so that whenever Et is larger then 16B, we do not perform the usual update. Instead, we perform a shrinking step that divides \u03b1(t) (and hence ft) by 4. Treating B as constant, this guarantees that \u2016\u03b1\u20161 = O(\u03b7T ), and in turn Var(\u2207\u0304t) = O(\u03b7 2T 2 m ). Setting \u03b7 = O(1/ \u221a T ), we have that m = O(T ) estimations are enough. The rationalle behind the shrinkage is that whenever Et is large, it indicates that ft is \u201cfar away\u201d from the B-ball, and a shrinkage step, similar to projection, leads ft closer to the optimal element in the B-ball hence improves ft. However, due to stochasticity, the shrinkage step does add a further term to the regret bound that we would need to take care of."}, {"heading": "5.1 Analysis", "text": "In what follows we analyze the regret for Algorithm 1. We begin by modifying the regret bound for OGD in Eq. 10 to accommodate for steps that differ from the standard gradient update, such as shrinkage.\nLemma 1. Let \u21131, . . . , \u2113T be an arbitrary sequence of convex loss functions, and let f1, . . . , fT be random vectors, produced by an online algorithm. Assume \u2016fi\u2016 \u2264 BT for all i \u2264 T . For each t let \u2207\u0304t be an unbiased estimator of \u2207\u2113t(ft). Denote f\u0302t = ft\u22121 \u2212 \u03b7\u2207\u0304t\u22121 and let\nPt(f \u2217) = P\n[ \u2016ft \u2212 f\u2217\u2016 > \u2016f\u0302t \u2212 f\u2217\u2016 ] . (13)"}, {"heading": "For every \u2016f\u2217\u2016 \u2264 B it holds that:", "text": "E\n[\nT \u2211\nt=1\n\u2113t(ft)\u2212 \u2113t(f\u2217) ] \u2264 B 2\n\u03b7 +\u03b7\nT \u2211\nt=1\nE [ \u2016\u2207t\u20162 ] +\u03b7\nT \u2211\nt=1\nV [ \u2207\u0304t ] +\nT \u2211\nt=1\n(BT +B) 2\n\u03b7 E [Pt+1(f\n\u2217)]\n(14)\nAs discussed earlier, the first two terms in the RHS are the standard bound for OGD from Eq. 10. Note that in OGD we always choose ft = f\u0302t therefore Pt(f\n\u2217) = 0 and the last term disappears.\nThe third term will be bounded by controlling \u2016\u03b1\u20161. The last term Pt+1(f\u2217) is a penalty that results from updates that stir ft away from the standard update step f\u0302t. This will indeed happen for the shrinkage step. The next lemma bounds this term.\nLemma 2. Run Algorithm 1 with parameters T , B \u2265 1 and \u03b7 < 1/8. Let \u2207\u0304t be the unbiased estimator of \u2207\u2113t(ft) of the form\n\u2207\u0304t = (Et \u2212 yt)\u03a6(xt)."}, {"heading": "Denote f\u0302t = ft \u2212 \u03b7\u2207\u0304t and define Pt(f\u2217) as in Eq. 13.", "text": "Pt(f \u2217) \u2264 2 exp\n(\n\u2212 m (3\u03b7t)2\n)\nConsidering Lemma 2 and Lemma 1, we obtain that the last term in Eq. 14 can be\nbounded by \u03b7T if we consider m = O\n(\n(\u03b7T )2 log (\nBT \u03b7\n)2 )\nestimations (while again for\nsimplicity, treating B as constant). One can show that BT = O(\u03b7T ), hence neglecting logarithmic factors and by choice of \u03b7 = O( 1\u221a\nT ), we obtain that m = O\u0303(T ) estimations\nper round suffice to bound the fourth term. A full proof of Theorem 1 and the above two Lemmas is given in the Appendix."}, {"heading": "6 Discussion", "text": "We presented a new online algorithm that employs kernels implicitly but avoids the kernel trick assumption. Namely, the algorithm can be invoked even when one has access to only estimations of the scalar product. The problem was motivated by kernels resulting from neural nets, but it can of course be applied to any scalar product of the form we described. To summarize, we can cast our result into a larger model that might be of independent interest. Consider a setting where a learner can observe an unbiased estimate of a coordinate in a kernel matrix, or alternatively the scalar product between any two observations. Our results imply that in this setting the above rates are applicable, and at least for the square loss, having no access to the true values in the kernel matrix is not necessarily prohibitive during training.\nThe results show that with sample size T we can achieve error of O( B\u221a T ). As demonstrated by [26] these rates are optimal, even when the scalar product is computable. To achieve this rate our algorithm needs to perform O\u0303(B4T 2) scalar product estimations. When the scalar product can be computed, existing kernelized algorithms need to observe a fixed proportion of the kernel matrix, hence they observe order of \u2126(T 2) scalar products. In [5] it was shown that when the scalar product can be computed exactly, one would need access to at least \u2126(T ) entries to the kernel matrix. It is still an open problem whether one has to access \u2126(T 2) entries when the kernel can be computed exactly. However, as we show here, for fixed B even if the kernel can only be estimated O\u0303(T 2) estimations are enough. It would be interesting to further investigate and improve the performance of our algorithm in terms of the norm bound B."}, {"heading": "Acknowledgement", "text": "The authors would like to thank Tomer Koren for helpful comments and suggestions. Roi Livni is a recipient of the Google Europe Fellowship in Learning Theory, and this research is supported in part by this Google Fellowship, and a Google Research Award."}, {"heading": "A Estimation Procedure \u2013 Concentration Bounds", "text": "In this section we provide concentration bounds for the estimation procedure in Algorithm 2.\nLemma 3. Run Algorithm 2 with \u03b1 and, {xi}Ti=1 x, and m. Let f = \u2211\n\u03b1i\u03a6(xi). Assume that |\u03c8(x;w)| < 1 for all w and x. Let E be the output of Algorithm 2. Then E is an unbiased estimator for \u3008f,\u03a6(x)\u3009 and:\nP [|E \u2212 \u3008f,\u03a6(x)\u3009| > \u01eb] \u2264 exp ( \u2212 m\u01eb 2\n\u2016\u03b1\u201621\n)\n(15)\nProof. Consider the random variables \u2016\u03b1\u20161E(k) (where E(k) is as defined in Algorithm 2) and note that they are IID. One can show that E [ \u2016\u03b1\u20161E(k) ] = \u2211 \u03b1iE [\u03c8(\u03a6(xi); w\u0304)\u03c8(\u03a6(x); w\u0304)] = \u3008f,\u03a6(x)\u3009. By the bound on \u03c8(x;w) we have that \u2223 \u2223\u2016\u03b1\u20161E(k) \u2223\n\u2223 < \u2016\u03b1\u20161 with probability 1. Since E = 1m \u2211 E(k) the result follows directly from Hoeffding\u2019s inequality.\nNext, we relate these guarantees to the output of Algorithm 1:\nLemma 4. The \u03b1(t) obtained in Algorithm 1 satisfies:\n\u2016\u03b1(t)\u20161 \u2264 (16B + 1)\u03b7t.\nAs a corollary of this and Lemma 3 we have that the function ft satisfies:\nP [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| > \u01eb] \u2264 exp ( \u2212 \u01eb 2m\n((16B + 1)\u03b7t)2\n)\n(16)\nProof. We prove the statement by induction. We separate into two cases, depending on whether the shrinkage step was performed or not.\nIf |Et| \u2265 16B the algorithm sets \u03b1(t+1) = 14\u03b1(t), and:\n\u2016\u03b1(t+1)\u20161 = 1\n4 \u2016\u03b1(t)\u20161 \u2264 (16B + 1)\u03b7(t + 1)\nIf |Et| < 16B the gradient update is performed. Since |yt| \u2264 1 we have that |Et\u2212yt| < 16B + 1 and:\n\u2016\u03b1(t+1)\u20161 \u2264 \u2016\u03b1(t)\u20161 + \u03b7|Et \u2212 yi| \u2264 (16B + 1)\u03b7(t + 1)."}, {"heading": "B Proofs of Lemmas", "text": ""}, {"heading": "B.1 Proof of Lemma 1", "text": "First, by convexity we have that\n2(\u2113t(ft)\u2212 \u2113t(f\u2217)) \u2264 2 \u3008\u2207t, ft \u2212 f\u2217\u3009 . (17)\nNext we upper bound \u3008\u2207t, ft \u2212 f\u2217\u3009. Denote by E the event \u2016ft+1\u2212f\u2217\u2016 > \u2016f\u0302t+1\u2212f\u2217\u2016. Note that\nE [ \u2016ft+1 \u2212 f\u2217\u20162 ] \u2264 E [ \u2016f\u0302t+1 \u2212 f\u2217\u20162 ] + E [ \u2016ft+1 \u2212 f\u2217\u20162 \u2223 \u2223E ] \u00b7 Pt+1(f\u2217) \u2264\nE\n[ \u2016f\u0302t+1 \u2212 f\u2217\u20162 ] + (B +BT ) 2Pt+1(f \u2217)\nPlugging in f\u0302t+1 = ft \u2212 \u03b7\u2207\u0304t we get\nE [ \u2016ft+1 \u2212 f\u2217\u20162 ] \u2264 E [ \u2016ft \u2212 f\u2217\u20162 ] +\u03b72E [ \u2016\u2207\u0304t\u20162 ] \u22122\u03b7E [ \u3008\u2207\u0304t, ft \u2212 f\u2217\u3009 ] +(B+BT ) 2Pt+1(f \u2217)\nDividing by \u03b7 we have that:\n2E [ \u3008\u2207\u0304t, ft \u2212 f\u2217\u3009 ] \u2264 E [ \u2016ft \u2212 f\u2217\u20162 ] \u2212 E [ \u2016ft+1 \u2212 f\u2217\u20162 ]\n\u03b7 + 1 \u03b7 E [ (B +BT ) 2Pt+1(f \u2217) ] +\u03b7E [ \u2016\u2207\u0304t\u20162 ]\n(18) Taking 17 and 18 and summing we have:\n2E\n[\nT \u2211\nt=1\n\u2113t(ft)\u2212 \u2113t(f\u2217) ] \u2264 2E [ \u2207\u22a4t (ft \u2212 f\u2217) ] = 2E [ \u2207\u0304\u22a4t (ft \u2212 f\u2217) ] \u2264\n\u2016f\u2217\u20162 \u03b7 + 1 \u03b7 T \u2211\nt=1\nE [ (B +BT ) 2Pt+1(f \u2217) ] + \u03b7\nT \u2211\nt=1\nE [ \u2016\u2207\u0304t\u20162 ] .\nFinally note that E [ \u2016\u2207\u0304t\u20162 ] = E [ \u2016\u2207t\u20162 ] + V [ \u2207\u0304t ] to obtain the result."}, {"heading": "B.2 Proof for Lemma 2", "text": "To prove the bound in the lemma, we first bound the event Pt(f \u2217) w.r.t to two possible events:\nLemma 5. Consider the setting as in Lemma 2. Run Algorithm 1 and for each t consider the following two events:\n\u2022 E t1 : |Et| > 16B and |Et| > 14\u03b7\u2016ft\u2016.\n\u2022 E t2 : |Et| > 16B and \u2016ft\u2016 < 8B.\nFor every \u2016f\u2217\u2016 < B we have that Pt(f\u2217) < P [ E t1 \u222a E t2 ] .\nProof. Denote the event |Et| > 16B by E t0. Note that if E t0 does not happen, then ft = f\u0302t. Hence trivially\nPt(f \u2217) = P\n[ \u2016ft \u2212 f\u2217\u2016 > \u2016f\u0302t \u2212 f\u2217\u2016 \u2227 E t0 ]\nWe will assume that:\n1. |Et| > 16B.\n2. |Et| < 14\u03b7\u2016ft\u2016.\n3. \u2016ft\u2016 > 8B\nand show \u2016ft+1 \u2212 f\u2217\u2016 \u2264 \u2016f\u0302t+1 \u2212 f\u2217\u2016. In other words, we will show that if E t0 happens and \u2016ft+1 \u2212 f\u2217\u2016 > \u2016f\u0302t+1 \u2212 f\u2217\u2016, then either E t2 or E t1 happened. This will conclude the proof. Fix t, note that since |\u03c8(x;w)| < 1 we have that \u2016\u03a6(x)\u2016 < 1. We then have:\n\u2016f\u0302t+1\u2016 = \u2016ft\u2212\u03b7(Et\u2212y)\u03a6(xt)\u2016 > \u2016ft\u2016\u2212\u2016\u03b7(Et\u2212y)\u03a6(xt)\u2016 \u2265 \u2016ft\u2016\u2212\u03b7|Et|\u2212\u03b7 \u2265 3\n4 \u2016ft\u2016\u2212\u03b7\nWhere the last inequality is due to assumption 2. We therefore have the following bound for every \u2016f\u2217\u2016 < B:\n\u2016f\u0302t+1 \u2212 f\u2217\u2016 \u2265 3\n4 \u2016ft\u2016 \u2212 \u03b7 \u2212B\nOn the other hand, if ft+1 6= f\u0302t+1 then by construction of the algorithm ft+1 = 14ft:\n\u2016ft+1 \u2212 f\u2217\u2016 \u2264 \u2016ft+1\u2016+ \u2016f\u2217\u2016 \u2264 \u2016ft\u2016 4 +B.\nNext note that \u03b7 < 2B and assumption 3 states \u2016ft\u2016 > 8B. Therefore:\n1 2 \u2016ft\u2016 > 4B > \u03b7 + 2B\nand we obtained the desired result:\n\u2016f\u0302t+1\u2212f\u2217\u2016 \u2265 3\n4 \u2016ft\u2016\u2212\u03b7\u2212B =\n1 4 \u2016ft\u2016+\n(\n1 2 \u2016ft\u2016 \u2212 \u03b7 \u2212 2B\n)\n+B \u2265 1 4 \u2016ft\u2016+B \u2265 \u2016ft+1\u2212f\u2217\u2016\nNext we upper bound P [ E t1 \u222a E t2 ] . In what follows the superscript t is dropped.\nA bound for P [E1 \u2229 Ec2 ]: Assume that\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| < ( 1\n4\u03b7 \u2212 1)8B.\nWe assume T is sufficiently large and \u03b7 < 18 . We have 1 4\u03b7 \u2212 1 > 1. Since we assume E2 did not happen we must have \u2016ft\u2016 > 8B and\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| < ( 1\n4\u03b7 \u2212 1)\u2016f\u2016.\nWe continue:\nEt \u2212 \u2016f\u2016 < |Et \u2212 \u3008ft,\u03a6(xt)\u3009| < ( 1\n4\u03b7 \u2212 1)\u2016f\u2016.\nWhich leads to\nEt < 1\n4\u03b7 \u2016f\u2016.\nAnd we get that E1 did not happen. We conclude that if E1 and not E2 then:\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 ( 1\n4\u03b7 \u2212 1)8B.\nSince 14\u03b7 \u2212 1 > 1 we have that:\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B.\nWe conclude that:\nP [E1 \u2229 Ec2 ] \u2264 P [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B] . (19)\nA bound for P [E2]: If |Et| > 16B and \u2016ft\u2016 < 8B then by normalization of \u03a6(xt) we have that \u3008ft,\u03a6(xt)\u3009 < 8B and trivially we have that\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B.\nAnd again we have that:\nP [E2] \u2264 P [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B] . (20)\nTaking Eq. 19 and Eq. 20 we have that\nP [E2 \u222a E1] \u2264 2P [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B] . (21)\nBy Lemma 4 we have that:\nP (|Et \u2212 \u3008ft,\u03a6(xt)\u3009|) > 8B) <\nexp(\u2212 m(8B) 2\n((16B + 1)\u03b7t)2 ) < exp\n(\n\u2212 m (3\u03b7t)2\n)\nTaking the above upper bounds together with Lemma 5 we can prove Lemma 2."}, {"heading": "C Proof of Main Result", "text": "C.1 Some more technical Lemmas\nWe begin by deriving Corollary 2 that bounds the first two terms in the regret bound. As discussed, this section follows standard techniques. We begin with an upper bound on E(\u2016\u2207\u0304t\u20162).\nLemma 6. Consider the setting as in Lemma 2. Then\nV [ \u2207\u0304t ] \u2264 ((16B + 1)\u03b7t) 2\nm ,\nand, E [ \u2016\u2207t\u20162 ]\n\u2264 2E [\u2113t(ft)] . Proof. Begin by noting that since \u2016\u03a6(x)\u2016 < 1, it follows from the definitions of \u2207, \u2207\u0304 that:\nV [ \u2207\u0304t ] = E [ \u2016\u2207\u0304t \u2212\u2207t\u20162 ] \u2264 E [ (Et \u2212 \u3008ft,\u03a6(xt)\u3009)2 ] = V [Et]\nBy construction (see Algorithm 2) we have that:\nV [Et] = 1 m V [ \u2016\u03b1(t)\u201621\u03c8(xi;w)\u03c8(xt;w) ]\nwhere the index i is sampled as in Algorithm 2, and \u03c8(xi;w)\u03c8(xt;w) is bounded by 1. By Lemma 4 we have that\nV [Et] \u2264 ((16B + 1)\u03b7t)2\nm .\nThis provides the required bound on V [ \u2207\u0304t ] . Additionally, we have that\n\u2016\u2207t\u20162 = (\u3008ft,\u03a6(xt)\u3009 \u2212 yt)2\u2016\u03a6(xt)\u20162 \u2264 2\u2113t(ft)\nand the result follows by taking expectation.\nWe thus have the following corollary that bounds the first three terms in Eq. 14:\nCorollary 2. With the notations and setting of Lemma 2 we have:\nB2\n\u03b7 + \u03b7\nT \u2211\nt=1\nE [ \u2016\u2207t\u20162 ] + \u03b7\nT \u2211\nt=1\nV [ \u2207\u0304t ] \u2264 2\u03b7E [ T \u2211\nt=1\n\u2113t(ft)\u2212 \u2113t(f\u2217) ] + B2\n\u03b7 (22)\n+2\u03b7\nT \u2211\nt=1\n\u2113t(f \u2217) + \u03b7\nT \u2211\nt=1\n((16B + 1)\u03b7T )2\nm"}, {"heading": "C.2 Proof of Theorem 1", "text": "Recall that Lemma 1 and Corollary 2 assume an upper bound BT on \u2016ft\u2016. We begin by noting that BT can be bounded as follows, using Lemma 4:\nBT = max t \u2016ft\u2016 \u2264 max t \u2016\u03b1(t)\u20161 \u2264 (16B + 1)\u03b7T. (23)\nPlugging Corollary 2 into Eq. 14 we obtain:\n(1\u22122\u03b7)E [ T \u2211\nt=1\n\u2113t(ft)\u2212 \u2113t(f\u2217) ] \u2264 B 2\n\u03b7 +2\u03b7\nT \u2211\nt=1\n\u2113t(f \u2217)+\u03b7\nT \u2211\nt=1\n((16B + 1)\u03b7T )2\nm + (BT +B)\n2\n\u03b7\nT \u2211\nt=1\nPt(f \u2217)\n(24)\nTo bound the second term we note that:\nmin \u2016f\u2217\u2016<B\nT \u2211\nt=1\n\u2113t(f \u2217) \u2264\nT \u2211\nt=1\n\u2113t(0) \u2264 T. (25)\nWe next set \u03b7 and m as in the statement of the theorem. Namely: \u03b7 = B 2 \u221a T , and m = ((16B + 1)B)2T log \u03b3, where \u03b3 = max (\n((16B+1)\u03b7T+B)2 ) \u03b72 , e ) .\nOur choice of m implies that m > ((16B+1)\u03b7T )2, and hence the third term in Eq. 24 is bounded as follows:\n\u03b7 T \u2211\nt=1\n((16B + 1)\u03b7T )2\nm \u2264 \u03b7T (26)\nNext we have that m > (3\u03b7t)2 log \u03b3 for every t, and by the bound on BT we have\nthat \u03b3 > (B+BT ) 2\n\u03b72 . Taken together with Lemma 2 we have that:\n(BT +B) 2\n\u03b7\nT \u2211\nt=1\nPt(f \u2217) \u2264 \u03b7T. (27)\nTaking Eq. 25, Eq. 27 and Eq. 26, plugging them into Eq. 24 we have that:\n(1\u2212 2\u03b7)E [ T \u2211\nt=1\n\u2113t(ft)\u2212 \u2113t(f\u2217) ] \u2264 B 2\n\u03b7 + 2\u03b7T + \u03b7T + \u03b7T\nFinally by choice of \u03b7, and dividing both sides by (1 \u2212 2\u03b7) we obtain the desired result.\nIt remains to show that we can estimate each ft in the desired complexity (the result\nfor the averaged f is the same). Each ft has the form ft = \u2211T t=1 \u03b1 (t) i xi, By Lemma 3 and Lemma 4, running Algorithm 2 m iterations will lead to a random variable E such that:\nP [|E \u2212 \u3008ft,x\u3009 |] \u2264 exp ( \u2212 \u01eb 2m\n((16B + 1)B \u221a T )2\n)\n.\nWe obtain that order of O(B 4T \u01eb2 log 1/\u03b4) estimations are enough."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "<lb>Infinite\u2013Layer Networks (ILN) have recently been proposed as an architecture<lb>that mimics neural networks while enjoying some of the advantages of kernel meth-<lb>ods. ILN are networks that integrate over infinitely many nodes within a single<lb>hidden layer. It has been demonstrated by several authors that the problem of<lb>learning ILN can be reduced to the kernel trick, implying that whenever a certain<lb>integral can be computed analytically they are efficiently learnable.<lb>In this work we give an online algorithm for ILN, which avoids the kernel trick<lb>assumption. More generally and of independent interest, we show that kernel meth-<lb>ods in general can be exploited even when the kernel cannot be efficiently computed<lb>but can only be estimated via sampling.<lb>We provide a regret analysis for our algorithm, showing that it matches the<lb>sample complexity of methods which have access to kernel values. Thus, our method<lb>is the first to demonstrate that the kernel trick is not necessary as such, and random<lb>features suffice to obtain comparable performance.", "creator": "LaTeX with hyperref package"}}}