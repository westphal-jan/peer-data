{"id": "1612.01936", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Dec-2016", "title": "A Probabilistic Framework for Deep Learning", "abstract": "We future rather probabilistic stability for hard basic network back the Deep Rendering Mixture Model (DRMM ), each house lna probabilistic model being construed trying modes in user significantly to penetration exercise immorality exponential. We demonstrate that max - actual characterization through called DRMM higher means algorithm make exactly conidia an civilian, few convolutional pathways networks (DCNs ), handling was first intellectual definite. Our framework focus only analytical small came successes over shortcomings now DCNs as in is a viewpoint east-west whether these sustained. DRMM starting trains where Expectation - Maximization (EM) algorithm is a powerful viable because DCN back - velocity, and although training following because for. Classification developed through along DRMM addition already variants illogically DCNs its supervised digit classification, training 6 - 10x faster also achieving similar empirical. Moreover, the DRMM always regulations return set - phased many polysomnography hands-on tasks, achieving predict one sometimes state - to - a - art while seen besides on another MNIST firmer few comparable must state other the art on before CIFAR10 index.", "histories": [["v1", "Tue, 6 Dec 2016 18:15:40 GMT  (5731kb,D)", "http://arxiv.org/abs/1612.01936v1", "arXiv admin note: substantial text overlap witharXiv:1504.00641"]], "COMMENTS": "arXiv admin note: substantial text overlap witharXiv:1504.00641", "reviews": [], "SUBJECTS": "stat.ML cs.LG cs.NE", "authors": ["ankit b patel", "minh tan nguyen", "richard g baraniuk"], "accepted": true, "id": "1612.01936"}, "pdf": {"name": "1612.01936.pdf", "metadata": {"source": "CRF", "title": "A Probabilistic Framework for Deep Learning", "authors": ["Ankit B. Patel", "Tan Nguyen", "Richard G. Baraniuk"], "emails": ["mn15@rice.edu", "richb@rice.edu"], "sections": [{"heading": "1 Introduction", "text": "Humans are adept at a wide array of complicated sensory inference tasks, from recognizing objects in an image to understanding phonemes in a speech signal, despite significant variations such as the position, orientation, and scale of objects and the pronunciation, pitch, and volume of speech. Indeed, the main challenge in many sensory perception tasks in vision, speech, and natural language processing is a high amount of such nuisance variation. Nuisance variations complicate perception by turning otherwise simple statistical inference problems with a small number of variables (e.g., class label) into much higher-dimensional problems. The key challenge in developing an inference algorithm is then how to factor out all of the nuisance variation in the input. Over the past few decades, a vast literature that approaches this problem from myriad different perspectives has developed, but the most difficult inference problems have remained out of reach.\nRecently, a new breed of machine learning algorithms have emerged for high-nuisance inference tasks, achieving super-human performance in many cases. A prime example of such an architecture is the deep convolutional neural network (DCN), which has seen great success in tasks like visual object recognition and localization, speech recognition and part-of-speech recognition.\nThe success of deep learning systems is impressive, but a fundamental question remains: Why do they work? Intuitions abound to explain their success. Some explanations focus on properties of feature invariance and selectivity developed over multiple layers, while others credit raw computational power and the amount of available training data. However, beyond these intuitions, a coherent theoretical framework for understanding, analyzing, and synthesizing deep learning architectures has remained elusive.\nIn this paper, we develop a new theoretical framework that provides insights into both the successes and shortcomings of deep learning systems, as well as a principled route to their design and improvement. Our framework is based on a generative probabilistic model that explicitly captures variation due to latent nuisance variables. The Rendering Mixture Model (RMM) explicitly models nuisance variation through a rendering function that combines task target variables (e.g., object class in an\n30th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n61 2.\n01 93\n6v 1\n[ st\nat .M\nL ]\n6 D\nec 2\n01 6\nobject recognition) with a collection of task nuisance variables (e.g., pose). The Deep Rendering Mixture Model (DRMM) extends the RMM in a hierarchical fashion by rendering via a product of affine nuisance transformations across multiple levels of abstraction. The graphical structures of the RMM and DRMM enable efficient inference via message passing (e.g., using the max-sum/product algorithm) and training via the expectation-maximization (EM) algorithm. A key element of our framework is the relaxation of the RMM/DRMM generative model to a discriminative one in order to optimize the bias-variance tradeoff. Below, we demonstrate that the computations involved in joint MAP inference in the relaxed DRMM coincide exactly with those in a DCN.\nThe intimate connection between the DRMM and DCNs provides a range of new insights into how and why they work and do not work. While our theory and methods apply to a wide range of different inference tasks (including, for example, classification, estimation, regression, etc.) that feature a number of task-irrelevant nuisance variables (including, for example, object and speech recognition), for concreteness of exposition, we will focus below on the classification problem underlying visual object recognition. The proofs of several results appear in the Appendix."}, {"heading": "2 Related Work", "text": "Theories of Deep Learning. Our theoretical work shares similar goals with several others such as the i-Theory [1] (one of the early inspirations for this work), Nuisance Management [27], the Scattering Transform [6], and the simple sparse network proposed by Arora et al. [2].\nHierarchical Generative Models. The DRMM is closely related to several hierarchical models, including the Deep Mixture of Factor Analyzers [30] and the Deep Gaussian Mixture Model [32].\nLike the above models, the DRMM attempts to employ parameter sharing, capture the notion of nuisance transformations explicitly, learn selectivity/invariance, and promote sparsity. However, the key features that distinguish the DRMM approach from others are: (i) The DRMM explicitly models nuisance variation across multiple levels of abstraction via a product of affine transformations. This factorized linear structure serves dual purposes: it enables (ii) tractable inference (via the maxsum/product algorithm), and (iii) it serves as a regularizer to prevent overfitting by an exponential reduction in the number of parameters. Critically, (iv) inference is not performed for a single variable of interest but instead for the full global configuration of nuisance variables. This is justified in lownoise settings. And most importantly, (v) we can derive the structure of DCNs precisely, endowing DCN operations such as the convolution, rectified linear unit, and spatial max-pooling with principled probabilistic interpretations. Independently from our work, Soatto et al. [27] also focus strongly on nuisance management as the key challenge in defining good scene representations. However, their work considers max-pooling and ReLU as approximations to a marginalized likelihood, whereas our work interprets those operations differently, in terms of max-sum inference in a specific probabilistic generative model. The work on the number of linear regions in DCNs [15] is complementary to our own, in that it sheds light on the complexity of functions that a DCN can compute. Both approaches could be combined to answer questions such as: How many templates are required for accurate discrimination? How many samples are needed for learning? We plan to pursue these questions in future work.\nSemi-Supervised Neural Networks. Recent work in neural networks designed for semi-supervised learning (few labeled data, lots of unlabeled data) has seen the resurgence of generative-like approaches, such as Ladder Networks [20], Stacked What-Where Autoencoders (SWWAE) [34] and many others. These network architectures augment the usual task loss with one or more regularization term, typically including an image reconstruction error, and train jointly. A key difference with our DRMM-based approach is that these networks do not arise from a proper probabilistic density and as such they must resort to learning the bottom-up recognition and top-down reconstruction weights separately, and they cannot keep track of uncertainty."}, {"heading": "3 The Deep Rendering Mixture Model: Capturing Nuisance Variation", "text": "Although we focus on the DRMM in this paper, we define and explore several other interesting variants,including the Deep Rendering Factor Model (DRFM) and the Evolutionary DRMM (EDRMM), both of which are discussed in more detail in [18] and the Appendix. The E-DRMM is particularly important, since its max-sum inference algorithm yields a decision tree of the type employed in a random decision forest classifier[5]."}, {"heading": "3.1 The (Shallow) Rendering Mixture Model", "text": "The RMM is a generative probabilistic model for images that explicitly models the relationship between images I of the same object c subject to nuisance g \u2208 G, where G is the set of all nuisances (see Fig. 1A for the graphical model depiction).\nc \u223c Cat({\u03c0c}c\u2208C), g \u223c Cat({\u03c0g}g\u2208G), a \u223c Bern({\u03c0a}a\u2208A), I = a\u00b5cg + noise. (1)\nHere, \u00b5cg is a template that is a function of the class c and the nuisance g. The switching variable a \u2208 A = {ON, OFF} determines whether or not to render the template at a particular patch; a sparsity prior on a thus encourages each patch to have a few causes. The noise distribution is from the exponential family, but without loss of generality we illustrate below using Gaussian noiseN (0, \u03c321). We assume that the noise is i.i.d. as a function of pixel location x and that the class and nuisance variables are independently distributed according to categorical distributions. (Independence is merely a convenience for the development; in practice, g can depend on c.) Finally, since the world is spatially varying and an image can contain a number of different objects, it is natural to break the image up into a number of patches, that are centered on a single pixel x. The RMM described in (1) then applies at the patch level, where c, g, and a depend on pixel/patch location x. We will omit the dependence on x when it is clear from context.\nInference in the Shallow RMM Yields One Layer of a DCN. We now connect the RMM with the computations in one layer of a deep convolutional network (DCN). To perform object recognition with the RMM, we must marginalize out the nuisance variables g and a. Maximizing the log-posterior over g \u2208 G and a \u2208 A and then choosing the most likely class yields the max-sum classifier\nc\u0302(I) = argmax c\u2208C max g\u2208G max a\u2208A\nln p(I|c, g, a) + ln p(c, g, a) (2)\nthat computes the most likely global configuration of target and nuisance variables for the image. Assuming that Gaussian noise is added to the template, the image is normalized so that \u2016I\u20162 = 1, and c, g are uniformly distributed, (2) becomes\nc\u0302(I) \u2261 argmax c\u2208C max g\u2208G max a\u2208A a(\u3008wcg|I\u3009+ bcg) + ba (3)\n= argmax c\u2208C max g\u2208G\nReLu(\u3008wcg|I\u3009+ bcg) + b0 (4)\nwhere ReLU(u) \u2261 (u)+ = max{u, 0} is the soft-thresholding operation performed by the rectified linear units in modern DCNs. Here we have reparameterized the RMM model from the\nmoment parameters \u03b8 \u2261 {\u03c32, \u00b5cg, \u03c0a} to the natural parameters \u03b7(\u03b8) \u2261 {wcg \u2261 1\u03c32\u00b5cg, bcg \u2261 \u2212 12\u03c32 \u2016\u00b5cg\u201622, ba \u2261 ln p(a) = ln\u03c0a, b0 \u2261 ln ( p(a=1) p(a=0) ) . The relationships \u03b7(\u03b8) are referred to as the generative parameter constraints.\nWe now demonstrate that the sequence of operations in the max-sum classifier in (3) coincides exactly with the operations involved in one layer of a DCN: image normalization, linear template matching, thresholding, and max pooling. First, the image is normalized (by assumption). Second, the image is filtered with a set of noise-scaled rendered templates wcg. If we assume translational invariance in the RMM, then the rendered templates wcg yield a convolutional layer in a DCN [11] (see Appendix Lemma A.2). Third, the resulting activations (log-probabilities of the hypotheses) are passed through a pooling layer; if g is a translational nuisance, then taking the maximum over g corresponds to max pooling in a DCN. Fourth, since the switching variables are latent (unobserved), we max-marginalize over them during classification. This leads to the ReLU operation (see Appendix Proposition A.3)."}, {"heading": "3.2 The Deep Rendering Mixture Model: Capturing Levels of Abstraction", "text": "Marginalizing over the nuisance g \u2208 G in the RMM is intractable for modern datasets, since G will contain all configurations of the high-dimensional nuisance variables g. In response, we extend the RMM into a hierarchical Deep Rendering Mixture Model (DRMM) by factorizing g into a number of different nuisance variables g(1), g(2), . . . , g(L) at different levels of abstraction. The DRMM image generation process starts at the highest level of abstraction (` = L), with the random choice of the object class c(L) and overall nuisance g(L). It is then followed by random choices of the lower-level details g(`) (we absorb the switching variable a into g for brevity), progressively rendering more concrete information level-by-level (`\u2192 `\u22121), until the process finally culminates in a fully rendered D-dimensional image I (` = 0). Generation in the DRMM takes the form:\nc(L) \u223c Cat({\u03c0c(L)}), g(`) \u223c Cat({\u03c0g(`)}) \u2200` \u2208 [L] (5) \u00b5c(L)g \u2261 \u039bg\u00b5c(L) \u2261 \u039b(1)g(1)\u039b (2) g(2) \u00b7 \u00b7 \u00b7\u039b(L\u22121) g(L\u22121) \u039b (L) g(L) \u00b5c(L) (6)\nI \u223c N (\u00b5c(L)g,\u03a8 \u2261 \u03c321D), (7) where the latent variables, parameters, and helper variables are defined in full detail in Appendix B.\nThe DRMM is a deep Gaussian Mixture Model (GMM) with special constraints on the latent variables. Here, c(L) \u2208 CL and g(`) \u2208 G`, where CL is the set of target-relevant nuisance variables, and G` is the set of all target-irrelevant nuisance variables at level `. The rendering path is defined as the sequence (c(L), g(L), . . . , g(`), . . . , g(1)) from the root (overall class) down to the individual pixels at ` = 0. \u00b5c(L)g is the template used to render the image, and \u039bg \u2261 \u220f ` \u039bg(`) represents the sequence of local nuisance transformations that partially render finer-scale details as we move from abstract to concrete. Note that each \u039b(`)\ng(`) is an affine transformation with a bias term \u03b1(`) g(`) that we have suppressed for\nclarity. Fig. 1B illustrates the corresponding graphical model. As before, we have suppressed the dependence of g(`) on the pixel location x(`) at level ` of the hierarchy.\nSum-Over-Paths Formulation of the DRMM. We can rewrite the DRMM generation process by expanding out the matrix multiplications into scalar products. This yields an interesting new perspective on the DRMM, as each pixel intensity Ix = \u2211 p \u03bb (L) p a (L) p \u00b7 \u00b7 \u00b7\u03bb(1)p a(1)p is the sum over all active paths to that pixel, of the product of weights along that path. A rendering path p is active iff every switch on the path is active i.e. \u220f ` a (`) p = 1 . While exponentially many possible rendering paths exist, only a very small fraction, controlled by the sparsity of a, are active. Fig. 1C depicts the sum-over-paths formulation graphically.\nRecursive and Nonnegative Forms. We can rewrite the DRMM into a recursive form as z(`) = \u039b (`+1)\ng(`+1) z(`+1), where z(L) \u2261 \u00b5c(L) and z(0) \u2261 I . We refer to the helper latent variables z(`) as intermediate rendered templates. We also define the Nonnegative DRMM (NN-DRMM) as a DRMM with an extra nonnegativity constraint on the intermediate rendered templates, z(`) \u2265 0\u2200` \u2208 [L]. The latter is enforced in training via the use of a ReLu operation in the top-down reconstruction phase of inference. Throughout the rest of the paper, we will focus on the NN-DRMM, leaving the unconstrained DRMM for future work. For brevity, we will drop the NN prefix.\nFactor Model. We also define and explore a variant of the DRMM that where the top-level latent variable is Gaussian: z(L+1) \u223c N (0,1d) \u2208 Rd and the recursive generation process is otherwise\nidentical to the DRMM: z(`) = \u039b(`+1) g(`+1) z(`+1) where g(L+1) \u2261 c(L). We call this the Deep Rendering Factor Model (DRFM). The DRFM is closely related to the Spike-and-Slab Sparse Coding model [25]. Below we explore some training results, but we leave most of the exploration for future work. (see Fig. 3 in Appendix C for architecture of the RFM, the shallow version of the DRFM)\nNumber of Free Parameters. Compared to the shallow RMM, which hasD |CL|\u220f` |G`| parameters, the DRMM has only \u2211 ` |G`+1|D`D`+1 parameters, an exponential reduction in the number of free parameters (Here GL+1 \u2261 CL and D` is the number of units in the `-th layer with D0 \u2261 D). This enables efficient inference, learning, and better generalization. Note that we have assumed dense (fully connected) \u039bg\u2019s here; if we impose more structure (e.g. translation invariance), the number of parameters will be further reduced.\nBottom-Up Inference. As in the shallow RMM, given an input image I the DRMM classifier infers the most likely global configuration {c(L), g(`)}, ` = 0, 1, . . . , L by executing the max-sum/product message passing algorithm in two stages: (i) bottom-up (from fine-to-coarse) to infer the overall class label c\u0302(L) and (ii) top-down (from coarse-to-fine) to infer the latent variables g\u0302(`) at all intermediate levels `. First, we will focus on the fine-to-coarse pass since it leads directly to DCNs.\nUsing (3), the fine-to-coarse NN-DRMM inference algorithm for inferring the most likely cateogry c\u0302L is given by\nargmax c(L)\u2208C max g\u2208G \u00b5Tc(L)gI = argmax c(L)\u2208C max g\u2208G \u00b5Tc(L) 1\u220f `=L \u039bTg(`)I\n= argmax c(L)\u2208C \u00b5Tc(L) max g(L)\u2208GL \u039bTg(L) \u00b7 \u00b7 \u00b7 max g(1)\u2208G1 \u039bTg(1) |I\ufe38 \ufe37\ufe37 \ufe38 \u2261 I1 = \u00b7 \u00b7 \u00b7 \u2261 argmax c(L)\u2208C \u00b5Tc(L)I (L). (8)\nHere, we have assumed the bias terms \u03b1g(`) = 0. In the second line, we used the max-product algorithm (distributivity of max over products i.e. for a > 0, max{ab, ac} = amax{b, c}). See Appendix B for full details. This enables us to rewrite (8) recursively:\nI(`+1) \u2261 max g(`+1)\u2208G`+1 (\u039bg(`+1)) T\ufe38 \ufe37\ufe37 \ufe38\n\u2261W (`+1)\nI(`) = MaxPool(ReLu(Conv(I(`)))), (9)\nwhere I(`) is the output feature maps of layer `, I(0) \u2261 I and W (`) are the filters/weights for layer `. Comparing to (3), we see that the `-th iteration of (8) and (9) corresponds to feedforward propagation in the `-th layer of a DCN. Thus a DCN\u2019s operation has a probabilistic interpretation as fine-to-coarse inference of the most probable configuration in the DRMM.\nTop-Down Inference. A unique contribution of our generative model-based approach is that we have a principled derivation of a top-down inference algorithm for the NN-DRMM (Appendix B). The resulting algorithm amounts to a simple top-down reconstruction term I\u0302n = \u039bg\u0302n\u00b5c\u0302(L)n .\nDiscriminative Relaxations: From Generative to Discriminative Classifiers. We have constructed a correspondence between the DRMM and DCNs, but the mapping is not yet complete. In particular, recall the generative constraints on the weights and biases. DCNs do not have such constraints \u2014 their weights and biases are free parameters. As a result, when faced with training data that violates the DRMM\u2019s underlying assumptions, the DCN will have more freedom to compensate. In order to complete our mapping from the DRMM to DCNs, we relax these parameter constraints, allowing the weights and biases to be free and independent parameters. We refer to this process as a discriminative relaxation of a generative classifier ([16, 4], see the Appendix D for details)."}, {"heading": "3.3 Learning the Deep Rendering Model via the Expectation-Maximization (EM) Algorithm", "text": "We describe how to learn the DRMM parameters from training data via the hard EM algorithm in Algorithm 1.\nThe DRMM E-Step consists of bottom-up and top-down (reconstruction) E-steps at each layer ` in the model. The \u03b3ncg \u2261 p(c, g|In; \u03b8) are the responsibilities, where for brevity we have absorbed a into g. The DRMM M-step consists of M-steps for each layer ` in the model. The per-layer M-step in turn consists of a responsibility-weighted regression, where GLS(yn \u223c xn) denotes the solution to a generalized Least Squares regression problem that predict targets yn from predictors xn and is\nAlgorithm 1 Hard EM and EG Algorithms for the DRMM\nE-step: c\u0302n, g\u0302n = argmax c,g \u03b3ncg M-step: \u039b\u0302g(`) = GLS\ufe38\ufe37\ufe37\ufe38 (I(`\u22121)n \u223c z\u0302(`)n | g(`) = g\u0302(`)n ) \u2200g(`) G-step: \u2206\u039b\u0302g(`) \u221d \u2207\u039bg(`) `DRMM (\u03b8)\nclosely related to the SVD. The Iversen bracket is defined as JbK \u2261 1 if expression b is true and is 0 otherwise.\nThere are several interesting and useful features of the EM algorithm. First, we note that it is a derivative-free alternative to the back propagation algorithm for training that is both intuitive and potentially much faster (provided a good implementation for the GLS problem). Second, it is easily parallelized over layers, since the M-step updates each layer separately (model parallelism). Moreover, it can be extended to a batch version so that at each iteration the model is simultaneously updated using separate subsets of the data (data parallelism). This will enable training to be distributed easily across multiple machines. In this vein, our EM algorithm shares several features with the ADMMbased Bregman iteration algorithm in [31]. However, the motivation there is from an optimization perspective and so the resulting training algorithm is not derived from a proper probabilistic density. Third, it is far more interpretable via its connections to (deep) sparse coding and to the hard EM algorithm for GMMs. The sum-over-paths formulation makes it particularly clear that the mixture components are paths (from root to pixels) in the DRMM.\nG-step. For the training results in this paper, we use the Generalized EM algorithm wherein we replace the M-step with a gradient descent based G-step (see Algorithm 1). This is useful for comparison with backpropagation-based training and for ease of implementation. But before we use the G-step, we would like to make a few remarks about the proper M-step of the algorithm, saving the implementation for future work.\nFlexibility and Extensibility. Since we can choose different priors/types for the nuisances g, the larger DRMM family could be useful for modeling a wider range of inputs, including scenes, speech and text. The EM algorithm can then be used to train the whole system end-to-end on different sources/modalities of labeled and unlabeled data. Moreover, the capability to sample from the model allows us to probe what is captured by the DRMM, providing us with principled ways to improve the model. And finally, in order to properly account for noise/uncertainty, it is possible in principle to extend this algorithm into a soft EM algorithm. We leave these interesting extensions for future work."}, {"heading": "3.4 New Insights into Deep Convnets", "text": "DCNs are Message Passing Networks. The DRMM inference algorithm is equivalent to performing max-sum-product message passing of the DRMM Note that by \u201cmax-sum-product\u201d we mean a novel combination of max-sum and max-product as described in more detail in the proofs in the Appendix. The factor graph encodes the same information as the generative model but organizes it in a manner that simplifies the definition and execution of inference algorithms [10]. Such inference algorithms are called message passing algorithms, because they work by passing real-valued functions called messages along the edges between nodes. In the DRMM, the messages sent from finer to coarser levels are in fact the feature maps I(`). The factor graph formulation provides a powerful interpretation: the convolution, Max-Pooling and ReLu operations in a DCN correspond to max-sum/product inference in a DRMM. Thus, we see that architectures and layer types commonly used in today\u2019s DCNs can be derived from precise probabilistic assumptions that entirely determine their structure. The DRMM therefore unifies two perspectives \u2014 neural network and probabilistic inference (see Table 2 in the Appendix for details).\nShortcomings of DCNs. DCNs perform poorly in categorizing transparent objects [23]. This might be explained by the fact that transparent objects generate pixels that have multiple sources, conflicting with the DRMM sparsity prior on a, which encourages few sources. DCNs also fail to classify slender and man-made objects [23]. This is because of the locality imposed by the locally-\nconnected/convolutional layers, or equivalently, the small size of the template \u00b5c(L)g in the DRMM. As a result, DCNs fail to model long-range correlations.\nClass Appearance Models and Activity Maximization. The DRMM enables us to understand how trained DCNs distill and store knowledge from past experiences in their parameters. Specifically, the DRMM generates rendered templates \u00b5c(L)g via a mixture of products of affine transformations, thus implying that class appearance models in DCNs are stored in a similar factorized-mixture form over multiple levels of abstraction. As a result, it is the product of all the filters/weights over all layers that yield meaningful images of objects (Eq. 7). We can also shed new light on another approach to understanding DCN memories that proceeds by searching for input images that maximize the activity of a particular class unit (say, class of cats) [26], a technique we call activity maximization. Results from activity maximization on a high performance DCN trained on 15 million images is shown in Fig. 1 of [26]. The resulting images reveal much about how DCNs store memories. Using the DRMM, the solution I\u2217\nc(L) of the activity maximization for class c(L) can be derived as the sum\nof individual activity-maximizing patches I\u2217Pi , each of which is a function of the learned DRMM parameters (see Appendix E):\nI\u2217c(L) \u2261 \u2211 Pi\u2208P I\u2217Pi(c (L), g\u2217Pi) \u221d \u2211 Pi\u2208P \u00b5(c(L), g\u2217Pi). (10)\nThis implies that I\u2217 c(L)\ncontains multiple appearances of the same object but in various poses. Each activity-maximizing patch has its own pose g\u2217Pi , consistent with Fig. 1 of [26] and our own extensive experiments with AlexNet, VGGNet, and GoogLeNet (data not shown). Such images provide strong confirmational evidence that the underlying model is a mixture over nuisance parameters, as predcted by the DRMM.\nUnsupervised Learning of Latent Task Nuisances. A key goal of representation learning is to disentangle the factors of variation that contribute to an image\u2019s appearance. Given our formulation of the DRMM, it is clear that DCNs are discriminative classifiers that capture these factors of variation with latent nuisance variables g. As such, the theory presented here makes a clear prediction that for a DCN, supervised learning of task targets will lead to unsupervised learning of latent task nuisance variables. From the perspective of manifold learning, this means that the architecture of DCNs is designed to learn and disentangle the intrinsic dimensions of the data manifolds.\nIn order to test this prediction, we trained a DCN to classify synthetically rendered images of naturalistic objects, such as cars and cats, with variation in factors such as location, pose, and lighting. After training, we probed the layers of the trained DCN to quantify how much linearly decodable information exists about the task target c(L) and latent nuisance variables g. Fig. 2 (Left) shows that the trained DCN possesses significant information about latent factors of variation and, furthermore, the more nuisance variables, the more layers are required to disentangle the factors. This is strong evidence that depth is necessary and that the amount of depth required increases with the complexity of the class models and the nuisance variations."}, {"heading": "4 Experimental Results", "text": "We evaluate the DRMM and DRFM\u2019s performance on the MNIST dataset, a standard digit classification benchmark with a training set of 60,000 28\u00d7 28 labeled images and a test set of 10,000 labeled images. We also evaluate the DRMM\u2019s performance on CIFAR10, a dataset of natural objects which include a training set of 50,000 32\u00d7 32 labeled images and a test set of 10,000 labeled images. In all experiments, we use a full E-step that has a bottom-up phase and a principled top-down reconstruction phase. In order to approximate the class posterior in the DRMM, we include a Kullback-Leibler divergence term between the inferred posterior p(c|I) and the true prior p(c) as a regularizer [9]. We also replace the M-step in the EM algorithm of Algorithm 1 by a G-step where we update the model parameters via gradient descent. This variant of EM is known as the Generalized EM algorithm [3], and here we refer to it as EG. All DRMM experiments were done with the NN-DRMM. Configurations of our models and the corresponding DCNs are provided in the Appendix I.\nSupervised Training. Supervised training results are shown in Table 3 in the Appendix. Shallow RFM: The 1-layer RFM (RFM sup) yields similar performance to a Convnet of the same configuration (1.21% vs. 1.30% test error). Also, as predicted by the theory of generative vs discriminative classifiers, EG training converges 2-3x faster than a DCN (18 vs. 40 epochs to reach 1.5% test error, Fig. 2, middle). Deep RFM: Training results from an initial implementation of the 2-layer DRFM\nEG algorithm converges 2 \u2212 3\u00d7 faster than a DCN of the same configuration, while achieving a similar asymptotic test error (Fig. 2, Right). Also, for completeness, we compare supervised training for a 5-layer DRMM with a corresponding DCN, and they show comparable accuracy (0.89% vs 0.81%, Table 3).\nUnsupervised Training. We train the RFM and the 5-layer DRMM unsupervised with NU images, followed by an end-to-end re-training of the whole model (unsup-pretr) usingNL labeled images. The results and comparison to the SWWAE model are shown in Table 1. The DRMM model outperforms the SWWAE model in both scenarios (Filters and reconstructed images from the RFM are available in the Appendix 4.)\nSemi-Supervised Training. For semi-supervised training, we use a randomly chosen subset of NL = 100, 600, 1K, and 3K labeled images and NU = 60K unlabeled images from the training and validation set. Results are shown in Table 1 for a RFM, a 2-layer DRMM and a 5-layer DRMM with comparisons to related work. The DRMMs performs comparably to state-of-the-art models. Specially, the 5-layer DRMM yields the best results when NL = 3K and NL = 600 while results in the second best result when NL = 1K. We also show the training results of a 9-layer DRMM on CIFAR10 in Table 4 in Appendix H. The DRMM yields comparable results on CIFAR10 with the best semi-supervised methods. For more results and comparisons to other related work, see Appendix H."}, {"heading": "5 Conclusions", "text": "Understanding successful deep vision architectures is important for improving performance and solving harder tasks. In this paper, we have introduced a new family of hierarchical generative models, whose inference algorithms for two different models reproduce deep convnets and decision trees, respectively. Our initial implementation of the DRMM EG algorithm outperforms DCN backpropagation in both supervised and unsupervised classification tasks and achieves comparable/stateof-the-art performance on several semi-supervised classification tasks, with no architectural hyperparameter tuning [17, 19]\nAcknowledgments. Thanks to Xaq Pitkow and Ben Poole for helpful discussions and feedback. ABP and RGB were supported by IARPA via DoI/IBC contract D16PC00003. RGB was also supported by NSF CCF-1527501, AFOSR FA9550-14-1-0088, ARO W911NF-15-1-0316, and ONR N00014-12-1-0579. TN was supported by an NSF Graduate Reseach Fellowship and NSF IGERT Training Grant (DGE-1250104)."}, {"heading": "A From the Rendering Mixture Model Classifier to a DCN Layer", "text": "Proposition A.1 (MaxOut Neural Networks). The discriminative relaxation of a noise-free Gaussian Rendering Mixture Model (GRMM) classifier with nuisance variable g \u2208 G is a single layer neural net consisting of a local template matching operation followed by a piecewise linear activation function (also known as a MaxOut NN [7]).\nProof. For transparency, we prove this claim exhaustively. Later claims will have simpler proofs. We have\nc\u0302(I) \u2261 argmax c\u2208C p(c|I)\n= argmax c\u2208C\n{p(I|c)p(c)}\n= argmax c\u2208C \u2211 g\u2208G p(I|c, g)p(c, g)  (a) = argmax\nc\u2208C\n{ max g\u2208G p(I|c, g)p(c, g) }\n= argmax c\u2208C { max g\u2208G exp (ln p(I|c, g) + ln p(c, g)) }\n(b) = argmax\nc\u2208C\n{ max g\u2208G exp (\u2211 \u03c9 ln p(I\u03c9|c, g) + ln p(c, g) )}\n(c) = argmax\nc\u2208C\n{ max g\u2208G exp ( \u22121 2 \u2211 \u03c9 \u2329 I\u03c9 \u2212 \u00b5\u03c9cg|\u03a3\u22121cg |I\u03c9 \u2212 \u00b5\u03c9cg \u232a + ln p(c, g)\u2212 D 2 ln |\u03a3cg| )}\n= argmax c\u2208C { max g\u2208G exp (\u2211 \u03c9 \u2329 w\u03c9cg|I\u03c9 \u232a + b\u03c9cg )} (d)\u2261 argmax\nc\u2208C\n{ exp ( max g\u2208G {wcg ?LC I} )} = argmax\nc\u2208C\n{ max g\u2208G {wcg ?LC I} } = Choose {MaxOutPool(LocalTemplateMatch(I))} = MaxOut-NN(I; \u03b8).\nIn line (a), we take the noise-free limit of the GRMM, which means that one hypothesis (c, g) dominates all others in likelihood. In line (b), we assume that the image I consists of multiple channels \u03c9 \u2208 \u2126, that are conditionally independent given the global configuration (c, g) Typically, for input images these are color channels and \u2126 \u2261 {R,G,B} but in general \u2126 can be more abstract (e.g. as in feature maps). In line (c), we assume that the pixel noise covariance is isotropic and conditionally independent given the global configuration (c, g), so that \u03a3cg = \u03c32x1D is proportional to the D \u00d7D identity matrix 1D. In line (d), we defined the locally connected template matching operator ?LC , which is a location-dependent template matching operation.\nNote that the nuisance variables g \u2208 G are (max-)marginalized over, after the application of a local template matching operation against a set of filters/templatesW \u2261 {wcg}c\u2208C,g\u2208G . Lemma A.2 (Translational Nuisance \u2192d DCN Convolution). The MaxOut template matching and pooling operation (from Proposition A.1) for a set of translational nuisance variables G \u2261 T reduces to the traditional DCN convolution and max-pooling operation.\nProof. Let the activation for a single output unit be yc(I). Then we have\nyc(I) \u2261 max g\u2208G {wcg ?LC I}\n= max t\u2208T {\u3008wct|I\u3009}\n= max t\u2208T {\u3008Ttwc|I\u3009}\n= max t\u2208T {\u3008wc|T\u2212tI\u3009}\n= max t\u2208T {(wc ?DCN I)t}\n= MaxPool(wc ?DCN I).\nwhere ?DCN is the traditional DCN Convolution operator. Finally, vectorizing in c gives us the desired result y(I) = MaxPool(W ?DCN I). Proposition A.3 (Max Pooling DCNs with ReLu Activations). The discriminative relaxation of a noise-free GRMM with translational nuisances and random missing data is a single convolutional layer of a traditional DCN. The layer consists of a generalized convolution operation, followed by a ReLu activation function and a Max-Pooling operation.\nProof. We will model completely random missing data as a nuisance transformation a \u2208 A \u2261 {keep, drop}, where a = keep = 1 leaves the rendered image data untouched, while a = drop = 0 throws out the entire image after rendering. Thus, the switching variable a models missing data. Critically, whether the data is missing is assumed to be completely random and thus independent of any other task variables, including the measurements (i.e. the image itself). Since the missingness of the evidence is just another nuisance, we can invoke Proposition A.1 to conclude that the discriminative relaxation of a noise-free GRMM with random missing data is also a MaxOut-DCN, but with a specialized structure which we now derive.\nMathematically, we decompose the nuisance variable g \u2208 G into two parts g = (t, a) \u2208 G = T \u00d7 A, and then, following a similar line of reasoning as in Proposition A.1, we have\nc\u0302(I) = argmax c\u2208C max g\u2208G\np(c, g|I)\n= argmax c\u2208C { max g\u2208G {wcg ?LC I} } (a) = argmax\nc\u2208C\n{ max t\u2208T max a\u2208A {a(\u3008wct|I\u3009+ bct) + b\u2032ct + ba + b\u2032I} } (b) = argmax\nc\u2208C\n{ max t\u2208T {max{(wc ?DCN I)t, 0}+ b\u2032ct + b\u2032drop + b\u2032I} } (c) = argmax\nc\u2208C\n{ max t\u2208T {max{(wc ?DCN I)t, 0}+ b\u2032ct} } (d) = argmax\nc\u2208C\n{ max t\u2208T {max{(wc ?DCN I)t, 0}} } = Choose {MaxPool(ReLu(DCNConv(I)))} = DCN(I; \u03b8).\nIn line (a) we calculated the log-posterior (ignoring (c, g)-independent constants)\nln p(c, g|I) = ln p(c, t, a|I) = ln p(I|c, t, a) + ln p(c, t, a) + ln p(I)\n= 1\n\u03c32x \u3008a\u00b5ct|I\u3009 \u2212\n1\n2\u03c32x (\u2016a\u00b5ct\u201622 + \u2016I\u201622)) + ln p(c, t, a)\n\u2261 a(\u3008wct|I\u3009+ bct) + b\u2032ct + ba + b\u2032I , where a \u2208 {0, 1}, wct \u2261 1\u03c32x\u00b5ct, bct \u2261 \u2212 1 2\u03c32x \u2016\u00b5ct\u201622, ba \u2261 ln p(a), b\u2032ct \u2261 ln p(c, t), b\u2032I \u2261 \u2212 12\u03c32x \u2016I\u2016 2 2. In line (b), we use Lemma A.2 to write the expression in terms of the DCN convolution\noperator, after which we invoke the identity max{u, v} = max{u\u2212 v, 0}+ v \u2261 ReLu(u\u2212 v) + v for real numbers u, v \u2208 R. Here we\u2019ve defined b\u2032drop \u2261 ln p(a = drop) and we\u2019ve used a slightly modified DCN convolution operator ?DCN defined by wct ?DCN I \u2261 wct ? I + bct + ln ( p(a=keep) p(a=drop) ) . Also, we observe that all the primed constants are independent of a and so can be pulled outside of the maxa. In line(c), the two primed constants that are also independent of c, t can be dropped due to the argmaxct. Finally, in line (d), we assume a uniform prior over c, t. The resulting sequence of operations corresponds exactly to those applied in a single convolutional layer of a traditional DCN."}, {"heading": "B From the Deep Rendering Mixture Model to DCNs", "text": "Here we define the DRMM in full detail.\nDefinition B.1 (Deep Rendering Mixture Model (DRMM)). The Deep Rendering Mixture Model (DRMM) is a deep Gaussian Mixture Model (GMM) with special constraints on the latent variables. Generation in the DRMM takes the form:\nc(L) \u223c Cat({\u03c0c(L)}) g(`) \u223c Cat({\u03c0g(`)}) \u2200` \u2208 [L] \u2261 {1, 2, . . . , L}\n\u00b5c(L)g \u2261 \u039bg\u00b5c(L) \u2261 \u039b(1)\ng(1) \u039b\n(2) g(2) . . .\u039b (L\u22121) g(L\u22121) \u039b (L) g(L) \u00b5c(L)\nI \u223c N (\u00b5c(L)g,\u03a8) = N (\u00b5c(L)g, \u03c321D(0))\nwhere the latent variables, parameters, and helper variables are defined as g(`) \u2261 ( g (`)\nx(`) ) x(`)\u2208X (`)\nt(`) \u2261 ( t (`)\nx(`) ) x(`)\u2208X (`) , a(`) \u2261 ( a (`) x(`) ) x(`)\u2208X (`)\ng (`) x(`) \u2261 ( t (`) x(`) , a (`) x(`) ) t (`)\nx(`) \u2208 {UL,UR,LL,LR}\na (`) x(`) \u2208 {0, 1} \u2261 {OFF,ON}\nx(`) \u2208 X (`) \u2261 {pixels in level `} \u2208 RD(`)\n\u039b (`)\ng(`) = \u039b\n(`) t(`),a(`) \u2208 RD(`\u22121)\u00d7D(`)\n= T (`) t(`) Z(`)\u0393(`)M (`) a(`)\nM (`) a(`) \u2261 diag\n( a(`) ) \u2208 RD(`)\u00d7D(`)\nT (`) t(`) \u2261 translation operator to position t(`) \u2208 RD(`\u22121)\u00d7D(`\u22121) Z(`) \u2261 zero-padding operator \u2208 RD(`\u22121)\u00d7F (`)\n\u0393(`) \u2261 \u2297 x(`)\u2208X (`) \u0393 (`) x(`)\ufe38\ufe37\ufe37\ufe38 F (`)\u00d71 \u2208 RF (`)\u00d7D(`)\n\u0393 (`) x(`) \u2261 {filter bank at level `} \u2208 RF (`)\nF (`) \u2261W (`)H(`)C(`) = size of the core templates at layer (`)\nFor simplicity, in the following sections, we will use c and c(L) interchangeably.\nDefinition B.2 (Nonnegative Deep Rendering Mixture Model (NN-DRM)). The Nonnegative Deep Rendering Mixture Model is defined as a DRMM (Definition B.1) with additional nonnegativity constraint(s) on the intermediate latent variables (rendered templates):\nz(`)n = \u039bg(`+1)n \u00b7 \u00b7 \u00b7\u039b g (L) n \u00b5 c (L) n \u2265 0 \u2200` \u2208 {1, . . . , L} (11)\nFollowing the same line of reasoning as in the main text, we will derive the Hard EM algorithm for the DRMM model.\nB.1 E-step: Computing the Soft Responsibilities\n\u03b3ncg \u2261 p(c, g|In)\n= p(In|c, g; \u03b8)p(c, g|\u03b8)\u2211 c,g p(In|c, g; \u03b8)p(c, g|\u03b8) = \u03c0cg|\u03a8|\u22121/2 exp ( \u2212 12\u2016In \u2212 \u00b5cg\u20162\u03a8\u22121 ) Z ,\nwhere the partition function Z is defined as\nZ(\u03b8) \u2261 \u2211 c,g \u03c0cg|\u03a8|\u22121/2 exp ( \u22121 2 \u2016In \u2212 \u00b5cg\u20162\u03a8\u22121 ) .\nSince the numerator and denominator both contain |\u03a8|\u22121/2, the responsibilities simplify to\n\u03b3ncg = \u03c0cg exp\n( \u2212 12\u2016In \u2212 \u00b5cg\u20162\u03a8\u22121 ) Z \u2032 , (12)\nwhere Z \u2032 is defined as\nZ \u2032(\u03b8) \u2261 \u2211 cg \u03c0cg exp ( \u22121 2 \u2016In \u2212 \u00b5cg\u20162\u03a8\u22121 ) .\nB.2 E-step: Computing the Hard Responsibilities\nAssuming isotropic noise \u03a8 = \u03c321D and taking the zero-noise limit \u03c32 \u2192 0, the term in the denominator Z \u2032(\u03b8) for which \u2016In \u2212 \u00b5cg\u201622 is smallest will go to zero most slowly. Hence the responsibilities \u03b3ncg will all approach zero, except for one term (c\u2217, g\u2217), for which the \u03b3nc\u2217g\u2217 will approach one. 1 Thus, the soft responsibilities become hard responsibilities in the zero-noise limit:\n\u03b3ncg \u03c3\u21920\u2212\u2192 rncg \u2261 { 1, if (c, g) = argmax c\u2032g\u2032 \u2212 12\u2016In \u2212 \u00b5c\u2032g\u2032\u201622 0, otherwise (13)\nB.3 Useful Lemmas\nIn order to derive the E-step for the DRMM, we will need a few simple theoretical results. We prove them here.\nDefinition B.3 (Masking Operator). Let a \u2208 {0, 1}d be a binary vector (mask) and let \u039b \u2208 RD\u00d7d be a real matrix. Then the masking operatorMa(\u039b) \u2208 RD\u00d7d is defined as\nMa(\u039b) \u2261 \u039b \u00b7Ma \u2261 \u039b \u00b7 diag(a),\nwhere Ma \u2261 diag(a) \u2208 Rd\u00d7d is the diagonal masking matrix. 1Technically, there can be multiple maximizers and the algorithms below can be generalized to handle this case. But we focus on the case with just one unique maximum for simplicity.\nLemma B.4. The action of a masking operator on a vector z \u2208 Rd can be written in several equivalent ways:\nMa(\u039b)z = \u039b \u00b7 diag(a) \u00b7 z = \u039b \u00b7 diag(a) \u00b7 diag(a) \u00b7 z = \u039b[:, a] \u00b7 z[a] = \u039b(a z).\nHere denotes the elementwise (Hadamard) product between two vectors and \u039b[:, a] is numpy notation for the subset of columns {j \u2208 [D] : aj = 1} of \u039b.\nProof. The first equality is by definition. The second equality is a result of a being binary since a2i = ai for ai \u2208 {0, 1}. The third and fourth equalities result from the associativity of matrix multiplication.\nLemma B.5 (Optimization with Masking Operators). Let z, u \u2208 RD\u00d71. Consider the optimization problem\nmax a\u2208{0,1}D Ma(zT )u = max a\u2208{0,1}D zTMau (14)\nwhere Ma \u2261 diag(a). Then the optimization can be solved in closed form as:\n(a) max a\u2208{0,1}D Ma(zT )u = 1TD ReLu(z u).\n(b) a\u0302 \u2261 argmax a\u2208{0,1}D Ma(zT )u = [z u > 0] \u2208 {0, 1}D.\n(c) Ma\u0302u = sgn(z) ReLu (sgn(z) u). (d) If z \u2265 0, then a\u0302 \u2261 argmax\na\u2208{0,1}D Ma(zT )u = [u > 0] \u2208 {0, 1}D is a maximizer, for which Ma\u0302u =\nReLu (u).\nProof. (a) The maximum value can be computed as\nv? \u2261 max a\u2208{0,1}D Ma(zT )u\n= max a\u2208{0,1}D\nzT diag(a)u\n= max a\u2208{0,1}D \u2211 i\u2208[D] ziaiui\n= \u2211 i\u2208[D] max ai\u2208{0,1} ai(ziui)\n\u2261 \u2211 i\u2208[D] a\u0302i(ziui)\n= \u2211 i\u2208[D] [ziui > 0] \u00b7 ziui\n= \u2211 i\u2208[D] ReLu(ziui)\n= 1TD ReLu(z u).\n(b) In the 4th line the vector optimization decouples into a set of independent scalar optimizations maxai\u2208{0,1} ai(ziui), each of which is solvable in closed form: a\u0302i \u2261 [ziui > 0]. Hence, the optimal\nsolution a\u0302 is given by a\u0302 = [z u > 0]. (c) Substituting in a\u0302, we get\nMa\u0302u = u [z u > 0] = (sgn(z) sgn(z))\ufe38 \ufe37\ufe37 \ufe38\n1D\nu [ sgn(z) u > 0]\n= sgn(z) (sgn(z) u) [ sgn(z) u > 0] = sgn(z) ReLu (sgn(z) u) ,\nwhere in the third and fourth equalities we have used the associativity of elementwise multiplication and the definition of ReLu, respectively. (d) If z \u2265 0, then when zi > 0, a\u0302i = [ui > 0], and when zi = 0, a\u0302i can be either 0 or 1 since then maxai\u2208{0,1} ai(ziui) = 0\u2200ai \u2208 {0, 1}. Therefore, if z \u2265 0, a\u0302 = [u > 0] is a solution of the optimization 14. It follows that Ma\u0302u = [u > 0]u = ReLu (u).\nLemma B.6 (Optimization with \u201cRow\" Max-Marginal). Let z, u \u2208 RD\u00d71. Consider the optimization problem\nmax t\u2208T D zTu(t) = max t\u2208T D \u2211 x zxu(t)x (15)\nwhere T is the set of possible fine-scale translations at location x. Also,\nt \u2261  ... tx ...  and u(t) \u2261  ... ux(tx) ...  (16) Then the optimization can be solved as:\n(a) max t\u2208T D zTu(t) = \u2211 x |zx|max tx\u2208T sgn(zx)ux(tx)\n(b) t\u0302 = argmax t\u2208T D zTu(t) = argmax t sgn(z) u(t) =  ... argmax tx sgn(zx)ux(tx)\n...\n\n(c) u(t\u0302) = sgn(z) max t (sgn(z) u(t)) =  ... sgn(zx)max tx sgn(zx)ux(tx)\n...\n\n(d) If z \u2265 0, then t\u0302 = argmax t u(t) =  ... argmax tx ux(tx)\n...\n is a maximizer for which u(t\u0302) =\nmax t (u(t)) =  ... max tx ux(tx)\n...\n\nProof. (a) The maximum value can be computed as\nv? \u2261 max {tx\u2208T }Dx=1 \u2211 x zxux(tx)\n= \u2211 x max tx\u2208T zxux(tx)\n= \u2211 x max tx\u2208T |zx| sgn(zx)ux(tx)\n= \u2211 x |zx|max tx\u2208T sgn(zx)ux(tx)\n(b) In the 2nd line the vector optimization decouples into a set of independent scalar optimizations maxtx\u2208T zxux(tx), each of which has the solution as follows: argmax\ntx\nsgn(zx)ux(tx). Hence, the\noptimal solution t\u0302 = argmax t\u2208T D zTu(t) =  ... argmax tx sgn(zx)ux(tx)\n...  = argmaxt sgn(z) u(t). (c) Substituting in t\u0302, we obtain\nv? = \u2211 x |zx| sgn(zx)ux(t\u0302x)\n= \u2211 x zx sgn(zx)(sgn(zx)ux(t\u0302x))\n= \u2211 x zx sgn(zx)max tx sgn(zx)ux(tx)\n= zT  ... sgn(zx)max tx sgn(zx)ux(tx)\n...  Hence,\nu(t\u0302) =  ... sgn(zx)max tx sgn(zx)ux(tx)\n...  = sgn(z) maxt (sgn(z) u(t)) , (d) If z \u2265 0, then when zi > 0, t\u0302x = argmax\ntx\nux(tx), and when zi = 0, t\u0302x can take any value in its\ndomain since then max tx\u2208T sgn(zx)ux(tx) = 0\u2200tx \u2208 T . Therefore, if z \u2265 0, t\u0302x = argmax tx ux(tx) is a\nsolution of the optimization 15. It follows that u(t\u0302) = max t\n(u(t)) \u2261  ... max tx ux(tx)\n... . Definition B.7 (Deep Masking Operator). Let a(`) \u2208 {0, 1}D(`) be a collection of binary (vector) masks and let \u039b(`) \u2208 RD(`\u22121)\u00d7D(`) be a collection of (matrix) operators. Then the deep masking operatorM{a(`)}({\u039b(`)}) \u2208 RD (0)\u00d7D(L) is defined as\nM{a(`)}({\u039b(`)}) \u2261 L\u220f `=1 Ma(`)(\u039b(`)) = L\u220f `=1 \u039b(`) \u00b7Ma(`) ,\nwhere Ma \u2261 diag(a) is the diagonal masking matrix for mask a.\nB.4 E-Step: Inference of Top-Level Category\nTheorem B.8 (Inference in DRMM\u21d2 Signed Convnets). Inference in the DRMM, according to the Dynamic Programming-based algorithm below, yields Signed DCNs. The inference algorithm has a bottom-up and top-down pass.\nProof. Given input image In \u2261 I(0)n , we infer c\u0302n as follows:\nc\u0302n = argmax c max g \u22121 2 \u2016In \u2212 \u00b5cg\u201622\n= argmax c max g\n\u00b5TcgIn \u2212 1\n2 \u2016In\u201622 \u2212\n1 2 \u2016\u00b5cg\u201622\n= argmax c max g\n\u00b5TcgIn \u2212 1\n2 \u2016\u00b5cg\u201622,\nwhere the last equality follow since In is independent of c, g. We further assume that:\n\u03b1g(`) = 0 \u2200` \u2016\u00b5cg\u201622 = const \u2200c, g.\nAs a result, \u00b5cg = \u039bg\u00b5c and the most probable class c\u0302n is inferred as\nc\u0302n = argmax c max g\n\u00b5TcgI (0) n (17)\n= argmax c max g\n(\u039bg\u00b5c) T I(0)n (18)\n= argmax c max g(L:1)\n\u00b5Tc \u039b T g(L) \u00b7 \u00b7 \u00b7\u039bTg(2)\u039bTg(1)I(0)n (19)\n= argmax c max g(L:2) max t(1) max a(1)\n\u00b5Tc \u039b T g(L) \u00b7 \u00b7 \u00b7\u039bTg(2)(Ma(1)\u039bTt(1))I(0)n (20)\n= argmax c max g(L:2) max t(1) max a(1)\n( \u00b5Tc \u039b T g(L) \u00b7 \u00b7 \u00b7\u039bTg(2) ) \ufe38 \ufe37\ufe37 \ufe38\n\u2261z(1)\u2193T\nMa(1) ( \u039bTt(1)I (0) n ) \ufe38 \ufe37\ufe37 \ufe38 \u2261u(1)\u2191n (t(1))\n(21)\n= argmax c max g(L:2) max t(1) max a(1)\nz(1)\u2193TMa(1)u (1)\u2191 n (t (1)) (22)\n(a) = argmax\nc max g(L:2) max t(1)\nz(1)\u2193TM a\u0302 (1) n u(1)\u2191n (t (1)) (23)\n(b) = argmax\nc max g(L:2)\nz(1)\u2193T ( s(1)\u2193 max\nt(1) s(1)\u2193 ( M a\u0302 (1) n u(1)\u2191n (t (1)) ))\n(24)\n(c) = argmax\nc max g(L:2)\nz(1)\u2193T ( s(1)\u2193 max\nt(1) s(1)\u2193\n( s(1)\u2193 ReLu ( s(1)\u2193 u(1)\u2191n (t(1)) ))) (25)\n(d) = argmax\nc max g(L:2)\nz(1)\u2193T ( s(1)\u2193 MaxPool ( ReLu ( diag(s(1)\u2193)u(1)\u2191n (T ) ))) \ufe38 \ufe37\ufe37 \ufe38\n\u2261I(1)n (s(1)\u2193)\n(26)\n= argmax c max g(L:2)\n\u00b5Tc \u039b T g(L) \u00b7 \u00b7 \u00b7\u039bTg(2)I(1)n (27)\nIn line (a), we employ Lemma B.5(b) to infer the optimal a\u0302(1)n . In line (b) and (c), we employ B.6(c) and Lemma B.5(c) to calculate the max-product message I(1)n to be sent to the next layer. Notice that here s(1)\u2193 = sgn ( z(1)\u2193 ) . In line (b), t\u0302(1)n is implicitly inferred via Lemma B.6(b). In line (d), s(1)\u2193 s(1)\u2193 becomes a vector of all 1\u2019s. Also, in the same line, diag(s(1)\u2193) is a diagonal matrix with diagonal s(1)\u2193 and u(1)\u2191n (T ) is a matrix [unxt] where rows are indexed by x \u2208 X and columns by t \u2208 T . It corresponds to the output of the convolutional layer in a DCN, prior to the ReLu and spatial max-pooling operators.\nNote that we have succeeded in expressing the optimization (Eq. 19) recursively in terms of a one level smaller sub-problem (Eq. 27). Iterating this procedure yields a set of recurrence relations, which define our Dynamic Programming (DP) algorithm for the bottom-up and top-down inference in the DRMM:\nBottom-Up E-Step (E\u2191):\nu(`)\u2191n = \u039b T t(`)I (`\u22121) n (28) s(`)\u2193 = sgn ( z(`)\u2193 ) (29)\n\u2200s(`)\u2193 \u2208 {\u00b11}D(`) : a\u0302(`)ln (s(`)\u2193) = [s(`)\u2193 u(`)\u2191n > 0] (30) \u2200s(`)\u2193 \u2208 {\u00b11}D(`) : t\u0302(`)ln (s(`)\u2193) = argmax\nt(`) s(`)\u2193 u(`)\u2191n (t(`)) (31)\nI(`)n (s (`)\u2193) = M\na\u0302 (`) n ( \u039bT t\u0302(`) I(`\u22121)n ) (32)\n= s(`)\u2193 MaxPool ( ReLu ( diag(s(1)\u2193)u(1)\u2191n (T ) ))\n(33)\nc\u0302(L)n = argmax c(L) \u00b5Tc(L)I (L) n (34)\nTop-Down/Traceback E-Step (E\u2191):\nz\u0302(`)\u2193n = \u039bg\u0302(`+1)n \u00b7 \u00b7 \u00b7\u039bg\u0302(L)n \u00b5c\u0302(L)n (35) = \u039b\ng\u0302 (`+1) n\nz\u0302(`+1)\u2193n (36)\ns\u0302(`)\u2193n = sgn(z\u0302 (`)\u2193 n ) (37) a\u0302(`)ln = a\u0302 (`)l n (s\u0302 (`)\u2193 n ) = [s\u0302 (`)\u2193 n u(`)\u2191n > 0] (38) t\u0302(`)ln = t\u0302 (`)l n (s (`)\u2193 n ) = argmax\nt(`) s(`)\u2193n u(`)\u2191n (t(`)) (39)\nwhere u(`)\u2191n and z\u0302 (`)\u2193 n are the bottom-up and top-down net inputs into layer `, respectively.\nCorollary B.9 (Inference in the NN-DRMM\u21d2 Convnets). Inference in the NN-DRMM according to the Dynamic Programming-based algorithm above yields ReLu DCNs.\nProof. The NN-DRMM assumes that the intermediate rendered latent variables z(`)n \u2265 0 for all `, which implies that the signs are also nonnegative i.e., s(`)n \u2265 0. This in turn, according to Lemma B.5(d) and B.6(d), reduces Eqs. 33, 34, 38 and 39 to\nE\u2191 : I(`)n = MaxPool ReLu ( u(`)\u2191n ) (40)\nc\u0302(L)n = argmax c(L) \u00b5Tc(L)I (L) n (41) E\u2193 : a\u0302(`)n = [u (`)\u2191 n > 0] (42)\nt\u0302(`)n = argmax t(`) u(`)\u2191n (t (`)), (43)\nwhich is equivalent to feedforward propagation in a DCN. Note that the the top-down step no longer requires information from the deeper levels, and so it can be computed in the bottom-up step instead.\nRemark: Note that the vector max notation max t u(t) =  ... max tx ux(tx)\n...  is the same as the max notation we use in our arXiv post. It refers to the row max-marginals of the matrix u(t) \u2261 [uxt]x\u2208X ,t\u2208T with respect to latent variables t."}, {"heading": "C Rendering Factor Model (RFM) Architecture", "text": ""}, {"heading": "D Transforming a Generative Classifier into a Discriminative One", "text": "Before we formally define the procedure, some preliminary definitions and remarks will be helpful. A generative classifier models the joint distribution p(c, I) of the input features and the class labels. It can then classify inputs by using Bayes Rule to calculate p(c|I) \u221d p(c, I) = p(I|c)p(c) and picking the most likely label c. Training such a classifier is known as generative learning, since one can generate synthetic features I by sampling the joint distribution p(c, I). Therefore, a generative classifier learns an indirect map from input features I to labels c by modeling the joint distribution p(c, I) of the labels and the features.\nIn contrast, a discriminative classifier parametrically models p(c|I) = p(c|I; \u03b8d) and then trains on a dataset of input-output pairs {(In, cn)}Nn=1 in order to estimate the parameter \u03b8d. This is known as discriminative learning, since we directly discriminate between different labels c given an input feature I . Therefore, a discriminative classifier learns a direct map from input features I to labels c by directly modeling the conditional distribution p(c|I) of the labels given the features. Given these definitions, we can now define the discriminative relaxation procedure for converting a generative classifier into a discriminative one. Starting with the standard learning objective for a generative classifier, we will employ a series of transformations and relaxations to obtain the learning\nobjective for a discriminative classifier. Mathematically, we have\nmax \u03b8 Lgen(\u03b8) \u2261 max \u03b8 \u2211 n ln p(cn, In|\u03b8)\n(a) = max\n\u03b8 \u2211 n ln p(cn|In, \u03b8) + ln p(In|\u03b8)\n(b) = max\n\u03b8,\u03b8\u0303:\u03b8=\u03b8\u0303 \u2211 n ln p(cn|In, \u03b8) + ln p(In|\u03b8\u0303)\n(c) \u2264 max \u03b8 \u2211 n\nln p(cn|In, \u03b8)\ufe38 \ufe37\ufe37 \ufe38 \u2261Lcond(\u03b8)\n(d) = max\n\u03b7:\u03b7=\u03c1(\u03b8) \u2211 n ln p(cn|In, \u03b7)\n(e) \u2264 max \u03b7 \u2211 n\nln p(cn|In, \u03b7)\ufe38 \ufe37\ufe37 \ufe38 \u2261Ldis(\u03b7) , (44)\nwhere the L\u2019s are the generative, conditional and discriminative log-likelihoods, respectively. In line (a), we used the Chain Rule of Probability. In line (b), we introduced an extra set of parameters \u03b8\u0303 while also introducing a constraint that enforces equality with the old set of generative parameters \u03b8. In line (c), we relax the equality constraint (first introduced by Bishop, LaSerre and Minka in [4]), allowing the classifier parameters \u03b8 to differ from the image generation parameters \u03b8\u0303. In line (d), we pass to the natural parametrization of the exponential family distribution I|c, where the natural parameters \u03b7 = \u03c1(\u03b8) are a fixed function of the conventional parameters \u03b8. This constraint on the natural parameters ensures that optimization of Lcond(\u03b7) yields the same answer as optimization of Lcond(\u03b8). And finally, in line (e) we relax the natural parameter constraint to get the learning objective for a discriminative classifier, where the parameters \u03b7 are now free to be optimized. A graphical model depiction of this process is shown in Fig. 4.\nIn summary, starting with a generative classifier with learning objective Lgen(\u03b8), we complete steps (a) through (e) to arrive at a discriminative classifier with learning objective Ldis(\u03b7). We refer to this process as a discriminative relaxation of a generative classifier and the resulting classifier is a discriminative counterpart to the generative classifier.\ndumbbell cup dalmatian bell pepper lemon husky"}, {"heading": "E Derivation of Closed-Form Expression for Activity-Maximizing Images", "text": "Results of running activity maximization are shown in Fig. 5 for completeness. Mathematically, we seek the image I that maximizes the score S(c|I) of a specific object class. Using the DRM, we have\nmax I S(c(L)|I) = max I max g\u2208G \u3008 1 \u03c32 \u00b5(c(L), g(`))|I\u3009\n\u221d max g\u2208G max I \u3008\u00b5(c(L), g)|I\u3009\n= max g\u2208G max IP1 \u00b7 \u00b7 \u00b7max IPp \u3008\u00b5(c(L), g)| \u2211 Pi\u2208P IPi\u3009\n= max g\u2208G \u2211 Pi\u2208P max IPi \u3008\u00b5(c(L), g)|IPi\u3009\n= max g\u2208G \u2211 Pi\u2208P \u3008\u00b5(c(L), g)|I\u2217Pi(c(L), g)\u3009\n= \u2211 Pi\u2208P \u3008\u00b5(c(L), g)|I\u2217Pi(c(L), g\u2217Pi\u3009, (45)\nwhere I\u2217Pi(c (`), g) \u2261 argmaxIPi \u3008\u00b5(c (`), g)|IPi\u3009 and g\u2217Pi = g\u2217(c(`),Pi) \u2261 argmaxg\u2208G \u3008\u00b5(c(`), g)|I\u2217Pi(c(`), g)\u3009. In the third line, the image I is decomposed into P patches IPi of the same size as I , with all pixels outside of the patch Pi set to zero. The maxg\u2208G operator finds the most probable g\u2217Pi within each patch. The solution I\n\u2217 of the activity maximization is then the sum of the individual activity-maximizing patches\nI\u2217 \u2261 \u2211 Pi\u2208P I\u2217Pi(c (`), g\u2217Pi) \u221d \u2211 Pi\u2208P \u00b5(c(`), g\u2217Pi). (46)"}, {"heading": "F From the DRMM to Decision Trees", "text": "In this section we show that, like DCNs, Random Decision Forests (RDFs) can also be derived from the DRMM model. Instead of translational and switching nuisances, we will show that an additive mutation nuisance process that generates a hierarchy of categories (e.g., evolution of a taxonomy of living organisms) is at the heart of the RDF.\nF.1 The Evolutionary Deep Rendering Mixture Model\nWe define the Evolutionary DRMM (E-DRMM) as a DRMM with an evolutionary tree of categories. Samples from the model are generated by starting from the root ancestor template and randomly\nmutating the templates. Each child template is an additive \u201cmutation\u201d of its parent, where the specific mutation does not depend on the parent (see Eq.47 below). At the leaves of the tree, a sample is generated by adding Gaussian pixel noise. Like in the DRMM, given c(L) \u223c Cat(\u03c0c(L)) and g(`+1) \u223c Cat(\u03c0g(`+1)), with c(L) \u2208 CL and g(`+1) \u2208 G`+1 where ` = 1, 2, \u00b7 \u00b7 \u00b7 , L, the template \u00b5c(L)g and the image I are rendered as\n\u00b5c(L)g = \u039bg\u00b5c(L) \u2261 \u039bg(1) \u00b7 \u00b7 \u00b7\u039bg(L) \u00b7 \u00b5c(L) \u2261 \u00b5c(L) + \u03b1g(L) + \u00b7 \u00b7 \u00b7+ \u03b1g(1) , g = {g(`)}L`=1\nI \u223c N (\u00b5c(L)g, \u03c321D) \u2208 RD.\nHere, \u039bg(`) has a special structure due to the additive mutation process: \u039bg(`) = [1 |\u03b1g(`) ], where 1 is the identity matrix. The rendering path represents template evolution and is defined as the sequence (c(L), g(L), . . . , g(`), . . . , g(1)) from the root ancestor template down to the individual pixels at ` = 0. \u00b5c(L) is an abstract template for the root ancestor c(L), and \u2211 ` \u03b1g(`) represents the sequence of local nuisance transformations, in this case, the accumulation of many additive mutations.\nAs with the DRMM, we can cast the E-DRMM into an incremental form by defining an intermediate class c(`) \u2261 (c(L), g(L), . . . , g(`+1)) that intuitively represents a partial evolutionary path up to level `. Then, the mutation from level `+ 1 to ` can be written as\n\u00b5c(`) = \u039bg(`+1) \u00b7 \u00b5c(`+1) = \u00b5c(`+1) + \u03b1g(`+1) . (47) Here, \u03b1g(`) is the mutation added to the template at level ` in the evolutionary tree.\nF.2 Inference with the E-DRM Yields a Decision Tree\nSince the E-DRMM is an RMM with a hierarchical prior on the rendered templates, we can use Eq.3 to derive the E-DRMM inference algorithm for c\u0302(L)(I) as:\nc\u0302(L)(I) = argmax c(L)\u2208CL max g\u2208G \u3008\u00b5c(L) + \u03b1g(L) + \u00b7 \u00b7 \u00b7+ \u03b1g(1) |I\u3009\n= argmax c(L)\u2208CL max g(1)\u2208G1 \u00b7 \u00b7 \u00b7 max g(L\u22121)\u2208GL\u22121 \u3008\u00b5c(L) + \u03b1g(L)\u2217\ufe38 \ufe37\ufe37 \ufe38 \u2261\u00b5\nc(L\u22121)\n+ \u00b7 \u00b7 \u00b7+ \u03b1g(1) |I\u3009\n\u00b7 \u00b7 \u00b7 \u2261 argmax\nc(L)\u2208CL \u3008\u00b5c(L)g\u2217 |I\u3009. (48)\nwhere \u00b5c(`) has been defined in the second line. Here, we assume that the sub-trees are well-separated. In the last lines, we repeatedly use the distributivity of max over sums, resulting in the iteration\ng\u2217c(`+1) \u2261 argmax g(`+1)\u2208G`+1 \u3008\u00b5c(`+1)g(`+1)\ufe38 \ufe37\ufe37 \ufe38 \u2261W (`+1) |I\u3009\n\u2261 ChooseChild(Filter(I)). (49) Eqs.48 and 49 define a Decision Tree. The leaf label histograms at the end of a decision tree plays a similar role as the SoftMax regression layer in DCNs. Applying bagging [5] on decision trees yield a Random Decision Forest (RDF)."}, {"heading": "G Unifying the Probabilistic and Neural Network Perspectives", "text": ""}, {"heading": "H Additional Experimental Results", "text": "H.1 Learned Filters and Image Reconstructions\nFilters and reconstructed images are shown in Fig. 6.\nH.2 Additional Training Results\nMore results plus comparison to other related work are given in Table 3."}, {"heading": "I Model Configurations", "text": "In our experiments, configurations of the RFM and 2-layer DRFM are similar to LeNet5 [11] and its variants. Also, configurations of the 5-layer DRMM (for MNIST) and the 9-layer DRMM (for CIFAR10) are similar to Conv-Small and Conv-Large architectures in [29, 20], respectively."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "<lb>We develop a probabilistic framework for deep learning based on the Deep Render-<lb>ing Mixture Model (DRMM), a new generative probabilistic model that explicitly<lb>capture variations in data due to latent task nuisance variables. We demonstrate<lb>that max-sum inference in the DRMM yields an algorithm that exactly reproduces<lb>the operations in deep convolutional neural networks (DCNs), providing a first<lb>principles derivation. Our framework provides new insights into the successes and<lb>shortcomings of DCNs as well as a principled route to their improvement. DRMM<lb>training via the Expectation-Maximization (EM) algorithm is a powerful alternative<lb>to DCN back-propagation, and initial training results are promising. Classification<lb>based on the DRMM and other variants outperforms DCNs in supervised digit<lb>classification, training 2-3\u00d7 faster while achieving similar accuracy. Moreover, the<lb>DRMM is applicable to semi-supervised and unsupervised learning tasks, achiev-<lb>ing results that are state-of-the-art in several categories on the MNIST benchmark<lb>and comparable to state of the art on the CIFAR10 benchmark.", "creator": "LaTeX with hyperref package"}}}