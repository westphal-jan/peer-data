{"id": "1703.00854", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Mar-2017", "title": "Learning the Structure of Generative Models without Labeled Data", "abstract": "Curating labeled training accurate year making along primary simplifies between radios learning. Recent ict address this bottleneck half stoichiometry features this synthesize producers at scale down weak supervision sources. The glibc alternative ' h dependency structure directly diabetes by quality of the 250 incorporate, so decisions a changes automatically being any readily determine is a distinct challenge. We propose well structure probabilities linear making maximizes soon $ \\ ell_1 $ - compartmentalized marginal pseudolikelihood included soon occurring internet. Our analytical shown made came amount of unlabelled data any hold identify though truly structure scales sublinearly on the fewer one serious fids for followed broad men however same. Experiments on synthetic data live that everything simplest another 125 $ \\ there $ actually none gave limits substantial yet without selects $ 1 / nine $ as various particulars polar. We also doing yet our techniques provides an average related 18. 37 F1 points has decrease than financing, feedback - developed identify liquefaction tool weeks real - asian data important as PubMed report topics.", "histories": [["v1", "Thu, 2 Mar 2017 16:52:09 GMT  (196kb,D)", "https://arxiv.org/abs/1703.00854v1", null], ["v2", "Sat, 9 Sep 2017 21:22:57 GMT  (280kb,D)", "http://arxiv.org/abs/1703.00854v2", null]], "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["stephen h bach", "bryan dawei he", "alexander ratner", "christopher r\u00e9"], "accepted": true, "id": "1703.00854"}, "pdf": {"name": "1703.00854.pdf", "metadata": {"source": "META", "title": "Learning the Structure of Generative Models without Labeled Data", "authors": ["Stephen H. Bach", "Bryan He", "Alexander Ratner", "Christopher R\u00e9"], "emails": ["<bach@cs.stanford.edu>."], "sections": [{"heading": "1. Introduction", "text": "Supervised machine learning traditionally depends on access to labeled training data, a major bottleneck in developing new methods and applications. In particular, deep learning methods require tens of thousands or more labeled data points for each specific task. Collecting these labels is often prohibitively expensive, especially when specialized domain expertise is required, and major technology companies are investing heavily in hand-curating labeled training data (Metz, 2016; Eadicicco, 2017). Aiming to overcome this bottleneck, there is growing interest in using generative models to synthesize training data from weak super-\n1Stanford University, Stanford, California. Correspondence to: Stephen Bach <bach@cs.stanford.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nvision sources such as heuristics, knowledge bases, and weak classifiers trained directly on noisy sources. Rather than treating training labels as gold-standard inputs, such methods model training set creation as a process in order to generate training labels at scale. The true class label for a data point is modeled as a latent variable that generates the observed, noisy labels. After fitting the parameters of this generative model on unlabeled data, a distribution over the latent, true labels can be inferred.\nThe structure of such generative models directly affects the inferred labels, and prior work assumes that the structure is user-specified (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013b; Ratner et al., 2016). One option is to assume that the supervision sources are conditionally independent given the latent class label. However, statistical dependencies are common in practice, and not taking them into account leads to misjudging the accuracy of the supervision. We cannot rely in general on users to specify the structure of the generative model, because supervising heuristics and classifiers might be independent for some data sets but not others. We therefore seek an efficient method for automatically learning the structure of the generative model from weak supervision sources alone.\nWhile structure learning in the supervised setting is wellstudied (e.g., Meinshausen & Bu\u0308hlmann, 2006; Zhao & Yu, 2006; Ravikumar et al., 2010, see also Section 6), learning the structure of generative models for weak supervision is challenging because the true class labels are latent. Although we can learn the parameters of generative models for a given structure using stochastic gradient descent and Gibbs sampling, modeling all possible dependencies does not scale as an alternative to model selection. For example, estimating all possible correlations for a modestly sized problem of 100 weak supervision sources takes over 40 minutes. (For comparison, our proposed approach solves the same problem in 15 seconds.) As users develop their supervision heuristics, rerunning parameter learning to identify dependencies becomes a prohibitive bottleneck.\nWe propose an estimator to learn the dependency structure of a generative model without using any labeled training data. Our method maximizes the `1-regularized marginal pseudolikelihood of each supervision source\u2019s output independently, selecting those dependencies that have nonzero\nar X\niv :1\n70 3.\n00 85\n4v 2\n[ cs\n.L G\n] 9\nS ep\n2 01\n7\nweights. This estimator is analogous to maximum likelihood for logistic regression, except that we marginalize out our uncertainty about the latent class label. Since the pseudolikelihood is a function of one free variable and marginalizes over one other variable, we compute the gradient of the marginal pseudolikelihood exactly, avoiding the need for approximating the gradient with Gibbs sampling, as is done for maximum likelihood estimation.\nOur analysis shows that the amount of data required to identify the true structure scales sublinearly in the number of possible dependencies for a broad class of models. Intuitively, this follows from the fact that learning the generative model\u2019s parameters is possible when there are a sufficient number of better-than-random supervision sources available. With enough signal to estimate the latent class labels better than random guessing, those estimates can be refined until the model is identified.\nWe run experiments to confirm these predictions. We also compare against the alternative approach of considering all possible dependencies during parameter learning. We find that our method is 100\u00d7 faster. In addition, our method returns 1/4 as many extraneous correlations on synthetic data when tuned for comparable recall. Finally, we demonstrate that on real-world applications of weak supervision, using generative models with automatically learned dependencies improves performance. We find that our method provides on average 1.5 F1 points of improvement over existing, user-developed information extraction applications on PubMed abstracts and hardware specification sheets."}, {"heading": "2. Background", "text": "When developing machine learning systems, the primary bottleneck is often curating a sufficient amount of labeled training data. Hand labeling training data is expensive, time consuming, and often requires specialized knowledge. Recently researchers have proposed methods for synthesizing labels from noisy label sources using generative models. (See Section 6 for a summary.) We ground our work in one framework, data programming (Ratner et al., 2016), that generalizes many approaches in the literature.\nIn data programming, weak supervision sources are encoded as labeling functions, heuristics that label data points (or abstain). A generative probabilistic model is fit to estimate the accuracy of the labeling functions and the strength of any user-specified statistical dependencies among their outputs. In this model, the true class label for a data point is a latent variable that generates the labeling function outputs. After fitting the parameters of the generative model, a distribution over the latent, true labels can be estimated and be used to train a discriminative model by minimizing the expected loss with respect to that distribution.\nWe formally describe this setup by first specifying for each data point xi a latent random variable yi \u2208 {\u22121, 1} that is its true label. For example, in an information extraction task, xi might be a span of text. Then, yi can represent whether it is a mention of a company or not (entity tagging). Alternatively, xi might be a more complex structure, such as a tuple of canonical identifiers along with associated mentions in a document, and then yi can represent whether a relation of interest over that tuple is expressed in the document (relation extraction).\nWe do not have access to yi (even at training time), but we do have n user-provided labeling functions \u03bb1, . . . , \u03bbn that can be applied to xi to produce outputs \u039bi1, . . . ,\u039bin. For example, for the company-tagging task mentioned above, a labeling function might apply the regular expression .+\\sInc\\. to a span of text and return whether it matched. The domain of each \u039bij is {\u22121, 0, 1}, corresponding to false, abstaining, and true. Generalizing to the multiclass case is straightforward.\nOur goal is to estimate a probabilistic model that generates the labeling-function outputs \u039b \u2208 {\u22121, 0, 1}m\u00d7n. A common assumption is that the outputs are conditionally independent given the true label, and that the relationship between \u039b and y is governed by n accuracy dependencies\n\u03c6Accj (\u039bi, yi) := yi\u039bij\nwith a parameter \u03b8Accj modeling how accurate each labeling function \u03bbj is. We refer to this structure as the conditionally independent model, and specify it as\np\u03b8(\u039b, Y ) \u221d exp  m\u2211 i=1 n\u2211 j=1 \u03b8Accj \u03c6 Acc j (\u039bi, yi)  , (1) where Y := y1, . . . , ym.\nWe estimate the parameters \u03b8 by minimizing the negative log marginal likelihood p\u03b8(\u039b\u0304) for an observed matrix of labeling function outputs \u039b\u0304:\narg min \u03b8 \u2212 log \u2211 Y p\u03b8(\u039b\u0304, Y ) . (2)\nOptimizing the likelihood is straightforward using stochastic gradient descent. The gradient of objective (2) with respect to parameter \u03b8Accj is\nm\u2211 i=1 ( E\u039b,Y\u223c\u03b8 [ \u03c6Accj (\u039bi, yi) ] \u2212 EY\u223c\u03b8|\u039b\u0304 [ \u03c6Accj (\u039b\u0304i, yi) ]) ,\nthe difference between the corresponding sufficient statistic of the joint distribution p\u03b8 and the same distribution conditioned on \u039b\u0304. In practice, we can interleave samples to estimate the gradient and gradient steps very tightly, taking\na small step after each sample of each variable \u039bij or yi, similarly to contrastive divergence (Hinton, 2002).\nThe conditionally independent model is a common assumption, and using a more sophisticated generative model currently requires users to specify its structure. In the rest of the paper, we address the question of automatically identifying the dependency structure from the observations \u039b\u0304 without observing Y ."}, {"heading": "3. Structure Learning without Labels", "text": "Statistical dependencies arise naturally among weak supervision sources. In data programming, users often write labeling functions with directly correlated outputs or even labeling functions deliberately designed to reinforce others with narrow, more precise heuristics. To address this issue, we generalize the conditionally independent model as a factor graph with additional dependencies, including higher-order factors that connect multiple labeling function outputs for each data point xi and label yi. We specify the general model as\np\u03b8(\u039b, Y ) \u221d exp ( m\u2211 i=1 \u2211 t\u2208T \u2211 s\u2208St \u03b8ts\u03c6 t s(\u039bi, yi) ) . (3)\nHere T is the set of dependency types of interest, and St is a set of index tuples, indicating the labeling functions that participate in each dependency of type t \u2208 T . We start by defining standard correlation dependencies of the form\n\u03c6Corjk (\u039bi, yi) := 1{\u039bij = \u039bik} .\nWe refer to such dependencies as pairwise among labeling functions because they depend only on two labeling function outputs. We can also consider higher-order dependencies that involve more variables, such as conjunction dependencies of the form\n\u03c6Andjk (\u039bi, yi) := 1{\u039bij = yi \u2227 \u039bik = yi} .\nEstimating the structure of the distribution p\u03b8(\u039b, Y ) is challenging because Y is latent; we never observe its value, even during training. We must therefore work with the marginal likelihood p\u03b8(\u039b). Learning the parameters of the generative model jointly requires Gibbs sampling to estimate gradients. As the number of possible dependencies increases at least quadratically in the number of labeling functions, this heavyweight approach to learning does not scale (see Section 5.2)."}, {"heading": "3.1. Learning Objective", "text": "We can scale up learning over many potentially irrelevant dependencies by optimizing a different objective: the log\nmarginal pseudolikelihood of the outputs of a single labeling function \u03bbj , i.e., conditioned on the outputs of the others \u03bb\\j , using `1 regularization to induce sparsity. The objective is\narg min \u03b8\n\u2212 log p\u03b8(\u039b\u0304j | \u039b\u0304\\j) + \u2016\u03b8\u20161 (4)\n= arg min \u03b8 \u2212 m\u2211 i=1 log \u2211 yi p\u03b8(\u039b\u0304ij , yi | \u039b\u0304i\\j) + \u2016\u03b8\u20161,\nwhere > 0 is a hyperparameter. By conditioning on all other labeling functions in each term log \u2211 yi p\u03b8(\u039b\u0304ij , yi | \u039b\u0304i\\j), we ensure that the gradient can be computed in polynomial time with respect to the number of labeling functions, data points, and possible dependencies; without requiring any sampling or variational approximations. The gradient of the log marginal pseudolikelihood is the difference between two expectations: the sufficient statistics conditioned on all labeling functions but \u03bbj , and conditioned on all labeling functions:\n\u2212 \u2202 log p(\u039b\u0304j | \u039b\u0304\\j)\n\u2202\u03b8ts = \u03b1\u2212 \u03b2, (5)\nwhere\n\u03b1 := m\u2211 i=1 \u2211 \u039bij ,yi p\u03b8(\u039bij , yi | \u039b\u0304i\\j)\u03c6ts((\u039bij , \u039b\u0304i\\j), yi)\n\u03b2 := m\u2211 i=1 \u2211 yi p(yi | \u039b\u0304i)\u03c6ts(\u039b\u0304i, yi).\nNote that in the definition of \u03b1, \u03c6ts operates on the value of \u039bij set in the summation and the observed values of \u039b\u0304i\\j .\nWe optimize for each labeling function \u03bbj in turn, selecting those dependencies with parameters that have a sufficiently large magnitude and adding them to the estimated structure."}, {"heading": "3.2. Implementation", "text": "We implement our method as Algorithm 1, a stochastic gradient descent (SGD) routine. At each step of the descent, the gradient (5) is estimated for a single data point, which can be computed in closed form. Using SGD has two advantages. First, it requires only first-order gradient information. Other methods for `1-regularized regression like interior-point methods (Koh et al., 2007) usually require computing second-order information. Second, the observations \u039b\u0304 can be processed incrementally. Since data programming operates on unlabeled data, which is often abundant, scalability is crucial. To implement `1 regularization as part of SGD, we use an online truncated gradient method (Langford et al., 2009).\nIn practice, we find that the only parameter that requires tuning is , which controls the threshold and regularization\nAlgorithm 1 Structure Learning for Data Programming\nInput: Observations \u039b\u0304 \u2208 {\u22121, 0, 1}m\u00d7n, threshold , distribution p with parameters \u03b8, initial parameters \u03b80, step size \u03b7, epoch count T , truncation frequency K D \u2190 \u2205 for j = 1 to n do \u03b8 \u2190 \u03b80 for \u03c4 = 1 to T do\nfor i = 1 to m do for \u03b8ts in \u03b8 do \u03b1\u2190 \u2211 \u039bij ,yi\np(\u039bij , yi|\u039b\u0304i\\j)\u03c6ts((\u039bij , \u039b\u0304i\\j), yi) \u03b2 \u2190 \u2211 yi p(yi | \u039b\u0304i)\u03c6ts(\u039b\u0304i, yi)\n\u03b8ts \u2190 \u03b8ts \u2212 \u03b7(\u03b1\u2212 \u03b2) if \u03c4m+ i mod K is 0 then\nfor \u03b8ts in \u03b8 where \u03b8ts > 0 do \u03b8ts \u2190 max{0, \u03b8ts \u2212K\u03b7 } for \u03b8ts in \u03b8 where \u03b8ts < 0 do \u03b8ts \u2190 min{0, \u03b8ts +K\u03b7 }\nfor \u03b8ts in \u03b8 where j \u2208 s do if |\u03b8ts| > then D \u2190 D \u222a {(s, t)}\nreturn D\nstrength. Higher values induce more sparsity in the selected structure. For the other parameters, we use the same values in all of our experiments: step size \u03b7 = m\u22121, epoch count T = 10, and truncation frequency K = 10."}, {"heading": "4. Analysis", "text": "We provide guarantees on the probability that Algorithm 1 successfully recovers the exact dependency structure. We first provide a general recovery guarantee for all types of possible dependencies, including both pairwise and higherorder dependencies. However, in many cases, higher-order dependencies are not necessary to model the behavior of the labeling functions. In fact, as we demonstrate in Section 5.3, in many useful models there are only accuracy dependencies and pairwise correlations. In this case, we show as a corollary to our general result that the number of samples required is sublinear in the number of possible dependencies, specifically O(n log n).\nPrevious analyses for the supervised case do not carry over to the unsupervised setting because the problem is no longer convex. For example, analysis of an analogous method for supervised Ising models (Ravikumar et al., 2010) relies on Lagrangian duality and a tight duality gap, which does not hold for our estimation problem. Instead, we reason about a region of the parameter space in which we can estimate Y well enough that we can eventually ap-\nproach the true model.\nWe now state the conditions necessary for our guarantees. First are two standard conditions that are needed to guarantee that the dependency structure can be recovered with any number of samples. One, we must have some set \u0398 \u2282 RM of feasible parameters. Two, the true model is in \u0398, i.e., there exists some choice of \u03b8\u2217 \u2208 \u0398 such that\n\u03c0\u2217(\u039b, Y ) = p\u03b8\u2217(\u039b, Y ), \u2200\u039b \u2208 {\u22121, 0, 1}m\u00d7n, Y \u2208 {\u22121, 1}m (6)\nwhere \u03c0\u2217 is the true distribution.\nNext, let \u03a6j denote the set of dependencies that involve either labeling function \u03bbj or the true label y. For any feasible parameter \u03b8 \u2208 \u0398 and j \u2208 {1, . . . , n}, there must exist c > 0 such that\ncI + m\u2211 i=1 Cov(\u039b,Y )\u223cp\u03b8 (\u03a6j(\u039b, Y ) | \u039bi = \u039b\u0304i)\nm\u2211 i=1 Cov(\u039b,Y )\u223cp\u03b8 (\u03a6j(\u039b, Y ) | \u039bi\\j = \u039b\u0304i\\j). (7)\nThis means that for each labeling function, we have a better estimate of the dependencies with the labeling function than without. It is analogous to assumptions made to analyze parameter learning in data programming.\nFinally, we require that all non-zero parameters be bounded away from zero. That is, for all \u03b8i 6= 0, and some \u03ba > 0, we have that\n|\u03b8i| \u2265 \u03ba. (8)\nUnder these conditions, we are able to provide guarantees on the probability of finding the correct dependency structure. First, we present guarantees for all types of possible dependencies in Theorem 1, proved in Appendix A.2. For this theorem, we define dj to be the number of possible dependencies involving either \u039bj or y, and we define d as the largest of d1, . . . , dn.\nTheorem 1. Suppose we run Algorithm 1 on a problem where conditions (6), (7), and (8) are satisfied. Then, for any \u03b4 > 0, an unlabeled input dataset of size\nm \u2265 32d c2\u03ba2 log\n( 2nd\n\u03b4 ) is sufficient to recover the exact dependency structure with a probability of at least 1\u2212 \u03b4.\nFor general dependencies, d can be as large as the number of possible dependencies due to the fact that higher-order dependencies can connect the true label and many labeling functions. The rate of Theorem 1 rate is therefore not directly comparable to that of Ravikumar et al. (2010), which applies to Ising models with pairwise dependencies.\nAs we demonstrate in Section 5.3, however, real-world applications can be improved by modeling just pairwise correlations among labeling functions. If only considering these dependencies, then d will only be 2n \u2212 1, rather than the number of potential dependencies. In Corollary 2, we show that a number of samples needed in this case is O(n log n). Notice that this is sublinear in the number of possible dependencies, which is O(n2).\nCorollary 2. Suppose we run Algorithm 1 on a problem where conditions (6), (7), and (8) are satisfied. Additionally, assume that the only potential dependencies are accuracy and correlation dependencies. Then, for any \u03b4 > 0, an unlabeled input dataset of size\nm \u2265 64n c2\u03ba2 log\n( 4n\n\u03b4 ) is sufficient to recover the exact dependency structure with a probability of at least 1\u2212 \u03b4.\nIn this case, we see the difference in analyses between the unsupervised and supervised settings. Whereas the rate of Corollary 2 depends on the maximum number of dependencies that could affect a variable in the model class, the rate of Ravikumar et al. (2010) depends cubically on the maximum number of dependencies that actually affect any variable in the true model and only logarithmically in the maximum possible degree. In the supervised setting, the guaranteed rate is therefore tighter for very sparse models. However, as we show in Section 5.1, the guaranteed rates in both settings are pessimistic, and in practice they appear to scale at the same rate."}, {"heading": "5. Experiments", "text": "We implement our method as part of the open source framework Snorkel1 and evaluate it in three ways. First, we measure how the probability of returning the exact correlation structure is affected by the problem parameters using synthetic data, confirming our analysis that its sample complexity is sublinear in the number of possible dependencies. In fact, we find that in practice the sample complexity is lower than the theoretically guaranteed rate, matching the rate seen in practice for fully supervised structure learning. Second, we compare our method to estimating structures via parameter learning over all possible dependencies. We demonstrate using synthetic data that our method is 100\u00d7 faster and more accurate, selecting 1/4 as many extraneous correlations on average. Third, we apply our method to real-world applications built using data programming, such as information extraction from PubMed journal abstracts and hardware specification sheets. In these applications, users did not specify any dependencies between the label-\n1snorkel.stanford.edu\ning functions they authored; however, as we detail in Section 5.3, these dependencies naturally arise, for example due to explicit composing, relaxing, or tightening of labeling function heuristics; related distant supervision sources; or multiple concurrent developers writing labeling functions. We show that learning this structure improves performance over the conditionally independent model, giving an average 1.5 F1 point boost."}, {"heading": "5.1. Sample Complexity", "text": "We test how the probability that Algorithm 1 returns the correct correlation structure depends on the true distribution. Our analysis in Section 4 guarantees that the sample complexity grows at worst on the order O(n log n) for n labeling functions. In practice, we find that structure learning performs better than this guaranteed rate, depending linearly on the number of true correlations and logarithmically on the number of possible correlations. This matches the observed behavior for fully supervised structure learning for Ising models (Ravikumar et al., 2010), which is also tighter than the best known theoretical guarantees.\nTo demonstrate this behavior, we attempt to recover the true dependency structure using a number of samples defined as\nm := 750 \u00b7 \u03b3 \u00b7 d\u2217 \u00b7 log n (9)\nwhere d\u2217 is the maximum number of dependencies that affect any one labeling function. For example, in the conditionally independent model d\u2217 = 1 and in a model with one correlation d\u2217 = 2. We vary the control parameter \u03b3 from 0.1 to 2.0 to determine the point at which m is sufficiently large for Algorithm 1 to recover the true dependency structure. (The constant 750 was selected so that it succeeds with high probability around \u03b3 = 1.0.)\nWe first test the effect of varying n, the number of labeling functions. For n \u2208 {25, 50, 75, 100}, we set two pairs of\nlabeling functions to be correlated with \u03b8Corjk = 0.25.We set \u03b8Accj = 1.0 for all j. We then generate m samples for each setting of \u03b3 over 100 trials. Figure 1 shows the fraction of times Algorithm 1 returns the correct correlation structure as a function of the control parameter \u03b3. That the curves are aligned for different values of n shows that the sample complexity in practice scales logarithmically in n.\nWe next test the effect of varying d\u2217, the maximum number of dependencies that affect a labeling function in the true distribution. For 25 labeling functions, we add correlations to the true model to form cliques of increasing degree. All parameters are the same as in the previous experiment. Figure 2 shows that for increasing values of d\u2217, (9) again predicts the number of samples for Algorithm 1 to succeed. That the curves are aligned for different values of d\u2217 shows that the sample complexity in practice scales linearly in d\u2217."}, {"heading": "5.2. Comparison with Maximum Likelihood", "text": "We next compare Algorithm 1 with an alternative approach. Without an efficient structure learning method, one could maximize the marginal likelihood of the observations \u039b\u0304 while considering all possible dependencies. To measure the benefits of maximizing the marginal pseudolikelihood, we compare its performance against an analogous maximum likelihood estimation routine that also uses stochastic gradient descent, but instead uses Gibbs sampling to estimate the intractable gradient of the objective.\nWe create different distributions over n labeling functions by selecting with probability 0.05 pairs of labeling functions to make correlated. Again, the strength of correlation is set at \u03b8Corjk = 0.25 and accuracy is set at \u03b8 Acc j = 1.0. We generate 100 distributions for n \u2208 {25, 30, 35, . . . , 100}. For each distribution we generate 10,000 samples and attempt to recover the true correlation structure.\nWe first compare running time between the two methods. Our implementation of maximum likelihood estimation is designed for speed: for every sample taken to estimate the gradient, a small update to the parameters is performed. This approach is state-of-the-art for high-speed learning for factor graphs (Zhang & Re\u0301, 2014). However, the need for sampling the variables \u039b and Y is still computationally expensive. Figure 3 shows that by avoiding variable sampling, using pseudolikelihood is 100\u00d7 faster.\nWe next compare the accuracy of the two methods, which depends on the regularization . The ideal is to maximize the probability of perfect recall with few extraneous correlations, because subsequent parameter estimation can reduce the influence of an extraneous correlation but cannot discover a missing correlation. We tune independently for each method. Figure 4 (top) shows that maximum pseudolikelihood is able to maintain higher levels of recall than maximum likelihood as the problem size increases. Figure 4 (bottom) shows that even tuned for better recall, maximum pseudolikelihood is more precise, returning 1/4 as many extraneous correlations. We interpret this improved accuracy as a benefit of computing the gradient for a data point exactly, as opposed to using Gibbs sampling to estimate it as in maximum likelihood estimation."}, {"heading": "5.3. Real-World Applications", "text": "We evaluate our method on several real-world information extraction applications, comparing the performance of data programming using dependencies selected by our method with the conditionally independent model (Table 1). In the data programming method, users express a variety of weak supervision rules and sources such as regular expression patterns, distant supervision from dictionaries and existing knowledge bases, and other heuristics as labeling functions. Due to the noisy and overlapping nature of these labeling functions, correlations arise. Learning this correlation structure gives an average improvement of 1.5 F1 points.\nExtracting structured information from unstructured text by identifying mentioned entities and relations is a challenging task that is well studied in the context of weak supervision (Bunescu & Mooney, 2007; Alfonseca et al., 2012; Ratner et al., 2016). We consider three tasks: extracting mentions of specific diseases from the scientific literature (Disease Tagging); extracting mentions of chemicals inducing diseases from the scientific literature (ChemicalDisease); and extracting mentions of electronic device polarity from PDF parts sheet tables (Device Polarity). In the first two applications, we consider a training set of 500 unlabeled abstracts from PubMed, and in the third case 100 PDF parts sheets consisting of mixed text and tabular data. We use hand-labeled test sets to evaluate on the candidatemention-level performance, which is the accuracy of the classifier in identifying correct mentions of specific entities or relations, given a set of candidate mentions. For example, in Chemical-Disease, we consider as candidates all pairs of co-occurring chemical-disease mention pairs as identified by standard preprocessing tools2.\nWe see that modeling the correlations between labeling functions gives gains in performance which appear to be correlated with the total number of sources. For example, in the disease tagging application, we have 233 labeling\n2 ncbi.nlm.nih.gov/CBBresearch/Lu/Demo/PubTator/index.cgi\nfunctions, the majority of which check for membership in specific subtrees of a reference disease ontology using different matching heuristics. There is overlap in the labeling functions which check identical subtrees of the ontology, and we see that our method increases end performance by a significant 2.6 F1 points by modeling this structure.\nExamining the Chemical-Disease task, we see that our method identifies correlations that are both obviously true and ones that are more subtle. For example, our method learns dependencies between labeling functions that are compositions of one another, such as one labeling function checking for the pattern [CHEM] induc.* [DIS], and a second labeling function checking for this pattern plus membership in an external knowledge base of known chemical-disease relations. Our method also learns more subtle correlations: for example, it selected a correlation between a labeling function that checks for the presence of a chemical mention in between the chemical and disease mentions comprising the candidate, and one that checks for the pattern .*-induced appearing in between."}, {"heading": "5.4. Accelerating Application Development", "text": "Our method is in large part motivated by the new programming model introduced by weak supervision, and the novel hurdles that developers face. For example in the Disease Tagging application above, we observed developers significantly slowed down in trying to to leverage the rich disease ontologies and matching heuristics they had available without introducing too many dependencies between their labeling functions. In addition to being slowed down, we also observed developers running into significant pitfalls due to unnoticed correlations between their weak supervision sources. In one collaborator\u2019s application, for every labeling function that referenced the words in a sentence, a corresponding labeling function referenced the lemmas, which were often identical, and this significantly degraded performance. By automatically learning dependencies, we were able to significantly mitigate the effects of such correlations. We therefore envision an accelerated development process enabled by our method.\nTo further explore the way in which our method can protect against such types of failure modes, we consider adding correlated, random labeling functions to those used in the Chemical-Disease task. Figure 5 shows the average estimated accuracy of copies of a random labeling function. An independent model grows more confident that the random noise is accurate. However, with structure learning, we identify that the noisy sources are not independent and they therefore do not outvote the real labeling functions. In this way, structure learning can protect against failures as users experiment with sources of weak supervision.\nTable 1. Candidate-mention scores of information extraction applications trained with data programming using generative models with no dependency structure (Independent) and learned dependency structure (Structure).\nAPPLICATION INDEPENDENT STRUCTURE F1 DIFF. # LFS # COR. % CORR.P R F1 P R F1\nDISEASE TAGGING 60.4 73.3 66.3 68.0 69.8 68.9 2.6 233 315 1.17%\nCHEMICAL-DISEASE 45.1 69.2 54.6 46.8 69.0 55.9 1.3 33 21 3.98%\nDEVICE POLARITY 78.9 99.6 88.1 80.5 98.6 88.7 0.6 12 32 48.49%\nFigure 5. Structure learning identifies and corrects correlated, random labeling functions added to the Chemical-Disease task."}, {"heading": "6. Related Work", "text": "Structure learning is a well-studied problem, but most work has assumed access to hand-labeled training data. Some of the earliest work has focused on generalized linear models. The lasso (Tibshirani, 1996), linear regression with `1 regularization, is a classic technique. Zhao & Yu (2006) showed that the lasso is a consistent structure estimator. The Dantzig selector (Candes & Tao, 2007) is another structure estimator for linear models that uses `1, which can learn in the high-dimensional setting where there are more possible dependencies than samples. Ng (2004) showed that `1-regularized logistic regression has sample complexity logarithmic in the number of features. `1 regularization has also been used as a prior for compressed sensing (e.g., Donoho & Elad, 2003; Tropp, 2006; Wainwright, 2009).\nRegularized estimators have also been used to select structures for graphical models. Meinshausen & Bu\u0308hlmann (2006) showed that parameter learning with `1 regularization for Gaussian graphical models under similar assumptions also consistently selects the correct structure. Most similar to our proposed estimator, Ravikumar et al. (2010) propose a fully supervised pseudolikelihood estimator for Ising models. Also related is the work of Chandrasekaran et al. (2012), which considers learning the structure of Gaussian graphical models with latent variables. Other techniques for learning the structure of graphical models include grafting (Perkins et al., 2003; Zhu et al., 2010) and the information bottleneck approach for learning Bayesian\nnetworks with latent variables (Elidan & Friedman, 2005).\nUsing heuristic sources of labels is increasingly common. Treating labels from a single heuristic source as gold labels is called distant supervision (Craven & Kumlien, 1999; Mintz et al., 2009). Some methods use multi-instance learning to reduce the noise in a distant supervision source (Riedel et al., 2010; Hoffmann et al., 2011). Others use hierarchical topic models to generate additional training data for weak supervision, but they do not support user-provided heuristics (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013a;b). Previous methods that support heuristics for weak supervision (e.g., Bunescu & Mooney, 2007; Shin et al., 2015) do not model the noise inherent in these sources. Also, Downey & Etzioni (2008) showed that PAC learning is possible without hand-labeled data if the features monotonically order data by class probability.\nEstimating the accuracy of multiple label sources without a gold standard is a classic problem (Dawid & Skene, 1979), and many proposed approaches are generalized in the data programming framework. Parisi et al. (2014) proposed a spectral approach to estimating the accuracy of members of classifier ensembles. Many methods for crowdsourcing estimate the accuracy of workers without hand-labeled data (e.g., Dalvi et al., 2013; Joglekar et al., 2015; Zhang et al., 2016). In data programming, the scaling of data to label sources is different from crowdsourcing; a relatively small number of sources label all the data. We can therefore learn rich dependency structures among the sources."}, {"heading": "7. Conclusion and Future Directions", "text": "We showed that learning the structure of a generative model enables higher quality data programming results. Our method for structure learning is also 100\u00d7 faster than a maximum likelihood approach. If data programming and other forms of weak supervision are to make machine learning tools easier to develop, selecting accurate structures for generative models with minimal user intervention is a necessary capability. Interesting questions remain. Can the guarantee of Theorem 1 be tightened for higher-order dependencies to match the pairwise case of Corollary 2? Preliminary experiments show that they converge at similar rates in practice."}, {"heading": "Acknowledgements", "text": "Thanks to Christopher De Sa for helpful discussions, and Henry Ehrenberg and Sen Wu for assistance with experiments. We gratefully acknowledge the support of the Defense Advanced Research Projects Agency (DARPA) SIMPLEX program under No. N66001-15-C-4043, the DARPA D3M program under No. FA8750-17-2-0095, the National Science Foundation (NSF) CAREER Award under No. IIS- 1353606, the Office of Naval Research (ONR) under awards No. N000141210041 and No. N000141310129, a Sloan Research Fellowship, the Moore Foundation, an Okawa Research Grant, Toshiba, and Intel. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA, NSF, ONR, or the U.S. government."}, {"heading": "A. Proofs", "text": "In this appendix, we provide proofs for Theorem 1 and Corollary 2 from the main text. In Section A.1, we provide an outline of the proof and state several lemmas. In Section A.2, we prove Theorem 1. In Section A.3, we prove Corollary 2, which follows directly from Theorem 1. In Section A.4, we prove the lemmas stated in Section A.1.\nA.1. Outline and Lemma Statements\nA.1.1. OUTLINE OF THEOREM 1 PROOF\nWe first show that the negative marginal log-pseudolikelihood is strongly convex under condition (7). In particular, in Lemma 1, we derive the gradient and Hessian of each term of the negative marginal log-pseudolikelihood, and in Lemma 2, we show that the negative marginal log-pseudolikelihood is strongly convex under condition (7).\nNext, in Lemma 3, we show that, under condition (6), the gradient of the negative marginal log-pseudolikelihood at the true parameter \u03b8\u2217 is small with high probability.\nFinally, we show that if we run SGD until convergence and then truncate, we will recover the exact sparsity structure with high probability. In Lemma 4, we show that if the true parameter \u03b8\u2217 has a small gradient, then the empirical minimum \u03b8\u0302 will be close to it, and in Lemma 5, we show that the correct sparsity structure is recovered.\nA.1.2. LEMMA STATEMENTS\nWe now formally state the lemmas used in our proof. Lemma 1. Given a family of maximum-entropy distributions\np\u03b8(x) = 1\nZ\u03b8 exp(\u03b8T\u03c6(x)),\nfor some function of sufficient statistics h : \u2126 \u2192 RM , if we let J be the negative log-pseudolikelihood objective for some event A \u2286 \u2126,\nJ(\u03b8) = \u2212 log px\u223cp\u03b8 (x \u2208 A | \u039b\\j),\nthen its gradient is\n\u2207J(\u03b8) = \u2212Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] + Ex\u223cp\u03b8 [ \u03c6(x) | \u039b\\j ] and its Hessian is\n\u22072J(\u03b8) = \u2212Covx\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] + Covx\u223cp\u03b8 [ \u03c6(x) | \u039b\\j ] Lemma 2. Let J be the empirical negative log-pseudolikelihood objective for the event \u039bj = \u039b\u0304j\nJ(\u03b8) = \u2212 m\u2211 i=1 [ log px\u223cp\u03b8 (\u039bij = \u039b\u0304ij | \u039bi\\j = \u039b\u0304i\\j) ] .\nLet \u0398j denote the set of parameters corresponding to dependencies incident on either labeling function \u03bbj or the true label y, and let \u0398\\j denote all the set of all remaining parameters.\nThen, J(\u03b8) is independent of the variables in \u0398\\j , and under condition (7), J(\u03b8) is strongly convex on the variables in \u0398j with a parameter of strong convexity of c.\nLemma 3. Let dj be the number of dependencies that involve either \u03bbj or y, and let \u03b8\u2217 be the true parameter specified by condition (6). Define W as the gradient of the negative log-pseudolikelihood of \u03bbj at this point\nW = \u2212\u2207J(\u03b8\u2217;X).\nThen, for any \u03b4.\nPr(\u2016W\u2016\u221e \u2265 \u03b4) \u2264 2dj exp ( \u2212m\u03b42\n8\n)\nLemma 4. Let J be a c-strongly convex function in d dimensions, and let \u03b8\u0302 be the minimizer of J . Suppose \u2016J(\u03b8\u2217)\u2016\u221e \u2264 \u03b4. Then,\n\u2016\u03b8\u0302 \u2212 \u03b8\u2217\u2016\u221e \u2264 \u03b4\nc\n\u221a d\nLemma 5. Suppose that conditions (6), (7), and (8) are satisfied. Suppose we run Algorithm 1 with m samples, a sufficiently small step size \u03b7, a sufficiently large number of epochs T , and truncate once at the end with K\u03b7 = \u03ba/2. Then, the probability that we fail to recover the exact sparsity structure is at most\n2nd exp\n( \u2212mc2\u03ba2\n32d\n) .\nA.2. Proof of Theorem 1\nTheorem 1. Suppose we run Algorithm 1 on a problem where conditions (6), (7), and (8) are satisfied. Then, for any \u03b4 > 0, an unlabeled input dataset of size\nm \u2265 32d c2\u03ba2 log\n( 2nd\n\u03b4 ) is sufficient to recover the exact dependency structure with a probability of at least 1\u2212 \u03b4.\nProof. If follows from Lemma 5 that the probability that we fail to recover the sparsity structure is at most\n2nd exp\n( \u2212mc2\u03ba2\n32d\n) .\nBy using the provided m, the probability of failure is at most\n2nd exp\n( \u2212 32dc2\u03ba2 log ( 2nd \u03b4 ) c2\u03ba2\n32d\n) = 2nd exp ( \u2212 log ( 2nd\n\u03b4\n)) = \u03b4.\nThus, we will succeed with probability at least 1\u2212 \u03b4.\nA.3. Proof of Corollary 2\nCorollary 3. Suppose we run Algorithm 1 on a problem where conditions (6), (7), and (8) are satisfied. Additionally, assume that the only potential dependencies are accuracy and correlation dependencies. Then, for any \u03b4 > 0, an unlabeled input dataset of size\nm \u2265 64n c2\u03ba2 log\n( 4n\n\u03b4 ) is sufficient to recover the exact dependency structure with a probability of at least 1\u2212 \u03b4.\nProof. In this case, each labeling function \u03bbj is involved in n \u2212 1 with other labeling functions, and the true label y is involved in n dependencies. Thus, d = (n\u2212 1) + n < 2n.\nWe can then apply Theorem 1 to show that the probability of success is at least 1\u2212 \u03c4 for the specified m.\nA.4. Proofs of Lemmas\nLemma 1. Given a family of maximum-entropy distributions\np\u03b8(x) = 1\nZ\u03b8 exp(\u03b8T\u03c6(x)),\nfor some function of sufficient statistics h : \u2126 \u2192 RM , if we let J be the negative log-pseudolikelihood objective for some event A \u2286 \u2126,\nJ(\u03b8) = \u2212 log px\u223cp\u03b8 (x \u2208 A | \u039b\\j),\nthen its gradient is\n\u2207J(\u03b8) = \u2212Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] + Ex\u223cp\u03b8 [ \u03c6(x) | \u039b\\j ] and its Hessian is\n\u22072J(\u03b8) = \u2212Covx\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] + Covx\u223cp\u03b8 [ \u03c6(x) | \u039b\\j ]\nProof. We first rewrite the netative log-pseudolikelihood as\nJ(\u03b8) = \u2212 log Pr x\u223c\u03c0\u03b8 (x \u2208 A | \u039b\\j)\n= \u2212 log Prx\u223c\u03c0\u03b8 (x \u2208 A,\u039b\\j)\nPrx\u223c\u03c0\u03b8 (\u039b\\j) = \u2212 log \u2211 x\u2208A,\u039b\\j p\u03b8(x)\u2211 x\u2208\u039b\\j p\u03b8(x)\n= \u2212 log \u2211 x\u2208A,\u039b\\j exp(\u03b8\nT\u03c6(x))\u2211 x\u2208\u039b\\j exp(\u03b8 T\u03c6(x))\n= \u2212 log \u2211\nx\u2208A,\u039b\\j exp(\u03b8T\u03c6(x)) + log \u2211 x\u2208\u039b\\j exp(\u03b8T\u03c6(x)).\nWe now derive the gradient\n\u2207J(\u03b8) = \u2207 \u2212 log \u2211 x\u2208A,\u039b\\j exp(\u03b8T\u03c6(x)) + log \u2211 x\u2208\u039b\\j exp(\u03b8T\u03c6(x))  = \u2212\u2207 log\n\u2211 x\u2208A,\u039b\\j exp(\u03b8T\u03c6(x)) +\u2207 log \u2211 x\u2208\u039b\\j exp(\u03b8T\u03c6(x))\n= \u2212 \u2211 x\u2208A,\u039b\\j \u03c6(x) exp(\u03b8\nT\u03c6(x))\u2211 x\u2208A,\u039b\\j exp(\u03b8 T\u03c6(x)) +\n\u2211 x\u2208\u039b\\j \u03c6(x) exp(\u03b8\nT\u03c6(x))\u2211 x\u2208\u039b\\j exp(\u03b8 T\u03c6(x))\n= \u2212Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] + Ex\u223cp\u03b8 [ \u03c6(x) | \u039b\\j ]\nWe now derive the Hessian\n\u22072J(\u03b8) = \u2207 [ \u2212 \u2211 x\u2208A,\u039b\\j \u03c6(x) exp(\u03b8\nT\u03c6(x))\u2211 x\u2208A,\u039b\\j exp(\u03b8 T\u03c6(x)) +\n\u2211 x\u2208\u039b\\j \u03c6(x) exp(\u03b8\nT\u03c6(x))\u2211 x\u2208\u039b\\j exp(\u03b8 T\u03c6(x))\n]\n= \u2212\u2207 \u2211 x\u2208A,\u039b\\j \u03c6(x) exp(\u03b8\nT\u03c6(x))\u2211 x\u2208A,\u039b\\j exp(\u03b8 T\u03c6(x)) +\u2207\n\u2211 x\u2208\u039b\\j \u03c6(x) exp(\u03b8\nT\u03c6(x))\u2211 x\u2208\u039b\\j exp(\u03b8 T\u03c6(x))\n= \u2212 \u2211x\u2208A,\u039b\\j \u03c6(x)\u03c6(x)T exp(\u03b8T\u03c6(x))\u2211 x\u2208A,\u039b\\j exp(\u03b8 T\u03c6(x)) \u2212 (\u2211 x\u2208A,\u039b\\j \u03c6(x) exp(\u03b8 T\u03c6(x)) )(\u2211 x\u2208A,\u039b\\j \u03c6(x) exp(\u03b8 T\u03c6(x)) )T (\u2211\nx\u2208A,\u039b\\j exp(\u03b8 T\u03c6(x))\n)2 \n+ \u2211x\u2208\u039b\\j \u03c6(x)\u03c6(x)T exp(\u03b8T\u03c6(x))\u2211 x\u2208\u039b\\j exp(\u03b8 T\u03c6(x)) \u2212 (\u2211 x\u2208\u039b\\j \u03c6(x) exp(\u03b8 T\u03c6(x)) )(\u2211 x\u2208\u039b\\j \u03c6(x) exp(\u03b8 T\u03c6(x)) )T (\u2211\nx\u2208\u039b\\j exp(\u03b8 T\u03c6(x))\n)2 \n= \u2212 ( Ex\u223cp\u03b8 [ \u03c6(x)\u03c6(x)T | x \u2208 A,\u039b\\j ] \u2212 Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ]T) + ( Ex\u223cp\u03b8 [ \u03c6(x)\u03c6(x)T | x \u2208 \u039b\\j ] \u2212 Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 \u039b\\j ] Ex\u223cp\u03b8 [ \u03c6(x) | x \u2208 \u039b\\j\n]T) = \u2212Covx\u223cp\u03b8 [ \u03c6(x) | x \u2208 A,\u039b\\j ] + Covx\u223cp\u03b8 [ \u03c6(x) | \u039b\\j ] .\nLemma 2. Let J be the empirical negative log-pseudolikelihood objective for the event \u039bj = \u039b\u0304j\nJ(\u03b8) = \u2212 m\u2211 i=1 [ log px\u223cp\u03b8 (\u039bij = \u039b\u0304ij | \u039bi\\j = \u039b\u0304i\\j) ] .\nLet \u0398j denote the set of parameters corresponding to dependencies incident on either labeling function \u03bbj or the true label y, and let \u0398\\j denote all the set of all remaining parameters.\nThen, J(\u03b8) is independent of the variables in \u0398\\j , and under condition (7), J(\u03b8) is strongly convex on the variables in \u0398j with a parameter of strong convexity of c.\nProof. First, we show that J(\u03b8) is independent of the variables in \u0398\\j . We simplify J(\u03b8) as\nJ(\u03b8) = m\u2211 i=1 \u2212 log\u2211 x\u2208\u039b\u0304 exp(\u03b8T\u03c6(x)) + log \u2211 x\u2208\u039b\u0304\\j exp(\u03b8T\u03c6(x))  =\nm\u2211 i=1 \u2212 log\u2211 x\u2208\u039b\u0304 exp ( \u03b8Tj \u03c6j(x) + \u03b8 T \\j\u03c6\\j(x) ) + log \u2211 x\u2208\u039b\u0304\\j exp ( \u03b8Tj \u03c6j(x) + \u03b8 T \\j\u03c6\\j(x) ) =\nm\u2211 i=1 \u2212 log\u2211 x\u2208\u039b\u0304 ( exp ( \u03b8Tj \u03c6j(x) ) exp ( \u03b8T\\j\u03c6\\j(x) )) + log \u2211 x\u2208\u039b\u0304\\j ( exp ( \u03b8Tj \u03c6j(x) ) exp ( \u03b8T\\j\u03c6\\j(x) )) =\nm\u2211 i=1\n\u2212 log exp(\u03b8T\\j\u03c6\\j(x))\u2211\nx\u2208\u039b\u0304\nexp ( \u03b8Tj \u03c6j(x) )+ log exp(\u03b8T\\j\u03c6\\j(x)) \u2211\nx\u2208\u039b\u0304\\j\nexp ( \u03b8Tj \u03c6j(x) ) =\nm\u2211 i=1 \u2212 log exp(\u03b8T\\j\u03c6\\j(x))\u2212 log\u2211 x\u2208\u039b\u0304 exp ( \u03b8Tj \u03c6j(x) ) + log exp ( \u03b8T\\j\u03c6\\j(x) ) + log \u2211 x\u2208\u039b\u0304\\j exp ( \u03b8Tj \u03c6j(x) ) =\nm\u2211 i=1 \u2212 log\u2211 x\u2208\u039b\u0304 exp ( \u03b8Tj \u03c6j(x) ) + log \u2211 x\u2208\u039b\u0304\\j exp ( \u03b8Tj \u03c6j(x) ) ,\nwhich does not depend on any variables in \u0398\\j .\nNext, we prove that J(\u03b8) is c-strongly convex in the variabes in \u0398j . By combining the previous result and Lemma 1, we can derive the Hessian\n\u22072J(\u0398j) = m\u2211 i=1 [ \u2212Cov(\u039b,Y )\u223cp\u03b8 (\u03a6j(\u039b, Y ) | \u039bi = \u039b\u0304i) + Cov(\u039b,Y )\u223cp\u03b8 (\u03a6j(\u039b, Y ) | \u039bi\\j = \u039b\u0304i\\j) ] = \u2212\nm\u2211 i=1 Cov(\u039b,Y )\u223cp\u03b8 (\u03a6j(\u039b, Y ) | \u039bi = \u039b\u0304i) + m\u2211 i=1 Cov(\u039b,Y )\u223cp\u03b8 (\u03a6j(\u039b, Y ) | \u039bi\\j = \u039b\u0304i\\j).\nIt then follows from condition (7) that\ncI \u22072J(\u0398j),\nwhich implies that J is c-strongly convex on variables in \u0398j .\nLemma 3. Let dj be the number of dependencies that involve either \u03bbj or y, and let \u03b8\u2217 be the true parameter specified by condition (6). Define W as the gradient of the negative log-pseudolikelihood of \u03bbj at this point\nW = \u2212\u2207J(\u03b8\u2217;X).\nThen, for any \u03b4.\nPr(\u2016W\u2016\u221e \u2265 \u03b4) \u2264 2dj exp ( \u2212m\u03b42\n8 ) Proof. From Lemma 1, we know that each element ofW can be written as the average ofm i.i.d. terms. From condition (7), we know that the terms have zero mean, and we also know that the terms are bounded in absolute value by 2, due to the fact that the dependencies have values falling in the interval [\u22121, 1].\nWe can alternatively think of the average of the terms as the sum of m i.i.d. zero-mean random variables that are bounded in absolute value by 2m . The two-sided Azuma\u2019s inequality bounds the probability that any term in W is large.\nPr(|Wj | \u2265 \u03b4) \u2264 2 exp\n( \u2212\u03b42\n2 \u2211m i=1 ( 2 m\n)2 ) \u2264 2 exp ( \u2212m\u03b42\n8\n)\nThe union bound then bounds the probability that any component of W is large. Pr(\u2016W\u2016\u221e \u2265 \u03b4) \u2264 2dj exp ( \u2212m\u03b42\n8\n)\nLemma 4. Let J be a c-strongly convex function in d dimensions, and let \u03b8\u0302 be the minimizer of J . Suppose \u2016J(\u03b8\u2217)\u2016\u221e \u2264 \u03b4. Then,\n\u2016\u03b8\u0302 \u2212 \u03b8\u2217\u2016\u221e \u2264 \u03b4\nc\n\u221a d\nProof. Because J is c-strongly convex,( \u2207J(\u03b8\u2217)\u2212\u2207J(\u03b8\u0302) )T (\u03b8\u2217 \u2212 \u03b8\u0302) \u2265 c\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u201622.\n\u2207J(\u03b8\u0302) = 0, so\n\u2207J(\u03b8\u2217)T (\u03b8\u2217 \u2212 \u03b8\u0302) \u2265 c\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u201622.\nThen, because \u2016J(\u03b8\u2217)\u2016\u221e \u2264 \u03b4,\nc\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u201622 \u2264 \u03b4\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u20161\n\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u201622 \u2264 \u03b4\nc \u2016\u03b8\u2217 \u2212 \u03b8\u0302\u20161.\nThen, we have that\n\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u201622 \u2264 \u03b42\nc2 d\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u20162 \u2264\n\u03b4\nc\n\u221a d,\nwhich implies that\n\u2016\u03b8\u2217 \u2212 \u03b8\u0302\u2016\u221e \u2264 \u03b4\nc\n\u221a d.\nLemma 5. Suppose that conditions (6), (7), and (8) are satisfied. Suppose we run Algorithm 1 with m samples, a sufficiently small step size \u03b7, a sufficiently large number of epochs T , and truncate once at the end with K\u03b7 = \u03ba/2. Then, the probability that we fail to recover the exact sparsity structure is at most\n2nd exp\n( \u2212mc2\u03ba2\n32d\n) .\nProof. First, we bound the probability that we fail to correctly recover the dependencies involving \u03bbj . By Lemma 3, we can bound the probability that the gradient is large at \u03b8\u2217 by\nPr ( \u2016W\u2016\u221e \u2265 c\u03ba\n2 \u221a d\n) \u2264 2d exp ( \u2212mc2\u03ba2\n32d\n) .\nNotice that if \u2016W\u2016\u221e \u2265 c\u03ba2\u221ad , then \u2016\u03b8 \u2217 \u2212 \u03b8\u0302\u2016\u221e \u2264 \u03ba/2. If then follows from Lemma 4 that\nPr ( \u2016\u03b8\u2217 \u2212 \u03b8\u0302\u2016\u221e \u2265 \u03ba/2 ) \u2264 2d exp ( \u2212mc2\u03ba2\n32d\n) .\nIf this is the case, then upon truncation, the correct dependencies will be recovered for \u03bbj . We now use the union bound to show that we will fail to recover the exact sparsity structure with probability at most\n2nd exp\n( \u2212mc2\u03ba2\n32d\n) ."}], "references": [{"title": "Pattern learning for relation extraction with a hierarchical topic model", "author": ["E. Alfonseca", "K. Filippova", "Delort", "J.-Y", "G. Garrido"], "venue": "In Annual Meeting of the Association for Computational Linguistics (ACL),", "citeRegEx": "Alfonseca et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Alfonseca et al\\.", "year": 2012}, {"title": "Learning to extract relations from the Web using minimal supervision", "author": ["R.C. Bunescu", "R.J. Mooney"], "venue": "In Annual Meeting of the Association for Computational Linguistics (ACL),", "citeRegEx": "Bunescu and Mooney,? \\Q2007\\E", "shortCiteRegEx": "Bunescu and Mooney", "year": 2007}, {"title": "The Dantzig selector: Statistical estimation when p is much larger than n", "author": ["E. Candes", "T. Tao"], "venue": "The Annals of Statistics,", "citeRegEx": "Candes and Tao,? \\Q2007\\E", "shortCiteRegEx": "Candes and Tao", "year": 2007}, {"title": "Latent variable graphical model selection via convex optimization", "author": ["V. Chandrasekaran", "P.A. Parrilo", "A.S. Willsky"], "venue": "The Annals of Statistics,", "citeRegEx": "Chandrasekaran et al\\.,? \\Q1935\\E", "shortCiteRegEx": "Chandrasekaran et al\\.", "year": 1935}, {"title": "Constructing biological knowledge bases by extracting information from text sources", "author": ["M. Craven", "J. Kumlien"], "venue": "In International Conference on Intelligent Systems for Molecular Biology (ISMB),", "citeRegEx": "Craven and Kumlien,? \\Q1999\\E", "shortCiteRegEx": "Craven and Kumlien", "year": 1999}, {"title": "Aggregating crowdsourced binary ratings", "author": ["N. Dalvi", "A. Dasgupta", "R. Kumar", "V. Rastogi"], "venue": "In International World Wide Web Conference (WWW),", "citeRegEx": "Dalvi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Dalvi et al\\.", "year": 2013}, {"title": "Maximum likelihood estimation of observer error-rates using the EM algorithm", "author": ["A.P. Dawid", "A.M. Skene"], "venue": "Journal of the Royal Statistical Society C,", "citeRegEx": "Dawid and Skene,? \\Q1979\\E", "shortCiteRegEx": "Dawid and Skene", "year": 1979}, {"title": "Optimally sparse representation in general (nonorthogonal) dictionaries via ` minimization", "author": ["D. Donoho", "M. Elad"], "venue": "Proceedings of the National Academy of Sciences of the USA,", "citeRegEx": "Donoho and Elad,? \\Q2003\\E", "shortCiteRegEx": "Donoho and Elad", "year": 2003}, {"title": "Look ma, no hands: Analyzing the monotonic feature abstraction for text classification", "author": ["D. Downey", "O. Etzioni"], "venue": "In Neural Information Processing Systems (NIPS),", "citeRegEx": "Downey and Etzioni,? \\Q2008\\E", "shortCiteRegEx": "Downey and Etzioni", "year": 2008}, {"title": "Learning hidden variable networks: The information bottleneck approach", "author": ["G. Elidan", "N. Friedman"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Elidan and Friedman,? \\Q2005\\E", "shortCiteRegEx": "Elidan and Friedman", "year": 2005}, {"title": "Training products of experts by minimizing contrastive divergence", "author": ["G.E. Hinton"], "venue": "Neural Computation,", "citeRegEx": "Hinton,? \\Q2002\\E", "shortCiteRegEx": "Hinton", "year": 2002}, {"title": "Knowledge-based weak supervision for information extraction of overlapping relations", "author": ["R. Hoffmann", "C. Zhang", "X. Ling", "L. Zettlemoyer", "D.S. Weld"], "venue": "In Annual Meeting of the Association for Computational Linguistics (ACL),", "citeRegEx": "Hoffmann et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Hoffmann et al\\.", "year": 2011}, {"title": "Comprehensive and reliable crowd assessment algorithms", "author": ["M. Joglekar", "H. Garcia-Molina", "A. Parameswaran"], "venue": "In International Conference on Data Engineering (ICDE),", "citeRegEx": "Joglekar et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Joglekar et al\\.", "year": 2015}, {"title": "An interior-point method for large-scale `1-regularized logistic regression", "author": ["K. Koh", "S.J. Kim", "S. Boyd"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Koh et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Koh et al\\.", "year": 2007}, {"title": "Sparse online learning via truncated gradient", "author": ["J. Langford", "L. Li", "T. Zhang"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Langford et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Langford et al\\.", "year": 2009}, {"title": "High-dimensional graphs and variable selection with the lasso", "author": ["N. Meinshausen", "P. B\u00fchlmann"], "venue": "The Annals of Statistics,", "citeRegEx": "Meinshausen and B\u00fchlmann,? \\Q2006\\E", "shortCiteRegEx": "Meinshausen and B\u00fchlmann", "year": 2006}, {"title": "Google\u2019s hand-fed AI now gives answers, not just search results, 2016", "author": ["C. Metz"], "venue": "Wired [Online; posted 29November-2016]", "citeRegEx": "Metz,? \\Q2016\\E", "shortCiteRegEx": "Metz", "year": 2016}, {"title": "Distant supervision for relation extraction without labeled data", "author": ["M. Mintz", "S. Bills", "R. Snow", "D. Jurafsky"], "venue": "In Annual Meeting of the Association for Computational Linguistics (ACL),", "citeRegEx": "Mintz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Mintz et al\\.", "year": 2009}, {"title": "Feature selection, l1 vs. l2 regularization, and rotational invariance", "author": ["A.Y. Ng"], "venue": "In International Conference on Machine Learning (ICML),", "citeRegEx": "Ng,? \\Q2004\\E", "shortCiteRegEx": "Ng", "year": 2004}, {"title": "Ranking and combining multiple predictors without labeled data", "author": ["F. Parisi", "F. Strino", "B. Nadler", "Y. Kluger"], "venue": "Proceedings of the National Academy of Sciences of the USA,", "citeRegEx": "Parisi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Parisi et al\\.", "year": 2014}, {"title": "Grafting: Fast, incremental feature selection by gradient descent in function space", "author": ["S. Perkins", "K. Lacker", "J. Theiler"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Perkins et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Perkins et al\\.", "year": 2003}, {"title": "Data programming: Creating large training sets, quickly", "author": ["A. Ratner", "C. De Sa", "S. Wu", "D. Selsam", "C. R\u00e9"], "venue": "In Neural Information Processing Systems (NIPS),", "citeRegEx": "Ratner et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Ratner et al\\.", "year": 2016}, {"title": "Highdimensional Ising model selection using `1-regularized logistic regression", "author": ["P. Ravikumar", "M.J. Wainwright", "J.D. Lafferty"], "venue": "The Annals of Statistics,", "citeRegEx": "Ravikumar et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Ravikumar et al\\.", "year": 2010}, {"title": "Modeling relations and their mentions without labeled text", "author": ["S. Riedel", "L. Yao", "A. McCallum"], "venue": "In European Conference on Machine Learning and Knowledge Discovery in Databases (ECML PKDD),", "citeRegEx": "Riedel et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Riedel et al\\.", "year": 2010}, {"title": "Feature-based models for improving the quality of noisy training data for relation extraction", "author": ["B. Roth", "D. Klakow"], "venue": "In Conference on Information and Knowledge Management (CIKM),", "citeRegEx": "Roth and Klakow,? \\Q2013\\E", "shortCiteRegEx": "Roth and Klakow", "year": 2013}, {"title": "Combining generative and discriminative model scores for distant supervision", "author": ["B. Roth", "D. Klakow"], "venue": "In Conference on Empirical Methods on Natural Language Processing (EMNLP),", "citeRegEx": "Roth and Klakow,? \\Q2013\\E", "shortCiteRegEx": "Roth and Klakow", "year": 2013}, {"title": "Incremental knowledge base construction using DeepDive", "author": ["J. Shin", "S. Wu", "F. Wang", "C. De Sa", "C. Zhang", "C. R\u00e9"], "venue": "Proceedings of the VLDB Endowment,", "citeRegEx": "Shin et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Shin et al\\.", "year": 2015}, {"title": "Reducing wrong labels in distant supervision for relation extraction", "author": ["S. Takamatsu", "I. Sato", "H. Nakagawa"], "venue": "In Annual Meeting of the Association for Computational Linguistics (ACL),", "citeRegEx": "Takamatsu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Takamatsu et al\\.", "year": 2012}, {"title": "Regression shrinkage and selection via the lasso", "author": ["R. Tibshirani"], "venue": "Journal of the Royal Statistical Society B,", "citeRegEx": "Tibshirani,? \\Q1996\\E", "shortCiteRegEx": "Tibshirani", "year": 1996}, {"title": "Just relax: Convex programming methods for identifying sparse signals in noise", "author": ["J. Tropp"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Tropp,? \\Q2006\\E", "shortCiteRegEx": "Tropp", "year": 2006}, {"title": "Sharp thresholds for high-dimensional and noisy sparsity recovery using `1-constrained quadratic programming (lasso)", "author": ["M.J. Wainwright"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Wainwright,? \\Q2009\\E", "shortCiteRegEx": "Wainwright", "year": 2009}, {"title": "DimmWitted: A study of mainmemory statistical analytics", "author": ["C. Zhang", "C. R\u00e9"], "venue": "Proceedings of the VLDB Endowment,", "citeRegEx": "Zhang and R\u00e9,? \\Q2014\\E", "shortCiteRegEx": "Zhang and R\u00e9", "year": 2014}, {"title": "On model selection consistency of lasso", "author": ["P. Zhao", "B. Yu"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Zhao and Yu,? \\Q2006\\E", "shortCiteRegEx": "Zhao and Yu", "year": 2006}, {"title": "Grafting-Light: Fast, incremental feature selection and structure learning of Markov random fields", "author": ["J. Zhu", "N. Lao", "E.P. Xing"], "venue": "In International Conference on Knowledge Discovery and Data Mining (KDD),", "citeRegEx": "Zhu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Zhu et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 16, "context": "Collecting these labels is often prohibitively expensive, especially when specialized domain expertise is required, and major technology companies are investing heavily in hand-curating labeled training data (Metz, 2016; Eadicicco, 2017).", "startOffset": 208, "endOffset": 237}, {"referenceID": 0, "context": "The structure of such generative models directly affects the inferred labels, and prior work assumes that the structure is user-specified (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013b; Ratner et al., 2016).", "startOffset": 138, "endOffset": 229}, {"referenceID": 27, "context": "The structure of such generative models directly affects the inferred labels, and prior work assumes that the structure is user-specified (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013b; Ratner et al., 2016).", "startOffset": 138, "endOffset": 229}, {"referenceID": 21, "context": "The structure of such generative models directly affects the inferred labels, and prior work assumes that the structure is user-specified (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013b; Ratner et al., 2016).", "startOffset": 138, "endOffset": 229}, {"referenceID": 21, "context": ") We ground our work in one framework, data programming (Ratner et al., 2016), that generalizes many approaches in the literature.", "startOffset": 56, "endOffset": 77}, {"referenceID": 10, "context": "a small step after each sample of each variable \u039bij or yi, similarly to contrastive divergence (Hinton, 2002).", "startOffset": 95, "endOffset": 109}, {"referenceID": 13, "context": "Other methods for `1-regularized regression like interior-point methods (Koh et al., 2007) usually require computing second-order information.", "startOffset": 72, "endOffset": 90}, {"referenceID": 14, "context": "To implement `1 regularization as part of SGD, we use an online truncated gradient method (Langford et al., 2009).", "startOffset": 90, "endOffset": 113}, {"referenceID": 22, "context": "For example, analysis of an analogous method for supervised Ising models (Ravikumar et al., 2010) relies on Lagrangian duality and a tight duality gap, which does not hold for our estimation problem.", "startOffset": 73, "endOffset": 97}, {"referenceID": 22, "context": "The rate of Theorem 1 rate is therefore not directly comparable to that of Ravikumar et al. (2010), which applies to Ising models with pairwise dependencies.", "startOffset": 75, "endOffset": 99}, {"referenceID": 22, "context": "Whereas the rate of Corollary 2 depends on the maximum number of dependencies that could affect a variable in the model class, the rate of Ravikumar et al. (2010) depends cubically on the maximum number of dependencies that actually affect any variable in the true model and only logarithmically in the maximum possible degree.", "startOffset": 139, "endOffset": 163}, {"referenceID": 22, "context": "This matches the observed behavior for fully supervised structure learning for Ising models (Ravikumar et al., 2010), which is also tighter than the best known theoretical guarantees.", "startOffset": 92, "endOffset": 116}, {"referenceID": 0, "context": "Extracting structured information from unstructured text by identifying mentioned entities and relations is a challenging task that is well studied in the context of weak supervision (Bunescu & Mooney, 2007; Alfonseca et al., 2012; Ratner et al., 2016).", "startOffset": 183, "endOffset": 252}, {"referenceID": 21, "context": "Extracting structured information from unstructured text by identifying mentioned entities and relations is a challenging task that is well studied in the context of weak supervision (Bunescu & Mooney, 2007; Alfonseca et al., 2012; Ratner et al., 2016).", "startOffset": 183, "endOffset": 252}, {"referenceID": 28, "context": "The lasso (Tibshirani, 1996), linear regression with `1 regularization, is a classic technique.", "startOffset": 10, "endOffset": 28}, {"referenceID": 29, "context": "`1 regularization has also been used as a prior for compressed sensing (e.g., Donoho & Elad, 2003; Tropp, 2006; Wainwright, 2009).", "startOffset": 71, "endOffset": 129}, {"referenceID": 30, "context": "`1 regularization has also been used as a prior for compressed sensing (e.g., Donoho & Elad, 2003; Tropp, 2006; Wainwright, 2009).", "startOffset": 71, "endOffset": 129}, {"referenceID": 27, "context": "The lasso (Tibshirani, 1996), linear regression with `1 regularization, is a classic technique. Zhao & Yu (2006) showed that the lasso is a consistent structure estimator.", "startOffset": 11, "endOffset": 113}, {"referenceID": 18, "context": "Ng (2004) showed that `1-regularized logistic regression has sample complexity logarithmic in the number of features.", "startOffset": 0, "endOffset": 10}, {"referenceID": 20, "context": "Other techniques for learning the structure of graphical models include grafting (Perkins et al., 2003; Zhu et al., 2010) and the information bottleneck approach for learning Bayesian networks with latent variables (Elidan & Friedman, 2005).", "startOffset": 81, "endOffset": 121}, {"referenceID": 33, "context": "Other techniques for learning the structure of graphical models include grafting (Perkins et al., 2003; Zhu et al., 2010) and the information bottleneck approach for learning Bayesian networks with latent variables (Elidan & Friedman, 2005).", "startOffset": 81, "endOffset": 121}, {"referenceID": 17, "context": "Treating labels from a single heuristic source as gold labels is called distant supervision (Craven & Kumlien, 1999; Mintz et al., 2009).", "startOffset": 92, "endOffset": 136}, {"referenceID": 23, "context": "Some methods use multi-instance learning to reduce the noise in a distant supervision source (Riedel et al., 2010; Hoffmann et al., 2011).", "startOffset": 93, "endOffset": 137}, {"referenceID": 11, "context": "Some methods use multi-instance learning to reduce the noise in a distant supervision source (Riedel et al., 2010; Hoffmann et al., 2011).", "startOffset": 93, "endOffset": 137}, {"referenceID": 26, "context": "Previous methods that support heuristics for weak supervision (e.g., Bunescu & Mooney, 2007; Shin et al., 2015) do not model the noise inherent in these sources.", "startOffset": 62, "endOffset": 111}, {"referenceID": 12, "context": "Many methods for crowdsourcing estimate the accuracy of workers without hand-labeled data (e.g., Dalvi et al., 2013; Joglekar et al., 2015; Zhang et al., 2016).", "startOffset": 90, "endOffset": 159}, {"referenceID": 14, "context": "Most similar to our proposed estimator, Ravikumar et al. (2010) propose a fully supervised pseudolikelihood estimator for Ising models.", "startOffset": 40, "endOffset": 64}, {"referenceID": 2, "context": "Also related is the work of Chandrasekaran et al. (2012), which considers learning the structure of Gaussian graphical models with latent variables.", "startOffset": 28, "endOffset": 57}, {"referenceID": 0, "context": "Others use hierarchical topic models to generate additional training data for weak supervision, but they do not support user-provided heuristics (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013a;b). Previous methods that support heuristics for weak supervision (e.g., Bunescu & Mooney, 2007; Shin et al., 2015) do not model the noise inherent in these sources. Also, Downey & Etzioni (2008) showed that PAC learning is possible without hand-labeled data if the features monotonically order data by class probability.", "startOffset": 146, "endOffset": 411}, {"referenceID": 0, "context": "Others use hierarchical topic models to generate additional training data for weak supervision, but they do not support user-provided heuristics (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth & Klakow, 2013a;b). Previous methods that support heuristics for weak supervision (e.g., Bunescu & Mooney, 2007; Shin et al., 2015) do not model the noise inherent in these sources. Also, Downey & Etzioni (2008) showed that PAC learning is possible without hand-labeled data if the features monotonically order data by class probability. Estimating the accuracy of multiple label sources without a gold standard is a classic problem (Dawid & Skene, 1979), and many proposed approaches are generalized in the data programming framework. Parisi et al. (2014) proposed a spectral approach to estimating the accuracy of members of classifier ensembles.", "startOffset": 146, "endOffset": 756}], "year": 2017, "abstractText": "Curating labeled training data has become the primary bottleneck in machine learning. Recent frameworks address this bottleneck with generative models to synthesize labels at scale from weak supervision sources. The generative model\u2019s dependency structure directly affects the quality of the estimated labels, but selecting a structure automatically without any labeled data is a distinct challenge. We propose a structure estimation method that maximizes the `1regularized marginal pseudolikelihood of the observed data. Our analysis shows that the amount of unlabeled data required to identify the true structure scales sublinearly in the number of possible dependencies for a broad class of models. Simulations show that our method is 100\u00d7 faster than a maximum likelihood approach and selects 1/4 as many extraneous dependencies. We also show that our method provides an average of 1.5 F1 points of improvement over existing, user-developed information extraction applications on real-world data such as PubMed journal abstracts.", "creator": "LaTeX with hyperref package"}}}