{"id": "1703.04274", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Mar-2017", "title": "Online Learning with Local Permutations and Delayed Feedback", "abstract": "We postpone an Online Learning a Local Permutations (OLLP) step, during one instead step-by-step entire need to narrower permute the \\ emph {.} known before loss appropriate compared and response understands. On than he, what redesigned oil situations where the reasons taken latter since gratifications ' update1 behaviors both not significant, or take beginning certain his, move control n't teachers the apologizing thanks, over minimise enormously coevolutionary final parameters. Also, same actual permutations, of can can showing not a drawn valences now pedantic and parameters debt. In this product, why consider was applicability raised this put still 2-dimensional forums study hand since interaction, 2002 much the input came to corrected not entered round $ t $ discovers well fewer failure $ \\ indi $. With such extended feedback, end choice determine indignation sail even well - the taking be $ O (\\ sqrt {\\ smc T} ) $. We consider this late while why return permute damage first given distance much just there $ M $ (three $ M \\ geq \\ acheron $ ), 's consequences makes those higher to $ O (\\ sqrt {T} (v + \\ sqrt {\\ epsilon ^ 3 / M} )) $, using end Mirror - Descent american algorithm all can without accepted for fact Euclidean and equal - Euclidean non-linear. We also fact is increased bound, negative they besides $ M & hn; \\ io / 29 $, there which precisely to ease this requires $ O (\\ sqrt {\\ nu T} ) $ contrary keeping later more one uncertainty further. Finally, understand provide some processes authenticating the exciting of must interface.", "histories": [["v1", "Mon, 13 Mar 2017 07:31:46 GMT  (470kb,D)", "http://arxiv.org/abs/1703.04274v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["ohad shamir", "liran szlak"], "accepted": true, "id": "1703.04274"}, "pdf": {"name": "1703.04274.pdf", "metadata": {"source": "CRF", "title": "Online Learning with Local Permutations and Delayed Feedback", "authors": ["Ohad Shamir", "Liran Szlak"], "emails": ["ohad.shamir@weizmann.ac.il", "liran.szlak@weizmann.ac.il"], "sections": [{"heading": null, "text": "regret can be improved to O( \u221a T (1 + \u221a \u03c42/M)), using a Mirror-Descent based algorithm which can be applied for both Euclidean and non-Euclidean geometries. We also prove a lower bound, showing that for M < \u03c4/3, it is impossible to improve the standard O( \u221a \u03c4T ) regret bound by more than constant factors. Finally, we provide some experiments validating the performance of our algorithm."}, {"heading": "1 Introduction", "text": "Online learning is traditionally posed as a repeated game where the learner has to provide predictions on an arbitrary sequence of loss functions, possibly even generated adversarially. Although it is often possible to devise algorithms with non-trivial regret guarantees, these have to cope with arbitrary loss sequences, which makes them conservative and in some cases inferior to algorithms not tailored to cope with worstcase behavior. Indeed, an emerging line of work considers how better online learning can be obtained on \u201ceasy\u201d data, which satisfies some additional assumptions. Some examples include losses which are sampled i.i.d. from some distribution, change slowly in time, have a consistently best-performing predictor across time, have some predictable structure, mix adversarial and stochastic losses, etc. (e.g. Sani et al. [2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]).\nIn this paper, we take a related but different direction: Rather than explicitly excluding highly adversarial loss sequences, we consider how slightly perturbing them can mitigate their worst-case behavior, and lead to improved performance. Conceptually, this resembles smoothed analysis Spielman and Teng [2004], in which one considers the worst-case performance of some algorithm, after performing some perturbation to their input. The idea is that if the worst-case instances are isolated and brittle, then a perturbation will lead to easier instances, and better reflect the attainable performance in practice.\nar X\niv :1\n70 3.\n04 27\n4v 1\n[ cs\n.L G\n] 1\n3 M\nar 2\nSpecifically, we propose a setting, in which the learner is allowed to slightly reorder the sequence of losses generated by an adversary: Assuming the adversary chooses losses h1, . . . , hT , and before any losses are revealed, the learner may choose a permutation \u03c3 on {1, . . . , T}, satisfying maxt |t \u2212 \u03c3(t)| \u2264 M for some parameter M , and then play a standard online learning game on losses h\u03c3(1), . . . , h\u03c3(T ). We denote this as the Online Learning with Local Permutations (OLLP) setting. Here, M controls the amount of power given to the learner: M = 0 means that no reordering is performed, and the setting is equivalent to standard adversarial online learning. At the other extreme, M = T means that the learner can reorder the losses arbitrarily. For example, the learner may choose to order the losses uniformly at random, making it a quasistochastic setting (the only difference compared to i.i.d. losses is that they are sampled without-replacement rather than with-replacement).\nWe argue that allowing the learner some flexibility in the order of responses is a natural assumption. For example, when the learner needs to provide rapid predictions on a high-frequency stream of examples, it is often immaterial if the predictions are not provided in the exact same order at which the examples arrived. Indeed, by buffering examples for a few rounds before being answered, one can simulate the local permutations discussed earlier.\nWe believe that this setting can be useful in various online learning problems, where it is natural to change a bit the order of the loss functions. In this paper, we focus on one well-known problem, namely online learning with delayed feedback. In this case, rather than being provided with the loss function immediately after prediction is made, the learner only receives the loss function after a certain number \u03c4 \u2265 1 of rounds. This naturally models situations where the feedback comes much more slowly than the required frequency of predictions: To give a concrete example, consider a web advertisement problem, where an algorithm picks an ad to display, and then receives a feedback from the user in the form of a click. It is likely that the algorithm will be required to choose ads for new users while still waiting for the feedback from the previous user.\nFor convex online learning with delayed feedback, in a standard adversarial setting, it is known that the attainable regret is on the order of O( \u221a \u03c4T ), and this is also the best possible in the worst case Weinberger and Ordentlich [2002], Mesterharm [2005], Langford et al. [2009], Joulani et al. [2013], Quanrud and Khashabi [2015]. On the other hand, in a stochastic setting where the losses are sampled i.i.d. from some distribution, Agarwal and Duchi [2011] show that the attainable regret is much better, on the order of O( \u221a T + \u03c4). This gap between the worst-case adversarial setting, and the milder i.i.d. setting, hints that this problem is a good fit for our OLLP framework. Thus, in this paper, we focus on online learning with feedback delayed up to \u03c4 rounds, in the OLLP framework where the learner is allowed to locally permute the loss functions (up to a distance of M ). First, we devise an algorithm, denoted as Delayed Permuted Mirror Descent, and prove that it achieves an expected regret bound of order O( \u221a T (\u03c42/M + 1)) assuming M \u2265 \u03c4 . As M increases compared to \u03c4 , this regret bound interpolates between the standard adversarial \u221a \u03c4T regret, and a milder \u221a T regret, typical of i.i.d. losses. As its name implies, the algorithm is based on the well-known online mirror descent (OMD) algorithm (see Hazan et al. [2016], Shalev-Shwartz et al. [2012]), and works in the same generality, involving both Euclidean and non-Euclidean geometries. The algorithm is based on dividing the entire sequence of functions into blocks of size M and performing a random permutation within each block. Then, two copies of OMD are ran on different parts of each block, with appropriate parameter settings. A careful analysis, mixing adversarial and stochastic elements, leads to the regret bound.\nIn addition, we provide a lower bound complementing our upper bound analysis, showing that when M is significantly smaller than \u03c4 (specifically, \u03c4/3), then even with local permutations, it is impossible to obtain a worse-case regret better than \u2126( \u221a \u03c4T ), matching (up to constants) the attainable regret in the\nstandard adversarial setting where no permutations are allowed. Finally, we provide some experiments validating the performance of our algorithm.\nThe rest of the paper is organized as follows: in section 2 we formally define the Online Learning with Local Permutation setting, section 3 describes the Delayed Permuted Mirror Descent algorithm and outlines its regret analysis, section 4 discusses a lower bound for the delayed setting with limited permutation power, section 5 shows experiments, and finally section 6 provides concluding remarks, discussion, and open questions. Appendix A contains most of the proofs."}, {"heading": "2 Setting and Notation", "text": "Convex Online Learning. Convex online learning is posed as a repeated game between a learner and an adversary (assumed to be oblivious in this paper). First, the adversary chooses T convex losses h1, . . . , hT which are functions from a convex set W to R. At each iteration t \u2208 {1, 2, . . . , T}, the learner makes a prediction wt, and suffers a loss of ht (wt). To simplify the presentation, we use the same notation \u2207ht(w) to denote either a gradient of ht at w (if the loss is differentiable) or a subgradient at w otherwise, and refer to it in both cases as a gradient. We assume that both w \u2208 W and the gradients of any function ht in any point w \u2208 W are bounded w.r.t. some norm: Given a norm \u2016 \u00b7 \u2016 with a dual norm \u2016 \u00b7 \u2016\u2217, we assume that the diameter of the spaceW is bounded by B2 and that \u2200w \u2208 W,\u2200h \u2208 {h1, h2, ..., hT } : \u2016\u2207h (w) \u2016\u2217 \u2264 G. The purpose of the learner is to minimize her (expected) regret, i.e.\nR(T ) = E [ T\u2211 t=1 ht (wt)\u2212 T\u2211 t=1 ht (w \u2217) ] where w\u2217 = argmin w\u2208W T\u2211 t=1 ht (w)\nwhere the expectation is with respect to the possible randomness of the algorithm. Learning with Local Permutations. In this paper, we introduce and study a variant of this standard setting, which gives the learner a bit more power, by allowing her to slightly modify the order in which the losses are processed, thus potentially avoiding highly adversarial but brittle loss constructions. We denote this setting as the Online Learning with Local Permutations (OLLP) setting. Formally, letting M be a permutation window parameter, the learner is allowed (at the beginning of the game, and before any losses are revealed) to permute h1, . . . , hT to h\u03c3\u22121(1), . . . , h\u03c3\u22121(T ), where \u03c3 is a permutation from the set Perm := {\u03c3 : \u2200t, |\u03c3 (t)\u2212 t| \u2264M}. After this permutation is performed, the learner is presented with the permuted sequence as in the standard online learning setting, with the same regret as before. To simplify notation, we let ft = h\u03c3\u22121(t), so the learner is presented with the loss sequence f1, . . . , fT , and the regret\nis the same as the standard regret, i.e. R(T ) = E [\u2211T t=1 ft(wt)\u2212 \u2211T t=1 ft(w \u2217) ] . Note that if M = 0 then we are in the fully adversarial setting (no permutation is allowed). At the other extreme, if M = T and \u03c3 is chosen uniformly at random, then we are in a stochastic setting, with a uniform distribution over the set of functions chosen by the adversary (note that this is close but differs a bit from a setting of i.i.d. losses). In between, as M varies, we get an interpolation between these two settings.\nLearning with Delayed Feedback. The OLLP setting can be useful in many applications, and can potentially lead to improved regret bounds for various tasks, compared to the standard adversarial online learning. In this paper, we focus on studying its applicability to the task of learning from delayed feedback.\nWhereas in standard online learning, the learner gets to observe the loss ft immediately at the end of iteration t, here we assume that at round t, she only gets to observe ft\u2212\u03c4 for some delay parameter \u03c4 < T (and if t < \u03c4 , no feedback is received). For simplicity, we focus on the case where \u03c4 is fixed, independent of t, although our results can be easily generalized (as discussed in subsection 3.3). We emphasize that this\nis distinct from another delayed feedback scenario sometimes studied in the literature (Agarwal and Duchi [2011], Langford et al. [2009]), where rather than receiving ft\u2212\u03c4 the learner only receives a (sub)gradient of ft\u2212\u03c4 at wt\u2212\u03c4 . This is a more difficult setting, which is relevant for instance when the delay is due to the time it takes to compute the gradient."}, {"heading": "3 Algorithm and Analysis", "text": "Our algorithmic approach builds on the well-established online mirror descent framework. Thus, we begin with a short reminder of the Online Mirror Descent algorithm (see e.g. Hazan et al. [2016] for more details). Readers who are familiar with the algorithm are invited to skip to Subsection 3.1.\nThe online mirror descent algorithm is a generalization of online gradient descent, which can handle non-Euclidean geometries. The general idea is the following: we start with some point wt \u2208 W , where W is our primal space. We then map this point to the dual space using a (striclty convex and continuously differentiable) mirror map \u03c8, i.e. \u2207\u03c8 (wt) \u2208 W\u2217, then perform the gradient update in the dual space, and finally map the resulting new point back to our primal spaceW again, i.e. we want to find a point wt+1 \u2208 W s.t. \u2207\u03c8 (wt+1) = \u2207\u03c8 (wt) \u2212 \u03b7 \u00b7 gt where gt denotes the gradient. Denoting by wt+ 1\n2 the point satisfying\n\u2207\u03c8(wt+ 1 2 ) = \u2207\u03c8 (wt) \u2212 \u03b7 \u00b7 gt, it can be shown that wt+ 1 2 = (\u2207\u03c8\u2217) (\u2207\u03c8 (wt)\u2212 \u03b7 \u00b7 gt), where \u03c8\u2217 is the dual function of \u03c8. This point, wt+ 1 2 , might lie outside our hypothesis classW , and thus we might need to project it back to our spaceW . We use the Bregman divergence associated to \u03c8 to do this:\nwt+1 = argmin w\u2208W 4\u03c8(w,wt+ 1 2 ),\nwhere the Bregman divergence \u2206\u03c8 is defined as\n4\u03c8 (x, y) = \u03c8 (x)\u2212 \u03c8 (y)\u2212 \u3008\u2207\u03c8(y), x\u2212 y\u3009.\nSpecific choices of the mirror map \u03c8 leads to specific instantiations of the algorithms for various geometries. Perhaps the simplest example is \u03c8 (x) = 12\u2016x\u2016 2 2, with associated Bregman divergence 4\u03c8 (x, y) = 1 2 \u00b7 \u2016x \u2212 y\u2016\n2. This leads us to the standard and well-known online gradient descent algorithm, where wt+1 is the Euclidean projection on the setW of wt \u2212 \u03b7 \u00b7 gt.\nAnother example is the negative entropy mirror map \u03c8 (x) = \u2211n\ni=1 xi \u00b7 log (xi), which is 1-strongly convex with respect to the 1-norm on the simplexW = { x \u2208 Rn+ : \u2211n i=1 xi = 1 } . In that case, the resulting\nalgorithm is the well-known multiplicative updates algorithm, wherewt+1,i = wt,i\u00b7exp(\u2212\u03b7gt,i)/ \u2211n\nj=1wt,i\u00b7 exp(\u2212\u03b7gt,j). Instead of the 1-norm on the simplex, one can also consider arbitrary p-norms, and take \u03c8(x) = 12 \u00b7 \u2016x\u2016 2 q , where q is the dual norm (satisfying 1/p+ 1/q = 1)."}, {"heading": "3.1 The Delayed Permuted Mirror Descent Algorithm", "text": "Before describing the algorithm, we note that we will focus here on the case where the permutation window parameter M is larger than the delay parameter \u03c4 . If M < \u03c4 , then our regret bound is generally no better than the O( \u221a \u03c4T ) obtainable by a standard algorithm without any permutations, and for M < \u03c4/3, this is actually tight as shown in Section 4. We now turn to present our algorithm, denoted as The Delayed Permuted Mirror Descent algorithm (see algorithm 1 below as well as figure 1 for a graphical illustration). First, the algorithm splits the time horizon T into M consecutive blocks, and performs a uniformly random permutation on the loss functions within each block. Then, it runs two online mirror descent algorithms in parallel, and uses the delayed gradients in\norder to update two separate predictors \u2013 wf and ws, where wf is used for prediction in the first \u03c4 rounds of each block, and ws is used for prediction in the remaining M \u2212 \u03c4 rounds (here, f stands for \u201cfirst\u201d and s stands for \u201csecond\u201d). The algorithm maintaining ws crucially relies on the fact that the gradient of any two functions in a block (at some point w) is equal, in expectation over the random permutation within each block. This allows us to avoid most of the cost incurred by delays within each block, since the expected gradient of a delayed function and the current function are equal. A complicating factor is that at the first \u03c4 rounds of each block, no losses from the current block has been revealed so far. To tackle this, we use another algorithm (maintaining wf ), specifically to deal with the losses at the beginning of each block. This algorithm does not benefit from the random permutation, and its regret scales the same as standard adversarial online learning with delayed feedback. However, as the block size M increases, the proportion of losses handled by wf decreases, and hence its influence on the overall regret diminishes.\nThe above refers to how the blocks are divided for purposes of prediction. For purposes of updating the predictor of each algorithm, we need to use the blocks a bit differently. Specifically, we let T1 and T2 be two sets of indices. T1 includes all indices from the first \u03c4 time points of every block, and is used to update wf . T2 includes the first M \u2212 \u03c4 indices of every block, and is used to update ws (see figure 1). Perhaps surprisingly, note that T1 and T2 are not disjoint, and their union does not cover all of {1, . . . , T}. The reason is that due to the random permutation in each block, the second algorithm only needs to update on some of the loss functions in each block, in order to obtain an expected regret bound on all the losses it predicts on.\nAlgorithm 1 Delayed Permuted Mirror Descent Input: M , \u03b7f , \u03b7s Init: wf1 = 0, w s 1 = 0, jf = js = 1\nDivide T to consecutive blocks of sizeM , and permute the losses uniformly at random within each block. Let f1, . . . , fT denote the resulting permuted losses. for t = 1..., T do\nif t \u2208 first \u03c4 rounds of the block then Predict using wfjf Receive a loss function from \u03c4 places back: ft\u2212M = fT1(jf\u2212\u03c4). If none exists (in the first \u03c4 iterations), take the 0 function. Compute: \u2207fT1(jf\u2212\u03c4) ( wfjf\u2212\u03c4\n) Update: wf\njf+ 1 2\n= (\u2207\u03c8\u2217) ( \u2207\u03c8 ( wfjf ) \u2212 \u03b7f\u2207fT1(jf\u2212\u03c4) ( wfjf\u2212\u03c4 )) Project: wjf+1 = argmin\nw\u2208W 4\u03c8\n( w,wf\njf+ 1 2 ) jf = jf + 1\nelse Predict using wsjs Receive a loss function from \u03c4 places back: ft\u2212\u03c4 = fT2(js) Compute: \u2207ft\u2212\u03c4 ( wsjs ) = \u2207fT2(js) ( wsjs\n) Update: ws\njs+ 1 2\n= (\u2207\u03c8\u2217) ( \u2207\u03c8 ( wsjs ) \u2212 \u03b7s \u00b7 \u2207fT2(js) ( wsjs )) Project: wjs+1 = argmin\nw\u2208W 4\u03c8\n( w,ws\njs+ 1 2 ) js = js + 1\nend if end for"}, {"heading": "3.2 Analysis", "text": "The regret analysis of the Delayed Permuted Mirror Descent algorithm is based on a separate analysis of each of the two mirror descent sub-algorithms, where in the first sub-algorithm the delay parameter \u03c4 enters multiplicatively, but doesn\u2019t play a significant role in the regret of the second sub-algorithm (which utilizes the stochastic nature of the permutations). Combining the regret bound of the two sub-algorithms, and using the fact that the portion of losses predicted by the second algorithm increases with M , leads to an overall regret bound improving in M .\nIn the proof, to analyze the effect of delay, we need a bound on the distance between any two consequent predictors wt, wt+1 generated by the sub-algorithm. This depends on the mirror map and Bregman divergence used for the update, and we currently do not have a bound holding in full generality. Instead, we let \u03a8(\u03b7f ,G) be some upper bound on \u2016wt+1 \u2212 wt\u2016, where the update is using step-size \u03b7f and gradients of norm \u2264 G. Using \u03a8(\u03b7f ,G) we prove a general bound for all mirror maps. In Lemmas 3 and 4 in Appendix A.1, we show that for two common mirror maps (corresponding to online gradient descent and multiplicative weights), \u03a8(\u03b7f ,G) \u2264 c \u00b7 \u03b7fG for some numerical constant c, leading to a regret bound of O( \u221a T (\u03c42/M + 1)). Also, we prove theorem 1 for 1-strongly convex mirror maps, although it can be generalized to any \u03bb-strongly convex mirror map by scaling.\nTheorem 1. Given a norm \u2016 \u00b7\u2016, suppose that we run the Delayed Permuted Mirror Descent algorithm using a mirror map \u03c8 which is 1-strongly convex w.r.t. \u2016 \u00b7 \u2016, over a domainW with diameter B2 w.r.t the bregman divergence of \u03c8: \u2200w, v \u2208 W : 4\u03c8(w, v) \u2264 B2, and such that the (sub)-gradient g of each loss function on any w \u2208 W satisfies \u2016g\u2016\u2217 \u2264 G (where \u2016 \u00b7 \u2016\u2217 is the dual norm of \u2016 \u00b7 \u2016). Then the expected regret, given a delay parameter \u03c4 and step sizes \u03b7f , \u03b7s satisfies:\nE [ T\u2211 t=1 ft (wt)\u2212 ft (w\u2217) ] \u2264 B 2 \u03b7f + \u03b7f \u00b7 T\u03c4 M \u00b7 G 2 2 + T\u03c42 M \u00b7G \u00b7\u03a8(\u03b7f ,G) + B2 \u03b7s + \u03b7s \u00b7 T \u00b7 (M \u2212 \u03c4) M \u00b7 G 2 2\nFurthermore, if \u03a8(\u03b7f ,G) \u2264 c \u00b7 \u03b7fG for some constant c, and \u03b7f = B\u00b7 \u221a M G\u00b7 \u221a T \u00b7\u03c4 \u00b7( 12+c\u00b7\u03c4) , \u03b7s = B\u00b7 \u221a 2M G\u00b7 \u221a T \u00b7(M\u2212\u03c4) , the regret is bounded by\nc\n\u221a T\u03c4\nM \u00b7BG\n\u221a 1\n2 + c \u00b7 \u03c4 +\n\u221a 2T (M \u2212 \u03c4)\nM \u00b7BG = O\n( \u221a T \u00b7 (\u221a \u03c42\nM + 1\n))\nWhen M = O(\u03c4), this bound is O( \u221a \u03c4T ). similar to the standard adversarial learning case. However, as M increases, the regret gradually improves to O( \u221a T + \u03c4), which is the regret attainable in a purely stochastic setting with i.i.d. losses. The full proof can be found in appendix A.1.1, and we sketch below the main ideas.\nFirst, using the definition of regret, we show that it is enough to upper-bound the regret of each of the two sub-algorithms separately. Then, by a standard convexity argument, we reduce this to bounding sums of terms of the form E[\u3008wft \u2212 w\u2217f ,\u2207ft(w f t )\u3009] for the first sub-algorithm, and E [\u3008wst \u2212 w\u2217s ,\u2207ft (wst )\u3009] for the second sub-algorithm (where w\u2217f and w \u2217 s are the best fixed points in hindsight for the losses predicted on by the first and second sub-algorithms, respectively, and where for simplicity we assume the losses are differentiable). In contrast, we can use the standard analysis of mirror descent, using delayed gradients, to get a bound for the somewhat different terms E[\u3008wft \u2212 w\u2217f ,\u2207ft\u2212\u03c4 (w f t\u2212\u03c4 )\u3009] for the first sub-algorithm, and E [\u3008wst \u2212 w\u2217s ,\u2207ft\u2212\u03c4 (wst )\u3009] for the second sub-algorithm. Thus, it remains to bridge between these terms. Starting with the second sub-algorithm, we note that since we performed a random permutation within each block, the expected value of all loss functions within a block (in expectation over the block, and evaluated at a fixed point) is equal. Moreover, at any time point, the predictor ws maintained by the second sub-algorithm does not depend on the delayed nor the current loss function. Therefore, conditioned on wst , and in expectation over the random permutation in the block, we have that\nE[\u2207ft(wst )] = E[ft\u2212\u03c4 (wst )]\nfrom which it can be shown that\nE [\u3008wst \u2212 w\u2217s ,\u2207ft(wst )\u3009] = E [\u3008wst \u2212 w\u2217s ,\u2207ft\u2212\u03c4 (wst )\u3009]\nThus, up to a negligible factor having to do with the first few rounds of the game, the second sub-algorithm\u2019s expected regret does not suffer from the delayed feedback.\nFor the first sub-algorithm, we perform an analysis which does not rely on the random permutation. Specifically, we first show that since we care just about the sum of the losses, it is sufficient to bound the difference between E[\u3008wft \u2212 w\u2217f ,\u2207ft(w f t )\u3009] and E[\u3008w f t+\u03c4 \u2212 w\u2217f ,\u2207ft(w f t )\u3009]. Using Cauchy-Shwartz, this difference can be upper bounded by \u2016wft \u2212w f t+\u03c4\u2016 \u00b7 \u2016\u2207ft(w f t )\u2016, which in turn is at most c \u00b7 \u03c4 \u00b7 \u03b7f \u00b7G2 using\nour assumptions on the gradients of the losses and the distance between consecutive predictors produced by the first sub-algorithm.\nOverall, we get two regret bounds, one for each sub-algorithm. The regret of the first sub-algorithm scales with \u03c4 , similar to the no-permutation setting, but the sub-algorithm handles only a small fraction of the iterations (the first \u03c4 in every block of size M ). In the rest of the iterations, where we use the second sub-algorithm, we get a bound that resembles more the stochastic case, without such dependence on \u03c4 . Combining the two, the result stated in Theorem 1 follows."}, {"heading": "3.3 Handling Variable Delay Size", "text": "So far, we discussed a setting where the feedback arrives with a fixed delay of size \u03c4 . However, in many situations the feedback might arrive with a variable delay size \u03c4t at any iteration t, which may raise a few issues. First, feedback might arrive in an asynchronous fashion, causing us to update our predictor using gradients from time points further in past after already using more recent gradients. This complicates the analysis of the algorithm. A second, algorithmic problem, is that we could also possibly receive multiple feedbacks simultaneously, or no feedback at all, in certain iterations, since the delay is of variable size. One simple solution is to use buffering and reduce the problem to a constant delay setting. Specifically, we assume that all delays are bounded by some maximal delay size \u03c4 . We would like to use one gradient to update our predictor at every iteration (this is mainly for ease of analysis, practically one could update the predictor with multiple loss functions in a single iteration). In order to achieve this, we can use a buffer to store loss functions that were received but have not been used to update the predictors yet. We defineGradf and Grads, two buffers that will contain gradients from time points in T1 or T2, correspondingly. Each buffer is of size \u03c4 . If we denote by Ft the set of function that have arrived in time t, we can simply store loss functions that have arrived asynchronously in the buffers defined above, sort them in ascending order, and take the delayed loss function from exactly \u03c4 iterations back in the update step. This loss function must be in the appropriate buffer since the maximal delay size is \u03c4 . From this moment on, the algorithm can proceed as usual and its analysis still applies."}, {"heading": "4 Lower Bound", "text": "In this section, we give a lower bound in the setting where M < \u03c43 with all feedback having delay of exactly \u03c4 . We will show that for this case, the regret bound cannot be improved by more than a constant factor over the bound of the adversarial online learning problem with a fixed delay of size \u03c4 , namely \u2126 (\u221a \u03c4T )\nfor a sequence of length T . We hypothesize that this regret bound also cannot be significantly improved for any M = O(\u03c4) (and not just \u03c4/3). However, proving this remains an open problem.\nTheorem 2. For every (possible randomized) algorithmA with a permutation window of sizeM \u2264 \u03c43 , there exists a choice of linear, 1-Lipschitz functions over [\u22121, 1] \u2282 R, such that the expected regret of A after T rounds (with respect to the algorithm\u2019s randomness), is\nE [ T\u2211 t=1 ft (wt)\u2212 T\u2211 t=1 ft (w \u2217) ] = \u2126 (\u221a \u03c4T ) where w\u2217 = argmin w\u2208W T\u2211 t=1 ft (w)\nFor completeness, we we also provide in appendix A.2 a proof that when M = 0 (i.e. no permutations allowed), then the worst-case regret is no better than \u2126( \u221a \u03c4T ). This is of course a special case of Theorem 2,\nbut applies to the standard adversarial online setting (without any local permutations), and the proof is simpler. The proof sketch for the setting where no permutation is allowed was already provided in Langford et al. [2009], and our contribution is in providing a full formal proof.\nThe proof in the case where M = 0 is based on linear losses of the form ft = \u03b1t \u00b7 wt over [\u22121,+1], where \u03b1t \u2208 {\u22121,+1}. Without permutations, it is possible to prove a \u2126( \u221a \u03c4T ) lower bound by dividing the T iterations into blocks of size \u03c4 , where the \u03b1 values of all losses at each block is the same and randomly chosen to equal either +1 or\u22121. Since the learner does not obtain any information about this value until the block is over, this reduces to adversarial online learning over T/\u03c4 rounds, where the regret at each round scales linearly with \u03c4 , and overall regret at least \u2126(\u03c4 \u221a T/\u03c4) = \u2126( \u221a \u03c4T ).\nIn the proof of theorem 2, we show that by using a similar construction, even with permutations, having a permutation window less than \u03c4/3 still means that the \u03b1 values would still be unknown until all loss functions of the block are processed, leading to the same lower bound up to constants.\nThe formal proof appears in the appendix, but can be sketched as follows: first, we divide the T iterations into blocks of size \u03c4/3. Loss functions within each block are identical, of the form ft = \u03b1t \u00b7 wt, and the value of \u03b1 per block is chosen uniformly at random from {\u22121,+1}, as before. Since here, the permutation window M is smaller than \u03c4/3, then even after permutation, the time difference between the first and last time we encounter an \u03b1 that originated from a single block is less than \u03c4 . This means that by the time we get any information on the \u03b1 in a given block, the algorithm already had to process all the losses in the block, which leads to the same difficulty as the no-permutation setting. Specifically, since the predictors chosen by the algorithm when handling the losses of the block do not depend on the \u03b1 value in that block, and that \u03b1 is chosen randomly, we get that the expected loss of the algorithm at any time point t equals 0. Thus, the cumulative loss across the entire loss sequence is also 0. In contrast, for w\u2217, the optimal predictor in hindsight over the entire sequence, we can prove an expected accumulated loss of \u2212\u2126( \u221a \u03c4T ) after T iterations, using Khintchine inequality and the fact that the \u03b1\u2019s were randomly chosen per block. This leads us to a lower bound of expected regret of order \u221a \u03c4T , for any algorithm with a local permutation window of size M < \u03c4/3."}, {"heading": "5 Experiments", "text": "We consider the adversarial setting described in section 4, where an adversary chooses a sequence of functions such that every \u03c4 functions are identical, creating blocks of size \u03c4 of identical loss functions, of the form ft(wt) = \u03b1t \u00b7 wt where \u03b1t is chosen randomly in {\u22121,+1} for each block. In all experiments we use T = 105 rounds, a delay parameter of \u03c4 = 200, set our step sizes according to the theoretical analysis, and report the mean regret value over 1000 repetitions of the experiments.\nIn our first experiment, we considered the behavior of our Delayed Permuted Mirror Descent algorithm, for window sizes M > \u03c4 , ranging from \u03c4 + 1 to T . In this experiment, we chose the \u03b1 values randomly, while ensuring a gap of 200 between the number of blocks with +1 values and the number of blocks with\u22121 values (this ensures that the optimal w\u2217 is a sufficiently strong competitor, since otherwise the setting is too \u201ceasy\u201d and the algorithm can attain negative regret in some situations). The results are shown in Figures 2 and 3, where the first figure presents the accumulated regret of our algorithm over time, whereas the second figure presents the overall regret after T rounds, as a function of the window size M .\nWhen applying our algorithm in this setting with different values of M > \u03c4 , ranging from M = \u03c4 + 1 and up to M = T , we get a regret that scales from the order of the adversarial bound to the order of the stochastic bound depending on the window size, as expected by our analysis. For all window sizes greater than 5 \u00b7 \u03c4 , we get a regret that is in the order of the stochastic bound - this is not surprising, since after\nthe permutation we get a sequence of functions that is very close to an i.i.d. sequence, in which case any algorithm can be shown to achieve O( \u221a T ) regret in expectation. Note that this performance is better than that predicted by our theoretical analysis, which implies an O( \u221a T ) behavior only when M \u2265 \u2126(\u03c42). It is an open and interesting question whether it means that our analysis can be improved, or whether there is a harder construction leading to a tighter lower bound.\nIn our second experiment, we demonstrate the brittleness of the lower bound construction for standard online learning with delayed feedback, focusing on theM < \u03c4 regime. Specifically, we create loss functions with blocks as before (where following the lower bound construction, the \u03b1 values in each block of size \u03c4 = 200 is chosen uniformly at random). Then, we perform a random permutation over consecutive windows of size M (ranging from M = 0 up to M = 910\u03c4 in intervals of 1 10\u03c4 ). Finally, we run standard Online\nGradient Descent with delayed gradients (and fixed step size 1/ \u221a T ), on the permuted losses. The results are presented in Figure 4. For window sizesM < \u03c42 we see that the regret is close to the adversarial bound, whereas as we increase the window size the regret decreases towards the stochastic bound. This experiment evidently shows that this hardness construction is indeed brittle, and easily breaks in the face of local permutations, even for window sizes M < \u03c4 ."}, {"heading": "6 Discussion", "text": "We presented the OLLP setting, where a learner can locally permute the sequence of examples from which she learns. This setting can potentially allow for improved learning in many problems, where the worst-case regret is based on highly adversarial yet brittle constructions. In this paper, we focused on the problem of learning from delayed feedback in the OLLP setting, and showed how it is possible to improve the regret\nby allowing local permutations. Also, we proved a lower bound in the situation where the permutation window is significantly smaller than the feedback delay, and showed that in this case, permutations cannot allow for a better regret bound than the standard adversarial setting. We also provided some experiments, demonstrating the power of the setting as well as the feasibility of the proposed algorithm. An interesting open question is what minimal permutation size allows non-trivial regret improvement, and whether our upper bound in Theorem 1 is tight. As suggested by our empirical experiments, it is possible that even small local permutations are enough to break highly adversarial sequences and improve performance in otherwise worst-case scenarios. Another interesting direction is to extend our results to a partial feedback (i.e. bandit) setting. Finally, it would be interesting to study other cases where local permutations allow us to interpolate between fully adversarial and more benign online learning scenarios."}, {"heading": "Acknowledgements", "text": "OS is supported in part by an FP7 Marie Curie CIG grant, the Intel ICRI-CI Institute, and Israel Science Foundation grant 425/13."}, {"heading": "A Proofs", "text": "A.1 Analysis Of The Delayed Permuted Mirror Descent Algorithm\nWe will use throughout the proofs the well known Pythagorean Theorem for Bregman divergences, and the \u2019projection\u2019 lemma that considers the projection step in the algorithm.\nLemma 1. Pythagorean Theorem for Bregman divergences Let v be the projection ofw onto a convex setW w.r.t Bregman divergence4\u03c8: v = argminu\u2208W4\u03c8 (u,w), then: 4\u03c8 (u,w) \u2265 4\u03c8 (u, v) +4\u03c8 (v, w)\nLemma 2. Projection Lemma LetW be a closed convex set and let v be the projection of w ontoW , namely, v = argmin\nx\u2208W \u2016x\u2212 w\u20162. Then, for every u \u2208 W , \u2016w \u2212 u\u20162 \u2212 \u2016v \u2212 u\u20162 \u2265 0\nThe following lemma gives a bound on the distance between two consequent predictions when using the Euclidean mirror map:\nLemma 3. Let g \u2208 Rn s.t. \u2016g\u20162 < G,W a convex set, and \u03b7 > 0 be fixed. Let w \u2208 W and w2 = w\u2212 \u03b7 \u00b7 g. Then, for w\u2032 = argmin\nu\u2208W \u2016w2 \u2212 u\u201622, we have that \u2016w \u2212 w\u2032\u2016 \u2264 \u03b7 \u00b7G\nProof. From the projection lemma: \u2016w2 \u2212 w\u201622 \u2265 \u2016w\u2032 \u2212 w\u201622 and so: \u2016w2 \u2212 w\u20162 \u2265 \u2016w\u2032 \u2212 w\u20162. From definition: \u2016w2 \u2212 w\u20162 = \u2016\u03b7 \u00b7 g\u20162 \u2264 \u03b7 \u00b7G. and so we get: \u2016w\u2032 \u2212 w\u20162 \u2264 \u2016w2 \u2212 w\u20162 \u2264 \u03b7 \u00b7G\nWe prove a modification of Lemma 2 given in Menache et al. [2014] in order to bound the distance between two consequent predictions when using the negative entropy mirror map:\nLemma 4. Let g \u2208 Rn s.t. \u2016g\u20161 \u2264 G for some G > 0 and let \u03b7 > 0 be fixed, with \u03b7 < 1\u221a2\u00b7G . For any distribution vector w in the n\u2212 simplex, if we define w\u2032 to be the new distribution vector\n\u2200i \u2208 {1, ..., n} , w\u2032i = wi \u00b7 exp (\u2212\u03b7 \u00b7 gi)\u2211n j=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj)\nThen \u2016w \u2212 w\u2032\u20161 \u2264 3\u03b7G\nProof. Since \u2016g\u2016\u221e < G and \u03b7 < 1\u221a2\u00b7G we get that \u2200i : |\u03b7 \u00b7 gi| < 1. We have that:\n\u2016w \u2212 w\u2032\u20161 = n\u2211 i=1 |wi \u2212 w\u2032i| = n\u2211 i=1 \u2223\u2223\u2223\u2223\u2223wi \u00b7 ( 1\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211n j=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) )\u2223\u2223\u2223\u2223\u2223 Since \u2016w\u20161 = 1, we can apply Holder\u2019s inequality, and upper bound the above by\nmax i \u2223\u2223\u2223\u2223\u22231\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211nj=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2223\u2223\u2223\u2223\u2223\nUsing the inequality 1\u2212 x \u2264 exp (\u2212x) \u2264 11+x for all |x| \u2264 1, we know that\n1\u2212 \u03b7 \u00b7 gi \u2264 exp (\u2212\u03b7 \u00b7 gi) \u2264 1\n1 + \u03b7 \u00b7 gi\nand since \u2212\u03b7G \u2264 \u03b7 \u00b7 gi \u2264 \u03b7G we have that\n1\u2212 \u03b7 \u00b7 gi \u2264 exp (\u2212\u03b7 \u00b7 gi) \u2264 1 1 + \u03b7 \u00b7 gi \u2264 1 1\u2212 \u03b7G\nand so we get:\n1\u2212 1 1+\u03b7gi 1 + \u03b7G \u2264 1\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211n j=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2264 1\u2212 1\u2212 \u03b7 \u00b7 gi1\n1\u2212\u03b7G\nUsing again the fact that \u2212\u03b7G \u2264 \u03b7 \u00b7 gi \u2264 \u03b7G, we have\n1\u2212 1\n1\u2212\u03b7G 1 + \u03b7G \u2264 1\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211n j=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2264 1\u2212 1\u2212 \u03b7G1 1\u2212\u03b7G\n=\u21d2 \u2212\u03b7 2G2 1\u2212 \u03b72G2 = 1\u2212 1 1\u2212 \u03b72G2 \u2264 1\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211n j=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2264 1\u2212 (1\u2212 \u03b7G)2 = 2\u03b7G+ \u03b72G2\nNow, since \u03b7G < 1, we get that:\n\u2212\u03b72G2 1\u2212 \u03b72G2 \u2264 1\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211n j=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2264 2\u03b7G+ \u03b7G = 3\u03b7G\nand so we can conclude that\nmax i \u2223\u2223\u2223\u2223\u22231\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211nj=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2223\u2223\u2223\u2223\u2223 \u2264 maxi (\u2223\u2223\u2223\u2223 \u2212\u03b72G21\u2212 \u03b72G2 \u2223\u2223\u2223\u2223 , |3\u03b7G|) \u2264 maxi ( \u03b7G 1\u2212 \u03b72G2 , 3\u03b7G )\nSince \u03b7 < 1\u221a 2G , we get (\u03b7 \u00b7G)2 < 12 . Thus we get:\nmax i \u2223\u2223\u2223\u2223\u22231\u2212 exp (\u2212\u03b7 \u00b7 gi)\u2211nj=1wj \u00b7 exp (\u2212\u03b7 \u00b7 gj) \u2223\u2223\u2223\u2223\u2223 \u2264 maxi (2\u03b7G, 3\u03b7G) \u2264 3\u03b7G\nwhich gives us our desired bound.\nWith the above two lemmas in hand, we bound the distance between consequent predictors by c\u03b7G, where c is a different constant in each mirror map: c = 1 for the euclidean case, and c = 3 for the negative entropy mirror map. Note that both mapping are 1-strongly convex with respect to their respective norms. For other mappings with a different strong convexity constant, one would need to scale the step sizes according to the strong convexity parameter in order to get the bound.\nA.1.1 Proof of Theorem 1\nWe provide an upper bound on the regret of the algorithm, by competing against the best fixed action in each one of the sets of iterations- the first \u03c4 iterations and the last M \u2212 \u03c4 iterations in each block. This is\nan upper bound on competing against the best fixed predictor in hindsight for the entire sequence. Formally, we bound:\nR(T ) = E [ T\u2211 t=1 ft (wt)\u2212 T\u2211 t=1 ft (w \u2217) ]\n\u2264 E  TM\u22121\u2211 i=0  M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 ft (wt)\u2212 ft ( w\u2217f ) + M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 ft (wt)\u2212 ft (w\u2217s)  where\nw\u2217f = argmin w\u2208W\nT M \u22121\u2211\ni=0 M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 ft (w) and w\u2217s = argmin w\u2208W T M \u22121\u2211 i=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 ft (w)\nwhere expectation is taken over the randomness of the algorithm. The diameter of the domainW is bounded by B2, and so4\u03c8 ( w\u2217f , w f 0 ) \u2264 B2 and4\u03c8 (w\u2217s , ws0) \u2264 B2. We start with a general derivation that will apply both for ws and for wf simultaneously. For the following derivation we use the notation wj , wj+1 omitting the f, s superscript, for denoting subsequent updates of the predictor vector, whether it is ws or wf .\nDenote by gj the gradient used to update wj , i.e., \u2207\u03c8 ( wj+ 1\n2\n) = \u2207\u03c8 (wj) \u2212 \u03b7 \u00b7 gj , and wj+1 =\nargmin w\u2208W\n4\u03c8 ( w,wj+ 1\n2\n) .\nLooking at the update step in the algorithm, we have that gj = 1\u03b7 \u00b7 ( \u2207\u03c8 (wj)\u2212\u2207\u03c8 ( wj+ 1\n2\n)) and thus:\n\u3008wj \u2212 w\u2217, gj\u3009 = 1 \u03b7 \u00b7 \u2329 wj \u2212 w\u2217, ( \u2207\u03c8 (wj)\u2212\u2207\u03c8 ( wj+ 1 2 ))\u232a = 1 \u03b7 \u00b7 ( 4\u03c8 (w\u2217, wj) +4\u03c8 ( wj , wj+ 1 2 ) \u22124\u03c8 ( w\u2217, wj+ 1 2\n)) We now use the Pythagorean Theorem to get:\n\u2264 1 \u03b7 \u00b7 ( 4\u03c8 (w\u2217, wj) +4\u03c8 ( wj , wj+ 1 2 ) \u22124\u03c8 (w\u2217, wj+1)\u22124\u03c8 ( wj+1, wj+ 1 2 )) When we sum terms for all updates of the predictor, wf or ws respectively, the terms 4\u03c8 (w\u2217, wj) \u2212 4\u03c8 (w\u2217, wj+1) will result in a telescopic sum, canceling all terms expect the first and last. Thus we now concentrate on bounding the term: 4\u03c8 ( wj , wj+ 1\n2\n) \u22124\u03c8 ( wj+1, wj+ 1\n2\n) .\n4\u03c8 ( wj , wj+ 1\n2\n) \u22124\u03c8 ( wj+1, wj+ 1\n2\n) = \u03c8 (wj)\u2212 \u03c8 (wj+1)\u2212 \u2329 wj \u2212 wj+1,\u2207\u03c8 ( wj+ 1\n2 )\u232a \u2264\n\u03c8 1-strong convex\n\u2329 wj \u2212 wj+1,\u2207\u03c8 (wj)\u2212\u2207\u03c8 ( wj+ 1\n2\n)\u232a \u2212 1\n2 \u00b7 \u2016wj \u2212 wj+1\u20162\n= \u3008wj \u2212 wj+1, \u03b7 \u00b7 gj\u3009 \u2212 1\n2 \u00b7 \u2016wj \u2212 wj+1\u20162\n\u2264 \u03b7 \u00b7G \u00b7 \u2016wj \u2212 wj+1\u2016 \u2212 1\n2 \u00b7 \u2016wj \u2212 wj+1\u20162\n\u2264 (\u03b7 \u00b7G) 2\n2\nwhere the last inequality stems from the fact that ( \u2016wj \u2212 wj+1\u2016 \u00b7 \u221a 1\u221a 2 \u2212 \u03b7\u00b7G\u221a 2 )2 \u2265 0 We now continue with the analysis referring to wf and ws separately. Summing over j = \u03c4 + 1 to( T M + 1 ) \u00b7 \u03c4 for wf (these are the TM \u03c4 iterations in which the first sub-algorithm is in use), and from j = 1 to TM \u00b7 (M \u2212 \u03c4) for w s (these are the TM (M \u2212 \u03c4) iterations in which the second sub-algorithm is in use) we get: For wf : ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u2329 wfj \u2212 w \u2217 f , gj \u232a\n= ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u2329 wfj \u2212 w \u2217 f ,\u2207fT1(j\u2212\u03c4) ( wfj\u2212\u03c4 )\u232a\n= ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 1 \u03b7 \u00b7 \u2329 wfj \u2212 w \u2217 f , ( \u2207\u03c8 ( wfj ) \u2212\u2207\u03c8 ( ws j+ 1 2 ))\u232a\n= ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 1 \u03b7 \u00b7 ( 4\u03c8 ( w\u2217f , w f j ) +4\u03c8 ( wfj , w f j+ 1 2 ) \u22124\u03c8 ( w\u2217f , w f j+ 1 2 )) \u2264 ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 1 \u03b7 \u00b7 ( 4\u03c8 ( w\u2217f , w f j ) +4\u03c8 ( wfj , w f j+ 1 2 ) \u22124\u03c8 ( w\u2217f , w f j+1 ) \u22124\u03c8 ( wfj+1, w f j+ 1 2 )) \u2264 1 \u03b7 \u00b7 ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 4\u03c8 ( w\u2217f , w f j ) \u22124\u03c8 ( w\u2217f , w f j+1 ) + 1 \u03b7 \u00b7 ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 4\u03c8 ( wfj , w f j+ 1 2 ) \u22124\u03c8 ( wfj+1, w f j+ 1 2 )\n= 1\n\u03b7 \u00b7 4\u03c8\n( w\u2217f , w f \u03c4+1 ) \u22124\u03c8 ( w\u2217f , w f\n( TM +1)\u00b7\u03c4\n) + 1 \u03b7 \u00b7 ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 4\u03c8 ( wfj , w f j+ 1 2 ) \u22124\u03c8 ( wfj+1, w f j+ 1 2 )\n\u2264 1 \u03b7f \u00b7 4\u03c8\n( w\u2217f , w f \u03c4+1 ) + 1\n\u03b7f \u00b7 T M \u00b7 \u03c4 \u00b7\n(\u03b7f \u00b7G)2\n2\n\u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7\n\u03b7f \u00b7G2\n2\nFor ws: T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s , gj \u232a\n= T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j) ( wsj )\u232a\n= T M \u00b7(M\u2212\u03c4)\u2211 j=1 1 \u03b7 \u00b7 \u2329 wsj \u2212 w\u2217s , ( \u2207\u03c8 ( wsj ) \u2212\u2207\u03c8 ( ws j+ 1 2 ))\u232a\n= T M \u00b7(M\u2212\u03c4)\u2211 j=1 1 \u03b7 \u00b7 ( 4\u03c8 ( w\u2217s , w s j ) +4\u03c8 ( wsj , w s j+ 1 2 ) \u22124\u03c8 ( w\u2217s , w s j+ 1 2 ))\n\u2264 T M \u00b7(M\u2212\u03c4)\u2211 j=1 1 \u03b7 \u00b7 ( 4\u03c8 ( w\u2217s , w s j ) +4\u03c8 ( wsj , w s j+ 1 2 ) \u22124\u03c8 ( w\u2217s , w s j+1 ) \u22124\u03c8 ( wsj+1, w s j+ 1 2 ))\n\u2264 1 \u03b7 \u00b7 T M \u00b7(M\u2212\u03c4)\u2211 j=1 4\u03c8 ( w\u2217s , w s j ) \u22124\u03c8 ( w\u2217s , w s j+1 ) + 1 \u03b7 \u00b7 4\u03c8 ( wsj , w s j+ 1 2 ) \u22124\u03c8 ( wsj+1, w s j+ 1 2 )\n= 1\n\u03b7 \u00b7 4\u03c8 (w\u2217s , ws1)\u22124\u03c8\n( w\u2217s , w\ns ( TM +1)\u00b7\u03c4\n) + 1\n\u03b7 \u00b7 T M \u00b7(M\u2212\u03c4)\u2211 j=1 4\u03c8 ( wsj , w s j+ 1 2 ) \u22124\u03c8 ( wsj+1, w s j+ 1 2 ) \u2264 1 \u03b7s \u00b7 4\u03c8 (w\u2217s , ws1) + 1 \u03b7s \u00b7 T M \u00b7 (M \u2212 \u03c4) \u00b7 (\u03b7s \u00b7G) 2 2\n\u2264 1 \u03b7s \u00b7B2 + T M \u00b7 (M \u2212 \u03c4) \u00b7 \u03b7s \u00b7G 2 2\nWe are after bounding the regret, which in itself is upper bounded by the sum of the regret accumulated by each sub-algorithm, considering iterations in the first \u03c4 and lastM\u2212\u03c4 per block separately, as mentioned above. Using the convexity of ft for all t, we bound these terms:\nE  TM\u22121\u2211 i=0 M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 ft (wt)\u2212 ft ( w\u2217f ) + T M \u22121\u2211 i=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 ft (wt)\u2212 ft (w\u2217s)  \u2264 E\n TM\u22121\u2211 i=0 M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 \u2329 wt \u2212 w\u2217f ,\u2207ft (wt) \u232a + T M \u22121\u2211 i=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 \u3008wt \u2212 w\u2217s ,\u2207ft (wt)\u3009  = E\n TM \u00b7\u03c4\u2211 j=1 \u2329 wfj \u2212 w \u2217 f ,\u2207fT1(j) ( wfj )\u232a + T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j)+\u03c4 ( wsj )\u232a\nIn the last equality of the above derivation, we simply replace notations, writing the gradient \u2207ft (wt) in notation of T1 and T2. T1 contains all time points in the first \u03c4 iterations of each block, and T2 contains all time points in the first M \u2212 \u03c4 iterations of each block.\nNote that what we have bounded so far is \u2211( T M +1)\u00b7\u03c4\nj=\u03c4+1 \u3008w f j\u2212w\u2217f ,\u2207fT1(j\u2212\u03c4)(w f j\u2212\u03c4 )\u3009 forwf and\n\u2211 T M \u00b7(M\u2212\u03c4)\nj=1\n\u2329 wsj \u2212 w\u2217s ,\u2207fT2(j) ( wsj )\u232a for ws, which are not the terms we need to bound in order to get a regret bound since they use the delayed gradient, and so we need to take a few more steps in order to be able to bound the regret.\nWe begin with wf :\nT M \u22121\u2211\ni=0 M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 \u2329 wt \u2212 w\u2217f ,\u2207ft (wt) \u232a = T M \u00b7\u03c4\u2211 j=1 \u2329 wfj \u2212 w \u2217 f ,\u2207fT1(j) ( wfj )\u232a\n=\nT M \u00b7\u03c4\u2211\nj=1\n\u2329 wfj+\u03c4 \u2212 w \u2217 f ,\u2207fT1(j) ( wfj )\u232a + \u2329 wfj \u2212 w f j+\u03c4 ,\u2207fT1(j) ( wfj )\u232a\n= ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u2329 wfj \u2212 w \u2217 f ,\u2207fT1(j\u2212\u03c4) ( wfj\u2212\u03c4 )\u232a + \u2329 wfj\u2212\u03c4 \u2212 w f j ,\u2207fT1(j\u2212\u03c4) ( wfj\u2212\u03c4 )\u232a\n\u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7\n\u03b7f \u00b7G2\n2 + ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u2329 wfj\u2212\u03c4 \u2212 w f j ,\u2207fT1(j\u2212\u03c4) ( wfj\u2212\u03c4 )\u232a\n\u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7\n\u03b7f \u00b7G2\n2 + ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u2016wfj\u2212\u03c4 \u2212 w f j \u2016 \u00b7 \u2016\u2207fT1(j\u2212\u03c4) ( wfj\u2212\u03c4 ) \u2016\n\u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7\n\u03b7f \u00b7G2\n2 + ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u03c4\u2211 i=1 \u2016wfj\u2212i \u2212 w f j\u2212i+1\u2016 \u00b7G\nThe last term in the above derivation, is the sum of differences between consecutive predictors. This difference, is determined by the mirror map in use, the step size \u03b7f , and the bound over the norm of the gradient used in the update stage of the algorithm, G. This is because every consecutive predictor is received by taking a gradient step from the previous predictor, in the dual space, with a step size \u03b7f , and projecting back to the primal space by use of the bregman divergence with the specific mirror map in use. We denote the bound on this difference by \u03a8(\u03b7f ,G), i.e., \u2200j, j + 1 : \u2016w f j \u2212 w f j+1\u2016 \u2264 \u03a8(\u03b7f ,G). Continuing our derivation, we have:\n\u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7\n\u03b7f \u00b7G2\n2 + ( TM +1)\u00b7\u03c4\u2211 j=\u03c4+1 \u03c4\u2211 i=1 \u03a8(\u03b7f ,G) \u00b7G\n\u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7\n\u03b7f \u00b7G2\n2 + T M \u00b7 \u03c42 \u00b7\u03a8(\u03b7f ,G) \u00b7G\nSince this upper bound does not depend on the permutation,and holds for every sequence, it holds also in expectation, i.e.\nE  TM\u22121\u2211 i=0 M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 ft (wt)\u2212 ft ( w\u2217f ) \u2264 1 \u03b7f \u00b7B2 + T M \u00b7 \u03c4 \u00b7 \u03b7f \u00b7G2 2 + T M \u00b7 \u03c42 \u00b7\u03a8(\u03b7f ,G) \u00b7G\nWe now turn to ws\nT M \u22121\u2211\ni=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 ft (wt)\u2212 ft (w\u2217s)\n\u2264\nT M \u22121\u2211\ni=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 \u3008wt \u2212 w\u2217s ,\u2207ft (wt)\u3009\n= T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j)+\u03c4 ( wsj )\u232a\n= T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j) ( wsj )\u232a + T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j)+\u03c4 ( wsj ) \u2212\u2207fT2(j) ( wsj )\u232a\n\u2264 1 \u03b7s \u00b7B2 + T M \u00b7 (M \u2212 \u03c4) \u00b7 \u03b7s \u00b7G 2 2 + T M \u00b7(M\u2212\u03c4)\u2211 j=1 \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j)+\u03c4 ( wsj ) \u2212\u2207fT2(j) ( wsj )\u232a\nWe now look at the expression \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j)+\u03c4 ( wsj ) \u2212\u2207fT2(j) ( wsj )\u232a for any j.\nWe first notice that for any j, wsj only depends on gradients of time points: T2 (1) , T2 (2) , ..., T2 (j \u2212 1). We also notice that given the functions received at these time points, i.e, given fT2(1), fT2(2), ..., fT2(j\u22121), wsj is no longer a random variable. We have that for all j, T2 (j) and T2 (j) + \u03c4 are both time points that are part of the same M -sized block. Suppose we have observed n functions of the block to which T2 (j) and T2 (j) + \u03c4 belong. All of these n functions are further in the past than both T2 (j) and T2 (j)+\u03c4 , because of the delay of size \u03c4 . We haveM\u2212n functions in the block that have not been observed yet, and since we performed a random permutation within each block, all remaining functions in the block have the same expected value. Formally, given wsj , the\nexpected value of the current and delayed gradient are the same, since we have: E[\u2207fT2(j)+\u03c4 ( wsj ) |wsj ] =\n1 M\u2212n \u00b7 \u2211M\u2212n i=1 \u2207fT2(j)+i ( wsj ) = E[\u2207fT2(j) ( wsj ) |wsj ]. As mentioned above, this stems from the random permutation we performed within the block - all M \u2212 n remaining functions (that were not observed yet in this block) have an equal (uniform) probability of being in each location, and thus the expected value of the gradients is equal. From the law of total expectation we have that\nE[\u2207fT2(j)+\u03c4 ( wsj ) ] = E[E[\u2207fT2(j)+\u03c4 ( wsj ) |wsj ]] = E[E[\u2207fT2(j) ( wsj ) |wsj ]] = E[\u2207fT2(j) ( wsj ) ]\nans thus E[\u2207fT2(j)+\u03c4 ( wsj ) \u2212\u2207fT2(j) ( wsj ) ] = 0.\nWe get that E[ \u2329 wsj \u2212 w\u2217s ,\u2207fT2(j)+\u03c4 ( wsj ) \u2212\u2207fT2(j) ( wsj )\u232a ] = 0 So we have that the upper bound on the expected regret of the time point in which we predict with ws\nis:\nE  TM\u22121\u2211 i=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 ft (wt)\u2212 ft (w\u2217s)  \u2264 1 \u03b7s \u00b7B2 + T M \u00b7 (M \u2212 \u03c4) \u00b7 \u03b7s \u00b7G 2 2\nSumming up the regret of the two sub-algorithms, we get:\nE [ T\u2211 t=1 ft (wt)\u2212 ft (w\u2217) ] \u2264 E  TM\u22121\u2211 i=0 M \u00b7i+\u03c4\u2211 t=M \u00b7i+1 ft (wt)\u2212 ft ( w\u2217f ) + T M \u22121\u2211 i=0 M \u00b7(i+1)\u2211 t=M \u00b7i+\u03c4+1 ft (wt)\u2212 ft (w\u2217s)  \u2264 B 2\n\u03b7f + \u03b7f \u00b7\nT\u03c4 M \u00b7 G\n2 2 + T\u03c42 M \u00b7G \u00b7\u03a8(\u03b7f ,G) + B2 \u03b7s + \u03b7s \u00b7 T \u00b7 (M \u2212 \u03c4) M \u00b7 G 2 2\nwhich gives us the bound. For \u03a8(\u03b7f ,G) \u2264 c \u00b7 \u03b7f \u00b7G where c is some constant, choosing the step sizes, \u03b7f , \u03b7s optimally:\n\u03b7f = B \u00b7 \u221a M G \u00b7 \u221a T \u00b7 \u03c4 \u00b7 ( 1 2 + c \u00b7 \u03c4 ) , \u03b7s = B \u00b7 \u221a2M G \u00b7 \u221a T \u00b7 (M \u2212 \u03c4)\nwe get the bound:\nE [ T\u2211 t=1 ft (wt)\u2212 ft (w\u2217) ]\n= \u221a T \u00b7 \u03c4 M \u00b7B \u00b7G \u00b7 \u221a 1 2 + c \u00b7 \u03c4 + \u221a T \u00b7 \u03c4 M \u00b7B \u00b7G \u00b7 1\u221a\n1 2 + c\u03c4\n+ \u221a T \u00b7 \u03c4 M \u00b7B \u00b7G \u00b7 c\u03c4\u221a\n1 2 + c\u03c4\n+\n\u221a 2 \u00b7 T \u00b7 (M \u2212 \u03c4)\nM \u00b7B \u00b7G \u2264 c \u00b7 \u221a T \u00b7 \u03c4 M \u00b7B \u00b7G \u00b7 \u221a 1 2 + c \u00b7 \u03c4 + \u221a 2 \u00b7 T \u00b7 (M \u2212 \u03c4) M \u00b7B \u00b7G\n= O (\u221a T \u00b7 \u03c42 M + \u221a T \u00b7 (M \u2212 \u03c4) M ) = O ( \u221a T \u00b7 (\u221a \u03c42 M + 1 ))\nA.2 Lower Bound For Algorithms With No Permutation Power\nTheorem 3. For every (possible randomized) algorithm A, there exists a choice of linear, 1-Lipschitz functions over [\u22121, 1] \u2282 R, with \u03c4 a fixed size delay of feedback, such that the expected regret of A after T rounds (with respect to the algorithm\u2019s randomness), is\nE [RA (T )] = E [ T\u2211 t=1 ft (wt)\u2212 T\u2211 t=1 ft (w \u2217) ] = \u2126 (\u221a \u03c4T ) , where w\u2217 = argmin w\u2208W T\u2211 t=1 ft (w)\nProof. First, we note that in order to show that for every algorithm, there exists a choice of loss functions by an oblivious adversary, such that the expected regret of the algorithm is bounded from below, it is enough to show that there exists a distribution over loss function sequences such that for any algorithm, the expected regret is bounded from below, where now expectation is taken over both the randomness of the algorithm and the randomness of the adversary. This is because if there exists such a distribution over loss function sequences, then for any algorithm, there exists some sequence of loss functions that can lead to a regret at least as high. To put it formally, if we mark E\nalg the expectation over the randomness of the algorithm, and\nE f1,...,fT the expectation over the randomness of the adversary, then:\n\u2203 a (randomized) adversary s.t. \u2200 algorithm A, E f1,...,fT E alg\n[RA (T )] > \u2126 (\u221a \u03c4T ) \u2192\n\u2200 algorithm A, \u2203f1, ..., fT s.t. E alg\n[RA (T )] > \u2126 (\u221a \u03c4T )\nThus, we prove the first statement above, that immediately gives us the second statement which gives the lower bound.\nWe consider the setting whereW = [\u22121, 1], and \u2200t \u2208 [1, T ] : ft (wt) = \u03b1t \u00b7 wt where \u03b1t \u2208 {1,\u22121}. We divide the T rounds to blocks of size \u03c4 . \u03b1t is chosen in the following way: if \u03b1t is the first \u03b1 in the block, it is randomly picked, i.e, Pr (\u03b1 = \u00b11) = 12 . Following this random selection, the next \u03c4 \u2212 1 \u03b1\u2019s of the block will be identical to the first \u03b1 in it, so that we now have a block of \u03c4 consecutive functions in which \u03b1 is identical. We wish to lower bound the expected regret of any algorithm in this setting.\nConsider a sequence of predictions by the algorithm w1, w2, ..., wT . Denote by \u03b1i,j the j\u2019th \u03b1 in the i\u2019th block, and similarly for wi,j , fi,j . We denote the entire sequence of \u03b1\u2019s by \u03b1\u0304(1\u2192T ), and the sequence of \u03b1\u2019s until time point j in block i by \u03b1\u0304(1\u2192i,j). Notice that wi,j is a function of the \u03b1\u2019s that arrive up until time point i \u00b7 \u03c4 + j \u2212 \u03c4 \u2212 1. We denote these \u03b1\u2019s as \u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121).\nThen the expected sum of losses is:\nE [ T\u2211 t=1 ft (wt) ] = E  T\u03c4\u2211 i=1 \u03c4\u2211 j=1 fi,j (wi,j)  =\nT \u03c4\u2211 i=1 \u03c4\u2211 j=1 E [fi,j (wi,j)]\n= T \u03c4\u2211 i=1 \u03c4\u2211 j=1 E\u03b1\u0304(1\u2192T ) [\u03b1i,j \u00b7 wi,j ]\n= T \u03c4\u2211 i=1 \u03c4\u2211 j=1 E\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) [ E\u03b1\u0304(i,j\u2212\u03c4\u2192T ) [ \u03b1i,j \u00b7 wi,j |\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) ]]\n= T \u03c4\u2211 i=1 \u03c4\u2211 j=1 E\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 E\u03b1\u0304(i,j\u2212\u03c4\u2192T ) [ \u03b1i,j |\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) ]]\n= T \u03c4\u2211 i=1 \u03c4\u2211 j=1 E\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 E\u03b1\u0304(i,1\u2192i,j) [ \u03b1i,j |\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) ]]\n= T \u03c4\u2211 i=1 \u03c4\u2211 j=1 E\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 E\u03b1i,1 [\u03b1i,1] ]\n= T \u03c4\u2211 i=1 \u03c4\u2211 j=1 E\u03b1\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 ( 1 2 \u00b7 1 + 1 2 \u00b7 (\u22121) )] = 0\nThe last equality is true because every first \u03b1 in any block has probability 12 to be either +1 or \u22121. We now continue to the expected sum of losses for the optimal choice ofw\u2217 = argminw\u2208W (\u2211T t=1 ft (w) ) .\nNote that in this setting, w\u2217 \u2208 {+1,\u22121} and is with opposite sign to the majority of \u03b1\u2019s in the sequence.\nE [ T\u2211 t=1 ft (w \u2217) ] = E  T\u03c4\u2211 i=1 \u03c4\u2211 j=1 fi,j (w \u2217)  = E  T\u03c4\u2211 i=1 \u03c4\u2211 j=1 \u03b1i,j \u00b7 w\u2217 \n= E  T\u03c4\u2211 i=1 \u03c4 \u00b7 \u03b1i,1 \u00b7 w\u2217  = \u03c4 \u00b7 E  T\u03c4\u2211 i=1 \u03b1i,1 \u00b7 w\u2217 \n= \u2212\u03c4 \u00b7 E | T\u03c4\u2211 i=1 \u03b1i,1|  Using Khintchine inequality we have that:\n\u2212\u03c4 \u00b7 E | T\u03c4\u2211 i=1 \u03b1i,1 \u00b7 1|  \u2264 \u2212\u03c4 \u00b7 C \u00b7 \u221a\u221a\u221a\u221a\u221a  T\u03c4\u2211 i=1 12  = \u2212\u03c4 \u00b7 C \u00b7\u221aT \u03c4 = \u2212\u2126 (\u221a \u03c4 \u00b7 T )\nwhere C is some constant. Thus we get that for a sequence of length T the expected regret is:\nE [ T\u2211 t=1 ft (wt) ] \u2212 E [ T\u2211 t=1 ft (w \u2217) ] = \u2126 (\u221a \u03c4 \u00b7 T )\nA.3 Proof of Theorem 2\nProof. First, we note that to show that for every algorithm, there exists a choice of loss functions by an oblivious adversary, such that the expected regret of the algorithm is bounded from below, it is enough to show that there exists a distribution over loss function sequences such that for any algorithm, the expected regret is bounded from below, where now expectation is taken over both the randomness of the algorithm and the randomness of the adversary. This is because if there exists such a distribution over loss function sequences, then for any algorithm, there exists some sequence of loss functions that can lead to a regret at least as high. To put it formally, if we mark E\nalg the expectation over the randomness of the algorithm, and\nE f1,...,fT the expectation over the randomness of the adversary, then:\n\u2203 a (randomized) adversary s.t. \u2200 algorithm A, E f1,...,fT E alg\n[RA (T )] > \u2126 (\u221a \u03c4T ) \u2192\n\u2200 algorithm A, \u2203f1, ..., fT s.t. E alg\n[RA (T )] > \u2126 (\u221a \u03c4T )\nThus, we prove the first statement above, that immediately gives us the second statement which is indeed our lower bound.\nWe consider the setting whereW = [\u22121, 1], and \u2200t \u2208 [1, T ] : ft (wt) = \u03b1t \u00b7 wt where \u03b1t \u2208 {1,\u22121}. We start by constructing our sequence of \u03b1\u2019s. We divide the T iterations to blocks of size \u03c43 . In each block,\nall \u03b1\u2019s are identical, and are chosen to be +1 or \u22121 w.p. 12 . This choice gives us blocks of \u03c4 3 consecutive functions in which \u03b1 is identical within each block. Let M be a permutation window of size smaller than \u03c43 . We notice first that since M < \u03c43 and the sequence of \u03b1\u2019s is organized in blocks of size \u03c4 3 , then even after permutation, the time difference between the first and last time we encounter an \u03b1 is \u2264 \u03c4 , which means we will not get the feedback from the first time we encountered this \u03b1 before encountering the next one, and we will not be able to use it for correctly predicting \u03b1\u2019s of this (original) block that arrive later. This is the main idea that stands in the basis of this lower bound.\nFormally, consider a sequence of w1, w2, ..., wT chosen by the algorithm. Denote by \u03b1i,j the j\u2019th \u03b1 in the i\u2019th block, and similarly for wi,j , fi,j . We denote the entire sequence of \u03b1\u2019s by \u03b1\u0304(1\u2192T ), and the sequence of \u03b1\u2019s until time point j in block i by \u03b1\u0304(1\u2192i,j). For simplicity we will denote \u03b2t as the \u03b1 that was presented at time t, after permutation, i.e. \u03b2t := \u03b1\u03c3\u22121(()t). Notice that wi,j is a function of the \u03b2\u2019s that arrive up until time point i \u00b7 ( \u03c4 3 ) + j \u2212 \u03c4 \u2212 1. We denote these \u03b2\u2019s as \u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121). I.e wi,j = g ( \u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) ) where g is some function. Going back to our main idea of the construction, we can put it in this new terminology- since the delay is \u03c4 and the permutation window is M < \u03c43 , for any i, j, the first time we encountered \u03b1\u03c3\u22121(i,j) is less than \u03c4 iterations ago, and thus, \u03b2i,j is independent of \u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121), while wi,j is a function of it: wi,j = g ( \u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) ) .\nWith this in hand, we look at the sum of losses of the predictions of the algorithm, w1, w2, ..., wT :\nE [ T\u2211 t=1 ft (wt) ] = E T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 fi,j (wi,j)  =\nT/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 E [fi,j (wi,j)]\n= T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 E\u03b2\u0304(1\u2192T ) [\u03b2i,j \u00b7 wi,j ]\n= T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 E\u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) [ E\u03b2\u0304(i,j\u2212\u03c4\u2192T ) [ \u03b2i,j \u00b7 wi,j |\u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) ]]\n= T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 E\u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 E\u03b2\u0304(i,j\u2212\u03c4\u2192T ) [ \u03b2i,j |\u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) ]]\n= T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 E\u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 E\u03b2\u0304(i,j\u2212\u03c4\u2192T ) [ \u03b1\u03c3\u22121(i,j) ]]\n= T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 E\u03b2\u0304(1\u2192i,j\u2212\u03c4\u22121) [ wi,j \u00b7 ( 1 2 \u00b7 1 + 1 2 \u00b7 (\u22121) )] = 0\nwhere the last equality stems from the fact that \u03b2i,j = \u03b1\u03c3\u22121(i,j) is equal to the expected value of the first time we encountered the \u03b1 that corresponds to \u03b1\u03c3\u22121(i,j), i.e, the first \u03b1 that came from the same block of \u03b1\u03c3\u22121(i,j). This expectation is 0 since we choose \u03b1 = 1 or \u03b1 = \u22121 with probability 12 for each block.\nWe now continue to the expected sum of losses for the optimal choice ofw\u2217 = argminw\u2208W (\u2211T t=1 ft (w) ) .\nNote that after permutation, the expected sum of losses of the optimalw remains the same since it is best predictor over the entire sequence, and so for simplicity we look at the sequence of \u03b1\u2019s as it is chosen initially. Also, in this setting, w\u2217 \u2208 {+1,\u22121} and is with opposite sign to the majority of \u03b1\u2019s in the sequence.\nE [ T\u2211 t=1 ft (w \u2217) ] = E T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 fi,j (w \u2217)  = E T/\u03c43\u2211 i=1 \u03c4 3\u2211 j=1 \u03b1i,j \u00b7 w\u2217 \n= E T/\u03c43\u2211 i=1 \u03c4 3 \u00b7 \u03b1i,1 \u00b7 w\u2217  = \u03c4 3 \u00b7 E T/\u03c43\u2211 i=1 \u03b1i,1 \u00b7 w\u2217 \n= \u2212\u03c4 3 \u00b7 E | T/\u03c43\u2211 i=1 \u03b1i,1|  Using Khintchine inequality we have that:\n\u2212\u03c4 3 \u00b7 E | T/\u03c43\u2211 i=1 \u03b1i,1 \u00b7 1|  \u2264 \u2212\u03c4 3 \u00b7 C \u00b7 \u221a\u221a\u221a\u221a\u221a T/\u03c43\u2211 i=1 12  = \u2212\u03c4 3 \u00b7 C \u00b7 \u221a T \u03c4 3\n= \u2212\u2126 (\u221a \u03c4 3 \u00b7 T ) = \u2212\u2126 (\u221a \u03c4 \u00b7 T )\nwhere C is some constant. Thus we get that overall expected regret for any algorithm with permutation power M < \u03c43 is:\nE [ T\u2211 t=1 ft (wt) ] \u2212 E [ T\u2211 t=1 ft (w \u2217) ] = \u2126 (\u221a \u03c4 \u00b7 T ) as in the adversarial case."}], "references": [{"title": "Distributed delayed stochastic optimization", "author": ["Alekh Agarwal", "John C Duchi"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Agarwal and Duchi.,? \\Q2011\\E", "shortCiteRegEx": "Agarwal and Duchi.", "year": 2011}, {"title": "The best of both worlds: Stochastic and adversarial bandits", "author": ["S\u00e9bastien Bubeck", "Aleksandrs Slivkins"], "venue": "In COLT,", "citeRegEx": "Bubeck and Slivkins.,? \\Q2012\\E", "shortCiteRegEx": "Bubeck and Slivkins.", "year": 2012}, {"title": "Online optimization with gradual variations", "author": ["Chao-Kai Chiang", "Tianbao Yang", "Chia-Jung Lee", "Mehrdad Mahdavi", "Chi-Jen Lu", "Rong Jin", "Shenghuo Zhu"], "venue": "In COLT,", "citeRegEx": "Chiang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Chiang et al\\.", "year": 2012}, {"title": "Extracting certainty from uncertainty: Regret bounded by variation in costs", "author": ["Elad Hazan", "Satyen Kale"], "venue": "Machine learning,", "citeRegEx": "Hazan and Kale.,? \\Q2010\\E", "shortCiteRegEx": "Hazan and Kale.", "year": 2010}, {"title": "Better algorithms for benign bandits", "author": ["Elad Hazan", "Satyen Kale"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Hazan and Kale.,? \\Q2011\\E", "shortCiteRegEx": "Hazan and Kale.", "year": 2011}, {"title": "Multi-armed bandits: Competing with optimal sequences", "author": ["Zohar S Karnin", "Oren Anava"], "venue": "In NIPS,", "citeRegEx": "Karnin and Anava.,? \\Q2016\\E", "shortCiteRegEx": "Karnin and Anava.", "year": 2016}, {"title": "Slow learners are fast", "author": ["John Langford", "Alexander Smola", "Martin Zinkevich"], "venue": "arXiv preprint arXiv:0911.0491,", "citeRegEx": "Langford et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Langford et al\\.", "year": 2009}, {"title": "On-demand, spot, or both: Dynamic resource allocation for executing batch jobs in the cloud", "author": ["Ishai Menache", "Ohad Shamir", "Navendu Jain"], "venue": "In 11th International Conference on Autonomic Computing (ICAC", "citeRegEx": "Menache et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Menache et al\\.", "year": 2014}, {"title": "On-line learning with delayed label feedback", "author": ["Chris Mesterharm"], "venue": "In International Conference on Algorithmic Learning Theory,", "citeRegEx": "Mesterharm.,? \\Q2005\\E", "shortCiteRegEx": "Mesterharm.", "year": 2005}, {"title": "Online learning with adversarial delays", "author": ["Kent Quanrud", "Daniel Khashabi"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Quanrud and Khashabi.,? \\Q2015\\E", "shortCiteRegEx": "Quanrud and Khashabi.", "year": 2015}, {"title": "Online learning with predictable sequences", "author": ["Alexander Rakhlin", "Karthik Sridharan"], "venue": "In COLT, pages 993\u20131019,", "citeRegEx": "Rakhlin and Sridharan.,? \\Q2013\\E", "shortCiteRegEx": "Rakhlin and Sridharan.", "year": 2013}, {"title": "Exploiting easy data in online optimization", "author": ["Amir Sani", "Gergely Neu", "Alessandro Lazaric"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Sani et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sani et al\\.", "year": 2014}, {"title": "One practical algorithm for both stochastic and adversarial bandits", "author": ["Yevgeny Seldin", "Aleksandrs Slivkins"], "venue": "In Proceedings of the 31st International Conference on Machine Learning", "citeRegEx": "Seldin and Slivkins.,? \\Q2014\\E", "shortCiteRegEx": "Seldin and Slivkins.", "year": 2014}, {"title": "Smoothed analysis of algorithms: Why the simplex algorithm usually takes polynomial time", "author": ["Daniel A Spielman", "Shang-Hua Teng"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Spielman and Teng.,? \\Q2004\\E", "shortCiteRegEx": "Spielman and Teng.", "year": 2004}, {"title": "Adaptivity and optimism: An improved exponentiated gradient algorithm", "author": ["Jacob Steinhardt", "Percy Liang"], "venue": "In ICML,", "citeRegEx": "Steinhardt and Liang.,? \\Q2014\\E", "shortCiteRegEx": "Steinhardt and Liang.", "year": 2014}, {"title": "On delayed prediction of individual sequences", "author": ["Marcelo J Weinberger", "Erik Ordentlich"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Weinberger and Ordentlich.,? \\Q2002\\E", "shortCiteRegEx": "Weinberger and Ordentlich.", "year": 2002}], "referenceMentions": [{"referenceID": 5, "context": "Sani et al. [2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al.", "startOffset": 0, "endOffset": 19}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al.", "startOffset": 8, "endOffset": 32}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al.", "startOffset": 33, "endOffset": 60}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al.", "startOffset": 33, "endOffset": 88}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al.", "startOffset": 33, "endOffset": 111}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]).", "startOffset": 33, "endOffset": 133}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]).", "startOffset": 33, "endOffset": 162}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]).", "startOffset": 33, "endOffset": 185}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]).", "startOffset": 33, "endOffset": 215}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]).", "startOffset": 33, "endOffset": 243}, {"referenceID": 1, "context": "[2014], Karnin and Anava [2016], Bubeck and Slivkins [2012], Seldin and Slivkins [2014], Hazan and Kale [2010], Chiang et al. [2012], Steinhardt and Liang [2014], Hazan and Kale [2011], Rakhlin and Sridharan [2013], Seldin and Slivkins [2014]). In this paper, we take a related but different direction: Rather than explicitly excluding highly adversarial loss sequences, we consider how slightly perturbing them can mitigate their worst-case behavior, and lead to improved performance. Conceptually, this resembles smoothed analysis Spielman and Teng [2004], in which one considers the worst-case performance of some algorithm, after performing some perturbation to their input.", "startOffset": 33, "endOffset": 558}, {"referenceID": 11, "context": "For convex online learning with delayed feedback, in a standard adversarial setting, it is known that the attainable regret is on the order of O( \u221a \u03c4T ), and this is also the best possible in the worst case Weinberger and Ordentlich [2002], Mesterharm [2005], Langford et al.", "startOffset": 207, "endOffset": 240}, {"referenceID": 6, "context": "For convex online learning with delayed feedback, in a standard adversarial setting, it is known that the attainable regret is on the order of O( \u221a \u03c4T ), and this is also the best possible in the worst case Weinberger and Ordentlich [2002], Mesterharm [2005], Langford et al.", "startOffset": 241, "endOffset": 259}, {"referenceID": 5, "context": "For convex online learning with delayed feedback, in a standard adversarial setting, it is known that the attainable regret is on the order of O( \u221a \u03c4T ), and this is also the best possible in the worst case Weinberger and Ordentlich [2002], Mesterharm [2005], Langford et al. [2009], Joulani et al.", "startOffset": 260, "endOffset": 283}, {"referenceID": 5, "context": "For convex online learning with delayed feedback, in a standard adversarial setting, it is known that the attainable regret is on the order of O( \u221a \u03c4T ), and this is also the best possible in the worst case Weinberger and Ordentlich [2002], Mesterharm [2005], Langford et al. [2009], Joulani et al. [2013], Quanrud and Khashabi [2015].", "startOffset": 260, "endOffset": 306}, {"referenceID": 5, "context": "For convex online learning with delayed feedback, in a standard adversarial setting, it is known that the attainable regret is on the order of O( \u221a \u03c4T ), and this is also the best possible in the worst case Weinberger and Ordentlich [2002], Mesterharm [2005], Langford et al. [2009], Joulani et al. [2013], Quanrud and Khashabi [2015]. On the other hand, in a stochastic setting where the losses are sampled i.", "startOffset": 260, "endOffset": 335}, {"referenceID": 0, "context": "from some distribution, Agarwal and Duchi [2011] show that the attainable regret is much better, on the order of O( \u221a T + \u03c4).", "startOffset": 24, "endOffset": 49}, {"referenceID": 0, "context": "from some distribution, Agarwal and Duchi [2011] show that the attainable regret is much better, on the order of O( \u221a T + \u03c4). This gap between the worst-case adversarial setting, and the milder i.i.d. setting, hints that this problem is a good fit for our OLLP framework. Thus, in this paper, we focus on online learning with feedback delayed up to \u03c4 rounds, in the OLLP framework where the learner is allowed to locally permute the loss functions (up to a distance of M ). First, we devise an algorithm, denoted as Delayed Permuted Mirror Descent, and prove that it achieves an expected regret bound of order O( \u221a T (\u03c42/M + 1)) assuming M \u2265 \u03c4 . As M increases compared to \u03c4 , this regret bound interpolates between the standard adversarial \u221a \u03c4T regret, and a milder \u221a T regret, typical of i.i.d. losses. As its name implies, the algorithm is based on the well-known online mirror descent (OMD) algorithm (see Hazan et al. [2016], Shalev-Shwartz et al.", "startOffset": 24, "endOffset": 930}, {"referenceID": 0, "context": "from some distribution, Agarwal and Duchi [2011] show that the attainable regret is much better, on the order of O( \u221a T + \u03c4). This gap between the worst-case adversarial setting, and the milder i.i.d. setting, hints that this problem is a good fit for our OLLP framework. Thus, in this paper, we focus on online learning with feedback delayed up to \u03c4 rounds, in the OLLP framework where the learner is allowed to locally permute the loss functions (up to a distance of M ). First, we devise an algorithm, denoted as Delayed Permuted Mirror Descent, and prove that it achieves an expected regret bound of order O( \u221a T (\u03c42/M + 1)) assuming M \u2265 \u03c4 . As M increases compared to \u03c4 , this regret bound interpolates between the standard adversarial \u221a \u03c4T regret, and a milder \u221a T regret, typical of i.i.d. losses. As its name implies, the algorithm is based on the well-known online mirror descent (OMD) algorithm (see Hazan et al. [2016], Shalev-Shwartz et al. [2012]), and works in the same generality, involving both Euclidean and non-Euclidean geometries.", "startOffset": 24, "endOffset": 960}, {"referenceID": 0, "context": "is distinct from another delayed feedback scenario sometimes studied in the literature (Agarwal and Duchi [2011], Langford et al.", "startOffset": 88, "endOffset": 113}, {"referenceID": 0, "context": "is distinct from another delayed feedback scenario sometimes studied in the literature (Agarwal and Duchi [2011], Langford et al. [2009]), where rather than receiving ft\u2212\u03c4 the learner only receives a (sub)gradient of ft\u2212\u03c4 at wt\u2212\u03c4 .", "startOffset": 88, "endOffset": 137}, {"referenceID": 6, "context": "The proof sketch for the setting where no permutation is allowed was already provided in Langford et al. [2009], and our contribution is in providing a full formal proof.", "startOffset": 89, "endOffset": 112}, {"referenceID": 7, "context": "and so we get: \u2016w\u2032 \u2212 w\u20162 \u2264 \u2016w2 \u2212 w\u20162 \u2264 \u03b7 \u00b7G We prove a modification of Lemma 2 given in Menache et al. [2014] in order to bound the distance between two consequent predictions when using the negative entropy mirror map: Lemma 4.", "startOffset": 88, "endOffset": 110}], "year": 2017, "abstractText": "We propose an Online Learning with Local Permutations (OLLP) setting, in which the learner is allowed to slightly permute the order of the loss functions generated by an adversary. On one hand, this models natural situations where the exact order of the learner\u2019s responses is not crucial, and on the other hand, might allow better learning and regret performance, by mitigating highly adversarial loss sequences. Also, with random permutations, this can be seen as a setting interpolating between adversarial and stochastic losses. In this paper, we consider the applicability of this setting to convex online learning with delayed feedback, in which the feedback on the prediction made in round t arrives with some delay \u03c4 . With such delayed feedback, the best possible regret bound is well-known to be O( \u221a \u03c4T ). We prove that by being able to permute losses by a distance of at most M (for M \u2265 \u03c4 ), the regret can be improved to O( \u221a T (1 + \u221a \u03c42/M)), using a Mirror-Descent based algorithm which can be applied for both Euclidean and non-Euclidean geometries. We also prove a lower bound, showing that for M < \u03c4/3, it is impossible to improve the standard O( \u221a \u03c4T ) regret bound by more than constant factors. Finally, we provide some experiments validating the performance of our algorithm.", "creator": "LaTeX with hyperref package"}}}