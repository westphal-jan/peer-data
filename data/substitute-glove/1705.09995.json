{"id": "1705.09995", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-May-2017", "title": "Subject Specific Stream Classification Preprocessing Algorithm for Twitter Data Stream", "abstract": "Micro - commenters service Twitter is another lucrative it they analyzed homestake software on global sharply. But possibility go the omnifariousness though part journals mentioned until full accurately generic; as is inefficient soon run a sources newcrest computable on the raw data. This paper discusses an initialization also accurately classify the entire stream ago whether time indeed number although helpful definition collectively declassification groundwater though each more but the computerized metallurgical algorithms wo no run separately yielding more implement nevertheless with 's high efficiency.", "histories": [["v1", "Sun, 28 May 2017 22:16:35 GMT  (113kb)", "http://arxiv.org/abs/1705.09995v1", "6 pages"]], "COMMENTS": "6 pages", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["nisansa de silva", "danaja maldeniya", "chamilka wijeratne"], "accepted": false, "id": "1705.09995"}, "pdf": {"name": "1705.09995.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "source for data mining applications on global sentiment. But due to the omnifariousness of the subjects mentioned in each data item; it is inefficient to run a data mining algorithm on the raw data. This paper discusses an algorithm to accurately classify the entire stream in to a given number of mutually exclusive collectively exhaustive streams upon each of which the data mining algorithm can be run separately yielding more relevant results with a high efficiency.\nIndex Terms\u2014 Data mining, Twitter, WordNet.\nI. INTRODUCTION\nWITTER is a social networking and micro-blogging website which allows registered users to send messages called tweets. A user can follow other users in order to receive their tweets. If the user account is not set to the option private, the tweets from that account are also obtainable from the public timeline. The public timeline and the tweets of the users that a certain user is following can be accessed using the Twitter API. A tweet is a text-based post which has an upper limit of 140 characters. Usually people tweet about their personal life and their opinion of the world and its events. With 190 million users worldwide, twitter is a valuable data source to gain on-the-fly information about the current situation of the world.\nBecause of the open-ended nature of Twitter, the tweets are spread across all the aspects of human life. This fact considered with the rate of which the tweets are added to the twitter stream, it is not very effective to run a data mining algorithm on the raw twitter stream.\nThe objective of this paper is to introduce an algorithm to select the best set of word attributes to classify the twitter stream for in a program which intends to run a data mining algorithm upon the twitter stream. The algorithm described in this paper will break the incoming twitter stream in to mutually exclusive collectively exhaustive classes upon each of which the data mining algorithm can be run to identify traits present within each class in relation to the class itself and time. Using the mined data it is possible to draw connections between the classes. The data mining tool Weka,\nthe accuracy of the algorithm."}, {"heading": "II. DESIGN AND IMPLEMENTATION", "text": "Though twitter is a continuous data stream and data mining tool Weka is built for static data mining purposes, the overall design assumes for blocks of tweets to be available. Thus data preprocessing is carried out separately from the twitter stream. Since the objective of the research was to develop a suitable data preprocessing methodology to be used in data mining tools such as Weka, this approach was decided to be acceptable.\nThe overall design and operation of the data preprocessing methodology consists of 5 distinct stages, after which a data model is built through Weka data mining tool.\nA. Data Collecting Methodology\nData required to train the data model were collected through the tweet collecting desktop and online application \u201ctHE ARCHIVISt\u201d [2], [3]. The public tweets that were available on the five categories art, lifestyle, politics, technology and business were collected during the periods of 24th November to 11th December, 2010 and 17th to 25th February, 2011. The data collected by \u201ctHE ARCHIVISt\u201d application were mostly through twitter search facilities thus the accuracy of the data obtained was significantly high.\nData were put into separate files according to the class to which the tweets were categorized. Each data file was created containing around 11,000 tweets with the class name of it as the filename. Around 300,000 tweets were collected with varying composition on the 5 classes.\nB. Indexing Algorithm\nNext step was to select suitable attributes to index the collected tweets. It was found that there are two ways to do this;\n1. Build the list of attributes using the words occurring in\nthe already classified tweets\n2. Use a dictionary of words and use them as attributes depending on their significance in classifying a tweet in to the class that it is classified to.\nIt was found that although the first approach would give attributes with direct correlation to the collected tweets, it\nT\ncomes with some inherent problems. The most severe problem was filtering out tweets that are not in English. Although languages using Cyrillic, Chinese, Arabic, etc. scripts could be easily filtered out, languages such as French, German, Spanish, etc. which use the Latin script to write was indistinguishable from English owing to the fact that English too is written using the Latin script. The typical behavior of the twitter users posed a problem too. Since there is a 140 character limit for a tweet people tend to use pseudo-words and on some accounts drop punctuation marks and spaces.\nBecause of the above problems the second approach was selected. For this end it was decided to use the WordNet[4] lexical database created by Cognitive Science Laboratory of Princeton University, since it is free and contains a well categorized list of over 150,000 different words. The first approach to be used is to list the words in each of the 45 WordNet files under the name of the file and use the file names as the attributes. Appendix A contains an extract from the \u201cnoun.person\u201d file. Thus in this approach the words; Zeus, Hera, Greek_deity, deity, God were listed under the attribute \u201cnoun.person\u201d\nWhen the index was queried with a tweet; it was programmed to go through the words of the tweet while looking up each word in the said 45 lists. An integer array with a length of 45 was maintained and for each occurs of a word in a give list; the matching integer value was increased. Finally the integer array was returned as the output.\nAlthough this approach was sound for tweet sets of the order of millions, for the number of tweets that we were going to use in this project the attributes were too coarse-grained. Thus it was decided to extend the indexing mechanism. Owing to the fact that WordNet lexical database itself is not a flat file, most of the words were mentioned with a hypernym. Thus it was possible to group words with the same hypernym together and set those words under an attribute by the name of the hypernym. For an example form Appendix A it is evident that the words \u201cZeus\u201d and \u201cHera\u201d have \u201cGreek_deity\u201d as the hypernym and in return \u201cGreek_deity\u201d has \u201cdeity\u201d as the hypernym. These chains of inheritance were extracted from WordNet. Then all the words that came as a hypernym for one or more word was removed from the basic word list and was added to a separate list. This hypernym list contained 11551 words. Words without a hypernym were listed using the old file name approach. For an example the word \u201cself\u201d in Appendix A was listed under \u201cnoun.person\u201d. Then chain inheritance was considered and words in the base list was linked to the top most ancestor and all the nodes in between were dropped. This resulted in an attribute count of 7906 plus the 45 filename attributes. Then a threshold function was introduced to filter the hypernyms based on the number of words that came as hyponyms of it. The words under the hypernyms that got disqualified at this stage were reclassified under the filename algorithm. It was found that the optimum value for the threshold value for the hypernym influence to be\n2500 in which case an attribute count of 262 was returned inclusive of the 45 filenames. The querying mechanism was not needed to be altered after this change in indexing algorithm.\nC. Recursive Duplicate Elimination Algorithm\nElimination of duplicate data from the trained data set is a vital component in achieving higher accuracy in the trained model. This is carried out under three stages.\n1) Removal of duplicate tweets: This eliminates occurrence of the same tweet in the data set over and over again. Even if two tweets are different, due to substitution of the usernames and URLs with \u201cuser\u201d and \u201curl\u201d words respectively, if other content of the tweet is the same, it would be considered as the same tweet.\n2) Removal of unclassified data items: Due to limitations of WordNet structure, certain tweets\u2019 words will not be categorized in to any of the attributes. Thus such data items are eliminated as they are insignificant for the data model.\n3) Recursive Duplicate Elimination Algorithm: The Comma Separated Value (csv) data items generated by extracting data from tweets and using the indexing algorithm consisted of many duplicates. In some cases same data was available for multiple classes reducing the efficiency and accuracy of the trained model. A recursive duplicate elimination algorithm was devised to remove such discrepancies Fig. 1 and 2.\nObjects are created for each data file with the tweet list and its duplicate tweet list. The algorithm was designed to\nincorporate in to threads in order to improve the utilization of multi-core capabilities of the computer and to increase the speed of execution.\nThe REMOVE-INTER-CLASS-DUPLICATES method eliminates duplicates between two data files and stores the duplicates in the resulting file for the use of others. REMOVE-CLASS-DUPLICATES eliminate the duplicate processed tweets in a data object by comparing another data object\u2019s duplicate tweet list.\nThe above three stages in eliminating duplicates in processed tweets results around 90% of the original tweets to be discarded.\nD. Parallel Thread Operation\nAlthough the algorithm described above was giving the correct logical output, it was underutilizing the computational power of the computes that it was run owing to the sequential manner the program was written so far. It was also observed that each of the parts that took the most computation time; Class duplicate handling and duplicate eliminating was actually consisted of for-loops where each iteration was completely independent of the previous iterations. Thus it was decided to parallelize both operations. After extensive analysis of the current algorithms used; it was decided that an architecture where a central master thread communicate with satellite threads via events is the best possible threaded architecture for this system. It was also observed that the duplicate eliminating process has to be started only after the class duplicate handling process was over. Thus a thread barrier was needed to be implemented.\nSince Java does not have an inbuilt threaded event handling system it was decided to use the free java package called LinkSet [5] as the base of the event architecture. By extending the java.lang.Thread class while implementing constructs of the LinkSet package, a class called \u201cLockingThread\u201d was created along with a thread barrier. Fig. 3 shows the pseudocode for the Barrier Algorithm in the\nLockingThread. The class duplicate handling methods were ported to a new class called \u201cClassDuplicateHandler\u201d which extended the LockingThread class. Fig. 4 shows the pseudocode for the class duplicate handler threading algorithm. Similarly the \u201cDuplicate eliminating\u201d methods were ported to a new class called \u201cDuplicatesEliminator\u201d which also extended the \u201cLockingThread\u201d class. Fig. 5 show the pseudocode for the duplicate eliminator threading algorithm.\n\u201cClassDuplicateHandler\u201d class and the \u201cDuplicatesEliminator\u201d class were to be the satellite thread instances. As for the master thread; the Generator class was altered by making it a child of the \u201cLockingThread\u201d class and introducing a variable length to the thread barrier. The length of the barrier indicates the number of threads that are executable in parallel.\nThe program was run on two computers with Intel\u00ae Core\u2122 Duo @2.10GHz, 2.10GHz processors. Thus the thread count was set to four to be twice the number of CPUs involved. This software configuration reported around 38% decrease in execution time from the sequential program. This is highly significant considering the fact that in the given hardware configuration it takes around 38 minutes to process around 300,000 tweets by the sequential program.\nE. Building Trained Data Model\nThe final processed data was used in 3 different classifiers to identify which classifier provides a reasonably accurate data model for tweet prediction purposes. Data mining tool Weka, developed by University of Waikato[1] was used for this purpose as it has number of classifiers developed for similar purposes. The newest version of Weka, 3.7.2 was used as per recommendation from its developers. Na\u00efve Bayes, Random Tree and Random Forest were chosen to develop the data model from the processed training data set.\n1) Naive Bayes Classifier: The Naive Bayes Classifier technique is based on the Bayesian theorem and is particularly suited when the dimensionality of the inputs is high [6]. This classifier assumes that the presence or absence of a particular attribute does not affect the presence or absence of other attributes.\n2) Random Tree Classifier: Randome tree algorithm constructs a tree that considers K random features (Smaller than the total number of features) from the data set at each node. It does not perform pruning.\n3) Random Forest Classifier: The random forest algorithm creates an ensemble of classifiers by training each classifier on a random redistribution of the training set. Each random redistribution is generated by randomly drawing with replacement N examples where N is the size of the training set. A tree is grown on a fixed-size subset of attributes (smaller than the total number of attributes) randomly drawn on each round [7].\nThe results indicated very high accuracy obtained through Random Forest and Random tree classifiers where as na\u00efve Bayes classifier produced poor inaccurate model. Due to high accuracy of using Random Forest classifier against test data, it was chosen as the classifier to be used against proposed data preprocessing system."}, {"heading": "III. RESULTS AND ANALYSIS", "text": "The train data collected was used in number of classifiers to build the data model. The following are the results for three classifiers Na\u00efve Bayes, Random Tree and Random Forest using 17, 861 train data items and 100 sample test data items.\nThough random Tree model shows highest accuracy over trained model, since it shows a low accuracy in terms of test data than Random Forest model, it was discarded as a suitable model. Na\u00efve Bayes showed poor performance against train and test data where as Random Forest model showed significantly high accuracy over train data.\nThe following demonstrates results of the experiment carried out on three samples of test data containing 100 data items each on Random Forest classifier.\nThe average sample test data set accuracy shows 56% in correctly classifying the tweets. Considering the fact that the probability of correctly classifying a tweet manually being 20%, model shows an accuracy increase of 36%.\nTABLE III shows the confusion matrix for test data sample 2 with 56% overall accuracy. As the matrix shows, technology and lifestyle classes are misclassified more than 50% of the time resulting reduction in overall accuracy. This is due to limited availability of tweet data of the above two classes in train data.\nParallel thread operation on duplicate elimination algorithm provides the following results on processing 307,000 tweets to 17,861 processed data items.\nData Processing with no threads 421 minutes\nData Processing with 4 threads 259 minutes\nExecution time speed up 38.48%"}, {"heading": "IV. FURTHER IMPROVEMENTS", "text": "The Data processing could be further improved through substituting a URL with the actual web site content as in heading of the web page. This would greatly improve the classification and identification of words in to attributes identified through indexing algorithm. In addition, use of significantly high number tweets (greater than 2 million) would improve the accuracy of the data model thus resulting higher accuracy in test data.\nThe data processing proposed is limited to the word count in WordNet library. Thus any improvement in the WordNet library or use of another superior word library would extract information more from the tweets in to attributes thus the processed tweet would be better represented through the attribute values."}, {"heading": "V. CONCLUSION", "text": "Twitter data stream allows users to get real time updates on the global sentiment. Due to the omnifariousness of the subjects in the stream, it is highly inefficient to run a data mining algorithm on the raw data. This paper discussed an algorithm to classify the stream in to a given number of mutually exclusive collectively exhaustive streams using the word repository of WordNet. Weka was used to observe the accuracy of the selected attribute combinations. Considering all tests performed and the subsequent results obtained; it can be concluded that the suggested algorithm is in fact suitable for selecting the most relevant attributes and building the train data set for the stream classifying operation.\nAPPENDIX\nA. An excerpt from the noun.person file.\n{ Zeus, Greek_deity,@i noun.group:Greek_mythology,;c ((Greek mythology) the supreme god of ancient Greek mythology; son of Rhea and Cronus whom he dethroned; husband and brother of Hera; brother of Poseidon and Hades; father of many gods; counterpart of Roman Jupiter) } { Hera, Here, Greek_deity,@i (queen of the Olympian gods in identified with Roman Juno) } { Greek_deity, deity,@ noun.time:antiquity,;c (a deity worshipped by the ancient Greeks) } { [ deity, verb.cognition:deify,+ ] [ divinity, adj.all:heavenly^divine2,+ ] god1, immortal, supernatural_being,@ noun.group:pantheon,#m (any supernatural being worshipped as controlling some part of the world or some aspect of life or who is the personification of a force) } { [ God, adj.all:heavenly^godly,+ ] Supreme_Being, supernatural_being,@i (the supernatural being conceived as the perfect and omnipotent and omniscient originator and ruler of the universe; the object of worship in monotheistic religions) } { self, noun.Tops:person,@ (a person considered as a unique individual; \"one's own self\") } { Parkinson1, James_Parkinson, surgeon,@i (English surgeon (1755-1824)) } { Morpheus, deity,@i Ovid,;c (the Roman god of sleep and dreams) } { democrat, [ populist, noun.cognition:populism,+ ] advocate,@ (an advocate of democratic principles) } { Dalai_Lama, Grand_Lama, lama,@ (chief lama and once ruler of Tibet) } { dame1, madam, ma'am, lady1, gentlewoman, woman,@ (a woman of refinement; \"a chauffeur opened the door of the limousine for the grand lady\") } { countryman, compatriot,@ (a man from your own country) } { Otto_I, Otho_I, Otto_the_Great, King_of_the_Germans,@i Holy_Roman_Emperor,@i (King of the Germans and Holy Roman Emperor (912-973)) } { paper-pusher, bureaucrat,@ clerk,@ (a clerk or bureaucrat who does paperwork) } { outdoorsman, noun.Tops:person,@ (a person who spends time outdoors (e.g., hunting or fishing)) } { clog_dancer, dancer1,@ (someone who does clog dancing) } { cowgirl, cowboy,@ (a woman cowboy) } { church_officer, official1,@ (a church official) } { [ butcher2, verb.contact:butcher,+ ] meatman, merchant,@ (a retailer of meat) } { bounty_hunter1, pursuer,@ (someone who pursues fugitives or criminals for whom a reward is offered) } { bird_fancier, fancier,@ (a person with a strong interest in birds) }"}, {"heading": "ACKNOWLEDGMENT", "text": "While doing this research we had to go on a long journey, meeting many challenges and overcoming those with contribution of the people who surrounded us with helping hand and courageous words. We would like to thank our subject coordinator Dr. Shehan Perera for the support and encouragement given in regard to this project."}], "references": [{"title": "LinkSet \u2013 An alternative Approach to  Events  Java [Online", "author": ["\u0141ukasz Bownik"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "Since Java does not have an inbuilt threaded event handling system it was decided to use the free java package called LinkSet [5] as the base of the event architecture.", "startOffset": 126, "endOffset": 129}], "year": 2011, "abstractText": "Micro-blogging service Twitter is a lucrative source for data mining applications on global sentiment. But due to the omnifariousness of the subjects mentioned in each data item; it is inefficient to run a data mining algorithm on the raw data. This paper discusses an algorithm to accurately classify the entire stream in to a given number of mutually exclusive collectively exhaustive streams upon each of which the data mining algorithm can be run separately yielding more relevant results with a high efficiency.", "creator": "PScript5.dll Version 5.2"}}}