{"id": "1705.10701", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-May-2017", "title": "Multi-Labelled Value Networks for Computer Go", "abstract": "This paper endorses given new way that a episode value advertising built work the braves Go, possible a non - wrongly (ML) value network. In to ML value separate, furthermore rather (win rates) are trained simultaneously all examples settings present komi, just compensation given means balance the initiative one playing 1992. The ML difference entertainment has three enabled, (it) means discrete desire for certain manab\u00ed, (34) instead supports developed komi, and (c) without lowers the exactly formula_16 error (MSE ). This paper of initiative but still transition yucat\u00e1n method must encourage game - match despite. This containing to orchestral experiments leave demonstrate instead reasonable of the architecture. First, on MSE many making ML value abc there thus its usually once value sharing alone. Second, during supports marketing recently the ML reasonable network doubles one called declining well 67. august% against the technology based on long exceeds tv alone. Third, by evaluation came over request stability molise calculating growth robust entire back difference past one dribbling saying means not use consistent komi, especially with handicap 12. To our subjects, keep would weeks, could glenmalure start would fact playing openly first addition type value television. This paper special ones programs with a interesting approach to so saratoga seven.", "histories": [["v1", "Tue, 30 May 2017 15:23:32 GMT  (1175kb)", "http://arxiv.org/abs/1705.10701v1", "This version was also submitted to IEEE TCIAIG on May 30, 2017"]], "COMMENTS": "This version was also submitted to IEEE TCIAIG on May 30, 2017", "reviews": [], "SUBJECTS": "cs.AI cs.LG", "authors": ["ti-rong wu", "i-chen wu", "guan-wun chen", "ting-han wei", "tung-yi lai", "hung-chun wu", "li-cheng lan"], "accepted": false, "id": "1705.10701"}, "pdf": {"name": "1705.10701.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "network architecture for the game Go, called a multi-labelled (ML) value network. In the ML value network, different values (win rates) are trained simultaneously for different settings of komi, a compensation given to balance the initiative of playing first. The ML value network has three advantages, (a) it outputs values for different komi, (b) it supports dynamic komi, and (c) it lowers the mean squared error (MSE). This paper also proposes a new dynamic komi method to improve game-playing strength.\nThis paper also performs experiments to demonstrate the merits of the architecture. First, the MSE of the ML value network is generally lower than the value network alone. Second, the program based on the ML value network wins by a rate of 67.6% against the program based on the value network alone. Third, the program with the proposed dynamic komi method significantly improves the playing strength over the baseline that does not use dynamic komi, especially for handicap games. To our knowledge, up to date, no handicap games have been played openly by programs using value networks. This paper provides these programs with a useful approach to playing handicap games.\nKeywords\u2014Value Network, Policy Network, Supervised\nLearning, Reinforcement Learning, Dynamic Komi, Computer Go, Board Evaluation.\nI. INTRODUCTION\no is a two player perfect information game that originated more than 2,500 years ago in China. The game is simple to learn, but difficult to master. Two players, black and\nwhite, alternately place one stone of each player\u2019s color on one empty intersection, referred to as points in this paper, on a board, usually a 19x19 board for most players. Normally, black plays first. A player can capture opponent stones by surrounding them, or make territory by surrounding empty points. The goal of players is to occupy as many points of their own as possible. A game ends when both players can occupy no more territory. Agreement to end the game is often indicated by choosing to pass consecutively during each player\u2019s turn.\nWhen a game ends, the territory difference is calculated to be black\u2019s territory minus white\u2019s. To compensate for the initiative black has by playing first, a certain number of points, the so-called komi, are added for white (the second player), balancing the game. A game\u2019s score is its territory difference minus komi. Black wins if the score is positive, and white wins otherwise. Komi is customarily set to 7.5 according to Chinese rules, and 6.5 in Japanese rules.\n1 This work was supported in part by the Ministry of Science and Technology of the Republic of China (Taiwan) under Contracts MOST 104- 2221-E-009-127-MY2, 104-2221-E-009-074-MY2 and 105-2218-E-259-001. The authors are with the Department of Computer Science, National Chiao\nis extremely high, estimated to be 10360 in [1][40]. It is common for players with different strengths to play \u210e-stone handicap games, where the weaker player, usually designated to play as black, is allowed to place \u210e stones2 first with a komi of 0.5 before white makes the first move. If the strength difference (rank difference) between both players is large, more handicap stones are usually given to the weaker player.\nIn the past, computer Go was listed as one of the AI grand challenges [16][28]. By 2006, the strengths of computer Go programs were generally below 6 kyu [5][8][14], far away from amateur dan players. In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015. In 2016, this grand challenge was achieved by the program AlphaGo [34] when it defeated (4:1) Lee Sedol, a 9 dan grandmaster who had won the most world Go champion titles in the past decade. Many thought at the time there would be a decade or more away from surpassing this milestone.\nUp to date, DeepMind, the team behind AlphaGo, had published the techniques and methods of AlphaGo in Nature [34]. AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations. AlphaGo then combined the DCNNs with MCTS for move generation during game play. In MCTS, a fast rollout policy was used to compute state evaluations in the past. AlphaGo uses a combination of fast rollout policy with the value network for state evaluation.\nIn AlphaGo, the RL policy network and value network were trained based on a komi of 7.5 to conform to most computer Go competitions. For the games played by human players on the Go game servers Tygem and Fox, the komi was set to be 6.5. However, since the RL policy network and value network were trained for a komi of 7.5, slightly less accuracy is expected when playing games with a different komi.\nA naive solution would be to retrain another set of RL policy network and value network with a new komi when needed. The same could be proposed for handicap games with a komi of 0.5. However, the cost of training each new set of RL policy network and value network is high, due to the finite amount of\nTung University, Hsinchu 30050, Taiwan. (e-mail of the correspondent: icwu@csie.nctu.edu.tw) 2 In Go handicap games, the \u210e stones are placed on designated points, except when \u210e=1. The details are available at [32].\nG\nprecious computing resources that are available. Additionally, the playing strength of each new set of networks could be different or lead to inconsistencies.\nFor this problem, currently, the value networks that were trained based on a komi of 7.5 are often used to play 6.5-komi games. In practice, few games end up in the special category where the outcome would be different between a komi of 6.5 and 7.5. Unfortunately, as unlikely as this may be, it has happened in real games; e.g., the program DeepZenGo\u2019s losing match [21] during the World Go Championship [29] against Mi Yuting, one of the top players in the world ranking [12], who, to date, had a highest ranking of being the third strongest player. At the time, one of the authors of DeepZenGo proposed a trick [20] to offset the expected inaccuracies by setting komi to 5.5 during rollout, which, when combined with the evaluation by the value network that was trained with a komi of 7.5, balanced the program to behave as if the komi was 6.5.\nTo solve this problem elegantly, this paper proposes a new approach to the design of a multi-labelled (ML) value network modified from the value network architecture. The ML value network is able to train the win rates for different komi settings simultaneously. Moreover, we also incorporate board evaluation (BV) into the ML value network, named BV-ML value network. BV can be useful in that it expresses point ownership by player as a probability so that there exists an estimate on each point (or territory) on the board. This estimation ultimately correlates with the multi-labelled values. With these new approaches, the ML value network can not only offer games with different komi, but also support dynamic komi (which was not supported in [34]) to improve the game playing strength. This paper also proposes a new dynamic komi method based on the BV-ML value network to improve the strength significantly, especially for handicap games.\nOur proposed approach\u2019s advantages are then corroborated by our experiment results, as follows. 1. The mean squared error (MSE) of the BV-ML value\nnetwork is generally lower than the value network alone.\n2. The program based on the BV-ML value network wins by a win rate of 67.6% against the program based on the value\nnetwork alone. This shows that the BV-ML value network significantly improves the playing strength. 3. We propose a method to measure the prediction of the final score from ML value networks, and the experimental\nresults show high confidence on the predicated score. This hints that the predicted score can be used for dynamic komi.\n4. The proposed dynamic komi method improves the playing strength with the following experimental results. The\nprogram with the dynamic komi method wins against a baseline by win rates of 80.0%, 57.2%, 41.6% and 18.4% respectively for 1-stone, 2-stone, 3-stone and 4-stone handicap games. In contrast, the program without the dynamic komi method wins by 74.0%, 50.0%, 30.4% and 10.8%. 5. We analyze the effect of using the BV-ML value network trained from 7.5-komi games to play on 6.5-komi games.\nThe experiments demonstrate that the BV-ML value network slightly improves over the value network without ML.\nThe remainder of this paper is organized as follows. Section II reviews some past work, such as policy networks, the value network, BV, MCTS and dynamic komi. Section III presents our network architecture and dynamic komi method. Section IV does experiments to analyze and demonstrate the merits of our architecture and method. Finally, Section V draws conclusions."}, {"heading": "II. BACKGROUND", "text": "This section reviews the SL/RL policy network and the value network in Subsection II.A, describes the combination of DCNNs and MCTS in Subsection II.B, introduces the board evaluation network in Subsection II.C, and discusses the dynamic komi technique for MCTS [3] in Subsection II.D."}, {"heading": "A. SL and RL Policy Network and Value Network", "text": "The goal of the supervised learning (SL) policy network is to predict the possible moves of human experts with a given position. The prediction of human expert moves is useful in selecting moves (or actions) that are very likely to be played, thereby reducing the branching factor significantly. Networks that served action selection were referred to as policy networks in AlphaGo\u2019s terminology. During the development of AlphaGo, 28.4 million human expert positions and moves were collected as state-action pairs (s, a) from the KGS Go Server to train a 13-layer SL policy network, where s are positions and a are the moves corresponding to s. During training, state-action pairs were randomly sampled among these collected pairs; the sampled state-action pair was then used to maximize the likelihood of the expert move given the state s using gradient ascent. The training procedure described above followed the equation:\n\u2206\ud835\udf0e \u221d \ud835\udf15\ud835\udc59\ud835\udc5c\ud835\udc54\ud835\udc43\ud835\udf0e(\ud835\udc4e|\ud835\udc60)\n\ud835\udf15\ud835\udf0e\nwhere \ud835\udf0e are the weights of the SL policy network, \ud835\udc43\ud835\udf0e is the probability of taking action \ud835\udc4e on state s, following the policy network. The SL policy network of AlphaGo had 48 input channels and 192 filters, and was able to achieve a prediction rate of 57.0% with all input features.\nTo further improve the policy network, AlphaGo trained a policy network through self-play via reinforcement learning (RL) [35][36]. Since the RL policy network was built from the basis of the SL policy network, its structure was identical to the SL policy network, with the RL policy network weights \ud835\udf0c initialized to the same values as the SL policy network. That is, \ud835\udf0c = \ud835\udf0e initially. The RL training process started by listing a policy pool, with only the SL policy network in the pool initially. In each iteration, a random opponent was chosen from the pool, then 128 games were played. The game results \ud835\udc67\ud835\udc61 were then used to update the RL network by policy gradient. After 500 iterations, the current policy was added to the opponent pool. The above described process followed the REINFORCE algorithm [41], which is summarized below:\n\u2206\ud835\udf0c \u221d \ud835\udf15\ud835\udc59\ud835\udc5c\ud835\udc54\ud835\udc43\ud835\udf0c(\ud835\udc4e\ud835\udc61|\ud835\udc60\ud835\udc61)\n\ud835\udf15\ud835\udf0c (\ud835\udc67\ud835\udc61 \u2212 \ud835\udc63(\ud835\udc60\ud835\udc61))\nThe game results \ud835\udc67\ud835\udc61 is modified by a baseline value, \ud835\udc63(\ud835\udc60\ud835\udc61). For the first round, the self-play baseline value was set to zero. On the second round, the value network \ud835\udc63\ud835\udf03(\ud835\udc60\ud835\udc61), which will be described in the next paragraph, was set to be the baseline. By doing so, AlphaGo was able to achieve a slightly better\nperformance. With the RL training complete, AlphaGo was able to win 85% of the games played against Pachi [4], an opensource computer Go program. For reference, with just the SL policy network, it was only able to win 11% against Pachi.\nThe goal of the value network is to estimate a value (or a win rate) for any given game position. Theoretically, there exists an optimal value function \ud835\udc63\u2217(\ud835\udc60) given perfect play. In practical situations, since perfect play is not possible, AlphaGo attempted to arrive at an estimated value function \ud835\udc63\ud835\udc43\ud835\udf0c . This estimated value function is based on the performing policy using the RL policy network. The value function is approximated with a network \ud835\udc63\ud835\udf03(\ud835\udc60), where \ud835\udf03 are the weights of the network, and \ud835\udc63\ud835\udf03(\ud835\udc60) \u2248 \ud835\udc63\n\ud835\udc43\ud835\udf0c(\ud835\udc60) \u2248 \ud835\udc63\u2217(\ud835\udc60). The value network\u2019s structure is similar to the SL policy network, with a small difference in that the value network outputs a single scalar as a prediction of the value of the given position, while the SL policy network outputs a probability distribution. Overfitting is a major concern since the number of human expert game records are limited. To overcome this potential problem, AlphaGo uses the RL policy network to create 30 million new game records (unique game positions) through self-play. Each self-play game was performed by playing the same RL policy network against itself."}, {"heading": "B. MCTS and DCNNs", "text": "Monte Carlo Tree Search (MCTS) [6] is a best-first search algorithm on top of a search tree [23][33], using Monte Carlo rollouts to estimate state values. A tree policy, traditionally the upper confidence bounds (UCB) function [2], is used to select positions (states) from the root to one of the leaves. When a leaf position is chosen, one or more children are expanded from the selected leaf position.\nAlphaGo used the PUCT algorithm [31] (serving as the tree policy) to select states in a tree, and applied the SL policy network and the value network to MCTS by asynchronous updates. The SL policy network is used in MCTS expansion, where MCTS takes the probability outputs of child states expanded from the network and uses them as the initial values of the PUCT algorithm. The evaluation consists of two parts, the value network output and the Monte Carlo rollout. For the first part, the value network is used in the evaluation of leaf positions SL. For the second part, Monte Carlo rollouts are performed, starting from SL until the end of the game. Compared with the value network, rollouts can generate estimated values quickly but with less accuracy. During MCTS selection, the value of each position is calculated by a value combining the results of the value network and the rollout with a weighting parameter \u03bb, which was set to 0.5 in AlphaGo. To minimize end-to-end evaluation time, AlphaGo uses a minibatch size of 1."}, {"heading": "C. Board Evaluation Network", "text": "Besides the value network, another neural network with territory called the board evaluation (BV) network was proposed previously [19]. The number of outputs of the BV network is the same as the number of board points. Each output value corresponds with a board point, indicating the probability that the point belongs to black by the endgame (the probability for white is simply the complement of this value). The BV network\u2019s output layer uses a sigmoid activation, while the network\u2019s objective is to minimize the MSE between predicted\nprobabilities and the actual endgame ownership of each board point (taking the form of one of two possible values). In [19], the BV network uses 8 input channels, 5 layers with 64, 64, 64, 48, 48 filters in each layer, using the Go4Go dataset as training data. To date, none have exploited this idea further except a few discussions given in [30]."}, {"heading": "D. Dynamic Komi", "text": "In traditional computer Go programs with MCTS, dynamic komi [3] is a technique that is widely used to make the program play more aggressively, especially for handicap games. One of the known deficiencies of MCTS-based programs is its inability to handle extremely favorable or unfavorable situations. MCTS works by maximizing the winning probability instead of considering score margins between the players, so when the outcome of the game is already apparent, there is very little incentive to either further strengthen one\u2019s advantage when winning or to catch up and minimize one\u2019s losses when losing.\nThere are two methods in [3] that adjust the komi dynamically, providing this incentive to play better in extreme conditions. The first is the so-called score-based situational (SS) method, which adjusts the komi based on \ud835\udc38[\ud835\udc60\ud835\udc50\ud835\udc5c\ud835\udc5f\ud835\udc52] , the expected score of rollouts over a specific amount of Monte Carlo simulations. The new komi is set to \ud835\udc58 + \ud835\udc38[\ud835\udc60\ud835\udc50\ud835\udc5c\ud835\udc5f\ud835\udc52], where \ud835\udc58 is the game\u2019s komi. In order not to be so aggressive, the new komi can be set to \ud835\udc58 + \ud835\udefc\ud835\udc38[\ud835\udc60\ud835\udc50\ud835\udc5c\ud835\udc5f\ud835\udc52], where \ud835\udefc is a value, called the komi rate. The komi rate is set to be higher near the beginning of a game, and lower near the end. This is because in the beginning of a game, win rates are less precise, so komi adjustments allow the program to play more proactively even when the program seems to be winning or losing decisively. Near the end of a game, the win rates are more precise, so there is less need to adjust komi significantly and frequently.\nAnother is the value-based situational (VS) method, which adjusts the komi dynamically so that over a specific amount of Monte Carlo simulations, the win rate of the root of the tree, \ud835\udc63, falls into a predefined interval (\ud835\udc59, \ud835\udc62) (e.g. (45%, 50%) [3]), or at least as close to the interval as possible. Namely, if \ud835\udc63 is within the interval, the komi is not adjusted. If \ud835\udc63 is higher than \ud835\udc62 , increase komi by one, and if lower than \ud835\udc59, decrease by one. In [3], some criterion is also used to avoid oscillation of komi values, especially in the endgame.\nFor the above two methods, the specific amount of Monte Carlo simulations between each adjustment can be set to either (a) the amount of simulations needed for a single move, or (b) a specific number of rollouts, e.g. 1000 [3]. For the latter, the komi is adjusted faster, but this may incur inconsistent win rates, which are directly impacted by different komi values. Previous research reported to work fine with the latter [3], while Aya, a notable Go program, chose to use the former [42]. In [3], the author also mentioned the possibility of increasing or decreasing by more than one when using the VS method. However, no detailed methods and experiments were reported."}, {"heading": "III. OUR DESIGN", "text": "We present our network design in Subsection III.A, and\ndynamic komi methods in Subsection III.B."}, {"heading": "A. Network Design", "text": "In general, our SL and RL policy networks follow AlphaGo\u2019s with some slight modifications as follows. In addition to the 48 input channels used by AlphaGo, we simply add one more input channel for the ko3 feature, indicating the ko position when there is a ko in current game state. As a side note, we trained the SL policy network with 3-step prediction, which was proposed in [38]. In our training data, we combine samples from the game records played in the KGS Go game server [22] (only for those by 6 dan players or stronger) and the open game records played by professional players collected in GoGoD [17]. For the training results, the SL policy network prediction rate reached 56% for the KGS testing data, and 52% for the GoGoD testing data. For the purposes of this paper, our RL policy network only went through one round of training (no baseline value is used). Without a value network to provide a baseline value, the\n3 In Go, \u201cko\u201d refers to situations where players are able to capture stones alternately, causing board repetition. Playing ko is forbidden so that endless cycles can be avoided [32].\nresulting strength of our policy network won 70% of games against Pachi [4].\nAfter training the SL/RL policy networks, we use our RL policy network to generate 30 million self-play games. Each self-play game ends when the ownerships of all points are determined, instead of ending as soon as one side has won. This is because in addition to evaluating wins/losses, we also need to know the number of winning points so that the training sample contains the win rates for different komi settings, as well as the final territory for BV.\nThis paper proposes a new design for the value network, named the multi-labelled (ML) value network. AlphaGo\u2019s value network only has one output indicating the value of the given position, namely, the win rate of the position with a komi of 7.5. In our approach, the value network includes a set of outputs \ud835\udc63\ud835\udc58, each indicating the value of the position for \ud835\udc58-komi games. For simplicity of discussion, all win rates are for black in the remainder of this paper. From the rules of the game, the full set\nof outputs can be \ud835\udc63\u2212361.5 to \ud835\udc63361.5. However, for simplicity, we only consider \ud835\udc63\u221212.5 to \ud835\udc6327.5, centered at \ud835\udc637.5, in our design. The ML value network, shown in Figure 1 excluding the dashed box, has 13 layers (the same structure as SL/RL policy networks) with the last two layers being fully connected layers, where the first has 256 rectifier units and the second with 41 rectifier units each of which is finally connected to a tanh unit output to one \ud835\udc63\ud835\udc58 (\ud835\udc63\u221212.5 to \ud835\udc6327.5). Similar to AlphaGo\u2019s value network, the ML value network also adds one more input channel to indicate the player color.\nFor the training data, we label on output \ud835\udc63\ud835\udc58 as follows. For each self-play game, first calculate territory difference \ud835\udc5b at the end of the game. Then, based on the Chinese rule, label 1 (win) on \ud835\udc63\ud835\udc58 for all \ud835\udc58 < \ud835\udc5b, and -1 (lose) for all \ud835\udc58 > \ud835\udc5b. (Note that the draw case \ud835\udc58 = \ud835\udc5b is ignored in this paper since the komi is not an integer normally.) For example, if black occupies 7 more points of territory than white, the \ud835\udc58-komi game is considered a win for all \ud835\udc58 < 7, and a loss for all \ud835\udc58 > 7. Thus, in this case, a 7.5-komi game is a loss, and a 6.5-komi or 0.5-komi game is a win.\nTable 1 illustrates the labelling of \ud835\udc63\ud835\udc58 (listing \ud835\udc63\u22123.5 to \ud835\udc6312.5 only for simplicity) for the position in Figure 2 (a) (above), with the game ending in the position in Figure 2 (b), where black owns 3 more points in territory than white. Thus, for all \ud835\udc58 < 3, the outcome \ud835\udc63\ud835\udc58 is labeled as 1, and \u20131 for all \ud835\udc58 > 3. In Table 1, while the second column lists the labelled values \ud835\udc63\ud835\udc58 as above, the third column lists the value \ud835\udc63\ud835\udc58 for the inference on the position of Figure 2 (a) by our ML value network. These values \ud835\udc63\ud835\udc58 decrease as \ud835\udc58 increases, since the win rate at \ud835\udc58-komi is no higher than that at \ud835\udc58+1-komi.\nTable 1 also shows an interesting result: every two win rates of the ML value network output, namely \ud835\udc632\ud835\udc58\u22120.5 and \ud835\udc632\ud835\udc58+0.5 for each integer \ud835\udc58, are very close in value. This phenomenon is because assuming all points are occupied by either black or white when the game ends, the territory difference (based on the Chinese rule) must be an odd number. The only possible case\n4 In Go, seki refers to local patterns where some points, called seki points in this paper, are adjacent to two live groups of stones of different colors and neither player can fill them without dying [32].\nwhere the territory difference is even is when games end with an odd number of seki4 points. However, our statistics indicate that only 1.5% of our self-play games end this way5.\nFurthermore, we incorporate BV into our value network, for which we refer to as board evaluation and multi-labelled (BVML) value network as follows. In the BV-ML value network, additional networks are added into the value network as shown in the dashed box of Figure 1. The network in the dashed box shares the same input channels and 12 layers as the ML value network. From there, the output of the 12th layer is connected to an additional convolution layer that is connected to a sigmoid layer outputting the predicted ownership \ud835\udc42\ud835\udc43 of each point \ud835\udc43 on board. A value network with BV but without the multi-labelled component is referred to as a BV value network.\nLet us illustrate by the position shown in Figure 2 (a). Let the position shown in Figure 2 (b) be the end of the self-play game starting from the position in Figure 2 (a). Consider two points, \ud835\udc34 at coordinate Q7 occupied by black and \ud835\udc35 at E3 by white at the end of the game (as shown in Figure 2 (b)). The output \ud835\udc42\ud835\udc34 is labelled with 1, and \ud835\udc42\ud835\udc35 is labelled with 0. The ownership outputs from the inference of the BV-ML value network are shown in Figure 2 (c).\nWe also apply these value networks to our computer Go program \u201cCGI Go Intelligence\u201d (abbr. CGI), placed 6th in the 9th UEC Cup [39]. The MCTS method basically follows AlphaGo\u2019s with some slight modifications as follows. Different from AlphaGo using a mini-batch size of 1 to minimize end-toend evaluation time, we use a larger batch size of 16. The reason is simply to speed up performance by increasing the throughput. In addition, we also proposed and implemented new dynamic komi methods, as described in the next subsection."}, {"heading": "B. Dynamic Komi", "text": "This subsection first modifies both SS and VS methods (described in Subsection II.D) in order to support dynamic komi on the Go programs with value networks, and then also proposes a new dynamic komi method.\nFor the SS method, dynamic komi is adjusted based on the territory at the root node which can be generated from rollouts, board evaluation of the BV network, or a mix of the two. Let SSR, SS-B and SS-M represent the SS method using the three kinds of territory generations respectively. In SS-M, the weighting parameter \ud835\udf06 = 0.5 is used, like the way the value is mixed from the rollouts and the value network in [34]. The formula of komi rate is the same as [3].\nFor the VS method, if the current dynamic komi is \ud835\udc58, the next dynamic komi is adjusted based on the win rate at the root node, \ud835\udc64\ud835\udc58 = (1 \u2212 \ud835\udf06)\ud835\udc5f\ud835\udc58 + \ud835\udf06\ud835\udc63\ud835\udc58, where \ud835\udc5f\ud835\udc58 is the win rate of rollouts and \ud835\udc63\ud835\udc58 is the value at komi \ud835\udc58 from the ML value network. Let VSM represent the above modified VS method. Similarly, the parameter \ud835\udf06 is also 0.5. Note that we do not consider other values for \ud835\udf06, namely, where \ud835\udf06 = 0 for rollouts alone and \ud835\udf06 = 1 for the value \ud835\udc63\ud835\udc58 alone.\nThis paper also proposes a new approach to supporting dynamic komi on value networks by leveraging multi-labelling. In this approach, all the mixed win rates \ud835\udc64\ud835\udc58 = (1 \u2212 \ud835\udf06)\ud835\udc5f\ud835\udc58 + \ud835\udf06\ud835\udc63\ud835\udc58\n5 With the Japanese rules, since it is possible to end the game without counting some of the last played moves, the chance of even territory differences are higher. The details on Japanese rules are available at [32].\nare maintained. Like the VS method, we want the mixed win rates \ud835\udc64\ud835\udc58 for the dynamic komi \ud835\udc58 to fall into a predefined interval (\ud835\udc59, \ud835\udc62), or at least as close to the interval possible. Let \ud835\udc580 be the game\u2019s komi. If \ud835\udc64\ud835\udc580 is within the interval, the next dynamic komi is still \ud835\udc580 for the next move. If it is out of the interval, say \ud835\udc64\ud835\udc580 > \ud835\udc62 without loss of generality, locate the closest komi \ud835\udc58 such that \ud835\udc64\ud835\udc58 \u2264 \ud835\udc62. Then, the next dynamic komi is set to \ud835\udc580 + \ud835\udefc(\ud835\udc58 \u2212 \ud835\udc580), where \ud835\udefc is the komi rate. For example, if \ud835\udc580 is 7.5, \ud835\udc6410.5 is 57% and \ud835\udc6411.5 is 53%, then the next dynamic komi would then be adjusted to 11.5 assuming \ud835\udefc = 1 and (\ud835\udc59, \ud835\udc62) = (45%, 55%). procedure ML-BASED DYNAMIC KOMI\n1. Require: 2. i: the ordinal number of the current move to play; 3. \ud835\udc98\ud835\udc8c: the mixed win rate of the root for all komi k; 4. \ud835\udc8c\ud835\udfce: the real komi for this game; 5. \ud835\udc69: the total points of the whole board, 361 in 19 \u00d7 19 Go games; 6. c and s: parameters to decide different komi rate; 7. u and l: the contending interval (u,l); 8. if \ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52 < \ud835\udc59 then 9. Locate a komi \ud835\udc58 such that \ud835\udc98\ud835\udc58 \u2265 \ud835\udc59 and \ud835\udc98\ud835\udc58\u22121 < \ud835\udc59.\n10. else if \ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52 > \ud835\udc62 then 11. Locate a komi \ud835\udc58 such that \ud835\udc98\ud835\udc58 \u2264 \ud835\udc62 and \ud835\udc98\ud835\udc58\u22121 > \ud835\udc62. 12. else 13. Locate komi \ud835\udc58 as the \ud835\udc8c\ud835\udfce; 14. end if 15. \ud835\udc3e\ud835\udc5c\ud835\udc5a\ud835\udc56\ud835\udc37\ud835\udc56\ud835\udc53\ud835\udc53 \u2190 \ud835\udc58 \u2212 \ud835\udc580 16. \ud835\udc3a\ud835\udc4e\ud835\udc5a\ud835\udc52\ud835\udc43\u210e\ud835\udc4e\ud835\udc60\ud835\udc52 \u2190 \ud835\udc8a / \ud835\udc69 \u2212 \ud835\udc60 17. \ud835\udc3e\ud835\udc5c\ud835\udc5a\ud835\udc56\ud835\udc45\ud835\udc4e\ud835\udc61\ud835\udc52 \u2190 (1 + \ud835\udc52\ud835\udc65\ud835\udc5d(\ud835\udc50 \u2219 \ud835\udc3a\ud835\udc4e\ud835\udc5a\ud835\udc52\ud835\udc43\u210e\ud835\udc4e\ud835\udc60\ud835\udc52))\u22121 18. \ud835\udc37\ud835\udc66\ud835\udc5b\ud835\udc4e\ud835\udc5a\ud835\udc56\ud835\udc50\ud835\udc3e\ud835\udc5c\ud835\udc5a\ud835\udc56 \u2190 \ud835\udc3e\ud835\udc5c\ud835\udc5a\ud835\udc56 + \ud835\udc3e\ud835\udc5c\ud835\udc5a\ud835\udc56\ud835\udc37\ud835\udc56\ud835\udc53\ud835\udc53 \u2219 \ud835\udc3e\ud835\udc5c\ud835\udc5a\ud835\udc56\ud835\udc45\ud835\udc4e\ud835\udc61\ud835\udc52\nend procedure\nThe above new dynamic komi routine, named ML-BASED DYNAMIC KOMI (ML-DK), contains parameters which are listed in Lines 2-7. The target komi is determined in Lines 8-14. The komi rate decreases by a small amount as games progress, according to the formula in Lines 15-17, and the next dynamic komi is calculated based on the komi rate in Line 18. The komi rate depends on parameters, \ud835\udc50 and \ud835\udc60 , set to 8 and 0.45 respectively in this paper. Figure 3 (below) shows how the komi rate changes as the game progresses."}, {"heading": "IV. EXPERIMENTS", "text": "In this section, all the experiments are done on machines equipped with four GTX 980Ti GPUs, two Intel Xeon E5-2690s (28 cores total), 2.6 GHz, 128 GB memory, and run on Linux. In Subsection IV.A, we introduce four different network architectures and measure their mean squared errors (MSEs) and\nplaying strengths. In Subsection IV.B, we analyze the MSEs of these networks for games of different komi values to verify the advantage of multi-labelled (ML) value networks. The accuracy of the number of winning points in BV-ML value network are presented and analyzed in Subsection IV.C. Subsection IV.D discusses different dynamic komi techniques in MCTS with different handicap games. Subsection IV.E analyzes the performance difference when using \ud835\udc637.5 and \ud835\udc636.5 to play 6.5- komi games. Finally, we analyze the correlation of BV and ML value network in Subsection 0."}, {"heading": "A. Different Value Networks", "text": "We use our RL policy network (as described in Subsection III.A) to generate 30 million self-play games, which with four GTX 980Ti GPUs takes about 3 weeks.\nWe implement four different value networks: just the value\nnetwork, the value network with BV only, the ML value network, and the BV-ML value network. For simplicity, they are denoted respectively by VN, BV-VN, ML-VN and BV-ML-VN. When updating, the loss weight ratio between BV and VN is set to 1:1. Each network has been trained to convergence, which with four GTX 980Ti GPUs takes about 2 weeks each.\nTo measure the quality of these value networks, we analyze their MSEs like AlphaGo [34] did. Three sets of KGS games were used as our benchmark, where at least one of the players is 6 dan or higher. The three sets are: a set of 0.5-komi games chosen at random from KGS, a set of 6.5-komi games, and a set of 7.5-komi games. Each of the sets listed above consists of 10,000 games. For the \ud835\udc56-th game in one set, assume that the result of the end game is \ud835\udc67\ud835\udc56, where \ud835\udc67\ud835\udc56 is 1 for a black win, and \u22121 otherwise. Let \ud835\udc60\ud835\udc56\ud835\udc57 denote the \ud835\udc57-th position in the \ud835\udc56-th game, and \ud835\udc63(\ud835\udc60\ud835\udc56\ud835\udc57) denote the value obtained by inputting the position into the given value network. The MSE(\ud835\udc57), or the MSE at all the \ud835\udc57-th positions for all \ud835\udc5b games, where \ud835\udc5b = 10,000 in each set, is calculated by the following formula.\n1 2 \u2211 (\ud835\udc67\ud835\udc56 \u2212 \ud835\udc63(\ud835\udc60\ud835\udc56\ud835\udc57)) 2\ud835\udc5b\n\ud835\udc56=1\nFor simplicity, all the \ud835\udc57-th positions where \ud835\udc57 \u2265285 is counted in MSE(285).\nFor fairness, we use the set of 7.5-komi games as testing data, and the MSEs of the four value networks are shown in Figure 4. Since the numbers are very close, we also show the average of these MSEs in Table 2 (below). The results show that both MLVN and BV-ML-VN have lower MSEs than VN and BV-VN.\nHowever, the MSE of BV-ML-VN is not lower than that of MLVN. The reason is that the BV output only provides the probability of each point\u2019s ownership at the end of the game. It has nothing to do with the win rates, nor the MSE of the win rates.\nWe apply the four value networks respectively to our computer Go program (CGI) to compare the strengths among these networks, for which the results are shown in Table 3. For each pair of programs (with different value networks), 500 games are played with 1s/move, while one GPU and six CPU cores are used for each program. The results shows that the programs with BV-ML-VN, BV-VN and ML-VN significantly outperform the program with VN only, and that BV-ML-VN performs the best. Although the BV-VN does not perform better than ML-VN/BV-ML-VN in terms of the MSE, the strength of BV-VN is nearly equal to ML-VN and close to BV-ML-VN. For the above reason, most of experiments in the remaining of this section are based on BV-ML-VN."}, {"heading": "B. Multi-labelled Value Network in Different Komi Games", "text": "To measure the network quality in different komi games, we analyze two other data sets, the 6.5-komi and 0.5-komi games. Since the MSE of both VN and BV-VN are nearly the same and the MSE of both ML-VN and BV-ML-VN are nearly the same (also from the previous subsection), we only show the MSE of BV-VN and BV-ML-VN for simplicity.\nFirst, we analyze the MSE of value networks for 6.5-komi games. For BV-VN, since the output only contains one label (trained from 7.5-komi games), it is used to estimate win rates for these games. For BV-ML-VN, we use the value \ud835\udc636.5 to estimate win rates of these games, instead. Figure 5 (below) depicts the MSE of BV-VN and BV-ML-VN in 6.5-komi games. The MSE for BV-ML-VN is slightly lower than that for BV-VN, but the difference is not much, since few 6.5-komi games ended with black winning by 0.5 points (usually marked as \u201cB+0.5\u201d in Go game scoring). Note that 6.5-komi games with \u201cB+0.5\u201d are losses if the games were played under a komi of 7.5 points. In our statistics, among all the collected games, only 0.78% 6.5- komi games ends with \u201cB+0.5\u201d. Since these are only a very small portion of all games, most programs with value networks\ndirectly play all games based on a komi of 7.5, even for games with a komi of 6.5.\nNext, we analyze the MSE of value networks for 0.5-komi games. For BV-ML-VN, we use the value \ud835\udc630.5 to estimate win rates of these games. Figure 6 depicts the MSE of BV-VN and BV-ML-VN in 0.5-komi games.\nFrom the figure, it is interesting that the MSE of BV-ML-VN is much higher than that of BV-VN in the early stage of games, namely, about 0.6 for BV-ML-VN versus 0.5 for BV-VN at the beginning of games. The initial (empty) games are nearly even, namely about 50% for 7.5-komi games, since they are trained from 7.5-komi games (assuming both players have equal strength). Thus, the values in BV-VN and \ud835\udc637.5 in BV-ML-VN are about 50%. Based on this, when the komi is changed to 0.5, this implies that the game favors black, and the win rate of black in the beginning should be more than 50%. In reality, we observed a win rate of 63% for black in our BV-ML-VN.\nHowever, the collected 0.5-komi games are usually played by players of different ranks, where white is often one dan higher than black. From these collected games, we found that black only obtained a win rate of 39.88%, which resulted in an even higher MSE. However, after 150 moves or so, the MSE of BVML-VN becomes lower than that of BV-VN\u2019s. This is because BV-VN always uses a komi of 7.5 to estimate win rates, resulting in a progressively inaccurate evaluation as the game goes on. Statistically, only 5.33% of 0.5-komi games had the results \u201cB+0.5\u201d to \u201cB+6.5\u201d; game results in this range are interesting because they will have different outcomes under these two circumstances. Namely, they are considered winning\nif they are played with a komi of 0.5, but losing for a komi of 7.5. From the calculation of MSE (as described in Subsection IV.A), an error rate of 5.33% results in larger MSE values as shown in Figure 6. In contrast, BV-ML-VN converges (as VN does for 7.5-komi games), since BV-ML-VN can accurately estimate the situation based on the output for \ud835\udc630.5."}, {"heading": "C. The Accuracy of Winning Points in BV-ML-VN", "text": "This subsection analyzes the accuracy of winning points in the BV-ML-VN. Previously, with only one label, the BV-VN only outputs an estimate of the win rate. With multiple labels for different values of komi, BV-ML-VN is instead able to evaluate the win rates for each komi. With this extra information, we can then estimate the point difference between the two players.\nFor our analysis, we first locate a komi \ud835\udc58 such that \ud835\udc63\ud835\udc58 \u2265 50% and \ud835\udc63\ud835\udc58+1 < 50%. Then, we expect black to win if the komi is smaller than and equal to \ud835\udc58, and lose if the komi is larger than and equal to \ud835\udc58 + 1. As mentioned in the komi rules in Section I, territory differences in real games can only be integers. That is, black leads by \ud835\udc58 + 0.5 without komi. For example, in Table 1, \ud835\udc58 is 4.5, since \ud835\udc634.5 \u2265 50%, \ud835\udc635.5 < 50%, and the BV-ML-VN expects black to lead by 5 points without komi. Since the game has a komi of 7.5, the network predicts \u201cW+2.5\u201d for the position corresponding to the table. The outcome of the real game is \u201cW+4.5\u201d (as shown in Section III.A), i.e., black leads by 3 points without komi. For simplicity of discussion, we say, in the remainder of this subsection, that the network predicts black is leading by 5 points (without komi) and that the real outcome of the game is black leading by 3 points. The difference of the point gap predicted by the network and the actual outcome of the game is called the prediction distance. In the above example, the prediction distance is 2.\nNow, we want to analyze the accuracy of our value network in the following manner. First, from the set of 7.5-komi KGS games (as described in Subsection IV.A), we choose the games ending with black leading -12 to 28 points (also excluding games that were resolved through resignations), since our BVML-VN is trained with multiple labels from \ud835\udc63\u221212.5 to \ud835\udc6327.5.\nA game is said to \ud835\udc51 -predict at move \ud835\udc56 correctly, if the prediction distance of the \ud835\udc56-th position of the game is smaller than or equal to \ud835\udc51. Consequently, \ud835\udc51-prediction rates at move \ud835\udc56 are the percentage of games that \ud835\udc51-predict at move \ud835\udc56 correctly. Figure 7 shows \ud835\udc51-prediction rates for \ud835\udc51 = 0 to 7.\nFor each \ud835\udc51, the prediction rates generally grows higher as the game progresses. As \ud835\udc51 increases, the \ud835\udc51 -prediction rates also increase. From the figure, we observe that the lines tend to \u201cpair up\u201d, i.e., \ud835\udc51-prediction rates for \ud835\udc51 = 2\ud835\udc58, 2\ud835\udc58 + 1, tend to be close. The reason is similar to the one given for the paired consecutive win rates \ud835\udc632\ud835\udc58 and \ud835\udc632\ud835\udc58\u22121 in Table 1. When \ud835\udc51 is 0, the prediction rates are about 8% at the initial stage, and increase up to 32% near the end of the game. Three factors negatively impact this prediction rate. First, human players may have consistently chosen sub-optimal moves due to miscalculation or decided to play too conservatively to secure victory, resulting in less than optimal values. Second, the network may not be able to predict accurately. Third, KGS uses Japanese rules which may cause a one point difference in some games. When \ud835\udc51 is 1, the prediction rates are slightly higher about 10% at the initial stage, and increase up to 40% near the end of the game.\nWhen \ud835\udc51 is 2 or 3, the prediction rates significantly improve, from about 20% in the beginning of the game to 75% near the end. The same can be observed for \ud835\udc51 = 4 or 5, and \ud835\udc51 = 6 or 7. When \ud835\udc51 is 6 or 7, the prediction rates are about 45% at the initial stage, and grow up to 92% near the end. The analysis shows high confidence for short prediction distance even with the three negative factors pointed out in the previous paragraphs. This finding hints at the accuracy of dynamic komi; more experiments about dynamic komi are described in Subsection IV.D."}, {"heading": "D. Dynamic Komi and Handicap Games", "text": "This subsection analyzes the performances of six different dynamic komi methods, namely, no dynamic komi, SS-R, SS-B, SS-M, VS-M, and ML-DK as described in Subsection III.B. For both VS-M and ML-DK, the win rate interval is (45%, 55%). For SS-* and ML-DK, we choose the setting of komi rates by letting parameters \ud835\udc50 = 8 and \ud835\udc60 = 0.45. The above dynamic komi methods are incorporated into our Go program CGI with BV-ML-VN. In this experiment, the baseline we choose is the version of our early CGI program which participated in the 9th UEC Cup. For each dynamic komi method, let the program with the method play against the baseline 250 games, each of which is played on 19 \u00d7 19 boards with one second per move. Since our BV-ML-VN supports \ud835\udc63\u221212.5 to \ud835\udc6327.5 only and one-stone handicap was valued at about 7 points difference according to the experiments in [3], we only analyze 1-stone to 4-stone handicaps, in addition to even games. The komi is set to 0.5 in handicap games, and 7.5 in even games.\nTable 4 presents the result for various dynamic komi methods in even games. The result shows that the version with ML-DK outperforms all other versions.\nTable 5 shows the results for all methods in 1-stone to 4-stone handicap games, denoted by H1 to H4 respectively, against the baseline when playing as white. Generally, both SS-R and MLDK clearly outperforms all the other methods. ML-DK performs better for H1 and H3, while SS-R performs better for H2 and H4. All in all, considering even and handicapped games altogether, ML-DK appears to perform slightly better than SS-R.\nThe SS-* methods, regardless of using either rollout or BV for territory estimation, show improvement over not using dynamic komi. The best method seems to be SS-R, while SS-M seems to be the worst among the three SS-* methods. A conjecture for why this is the case is that territory estimates using rollout and BV may be conflicting.\nSecond, while the VS method performed the best in [3], in our experiments, the VS-M method did not perform well. In fact, it performs nearly the same as when dynamic komi is not used at all. We observed that the adjustment of dynamic komi using rollouts is relatively slow when compared to that for BV-MLVN. Figure 8 shows the win rates of rollout and BV-ML-VN with respect to different komi values at the beginning of a game (with an empty board). In the figure, the value of BV-ML-VN is sensitive to each komi value change and is empirically accurate as shown in Subsection IV.C, while the value of rollout is less sensitive as komi changes. Thus, the VS-M method, which only adjusts \u00b11 each time komi changes, is slow to handle the values obtained from value networks. In [3], since only the rollout was used, it performed relatively well.\nIn fact, this is what motivated us to design the ML-DK method,\nwhich adjusts dynamic komi more responsively. Whenever the\nscore and its corresponding win rate is significantly changed, the next dynamic komi is adjusted quickly and accurately by making full use of the BV-ML-VN.\nNext, consider the case where only the VN is available. Since multi-labelled values are not available, dynamic methods can only be applied to rollouts. Table 6 shows the results of the two previous best methods when using the SS-R and ML-DK. The results in Table 6 are clearly lower than the same methods in Table 5, showing that having multi-labelled values is clearly superior when they are available.\nE. 6.5-Komi vs. 7.5-Komi\nIn this subsection, we perform experiments to demonstrate and analyze the effect of using the value network (BV-ML-VN) trained from 7.5-komi games to play on 6.5-komi games. First, a black-winning game with score 0.5 in a 6.5-komi game is actually a white-winning game with score -0.5 in a 7.5-komi game. Therefore, among all the KGS 6.5-komi games, we collected 2630 games (about 0.68%) ending with score 0.5 for our analysis.\nThe experiment tries to investigate whether for any of such\ngames, using \ud835\udc636.5 from the BV-ML-VN, denoted by VN-6.5, helps in contrast to a value network trained from 7.5-komi games, denoted by VN-7.5. For simplicity, for VN-7.5, we actually use the BV-ML-VN\u2019s output \ud835\udc637.5 , instead of a normal value network trained from 7.5-komi games. To reduce human mistakes, we choose the 10th position from the end of a game as the starting position of a game. For fairness, each game is played twice between the two programs; a program will play as black and white exactly once each for the game. For each move, both programs are given one second.\nThe experimental result shows a win rate of 51.52\u00b11.22% for the 2630 games. Among the 2630 games, 80 more games are won both times by VN-6.5. This implies that using \ud835\udc636.5 does matter, though not by much, which is as expected from the following two reasons. First, in these games, human players may still often miscalculate and make blunders (as described in Subsection IV.C) even for these final 10 moves. Therefore, most of these games may not actually end with score 0.5 for 6.5-komi games. Second, rollout is often sufficient in obtaining a reasonable win rate, which remedies and greatly reduces the problem of using 7.5-komi VN, especially during the end games. Let us illustrate this by a case where black is to lead by 7 points in the optimal play; that is, the position will be winning if the game\u2019s komi was set to 6.5 and losing if set to 7.5. Assume black is to move. Let the moves that result in a lead of 7 points be called the optimal moves. In general, the VN based on 7.5-komi games will evaluate that all moves (even for the optimal moves) will have a very low win rate, say nearly 0%. In such a situation, as long as the rollout plays accurately, the mixed value (the average of rollout and VN output) can still differentiate the\noptimal moves from others. Thus, the program will tend to play the optimal moves. The situation is similar when assuming white is to play, so the discussion is omitted. Hence, most programs find using networks trained from 7.5-komi games to be sufficient."}, {"heading": "F. The Correlation between BV and VN", "text": "In this subsection, the correlation between BV and VN in the BV-ML-VN is depicted in a scatter plot as Figure 9 (below). In this figure, each dot represents a position, and only 2,000 positions are chosen from KGS 7.5-komi games at random for simplicity. For each dot, the y-axis is the value \ud835\udc637.5 of the corresponding position, and the x-axis indicates territory based on BV, namely the sum of ownership probabilities of all the board points from the outputs of BV. The figure shows that both are correlated in general, as indicated by a regressed line (in black), centered around (7.5, 50%). Most dots to the right of the vertical line (in red) at 7.5 have values (win rates) higher than 50%, while most dots to the left have values lower than 50%. These dots indicate positive correlation between the board ownership (from BV) and the win rate (from VN). On the other hand, only 6.85% of the dots are in the lower right and 5.3% are in the upper left, which indicate native correlation.\nFigure 10 shows another scatter plot on 0.5-komi games. The only difference between Figure 9 and Figure 10 is the value of the y-axis, namely, the y-axis is the value \ud835\udc630.5 in Figure 10. Interestingly, we can see all the dots have shifted slightly to the left, and centered around the 0.5 line again (in red). Only 2.7% of the dots are in the lower right and 7.8% are in the upper left, which indicate native correlation.\nThese figures show that BV gives clues about the win rates of VN. However, the figures do not imply that the values from VN can be directly derived from the ownership probabilities of the BV."}, {"heading": "V. CONCLUSIONS", "text": "This paper proposes a new approach for a value network architecture in the game of Go, called a multi-labelled (ML) value network. The ML value network has the three advantages, (a) offering different value settings of komi, (b) supporting dynamic komi, and (c) lowering the mean squared error (MSE). In addition, board evaluation (BV) is also incorporated into the ML value network to help slightly improve the game-playing strength.\nA metric called the \ud835\udc51-prediction rate is devised to measure the quality of final score prediction from ML value networks. Experimental results show high confidence on the predicted scores. This shows that the predicted score can be used for dynamic komi. New dynamic komi methods are then designed to support the ML value network, which then improved the game-playing strength of our program, especially for handicap games.\nExperiments were conducted to demonstrate and analyze the merits of our architecture and dynamic komi methods. 1. The MSE of the BV-ML value network is generally lower\nthan the VN alone, especially for those games with komi other than 7.5. 2. The program using the BV-ML value network outperforms those using other value networks. Most significantly, it\nwins against the baseline program, which has just the value network, by a rate of 67.6%. The programs using either just the ML value network or the BV value network also significantly outperform the baseline.\n3. For the BV-ML value network, our experiments show the \ud835\udc51 -prediction rates as follows. When \ud835\udc51 is 0, the \ud835\udc51 - prediction rates are about 8% in the initial stage of the game,\ngrowing to 32% near the end. When \ud835\udc51 increases, the \ud835\udc51- prediction rates also increase. For example, when \ud835\udc51 is 6, the prediction rates significantly improve, with about 45% in the initial stage, growing up to 92% near the end. The results show high confidence for short prediction distance, even with the three negative effects described in Subsection IV.C. 4. Experiments show that the proposed ML-DK method improves playing strength. The program with ML-DK wins\nagainst a baseline by win rates of 80.0%, 57.2%, 41.6% and 18.4% for 1-stone, 2-stone, 3-stone and 4-stone handicap games respectively. In contrast, the program without using any dynamic komi methods wins by 74.0%, 50.0%, 30.4% and 10.8%. We also investigate other dynamic komi methods such as SS-R, SS-B, SS-M, and VS-M. Among these methods, SS-R performs the best. SS-R also performs better than ML-DK for 2-stone and 4-stone handicap games, but not in any other conditions. 5. Experiments in Subsection IV.E demonstrate that the BVML value network, trained from 7.5-komi games, does\nimprove (not by much though) over the value network without ML when playing 6.5-komi games.\n6. Our experiments also show high correlation between ML value network output values and BV output values.\nFrom the above, the BV-ML value network proposed by this paper can be easily and flexibly generalized to different komi games. This is especially important for playing handicap games. To our knowledge, up to date, no handicap games have been played openly by programs utilizing value networks. It can be expected that the interest to see handicap games played by programs (e.g., handicap games between top Go programs and top players) will grow, especially when Go programs continually grow stronger. This paper provides programs with a useful approach to playing handicap games."}, {"heading": "ACKNOWLEDGMENT", "text": "The authors would like to thank the Ministry of Science and\nTechnology of the Republic of China (Taiwan) for financial support of this research under contract numbers MOST 104-\n2221-E-009-127-MY2, 104-2221-E-009-074-MY2 and 105-\n2218-E-259-001."}], "references": [{"title": "Searching for Solutions in Games and Artificial Intelligence", "author": ["L.V. Allis"], "venue": "Ph.D. Thesis,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1994}, {"title": "Finite-time analysis of the multiarmed bandit problem", "author": ["P. Auer", "N. Cesa-Bianchi", "P. Fischer"], "venue": "Machine learning, 47(2-3),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2002}, {"title": "Balancing MCTS by dynamically adjusting the komi value", "author": ["P. Baudi\u0161"], "venue": "ICGA Journal, 34(3),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "Pachi: State of the art open source Go program", "author": ["P. Baudi\u0161", "J.L. Gailly"], "venue": "In Advances in computer games,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2011}, {"title": "A survey of monte carlo tree search methods", "author": ["C.B. Browne", "E. Powley", "D. Whitehouse", "S.M. Lucas", "P.I. Cowling", "P. Rohlfshagen", "S. Tavener", "D. Perez", "S. Samothrakis", "S. Colton"], "venue": "IEEE Transactions on Computational Intelligence and AI in games,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Residual Networks for Computer Go", "author": ["T. Cazenave"], "venue": "Accepted by IEEE Transactions on Computational Intelligence and AI in Games,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2017}, {"title": "The move decision process of Go Intellect", "author": ["K. Chen"], "venue": "Computer Go, (14),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1990}, {"title": "Training deep convolutional neural networks to play go", "author": ["C. Clark", "A. Storkey"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Computing elo ratings of move patterns in the game of go", "author": ["R. Coulom"], "venue": "In Computer games workshop,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2007}, {"title": "Efficient selectivity and backup operators in Monte Carlo tree search.", "author": ["Coulom", "R\u00e9mi"], "venue": "International Conference on Computers and Games. Springer Berlin Heidelberg,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "Fuego\u2014an opensource framework for board games and Go engine based on Monte Carlo tree search", "author": ["M. Enzenberger", "M. Muller", "B. Arneson", "R. Segal"], "venue": "IEEE Transactions on Computational Intelligence and AI in Games, 2(4),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Knowledge Representation in The Many Faces of Go, available at http://www.smart-games.com/knowpap.txt", "author": ["D. Fotland"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1993}, {"title": "Combining online and offline knowledge in UCT", "author": ["S. Gelly", "D. Silver"], "venue": "In Proceedings of the 24th international conference on Machine learning,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2007}, {"title": "The grand challenge of computer Go: Monte Carlo tree search and extensions", "author": ["S. Gelly", "L. Kocsis", "M. Schoenauer", "M. Sebag", "D. Silver", "C. Szepesv\u00e1ri", "O. Teytaud"], "venue": "Communications of the ACM,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}, {"title": "Using Deep Convolutional Neural Networks in Monte Carlo Tree Search", "author": ["T. Graf", "M. Platzner"], "venue": "In International Conference on Computers and Games, Springer International Publishing,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2016}, {"title": "Message to the computer-go mailing list, Different Rules", "author": ["H. Kato"], "venue": "Available: http://computer-go.org/pipermail/computer-go/2017- March/009995.html,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2017}, {"title": "Message to the computer-go mailing list, Zen lost to Mi Tu Ting", "author": ["H. Kato"], "venue": "Available: http://computer-go.org/pipermail/computer-go/2017- March/009979.html,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2017}, {"title": "Bandit based monte-carlo planning", "author": ["L. Kocsis", "C. Szepesv\u00e1ri"], "venue": "In European conference on machine learning,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2006}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "In Advances in Neural Information Processing Systems (NIPS),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Move evaluation in go using deep convolutional neural networks", "author": ["C.J. Maddison", "A. Huang", "I. Sutskever", "D. Silver"], "venue": "arXiv preprint arXiv:1412.6564,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2014}, {"title": "Human-level control through deep reinforcement learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski", "S. Petersen"], "venue": "Nature, 518(7540),", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2015}, {"title": "Message to the computer-go mailing list, Training the value network (a possibly more efficient approach)", "author": ["B. Peng"], "venue": "Available: http://computergo.org/pipermail/computer-go/2017-January/009820.html,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2017}, {"title": "Multi-armed bandits with episode context", "author": ["C.D. Rosin"], "venue": "Annals of Mathematics and Artificial Intelligence, 61(3),", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2011}, {"title": "Reinforcement learning and simulation based search in the game of Go", "author": ["D. Silver"], "venue": "Ph.D. dissertation, Dept. Comput. Sci., Univ. Alberta,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2009}, {"title": "Mastering the game of Go with deep neural networks and tree search", "author": ["D. Silver", "A. Huang", "C.J. Maddison", "A. Guez", "L. Sifre", "G. Van Den Driessche", "J. Schrittwieser", "I. Antonoglou", "V. Panneershelvam", "M. Lanctot", "S. Dieleman"], "venue": "Nature, 529(7587),", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2016}, {"title": "Policy gradient methods for reinforcement learning with function approximation", "author": ["R.S. Sutton", "D.A. McAllester", "S.P. Singh", "Y. Mansour"], "venue": "In Advances in Neural Information Processing Systems (NIPS),", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 1999}, {"title": "On-line policy improvement using Monte- Carlo search", "author": ["G. Tesauro", "G.R. Galperin"], "venue": "In Advances in Neural Information Processing Systems (NIPS),", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1996}, {"title": "Better computer go player with neural network and long-term prediction", "author": ["Y. Tian", "Y. Zhu"], "venue": "arXiv preprint arXiv:1511.06410,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2015}, {"title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "author": ["R.J. Williams"], "venue": "Machine learning,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1992}], "referenceMentions": [{"referenceID": 0, "context": "The authors are with the Department of Computer Science, National Chiao Although the rules of Go are simple, its game tree complexity is extremely high, estimated to be 10 in [1][40].", "startOffset": 175, "endOffset": 178}, {"referenceID": 13, "context": "In the past, computer Go was listed as one of the AI grand challenges [16][28].", "startOffset": 70, "endOffset": 74}, {"referenceID": 6, "context": "By 2006, the strengths of computer Go programs were generally below 6 kyu [5][8][14], far away from amateur dan players.", "startOffset": 77, "endOffset": 80}, {"referenceID": 11, "context": "By 2006, the strengths of computer Go programs were generally below 6 kyu [5][8][14], far away from amateur dan players.", "startOffset": 80, "endOffset": 84}, {"referenceID": 4, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 40, "endOffset": 43}, {"referenceID": 9, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 43, "endOffset": 47}, {"referenceID": 12, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 47, "endOffset": 51}, {"referenceID": 17, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 51, "endOffset": 55}, {"referenceID": 26, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 55, "endOffset": 59}, {"referenceID": 3, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 134, "endOffset": 137}, {"referenceID": 8, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 137, "endOffset": 141}, {"referenceID": 10, "context": "In 2006, Monte Carlo tree search (MCTS) [6][11][15][23][37] was invented and computer Go programs started making significant progress [4][10][13], roughly up to 6 dan in 2015.", "startOffset": 141, "endOffset": 145}, {"referenceID": 24, "context": "In 2016, this grand challenge was achieved by the program AlphaGo [34] when it defeated (4:1) Lee Sedol, a 9 dan grandmaster who had won the most world Go champion titles in the past decade.", "startOffset": 66, "endOffset": 70}, {"referenceID": 24, "context": "Up to date, DeepMind, the team behind AlphaGo, had published the techniques and methods of AlphaGo in Nature [34].", "startOffset": 109, "endOffset": 113}, {"referenceID": 18, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 135, "endOffset": 139}, {"referenceID": 5, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 187, "endOffset": 190}, {"referenceID": 7, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 190, "endOffset": 193}, {"referenceID": 14, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 193, "endOffset": 197}, {"referenceID": 19, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 197, "endOffset": 201}, {"referenceID": 27, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 201, "endOffset": 205}, {"referenceID": 20, "context": "AlphaGo was able to surpass experts\u2019 expectations by proposing a new method that uses three deep convolutional neural networks (DCNNs) [24][25]: a supervised learning (SL) policy network [7][9][18][26][38] learning to predict experts\u2019 moves from human expert game records, a reinforcement learning (RL) policy network [27] improving the SL policy network via self-play, and a value network that performs state evaluation based on self-play game simulations.", "startOffset": 318, "endOffset": 322}, {"referenceID": 16, "context": ", the program DeepZenGo\u2019s losing match [21] during the World Go Championship [29] against Mi Yuting, one of the top players in the world ranking [12], who, to date, had a highest ranking of being the third strongest player.", "startOffset": 39, "endOffset": 43}, {"referenceID": 15, "context": "At the time, one of the authors of DeepZenGo proposed a trick [20] to offset the expected inaccuracies by setting komi to 5.", "startOffset": 62, "endOffset": 66}, {"referenceID": 24, "context": "With these new approaches, the ML value network can not only offer games with different komi, but also support dynamic komi (which was not supported in [34]) to improve the game playing strength.", "startOffset": 152, "endOffset": 156}, {"referenceID": 2, "context": "C, and discusses the dynamic komi technique for MCTS [3] in Subsection II.", "startOffset": 53, "endOffset": 56}, {"referenceID": 25, "context": "To further improve the policy network, AlphaGo trained a policy network through self-play via reinforcement learning (RL) [35][36].", "startOffset": 126, "endOffset": 130}, {"referenceID": 28, "context": "The above described process followed the REINFORCE algorithm [41], which is summarized below:", "startOffset": 61, "endOffset": 65}, {"referenceID": 3, "context": "With the RL training complete, AlphaGo was able to win 85% of the games played against Pachi [4], an opensource computer Go program.", "startOffset": 93, "endOffset": 96}, {"referenceID": 4, "context": "Monte Carlo Tree Search (MCTS) [6] is a best-first search algorithm on top of a search tree [23][33], using Monte Carlo rollouts to estimate state values.", "startOffset": 31, "endOffset": 34}, {"referenceID": 17, "context": "Monte Carlo Tree Search (MCTS) [6] is a best-first search algorithm on top of a search tree [23][33], using Monte Carlo rollouts to estimate state values.", "startOffset": 92, "endOffset": 96}, {"referenceID": 23, "context": "Monte Carlo Tree Search (MCTS) [6] is a best-first search algorithm on top of a search tree [23][33], using Monte Carlo rollouts to estimate state values.", "startOffset": 96, "endOffset": 100}, {"referenceID": 1, "context": "A tree policy, traditionally the upper confidence bounds (UCB) function [2], is used to select positions (states) from the root to one of the leaves.", "startOffset": 72, "endOffset": 75}, {"referenceID": 22, "context": "AlphaGo used the PUCT algorithm [31] (serving as the tree policy) to select states in a tree, and applied the SL policy network and the value network to MCTS by asynchronous updates.", "startOffset": 32, "endOffset": 36}, {"referenceID": 21, "context": "To date, none have exploited this idea further except a few discussions given in [30].", "startOffset": 81, "endOffset": 85}, {"referenceID": 2, "context": "In traditional computer Go programs with MCTS, dynamic komi [3] is a technique that is widely used to make the program play more aggressively, especially for handicap games.", "startOffset": 60, "endOffset": 63}, {"referenceID": 2, "context": "There are two methods in [3] that adjust the komi dynamically, providing this incentive to play better in extreme conditions.", "startOffset": 25, "endOffset": 28}, {"referenceID": 2, "context": "(45%, 50%) [3]), or at least as close to the interval as possible.", "startOffset": 11, "endOffset": 14}, {"referenceID": 2, "context": "In [3], some criterion is also used to avoid oscillation of komi values, especially in the endgame.", "startOffset": 3, "endOffset": 6}, {"referenceID": 2, "context": "1000 [3].", "startOffset": 5, "endOffset": 8}, {"referenceID": 2, "context": "Previous research reported to work fine with the latter [3], while Aya, a notable Go program, chose to use the former [42].", "startOffset": 56, "endOffset": 59}, {"referenceID": 2, "context": "In [3], the author also mentioned the possibility of increasing or decreasing by more than one when using the VS method.", "startOffset": 3, "endOffset": 6}, {"referenceID": 27, "context": "As a side note, we trained the SL policy network with 3-step prediction, which was proposed in [38].", "startOffset": 95, "endOffset": 99}, {"referenceID": 3, "context": "resulting strength of our policy network won 70% of games against Pachi [4].", "startOffset": 72, "endOffset": 75}, {"referenceID": 24, "context": "5 is used, like the way the value is mixed from the rollouts and the value network in [34].", "startOffset": 86, "endOffset": 90}, {"referenceID": 2, "context": "The formula of komi rate is the same as [3].", "startOffset": 40, "endOffset": 43}, {"referenceID": 24, "context": "To measure the quality of these value networks, we analyze their MSEs like AlphaGo [34] did.", "startOffset": 83, "endOffset": 87}, {"referenceID": 2, "context": "5 only and one-stone handicap was valued at about 7 points difference according to the experiments in [3], we only analyze 1-stone to 4-stone handicaps, in addition to even games.", "startOffset": 102, "endOffset": 105}, {"referenceID": 2, "context": "Second, while the VS method performed the best in [3], in our experiments, the VS-M method did not perform well.", "startOffset": 50, "endOffset": 53}, {"referenceID": 2, "context": "In [3], since only the rollout was used, it performed relatively well.", "startOffset": 3, "endOffset": 6}], "year": 2017, "abstractText": "This paper proposes a new approach to a novel value network architecture for the game Go, called a multi-labelled (ML) value network. In the ML value network, different values (win rates) are trained simultaneously for different settings of komi, a compensation given to balance the initiative of playing first. The ML value network has three advantages, (a) it outputs values for different komi, (b) it supports dynamic komi, and (c) it lowers the mean squared error (MSE). This paper also proposes a new dynamic komi method to improve game-playing strength. This paper also performs experiments to demonstrate the merits of the architecture. First, the MSE of the ML value network is generally lower than the value network alone. Second, the program based on the ML value network wins by a rate of 67.6% against the program based on the value network alone. Third, the program with the proposed dynamic komi method significantly improves the playing strength over the baseline that does not use dynamic komi, especially for handicap games. To our knowledge, up to date, no handicap games have been played openly by programs using value networks. This paper provides these programs with a useful approach to playing handicap games. Keywords\u2014Value Network, Policy Network, Supervised Learning, Reinforcement Learning, Dynamic Komi, Computer Go,", "creator": "Microsoft\u00ae Word 2013"}}}