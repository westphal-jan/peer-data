{"id": "1708.05522", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Aug-2017", "title": "Exploring Directional Path-Consistency for Solving Constraint Networks", "abstract": "Among after separate liking methodologies applied making task constraint system, towards - consistency (PC) has 20 a as deal of despite. However, safeguards PC does chillingly purchase working less way unnecessary. Directional path - durability (DPC) is hand weaker purely of PC that consider a given fixed ordering and see thus same curfew likely competently as PC. This selling shows others DPC (the DPC restricting computes following Dechter between Pearl) proceed once necessitates importance problem (CSP) although taking constraint fluent but any instance this and because the function round property (VEP ). However, make major show as no complete VEP formula_13 language can there a user it fewer fewer 2002 desire. We next in setting simple variant seen. DPC computable, 's DPC *, some showing what under CSP part called thermodynamic definition therefore never decided by DPC * nor it for closed under gave within possible. In extent, DPC * is amounts already protects retract - free search for because constraint operating. Examples include majority - yesterday determines classes include its girls latter connected behind - cross-section (CRC) constraints which cave - vital complexity, same far well databases same various top-level, such such mysterious applying, temporal analysis, generalizations reasoning, own correct utilize. Our experimenting evaluations show that DPC * expanding netvista created washington - called - the - literature implementations same aspect moderates - ended adequate.", "histories": [["v1", "Fri, 18 Aug 2017 07:06:23 GMT  (647kb,D)", "http://arxiv.org/abs/1708.05522v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["shufeng kong", "sanjiang li", "michael sioutis"], "accepted": false, "id": "1708.05522"}, "pdf": {"name": "1708.05522.pdf", "metadata": {"source": "CRF", "title": "Exploring Directional Path-Consistency for Solving Constraint Networks", "authors": ["Shufeng Kong", "Sanjiang Li", "Michael Sioutis"], "emails": ["michael.sioutis@oru.se"], "sections": [{"heading": null, "text": "We then present a simple variant of the DPC algorithm, called DPC\u2217, and show that the CSP of a constraint language can be decided by DPC\u2217 if it is closed under a majority operation. In fact, DPC\u2217 is sufficient for guaranteeing backtrack-free search for such constraint networks. Examples of majority-closed constraint classes include the classes of connected row-convex (CRC) constraints and tree-preserving constraints, which have found applications in various domains, such as scene labeling, temporal reasoning, geometric reasoning, and logical filtering. Our experimental evaluations show that DPC\u2217 significantly outperforms the state-of-the-art algorithms for solving majority-closed constraints.\nKeywords: Path-consistency; directional path-consistency; constraint networks"}, {"heading": "1 Introduction", "text": "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26]. A constraint network comprises a set of variables ranging over some domain of possible values, and a set of constraints that specify allowed value combinations for these variables. Solving a constraint network amounts to assigning values to its variables such that its constraints are satisfied. Backtracking search is the principal mechanism for solving a constraint network; it assigns values to variables in a depth-first manner, and backtracks to the previous variable assignment if there are no consistent values for the variable at hand. Local consistency techniques are commonly used to reduce the size of the search space before commencing search. However, searching for a complete solution for a constraint network is still hard. In fact, even deciding whether the constraint network has a solution is NP-complete in general. Therefore, given a particular ar X iv :1\n70 8.\n05 52\n2v 1\n[ cs\n.A I]\n1 8\nA ug\n2 01\n7\nform of local consistency, a crucial task is to determine problems that can be solved by backtrack-free search using that local consistency [17].\nThis paper considers a particular form of local consistency, called path-consistency (PC), which is one of the most important and heavily studied local consistencies in the literature (see e.g. [27,29,32,6,10]). Recently, it was shown that PC can be used to decide the satisfiability of a problem if and only if the problem does not have the ability to count [2,1]; however, it remains unclear whether backtrack-free search can be used to extract a solution for such a problem after enforcing PC.\nDirectional path-consistency (DPC) [15] is a weaker notion of PC that considers a given variable ordering and can thus be enforced more efficiently than PC. The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33]. It is then natural to ask what binary constraint networks with finite domains can be solved by DPC. Dechter and Pearl [15] showed that DPC is sufficient for enabling backtrack-free search for networks with constraint graphs of regular width 2. We consider the aforementioned question in the context of constraint languages, which is a widely adopted approach in the study of tractability of constraint satisfaction problems [8]. Specifically, we are interested in finding all binary constraint languages \u0393 such that the consistency of any constraint network defined over \u0393 can be decided by DPC.\nTo this end, we first exploit the close connection between DPC and variable elimination by defining constraint languages that have the (weak) variable elimination property (VEP) (which will become clear in Definition 6). We call a constraint language \u0393 complete if it contains all relations that are definable in \u0393 (in the sense of Definition 3). Then, we show that the constraint satisfaction problem (CSP) of a complete constraint language \u0393 can be decided by DPC if it is complete and has VEP, which is shown to be equivalent to the Helly property. However, we also show that no complete VEP constraint language can have a domain with more than 2 values.\nWe then present a simple variant of the algorithm DPC, called DPC\u2217, and show that the consistency of a constraint network can be decided by DPC\u2217 if it is defined over any majority-closed constraint language. In fact, we show that DPC\u2217 is sufficient for guaranteeing backtrack-free search for such constraint networks. Several important constraint classes have been found to be majority-closed. The most well-known one is the class of connected row-convex (CRC) constraints [16], which is further generalized to a larger class of tree-preserving constraints [20]. The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20]. We also conduct experimental evaluations to compare DPC\u2217 to the state-of-the-art algorithms for solving majority-closed constraints, and show that DPC\u2217 significantly outperforms the latter algorithms.\nThe remainder of this paper is organized as follows. In Section 2 we introduce basic notions and results that will be used throughout the paper. In Section 3 we present the DPC algorithm, and in Section 4 we discuss the connection between DPC and variable elimination. In Section 5 we prove that a complete constraint language \u0393 has weak VEP if and only if \u0393 is majority-closed. We then present in Section 6 our variable\nelimination algorithm DPC\u2217, and empirically evaluate DPC\u2217 in Section 7. Finally, Section 8 concludes the paper."}, {"heading": "2 Preliminaries", "text": "This section recalls necessary notions and results.\nDefinition 1. A binary constraint network (BCN) N is a triple \u3008V,D, C\u3009, where\n\u2013 V = {v1, . . . , vn} is a nonempy finite set of variables; \u2013 D = {D1, . . . , Dn}, where Di is the domain of vi; \u2013 C = {(sp, Rp) | 1 \u2264 p \u2264 m} is a set of binary constraints, where sp = (vi, vj)(i 6= j) (called the scope of (sp, Rp)) is a pair of variables in V and Rp (called the constraint relation of (sp, Rp)) is a subset of Di \u00d7Dj .\nGiven a BCN N = \u3008V,D, C\u3009 and any pair of variables (vi, vj) with vi, vj \u2208 V and vi 6= vj , we assume that there exists at most one constraint between the pair. For simplicity, we will often denote the constraint between vi and vj by Rij . Further, we assume Rij = R\u22121ji , which is the inverse of Rji. We write Rij \u2208 C throughout the paper to state that a constraint with scope (vi, vj) is in C. Usual operations on relations such as intersection (\u2229), composition (\u25e6), and inverse (\u22121) are also assumed.\nA partial solution of N w.r.t. a subset V \u2032 of V is an assignment of values to variables in V \u2032 such that all of the constraints Rij with vi, vj \u2208 V \u2032 are satisfied. A partial solution w.r.t. V is called a solution ofN . We say thatN is consistent or satisfiable if it admits a solution, and inconsistent or unsatisfiable otherwise. A BCN N = \u3008V,D, C\u3009 is said to be globally consistent if every partial solution w.r.t. V \u2032 \u2286 V can be consistently extended to a solution w.r.t. V . Further,N is said to be trivially inconsistent if C contains an empty constraint orD contains an empty domain. Two BCNs are equivalent if they have the same set of solutions.\nExample 1. Consider a BCN N = \u3008V,D, C\u3009, where\n\u2013 V = {v1, v2, v3, v4}; \u2013 Di = {a, b, c} for i = 1, 2, 3, 4; \u2013 C = {R12, R23, R34, R24} where\nR12 = 1 1 11 1 0 1 0 0 , R34 = 1 1 11 0 0 1 0 0 , and R32 = R24 = 1 1 10 1 1 0 0 1 . We use Boolean matrices to represent binary relations. For example, R12 represents the relation {\u3008a, a\u3009, \u3008a, b\u3009, \u3008a, c\u3009, \u3008b, a\u3009, \u3008b, b\u3009, \u3008c, a\u3009} between v1 and v2, where the values in both D1 and D2 are ordered as a \u227a b \u227a c. It is easy to check that \u03c3 = \u3008a, a, a, a\u3009 is a solution of N .\nThe constraint graph GN of N = \u3008V,D, C\u3009 is the undirected graph (V,E), where eij \u2208 E iff Rij \u2208 C. We assume eij is always labeled with its corresponding constraint Rij . Fig. 1 shows the constraint graph of the BCN in Example 1.\nAn undirected graph G is triangulated or chordal if every cycle of length greater than 3 has a chord, i.e., an edge connecting two non-consecutive vertices of the cycle. The constraint graphGN of a networkN = \u3008V,D, C\u3009 can be completed or triangulated by adding new edges eij labeled with the universal constraint Di \u00d7Dj .\nTriangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33]. A graphG is triangulated iff it admits a perfect elimination ordering (PEO) [18]. An ordering \u227a of the vertices of a graph G = (V,E) is a PEO if Fv = {w | (v, w) \u2208 E, v \u227a w} for all of v \u2208 V , i.e., the set of successors of v in the ordering induces a complete subgraph of G (see Fig. 1 for an example).\nA variable vi is arc-consistent (AC) relative to a variable vj (or Rij) if for any a \u2208 Di we have some b \u2208 Dj such that \u3008a, b\u3009 \u2208 Rij . Given a constraint graph GN = (V,E), an edge eij ofGN is AC if vi is AC relative to vj . Let \u03c0 = (v0, \u00b7 \u00b7 \u00b7 , vi, \u00b7 \u00b7 \u00b7 , vk) be a path inGN with e0k \u2208 E. We say that \u03c0 is path-consistent (PC) if for all \u3008c0, ck\u3009 \u2208 R0k we can find values for all intermediate variables vi (0 < i < k) such that all the constraints Ri,i+1 (0 \u2264 i < k) are satisfied. See Fig. 2 for an illustration. In particular, (v0, v2) is PC relative to a third vertex v1 if e01, e12, and e02 are all in E and the path \u03c0 = (v0, v1, v2) is PC. A constraint graph GN is AC (resp. PC) iff all edges (resp. paths) in GN are AC (resp. PC); GN is strongly PC iff it is both AC and PC. A constraint network N is AC if GN is AC and N is PC if the competition of GN is PC [6].\nConsider the BCN N in Example 1. We can see that every edges in GN is AC, but the path \u03c0 = (v3, v2, v4) is not PC as R34 is not contained in R32 \u25e6R24.\nIn this paper we are concerned with BCNs defined over a particular constraint language and we use constraint languages, constraint classes and sets of relations interchangeably.\nDefinition 2. [19] Let D = {D1, . . . , Dn} be a set of domains. An n-ary relation R overD is a subset ofD1\u00d7 . . .\u00d7Dn. For any tuple t \u2208 R and any 1 \u2264 i \u2264 n, we denote by t[i] the value in the i-th coordinate position of t and write t as \u3008t[1], . . . , t[n]\u3009.\nDefinition 3. [19] Given a set of binary relations \u0393 , we write \u0393+ for the set of relations that can be obtained from \u0393 using some sequence of the following operations:\n\u2013 Cartesian product, i.e., for R1, R2 \u2208 \u0393,R1 \u00d7R2 = {\u3008t1, t2\u3009 | t1 \u2208 R1, t2 \u2208 R2}, \u2013 equality selection, i.e., for R \u2208 \u0393, \u03c4i=j(R) = {t \u2208 R | t[i] = t[j]}, and \u2013 projection, i.e., for R \u2208 \u0393, \u03c0i1,\u00b7\u00b7\u00b7 ,ik(R) = {\u3008t[i1], \u00b7 \u00b7 \u00b7 , t[ik]\u3009 | t \u2208 R}.\nA relation R is said to be definable in \u0393 if R \u2208 \u0393+, and a set of binary relations \u0393 is said to be complete if every binary relation definable in \u0393 is also contained in \u0393 . The completion of \u0393 , written as \u0393 c, is the set of all binary relations contained in \u0393+.\nThe following lemma asserts that a complete set of binary relations \u0393 is closed under the operations that are used to achieve PC and AC.\nLemma 1. [11] Let \u0393 be a complete set of binary relations over a domainD. Suppose R,S are binary relations and T a unary relation, all in \u0393 . Then R \u2229 S, R \u25e6 S, and T \u2032 = {a \u2208 D | \u3008a, b\u3009 \u2208 R, b \u2208 T} are also all in \u0393 .\nLet \u0393 be a set of binary relations. A BCN N = \u3008V,D, C\u3009 is defined over (or, simply, over) \u0393 if R \u2208 \u0393 for every constraint (s,R) in C. The constraint satisfaction problem (CSP) of \u0393 , denoted by CSP(\u0393 ), is the problem of deciding the consistency of BCNs defined over \u0393 . CSP(\u0393+) is log-space reducible to CSP(\u0393 ) [11].\nA set of binary relations \u0393 is weakly closed under singletons, if {\u3008a, b\u3009} \u2208 \u0393+ for any R \u2208 \u0393 and any \u3008a, b\u3009 \u2208 R.\nIn this paper we often assume that the constraint languages are complete and weakly closed under singletons. We will see that this is not very restrictive as, for any set \u0393 of binary relations that is closed under a majority operation \u03d5, the completion \u0393 c of \u0393 is also closed under \u03d5 [19] and weakly closed under singletons (cf. Proposition 4)."}, {"heading": "3 The Strong Directional PC Algorithm", "text": "This section recalls the notions of directional arc-consistency (DAC) and directional path-consistency (DPC), and the strong DPC enforcing algorithm of Dechter and Pearl [13].\nDefinition 4. [13] Let N = \u3008V,D, C\u3009 be a BCN and \u227a= (v1, . . . , vn) an ordering of the variables in V . We say that N is directionally arc-consistent (DAC) relative to \u227a if vi is arc-consistent relative to vk for all k > i with Rik \u2208 C. Similarly, N is directionally path-consistent (DPC) relative to\u227a if, for any i 6= j withRij \u2208 C, (vi, vj) is path-consistent relative to vk for all k > i, j whenever Rik, Rjk \u2208 C. Meanwhile, N is strongly DPC relative to \u227a if it is both DAC and DPC relative to \u227a.\nAlgorithm 1: DPC Input : A binary constraint networkN = \u3008V,D, C\u3009;\nan ordering \u227a = (v1, . . . , vn) on V . Output: An equivalent subnetwork that is strongly DPC relative to \u227a, or \u201cInconsistent\u201d.\n1 for k \u2190 n to 1 do 2 for i < k with Rik \u2208 C do 3 Di \u2190 Di \u2229Rki(Dk); 4 if Di = \u2205 then 5 return \u201cInconsistent\u201d\n6 for i, j < k with Rik, Rjk \u2208 C do 7 if Rij 6\u2208 C then 8 Rij \u2190 Di \u00d7Dj ; 9 C \u2190 C \u222a {Rij};\n10 Rij \u2190 Rij \u2229 (Rik \u25e6Rkj); 11 if Rij = \u2205 then 12 return \u201cInconsistent\u201d;\n13 returnN .\nThe strong DPC algorithm is presented as Algorithm 1. In comparison with traditional PC algorithms [10], a novelty of this single pass algorithm is its explicit reference to the constraint graph of the input constraint network. As only Line 8 may require extra working space, Algorithm 1 has a very low space complexity in practice. Further, Algorithm 1 runs inO(w\u2217(\u227a) \u00b7e \u00b7 (\u03b1+\u03b2)) time [13], where e is the number of edges of the output constraint graph, w\u2217(\u227a) is the induced width of the ordered graph along \u227a, and \u03b1, \u03b2 are the runtimes of relational intersection and composition respectively. Note that w\u2217(\u227a) \u2264 n and \u03b1, \u03b2 are bounded by O(d), where d is the largest domain size.\nProposition 1. [13] Let (N ,\u227a) be an input to Algorithm 1, where \u227a = (v1, . . . , vn). Suppose N \u2032 = \u3008V,D\u2032, C \u2032\u3009 is the output. Then\n(i) GN \u2032 is triangulated and \u227a\u22121, the inverse of \u227a, is a PEO of GN \u2032 ; (ii) N \u2032 is equivalent to N and strongly DPC relative to \u227a.\nLet \u0393 be a set of binary relations. We say that Algorithm 1 decides CSP(\u0393 ) if, for any given BCN N in CSP(\u0393 ) and any ordering \u227a of variables of N , Algorithm 1 returns \u201cInconsistent\u201d iff N is inconsistent.\nThe following corollary follows directly from Proposition 1.\nCorollary 1. Let \u0393 be a complete set of binary relations. Then the following two conditions are equivalent:\n(i) Algorithm 1 decides CSP(\u0393 ). (ii) Let N be a non-trivially inconsistent BCN in CSP(\u0393 ). Suppose N \u2019s constraint\ngraph GN is triangulated and let \u227a\u22121 = (vn, . . . , v1) be a PEO of it. Then N is consistent if N is strongly DPC relative to \u227a.\nExample 2. The graph coloring problemN with domains {red, blue} depicted in Fig. 3 is taken from [13] and can be decided by Algorithm 1. After applying Algorithm 1 to (N ,\u227a), where \u227a= (v1, v2, v3, v4), a solution can be obtained along \u227a in a backtrackfree manner (see Fig. 3b)."}, {"heading": "4 Directional PC and Variable Elimination", "text": "This section characterizes the binary constraint languages \u0393 such that CSP(\u0393 ) can be decided by DPC. We observe that DPC achieves (strong) DPC using the idea of variable elimination [13]: it iterates variables along the ordering \u227a\u22121, and propagates the constraints of a variable vk to subsequent variables in the ordering with the update rule Rij \u2190 Rij \u2229 (Rik \u25e6Rkj), as if vk is \u2018eliminated\u2019.\nThe following definition formalizes the process of elimination.\nDefinition 5. LetN = \u3008V,D, C\u3009 be a BCN with V = {v1, ..., vn} andD = {D1, ..., Dn}. For a variable vx in V , let Ex = {Rix | Rix \u2208 C}. The network obtained after vx is eliminated from N , written as\nN\u2212x = \u3008V \\ {vx}, {D\u20321, ..., D\u2032x\u22121, D\u2032x+1, ..., D\u2032n}, C \u2032\u3009,\nis defined as follows:\n\u2013 If Ex = {Rix}, we set C \u2032 = C \\ Ex and let\nD\u2032j =\n{ Di \u2229Rxi(Dx), if j = i\nDj , otherwise (1)\n\u2013 If |Ex| 6= 1, we set D\u2032j = Dj for all j 6= x, and let\nC \u2032 = (C \\ Ex) \u222a {Rix \u25e6Rxj \u2229Rij | Rjx, Rix \u2208 Ex, i 6= j}.\nRij is assumed to be Di \u00d7Dj if Rij 6\u2208 C. Fig. 4 illustrates the elimination process.\nDefinition 6. A BCN N = \u3008V,D, C\u3009 is said to have the variable elimination property (VEP), if, for any vx in V , every solution of N\u2212x can be extended to a solution of N . N is said to have weak VEP, if, for any vx in V such that vx is AC relative to all relations in Ex, every solution of N\u2212x can be extended to a solution of N . A set of binary relations \u0393 is said to have (weak) VEP if every BCN in CSP(\u0393 )\nhas (weak) VEP. Such a set of binary relations \u0393 is also called a (weak) VEP class.\nIt is easy to see that, if a BCN (a set of binary relations) has VEP, then it also has weak VEP. The following example explains why we should take special care when eliminating variables with only one successor in Eq. (1).\nExample 3. Let N = \u3008V,D, C\u3009 be a BCN defined by V = {v1, v2, v3}, D1 = D2 = D3 = {0, 1}, and C = {((v3, v2), R), ((v2, v1), R)} with R = {(1, 0)} (see Fig. 5). Suppose we do not have the operation specified in (1) and \u227a = (v3, v2, v1) is the variable elimination ordering. LetN\u22123 be the restriction ofN to {v1, v2}. ThenN\u22123 has a unique solution \u03c3 but it cannot be extended to a solution of N .\nProposition 2. Let \u0393 be a complete set of binary relations that is weakly closed under singletons. Then DPC decides CSP(\u0393 ) iff \u0393 has VEP.\nProof. We address the \u2018if\u2019 part first. Assume that \u0393 has VEP, and let N = \u3008V,D, C\u3009 be a network in CSP(\u0393 ) that is non-trivially inconsistent and strongly DPC relative to\n\u227a= (v1, . . . , vn), where GN is triangulated and\u227a\u22121 is a PEO of it. We show thatN is consistent. Let Vi = {v1, . . . , vi} andN|Vi be the restriction ofN to Vi. We claim that N|Vi is consistent for k = 1, . . . , n and prove the claim by induction on k. First, since N is strongly DPC relative to \u227a, D1 is not empty and there is an a1 \u2208 D1. Then,N|V1 is consistent and has a solution \u03c31 = \u3008a1\u3009. Further, suppose that N|Vi is consistent and \u03c3i = \u3008a1, a2, ..., ai\u3009 is a solution of N|Vi . We show that \u03c3i can be extended to a solution \u03c3i+1 = \u3008a1, . . . , ai, ai+1\u3009 of N|Vi+1 . We consider three subcases: (i) If Ei+1 is empty, then for any ai+1 \u2208 Di+1, \u03c3i+1 = \u3008a1, a2, ..., ai, ai+1\u3009 is a solution of N|Vi+1 because there is no constraint between vi and vi+1. (ii) If Ei+1 = {Rj,i+1} is a singleton, then, since N is DAC relative to \u227a, we have ai+1 \u2208 Di+1 such that \u3008ai, ai+1\u3009 \u2208 Ri,i+1 and \u03c3i+1 = \u3008a1, a2, ..., ai, ai+1\u3009 is a solution of N|Vi+1 . (iii) If Ei+1 contains more than one variable, for every pair of distinct variables (vx, vy) in Vi with Rx,i+1, Ry,i+1 \u2208 Ei+1, we know Rxy \u2208 C because \u227a\u22121 is a PEO of GN . Moreover, since (vx, vy) is PC relative to vi+1, we have Rxy \u2286 Rx,i+1 \u25e6 Ri+1,y . Then since \u0393 has VEP and N|Vi is indeed the same network as the one obtained by eliminating vi+1 from N|Vi+1 , by Definition 6, \u03c3i can be extended to a solution \u03c3i+1 of N|Vi+1 . Thus, N is consistent. By Corollary 1, DPC decides CSP(\u0393 ).\nNext, we address the \u2018only if\u2019 part. Assume that DPC decides CSP(\u0393 ). We show that \u0393 has VEP. LetN = \u3008V,D, C\u3009 be a non-trivially inconsistent network in CSP(\u0393 ). Given vx \u2208 V , we show that every solution ofN\u2212x can be extended toN . Without loss of generality, we assume that x = n. Let \u03c3 = \u3008a1, . . . , an\u22121\u3009 be a solution ofN\u2212n, and En = {Rin | Rin \u2208 C}. By the definition of N\u2212n, for any Rin, Rjn \u2208 En(i 6= j), we have \u3008ai, aj\u3009 \u2208 Rin \u25e6 Rnj \u2229 Rij . We then construct a new problem N \u2032 = \u3008V,D\u2032, C \u2032\u3009 in CSP(\u0393 ), where D\u2032 = {D\u20321, ..., D\u2032n\u22121, Dn} with D\u2032i = {ai} for 1 \u2264 i < n and C \u2032 = {{\u3008ai, aj\u3009} | 1 \u2264 i 6= j < n}\u222aEn. Clearly, \u03c3 is also a solution ofN \u2032\u2212n andN \u2032\u2212n is strongly PC and, hence, strongly DPC relative to the ordering (v1, . . . , vn\u22121). Further, since \u3008ai, aj\u3009 \u2208 Rin \u25e6 Rnj \u2229 Rij for any Rin, Rjn \u2208 En(i 6= j), we have that N \u2032 is strong DPC relative to \u227a = (v1, . . . , vn). As GN \u2032\u2212n is complete, GN \u2032 is triangulated with \u227a\u22121 being a PEO of it. As DPC decides CSP(\u0393 ) and N \u2032 \u2208 CSP(\u0393 ), by Corollary 1, N \u2032 is consistent and has a solution that extends \u03c3 and is also a solution of N . This shows that N is consistent and, hence, \u0393 has VEP. ut\nTherefore, if N = \u3008V,D, C\u3009 is defined over a complete VEP class, then DPC can decide it. Note that in the above proposition we require \u0393 to be complete. This is important; for example, every row-convex constraint [3] network has VEP (cf. the proof of [34, Theorem 1]) and, hence, the class of row-convex constraints has VEP. However, DPC does not decide the consistency problem over the row-convex constraint class because it was shown to be NP-hard (cf. e.g. [20]).\nVEP is closely related to the Helly property, defined as follows.\nDefinition 7. A set \u0393 of binary relations over D = {D1, ..., Dn} is said to have the Helly property if for any k > 2 binary relations,Ri \u2286 Dui\u00d7Du0(1 \u2264 i \u2264 k, 1 \u2264 ui 6= u0 \u2264 n), in \u0393 , and for any k values, ai \u2208 Dui(1 \u2264 i \u2264 k), such that Ri(ai) = {b \u2208 Du0 | \u3008ai, b\u3009 \u2208 Ri} is nonempty, we have \u22c2k i=1Ri(ai) 6= \u2205 iff Ri(ai) \u2229 Rj(aj) 6= \u2205 for any 1 \u2264 i 6= j \u2264 k.\nExample 4. Let Du0 = {a, b, c, d}, Du1 = {e}, Du2 = {f}, Du3 = {g} and R1 = {\u3008e, a\u3009, \u3008e, b\u3009, \u3008e, c\u3009}, R2 = {\u3008f, b\u3009, \u3008f, c\u3009, \u3008f, d\u3009}, R3 = {\u3008g, c\u3009, \u3008g, d\u3009, \u3008g, a\u3009}. See Fig. 6 for an illustration. Then \u0393 = {R1, R2, R3} over D = {Du0 , Du1 , Du2 , Du3} has the Helly property.\nTheorem 1. A set of binary relations \u0393 has VEP iff it has the Helly property.\nProof. Suppose \u0393 has VEP, we show \u0393 has the Helly property. Let D = {D1, ..., Dn} be the set of domains related to relations in \u0393 . Suppose Ri \u2286 Dui \u00d7Du0 (1 \u2264 i \u2264 k, 1 \u2264 ui 6= u0 \u2264 n) are k > 2 binary relations in \u0393 and ai \u2208 Dui (1 \u2264 i \u2264 k) are values such that \u2205 6= Ri(ai) \u2286 Du0 . Suppose Ri(ai) \u2229 Rj(aj) is nonempty for any i, j with 1 \u2264 i 6= j \u2264 k. We show that \u22c2k i=1Ri(ai) is nonempty. To this end, we construct a BCNN = \u3008V,D\u2032, C\u3009 over \u0393 with V = {v1, ..., vk, vk+1},D\u2032 = {Du1 , ..., Duk , Du0}, and C = {Ri,k+1 | 1 \u2264 i \u2264 k}, where Ri,k+1 = Ri. Consider N\u2212(k+1). As Ri(ai) \u2229 Rj(aj) 6= \u2205, we have \u3008ai, aj\u3009 \u2208 Ri,k+1 \u25e6Rk+1,j . This shows that \u03c3 = \u3008a1, . . . , ak\u3009 is a solution ofN\u2212(k+1). Since \u0393 and, hence,N have VEP,N has a solution that extends \u03c3. Hence there exists a \u2208 Du0 such that a \u2208 Ri,k+1(ai) for every 1 \u2264 i \u2264 k. Thus\u22c2k\ni=1Ri(ai) 6= \u2205. This proves that \u0393 has the Helly property. Suppose \u0393 has the Helly property, we show \u0393 has VEP. Let N = \u3008V,D, C\u3009 be a non-trivially inconsistent BCN defined over \u0393 with V = {v1, v2, ..., vn} and C is a set of binary constraints ((vi, vj), R) with R \u2208 \u0393 . Let En = {Rin | Rin \u2208 C}. Assume \u03c3 = \u3008a1, a2, ..., an\u22121\u3009 is a solution of, say, N\u2212n. We show that there exists an \u2208 Dn such that \u3008a1, ..., an\u22121, an\u3009 is a solution ofN . If En is empty, we can take any an from Dn which is nonempty since N is non-trivially inconsistent; if En contains only one constraint, say, ((vi, vn), Rin), by ai \u2208 D\u2032i = Di\u2229Rni(Dn), there exists an \u2208 Dn such that \u3008ai, an\u3009 \u2208 Rin; if En contains k \u2265 2 constraints and let them be ((vui , vn), Ruin) (1 \u2264 i \u2264 k), we have \u3008ai, aj\u3009 \u2208 Ruiuj \u2229 (Ruin \u25e6Rnuj ) for 1 \u2264 i 6= j \u2264 k. Therefore, we have Ruin(ai) \u2229 Rujn(aj) 6= \u2205 for 1 \u2264 i 6= j \u2264 k. By the Helly property of \u0393 , we have \u22c2k i=1Ruin(ai) 6= \u2205. So we can take any an \u2208 \u22c2k i=1Ruin(ai) so that \u3008a1, . . . , an\u22121, an\u3009 is a solution of N . Therefore, \u0393 has VEP. ut\nThe class of row-convex constraints [3] and the class of tree-convex constraints [35] have the Helly property and, thus, they have VEP by Theorem 1.\nProposition 3. Suppose \u0393 is a set of binary relations that has the Helly property. Let N \u2208 CSP(\u0393 ). Suppose N is non-trivially inconsistent and GN is triangulated with\n\u227a\u22121= (vn, . . . , v1) as a PEO of it. Then N is consistent if it is strongly DPC relative to \u227a.\nProof. Let N \u2208 CSP(\u0393 ). Suppose N = \u3008V,D, C\u3009 is non-trivially inconsistent and GN is triangulated with \u227a\u22121 = (vn, . . . , v1) being a PEO of it. Suppose N is strongly DPC relative to\u227a. We show thatN is consistent. Let Vk = {v1, . . . , vk} andNk be the restriction of N to Vk. Since N is non-trivially inconsistent, we have that N1 is consistent. Suppose Nk is consistent, we show Nk+1 is consistent. Let \u03c3 = \u3008a1, . . . , ak\u3009 be a solution of Nk. Let Ek+1 = {Ri,k+1 | Ri,k+1 \u2208 C, i \u2264 k}. Since GN is triangulated and \u227a\u22121= (vn, . . . , v1) is a PEO of it, for any two different constraints Ri,k+1, Rj,k+1 \u2208 Ek+1, we haveRij \u2208 C. Further, sinceN is strongly DPC relative to \u227a, we have \u3008ai, aj\u3009 \u2208 Ri,k+1\u25e6Rk+1,j\u2229Rij . Thus, we haveRi,k+1(ai)\u2229Rj,k+1(aj) 6= \u2205 for any two different constraintsRi,k+1, Rj,k+1 \u2208 Ek+1. Since \u0393 has the Helly property, we have \u22c2 Ri,k+1\u2208Ek+1 Ri,k+1(ai) 6= \u2205. Therefore, \u03c3 can be extended to a solution ofNk+1 andNk+1 is consistent. By induction on k, we have thatN is consistent. ut"}, {"heading": "5 Majority-Closed Constraint Languages", "text": "In this section we characterize weak VEP classes. We will show that a complete set of binary relations \u0393 has weak VEP iff all relations in \u0393 are closed under a majority operation, which is defined as follows.\nDefinition 8. [7] Let D = {D1, . . . , Dn} be a set of domains. A multi-sorted majority operation \u03d5 onD is a set {\u03d51, . . . , \u03d5n}, where \u03d5i is a one-sorted majority operation on Di, i.e., a mapping from D3i to Di such that \u03d5i(e, d, d) = \u03d5i(d, e, d) = \u03d5i(d, d, e) = d for all d, e in Di.\nAn m-ary relation R \u2286 Di1 \u00d7 ...\u00d7Dim with i1, ..., im \u2208 {1, 2, ..., n} is said to be closed under \u03d5 if \u03d5(t1, t2, t3) = \u3008\u03d5i1(t1[1], t2[1], t3[1]), . . . , \u03d5im(t1[m], t2[m], t3[m])\u3009 is in R for any t1, t2, t3 \u2208 R.\nA set of relations \u0393 is said to be closed under \u03d5 if every R \u2208 \u0393 is closed under \u03d5.\nA set of relations \u0393 is called a majority-closed language if there exists a (multi-sorted) majority operation \u03d5 such that every relation in \u0393 is closed under \u03d5."}, {"heading": "5.1 Tree-Preserving Constraints", "text": "The class of tree-preserving constraints is majority-closed.\nDefinition 9. [21] An undirected graph structure can often be associated to a finite domainD such that there is a bijection between the vertices in the graph and the values in D. If the graph is connected and acyclic, i.e. a tree, then we say it is a tree domain of x, denote as T = (D,E) where E is a set of edges. A constraint Rij over tree domains Ti = (Di, Ei) and Tj = (Dj , Ej) is called tree-preserving if the image of every subtree in Ti is a subtree in Tj .\nAn example of tree-preserving constraint is shown in Fig. 7. A CRC constraint is a special tree-preserving constraint where related tree domains are chains [21].\nDefinition 10. Let Ti be a nonempty tree domain for a variable vi. The standard majority operation mi on Ti is defined as:\n(\u2200a, b, c \u2208 Ti) mi(a, b, c) = \u03c0a,b \u2229 \u03c0b,c \u2229 \u03c0a,c,\nwhere a, b, c are not necessarily distinct and \u03c0u,v denotes the unique path from u to v in Ti.\nThe following result establishes the connection between tree-preserving constraints and majority-closed constraints.\nTheorem 2. [21] Let Ti and Tj be two nonempty tree domains and mi and mj their standard majority operations. Suppose Rij \u2286 Ti \u00d7 Tj is a nonempty constraint such that both Rij and Rji are arc-consistent. Then Rij is closed under {mi,mj} iff both Rij and Rji are tree-preserving w.r.t. Ti and Tj ."}, {"heading": "5.2 Weak VEP Classes and Majority-Closed Classes", "text": "We first study a few properties of majority-closed classes.\nProposition 4. Let \u0393 be the set of binary relations that is closed under a multi-sorted majority operation \u03d5 = {\u03d51, ..., \u03d5n} on D = {D1, ..., Dn}. Then \u0393 is weakly closed under singletons.\nProof. Suppose R is a relation in \u0393 and \u3008a, b\u3009 \u2208 R \u2286 Di \u00d7Dj . We show that {\u3008a, b\u3009} is closed under \u03d5. For any t1, t2, t3 \u2208 {\u3008a, b\u3009}, we have t1 = t2 = t3 = \u3008a, b\u3009, and, hence, \u03d5(t1, t2, t3) = \u3008\u03d5i(a, a, a), \u03d5j(b, b, b)\u3009 = \u3008a, b\u3009. This shows that {\u3008a, b\u3009} is closed under \u03d5 and, hence, a relation in \u0393 . ut\nMajority-closed relations are decomposable.\nDefinition 11. An m-ary relation R is said to be r-decomposable if, for any m-tuple t, t \u2208 R if \u03c0I(t) \u2208 \u03c0I(R) for all I = (i1, . . . , ik) (a list of indices from {1, . . . ,m}) with k \u2264 r, where \u03c0I(t) = \u3008t[i1], ..., t[ik]\u3009 and \u03c0I(R) = {\u3008t[i1], ..., t[ik]\u3009 | t \u2208 R}.\nTheorem 3. [19] Let \u0393 be a set of binary relations over a set of finite domains D = {D1, . . . , Dn}. The following statements are equivalent:\n(1) \u0393 is a majority-closed constraint language. (2) Every R \u2208 \u0393+ is 2-decomposable. (3) For every N \u2208 CSP(\u0393 ), establishing strong PC in N ensures global consistency.\nFinally, we show that complete weak VEP classes are majority-closed classes.\nTheorem 4. Let \u0393 be a complete set of binary relations over a set of finite domains D = {D1, ..., Dn}. Then \u0393 has weak VEP iff it is a majority-closed class.\nProof. We first deal with the \u2018only if\u2019 part. Suppose that \u0393 is a complete set of binary relations that has weak VEP. By Theorem 3, we only need to show that for every BCN in CSP(\u0393 ), establishing strong PC ensures global consistency. LetN 0 be a network in CSP(\u0393 ) and suppose N = \u3008V,D, C\u3009 is the network obtained by enforcing strong PC onN 0. Since \u0393 is complete and thus closed under operations for achieving AC and PC by Lemma 1,N is also a problem in CSP(\u0393 ). SupposeN is non-trivially inconsistent. We show that any partial solution of N can be extended to a solution of N .\nSuppose V \u2032 = {v1, . . . , vm\u22121} \u2282 V and \u03c3 = \u3008a1, . . . , am\u22121\u3009 is a solution of N|V \u2032 , which is the restriction of N to V \u2032. Assume further that vm 6\u2208 V \u2032 is a new variable and let V \u2032\u2032 = V \u2032 \u222a {vm}. We show that \u03c3 can be consistently extended to N|V \u2032\u2032 , the restriction of N to V \u2032\u2032. Because N is strongly PC, N|V \u2032\u2032 is strongly PC as well. In particular, vi is AC relative to vm for any Rim in C, and Rij is PC relative to vm (i.e., Rij \u2286 Rim \u25e6 Rmj) for any i 6= j such that both Rim and Rjm are in C. By Definition 5,N|V \u2032 is the same as (N|V \u2032\u2032)\u2212m, viz., the network obtained by eliminating vm from N|V \u2032\u2032 . Moreover, since N and, hence, N|V \u2032\u2032 are AC, vm is AC relative to all constraints Rim that are in C. By the assumption that \u0393 has weak VEP, \u03c3 can be consistently extended to vm. Following this reasoning, we will find a solution ofN that extends \u03c3.\nNext, we consider the \u2018if\u2019 part. Suppose that \u0393 is a complete set of binary relations that is closed under some multi-sorted majority operation \u03d5 = {\u03d51, . . . , \u03d5n} on D. Let N = \u3008V,D, C\u3009 be a problem in CSP(\u0393 ) and vx a variable in V . Let Ex = {Rix | Rix \u2208 C}, and N\u2212x = \u3008V \\ {vx},D, C \u2032\u3009, where C \u2032 = (C \u222a {Rix \u25e6 Rxj \u2229 Rij | Rjx, Rix \u2208 Ex}) \\ Ex. Suppose that vx is AC relative to all relations in Ex. We only need to show that any solution of N\u2212x can be extended to a solution of N . We prove this by contradiction.\nLet \u03c3 be a solution of N\u2212x. Assume that \u03c3 cannot be extended to a solution of N . Therefore, Ex cannot be empty, otherwise \u03c3 can be trivially extended to a solution of N . The case where Ex = {Rix} is a singleton is also impossible, as by (1), vi is AC relative to Rix and we could extend \u03c3 to a solution of N by assigning any valid value to vx. Suppose that Ex has q \u2265 2 constraints and let them be ((v1, vx), R1), . . ., ((vq, vx), Rq). We define a new problemN \u2032 = \u3008V,D, Ex\u3009 as illustrated in Fig. 8. Since vx is AC relative to all relations in Ex, it is easy to verify that N \u2032 has a solution. For example, one can construct a solution of N \u2032 by simply picking a value from Dx for vx and then extending that valuation to v1, . . . , vq . Now, we construct a q-ary relation R = {\u3008\u03b3(v1), . . . , \u03b3(vq)\u3009 | \u03b3 is a solution of N \u2032}. The solution set S of N \u2032 can be\nobtained by using a sequence of the Cartesian product, equality selection, and projection operations [19]. Therefore, S \u2208 \u0393+. Since R = \u03c0v1,...,vq (S), we have R \u2208 \u0393+. By Theorem 3, R should be 2-decomposable; however, in the sequel we show that it is not, which is a contradiction.\nLet t = \u3008\u03c3(v1), . . . , \u03c3(vq)\u3009, where \u03c3 is a solution of N\u2212x. It is clear that t is a solution ofN \u2032|{v1,...,vq}. For any list of indices I chosen from {1, . . . , q}, with |I| \u2264 2, we claim that \u03c0I(t) \u2208 \u03c0I(R). We recall that, for any two relations Rix, Rjx \u2208 Ex, the relation between vi and vj in N\u2212x is Rij \u2229 (Rix \u25e6 Rxj). Therefore, any partial solution \u3008\u03c3(vi), \u03c3(vj)\u3009(1 \u2264 i, j \u2264 q) of N \u2032 can be consistently extended to vx and, by the construction of N \u2032, further consistently extended to a solution of N \u2032. Thus, \u03c0I(t) is in \u03c0I(R) for any list of indices I chosen from {1, . . . , q}, with |I| \u2264 2. However, t 6\u2208 R because \u03c3 cannot be extended to a solution of N \u2032, which implies that R is not 2-decomposable. ut"}, {"heading": "6 The Variable Elimination Algorithm DPC\u2217", "text": "This section presents a variant of DPC for solving BCNs defined over any weak VEP class. The new algorithm, called DPC\u2217 and presented as Algorithm 2, can solve problems that are not solvable by DPC (cf. Example 5 and Proposition 6). Compared with the variable elimination algorithm for solving CRC constraints [34], DPC\u2217 enforces a weaker AC condition instead of full AC. We first justify the correctness of Algorithm 2.\nTheorem 5. Let \u0393 be a complete weak VEP class. Suppose N is a BCN defined over \u0393 and \u227a= (v1, . . . , vn) any ordering of variables of N . Then, given N and \u227a, Algorithm 2 does not return \u201cInconsistent\u201d iff N is consistent.\nProof. Suppose the input network N is consistent. Since DPC\u2217 only prunes off certain infeasible domain values or relation tuples, the algorithm does not find any empty domains or relations in Lines 4, 9, and 19. Thus, it does not return \u201cInconsistent\u201d.\nSuppose the algorithm does not return \u201cInconsistent\u201d and let N \u2032 = \u3008V,D\u2032, C \u2032\u3009 be the output network, where D\u2032 = {D\u20321, ..., D\u2032n}. We show N \u2032 is consistent.\nWriteM(0) forN and writeM(i) for the result of the i-th loop in calling DPC\u2217 for the inputN and\u227a= (v1, v2, ..., vn). ThenN \u2032 =M(n\u22121) and allM(i) (0 \u2264 i < n) are equivalent to N . Let Qk be the restriction ofM(k) to {v1, v2, ..., vn\u2212k} (0 \u2264 k < n). In essence, Qk is obtained by eliminating vn\u2212k+1 from Qk\u22121 (Lines 2-5 or Lines 11- 20), while also enforcing AC (Lines 7-10) for vn\u2212k+1 relative to all its successors if\nAlgorithm 2: DPC\u2217\nInput : A binary constraint networkN = \u3008V,D, C\u3009; an ordering \u227a = (v1, . . . , vn) on V .\nOutput: An equivalent subnetwork that is decomposable relative to \u227a, or \u201cInconsistent\u201d. 1 for k \u2190 n to 1 do 2 if k has only one successor and that successor is i then 3 Di \u2190 Di \u2229Rki(Dk) 4 if Di = \u2205 then 5 return \u201cInconsistent\u201d\n6 else 7 for i < k with Rik \u2208 C do 8 Dk \u2190 Dk \u2229Rik(Di) 9 if Dk = \u2205 then\n10 return \u201cInconsistent\u201d\n11 for i < k with Rik \u2208 C do 12 Rik \u2190 Rik \u2229 (Di \u00d7Dk) 13 for j < i with Rjk \u2208 C do 14 Rjk \u2190 Rjk \u2229 (Dj \u00d7Dk) 15 if Rij 6\u2208 C then 16 Rij \u2190 Di \u00d7Dj 17 C \u2190 C \u222a {Rij} 18 Rij \u2190 Rij \u2229 (Rik \u25e6Rkj); 19 if Rij = \u2205 then 20 return \u201cInconsistent\u201d\n21 returnN .\nit has more than one successor. Since \u0393 is a complete weak VEP class, every BCN defined over \u0393 has weak VEP. In particular, eachQk\u22121 is defined over \u0393 and has weak VEP. This implies that every solution of Qk can be extended to a solution of Qk\u22121. Since no inconsistency is detected in the process, we have D\u20321 6= \u2205 and thus Qn\u22121 is consistent. By the above analysis, this implies thatQn\u22122, ...,Q1,Q0 =M(0) = N are all consistent. ut\nThe preceding proof also gives a way to generate all solutions of a consistent input network backtrack-free by appropriately instantiating the variables along the input ordering \u227a. Indeed, for all 1 \u2264 k < n, a solution \u3008a1, . . . , ak\u3009 of N \u2032k can be extended to a solution \u3008a1, . . . , ak+1\u3009 of N \u2032k+1 by choosing an element ak+1 from the intersection of all Ri,k+1(ai) with i \u2264 k and Ri,k+1 \u2208 C \u2032, which is always nonempty as shown in the preceding proof. As we know that if \u0393 is majority-closed, the completion of \u0393 is also majority-closed [19], and that complete majority-closed classes and complete weak VEP classes are equivalent by Theorem 4, this also proves the following result:\nProposition 5. Suppose N is a consistent BCN defined over a majority-closed class and \u227a = (v1, ..., vn) an ordering of variables ofN . Then, givenN and \u227a, Algorithm 2 returns an equivalent subnetwork N \u2032 that is decomposable relative to \u227a, i.e., any partial solution of N \u2032 on {v1, ..., vk} for any 1 \u2264 k < n can be extended to a solution of N \u2032.\nNote that Lines 2-10 in DPC\u2217do not achieve DAC of input networks. Therefore, DPC\u2217 does not achieve strong DPC. Since the overall runtime of Lines 2-10 is the same as enforcing DAC, this places DPC\u2217 in the same time complexity class as DPC. The following example, however, gives a BCN that can be solved by DPC\u2217 but not by DPC, which shows that the loop in Lines 7-10 is necessary.\nExample 5. Let D = {a, b, c} and \u03d5 be the majority operation on D such that for all i, j, k \u2208 D, \u03d5(i, j, k) = a if i 6= j, j 6= k, and i 6= k, and \u03d5(i, j, k) = r otherwise, where r is the repeated value (e.g., \u03d5(b, c, b) = b). Let \u0393 = {R1, R2, R3, R4, R5, R6}, whereR1 = {\u3008a, a\u3009, \u3008a, c\u3009},R2 = {\u3008c, c\u3009, \u3008c, b\u3009},R3 = {\u3008b, b\u3009, \u3008b, a\u3009},R4 = {\u3008a, c\u3009}, R5 = {\u3008c, b\u3009}, and R6 = {\u3008a, b\u3009}. Every R \u2208 \u0393 is closed under the majority operation \u03d5 on D. Now, consider the constraint network N \u2208 CSP(\u0393 ) as presented in Figure 9. Since Rxw \u25e6 Rwz = R6, Rxw \u25e6 Rwy = R4, and Ryw \u25e6 Rwz = R5, the eliminated network N\u2212w is the same as the restriction of N to the set of variables {vx, vy, vz}. Let \u03c3(vx) = a, \u03c3(vy) = c, \u03c3(vz) = b. Then \u03c3 is a solution of N\u2212w, but \u03c3 cannot be extended to a solution of N . Thus, N and hence \u0393 do not have VEP. By Theorem 2, DPC does not decide CSP(\u0393 ).\nOn the other hand, since \u0393 is majority-closed, by Proposition 5, DPC\u2217 can correctly decide the consistency ofN . This observation is confirmed by calling the two algorithms onN . Take the PEO\u227a= (w, x, y, z) as an example; the other PEOs are analogous. Let (N ,\u227a) be an input to DPC. After processing w, we haveDx = {a}, Dy = {c}, Dz = {b} and Rxy = {\u3008a, c\u3009}, Rxz = {\u3008a, b\u3009}, Rzy = {b, c}. We can observe that \u3008x = a, y = c, z = b\u3009 is a solution to the eliminated subnetwork. Thus, if we keep running DPC, it will not detect inconsistency. On the other hand, for DPC\u2217, when eliminating w, DPC\u2217 makes w AC relative to its neighbors. Note that DPC does not perform this operation. After that, Dw is empty, and the algorithm will stop and output \u201cInconsistent\u201d.\nThe following result shows that complete majority-closed classes over domains with more than two elements cannot have VEP.\nProposition 6. Let \u03d5 = {\u03d51, . . . , \u03d5n} be a majority operation onD = {D1, . . . , Dn}. If there exists a domain Di in D that contains more than two elements, then the set \u0393\u03d5 of binary relations that are closed under \u03d5 has neither the Helly property nor VEP.\nProof. Suppose a, b, c are three different values from Di. It is easy to see that the relations R1 = {\u3008a, a\u3009, \u3008a, b\u3009}, R2 = {\u3008a, b\u3009, \u3008a, c\u3009}, and R3 = {\u3008a, a\u3009, \u3008a, c\u3009} are all closed under \u03d5. Therefore, R1, R2, and R3 are all in \u0393\u03d5. Because any two of R1(a), R2(a), R3(a) have a common element but R1(a) \u2229 R2(a) \u2229 R3(a) = \u2205, this shows that \u0393\u03d5 does not have the Helly Property and, hence by Theorem 1, does not have VEP. ut\nThis result shows that no complete VEP class could have a domain with 3 or more values. Therefore, there are no interesting complete constraint languages except the boolean ones that can be decided by DPC (cf. Proposition 2), while all binary majority-closed classes (including CRC and tree-preserving constraints) can be decided by DPC\u2217 (cf. Proposition 5).\nDPC\u2217 can also be used to solve majority-closed constraints of higher arities. This is because, by Theorem 3, every relation definable in a majority-closed language is 2- decomposable. Therefore, for each majority relation R of arity m > 2, if a constraint c = ((y1, ..., ym), R) appears in a constraint network N , we could replace c with a set of binary constraints cij = ((yi, yj) | \u03c0ij(R)) (1 \u2264 i < j \u2264 m), where \u03c0ij(R) = {\u3008t[yi], t[yj ]\u3009 | t \u2208 R}."}, {"heading": "7 Evaluations", "text": "In this section we experimentally compare algorithm DPC\u2217 against the state-of-the-art algorithms for solving majority-closed constraint networks. These are SAC3-SDS [4] and PC2001 [5]. SAC3-SDS is currently the best singleton arc-consistency (SAC) enforcing algorithm [12]. Enforcing either SAC1 or PC correctly decides the consistency of a majority-closed constraint network [9,19].\nTwo different sets of data are considered for experiments, which are described as follows:\n(1) Tree-preserving constraint networks. (2) Random majority-closed constraint networks. These can be used to test the aver-\nage performance of different algorithms. To generate such networks, we need to generate random majority-closed constraint languages as follows. \u2022 Randomly define a majority operation\u2297i : D3i \u2192 Di for each domainDi \u2208 D\nas follows: for any x, y, z \u2208 Di, \u2297i(x, y, z) = {\nany v \u2208 Di, if x, y, z are all different, any repeated value of x, y, z, otherwise.\n(2) 1 Singleton linear arc-consistency (SLAC) is an alternative consistency notion that can be en-\nforced to solve majority-closed constraint network [22], but no practical SLAC algorithms are available so far.\n\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether\n{\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3)\nholds. By definition, Rij is majority-closed under (\u2297i,\u2297j) iff (3) holds.\nWe used the model in [6,16] to generate random consistent constraint networks for experiments. These constraint networks were generated by varying four parameters: (1) the number of variables n, (2) the size of the domains d, (3) the density of the constraint networks \u03c1 (i.e. the ratio of non-universal constraints to n2) and (4) the looseness of constraints l (i.e. the ratio of the number of allowed tuples to d2). We fix three of the four parameters and vary the remaining parameter. Experiments were carried out on a computer with an Intel Core i5-4570 processor with a 3.2 GHz frequency per CPU core, and 4 GB memory.\nThe graphs in Fig. 10 and Fig. 11 illustrate the experimental comparisons among algorithms DPC\u2217, SAC3-SDS and PC2001 for solving tree-preserving and random\nmajority-closed constraint networks respectively. The data points in each graph are CPU times averaged over 20 instances.\nFrom Fig. 10 and Fig. 11, we observe that all algorithms behave similarly to one another when solving tree-preserving and random majority-closed constraint networks. Therefore, our analysis only focuses on Fig. 10 and the results are applicable to Fig. 11 as well.\nWe observe in Fig. 10a and Fig. 10b that all algorithms approximately show linear time behaviors with respect to n and d. On the other hand, Fig. 10c shows that PC2001 is not sensitive to the density of networks whereas DPC\u2217 and SAC3-SDS perform better when the density of networks is lower. Fig. 10d shows that the CPU time for DPC\u2217\nremains almost unchanged when increasing the looseness of constraints. However, the CPU times for PC2001 and SAC3-SDS both go up and then drop down when increasing the looseness of constraints. Finally, we also observe in all the graphs in Fig. 10 that the performance differences among DPC\u2217, PC2001 and SAC3-SDS are remarkable. DPC\u2217\nnot only runs significantly faster than PC2001 and SAC3-SDS, but it also scales up to 7 times and 5 times better than PC2001 and SAC3-SDS respectively. This mainly owes to the fact that DPC\u2217 is a single pass algorithm over the ordered input constraint networks."}, {"heading": "8 Conclusion", "text": "This paper investigated which constraint satisfaction problems can be efficiently decided by enforcing directional path-consistency. Given a complete binary constraint language \u0393 , it turns out that DPC can decide CSP(\u0393 ) if \u0393 is defined over domains with less than three values. For a possibly incomplete binary constraint language \u0393 , we proved that \u0393 has the Helly property if, and only if, for any non-trivially inconsistent and triangulated binary constraint network N over \u0393 , N is consistent if it is strongly DPC relative to the inverse ordering of some perfect elimination ordering of the constraint graph of N . The classes of row-convex [3] and tree-convex [35] constraints are examples of constraint classes which have the Helly property. More importantly, we presented the algorithm DPC\u2217, a simple variant of DPC, which can decide the CSP of any majority-closed constraint language, and is sufficient for guaranteeing backtrackfree search for majority-closed constraint networks, which have been found applications in various domains, such as scene labeling, temporal reasoning, geometric reasoning, and logical filtering. Our evaluations also show that DPC\u2217 significantly outperforms the state-of-the-art algorithms for solving majority-closed constraint networks."}], "references": [{"title": "The collapse of the bounded width hierarchy", "author": ["L. Barto"], "venue": "Journal of Logic and Computation 26(3), 923\u2013943", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2016}, {"title": "Constraint satisfaction problems solvable by local consistency methods", "author": ["L. Barto", "M. Kozik"], "venue": "Journal of the ACM 61(1), 3:1\u20133:19", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2014}, {"title": "On the minimality and global consistency of row-convex constraint networks", "author": ["P. van Beek", "R. Dechter"], "venue": "Journal of the ACM 42(3), 543\u2013561", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1995}, {"title": "Efficient algorithms for singleton arc consistency", "author": ["C. Bessi\u00e8re", "S. Cardon", "R. Debruyne", "C. Lecoutre"], "venue": "Constraints 16(1), 25\u201353", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "An optimal coarse-grained arc consistency algorithm", "author": ["C. Bessi\u00e8re", "J.C. R\u00e9gin", "R.H. Yap", "Y. Zhang"], "venue": "Artificial Intelligence 165(2), 165\u2013185", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2005}, {"title": "Path consistency on triangulated constraint graphs", "author": ["C. Bliek", "D. Sam-Haroud"], "venue": "IJCAI. pp. 456\u2013461", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1999}, {"title": "An algebraic approach to multi-sorted constraints", "author": ["A.A. Bulatov", "P. Jeavons"], "venue": "CP. pp. 183\u2013198", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2003}, {"title": "Tractability in constraint satisfaction problems: A survey", "author": ["C. Carbonnel", "M.C. Cooper"], "venue": "Constraints 21(2), 115\u2013144", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2016}, {"title": "Arc consistency and friends", "author": ["H. Chen", "V. Dalmau", "B. Gru\u00dfien"], "venue": "Journal of Logic and Computation 23(1), 87\u2013108", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2011}, {"title": "Efficient path-consistency propagation", "author": ["A. Chmeiss", "P. J\u00e9gou"], "venue": "International Journal on Artificial Intelligence Tools 7(02), 121\u2013142", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1998}, {"title": "The complexity of constraint languages", "author": ["D. Cohen", "P. Jeavons"], "venue": "Handbook of Constraint Programming, pp. 169\u2013204. Elsevier", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2006}, {"title": "Some practicable filtering techniques for the constraint satisfaction problem", "author": ["R. Debruyne", "C. Bessi\u00e8re"], "venue": "IJCAI. pp. 412\u2013417", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1997}, {"title": "Constraint processing", "author": ["R. Dechter"], "venue": "Morgan Kaufmann", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2003}, {"title": "Temporal constraint networks", "author": ["R. Dechter", "I. Meiri", "J. Pearl"], "venue": "Artificial Intelligence 49(1-3), 61\u201395", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1991}, {"title": "Network-based heuristics for constraint-satisfaction problems", "author": ["R. Dechter", "J. Pearl"], "venue": "Artificial Intelligence 34(1), 1\u201338", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1987}, {"title": "Constraint satisfaction over connected row convex constraints", "author": ["Y. Deville", "O. Barette", "P. van Hentenryck"], "venue": "Artificial Intelligence 109(1-2), 243\u2013271", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1999}, {"title": "A sufficient condition for backtrack-free search", "author": ["E.C. Freuder"], "venue": "Journal of the ACM 29(1), 24\u201332", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1982}, {"title": "Incidence matrices and interval graphs", "author": ["D. Fulkerson", "O. Gross"], "venue": "Pacific Journal of Mathematics 15(3), 835\u2013855", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1965}, {"title": "Constraints, consistency and closure", "author": ["P. Jeavons", "D. Cohen", "M.C. Cooper"], "venue": "Artificial Intelligence 101(1), 251\u2013265", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1998}, {"title": "On tree-preserving constraints", "author": ["S. Kong", "S. Li", "Y. Li", "Z. Long"], "venue": "CP. pp. 244\u2013261", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "On tree-preserving constraints", "author": ["S. Kong", "S. Li", "Y. Li", "Z. Long"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2017}, {"title": "Weak consistency notions for all the csps of bounded width", "author": ["M. Kozik"], "venue": "LICS. pp. 633\u2013 641", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2016}, {"title": "On geometric CSPs with (near)-linear domains and max-distance constraints", "author": ["T.K.S. Kumar"], "venue": "Workshop on Modelling and Solving Problems with Constraints. pp. 125\u2013138", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "On the tractability of restricted disjunctive temporal problems", "author": ["T.K.S. Kumar"], "venue": "ICAPS. pp. 110\u2013119", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2005}, {"title": "On some tractable cases of logical filtering", "author": ["T.K.S. Kumar", "S.J. Russell"], "venue": "ICAPS. pp. 83\u201392", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2006}, {"title": "Qualitative constraint satisfaction problems: an extended framework with landmarks", "author": ["S. Li", "W. Liu", "S. Wang"], "venue": "Artificial Intelligence 201, 32\u201358", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2013}, {"title": "Consistency in networks of relations", "author": ["A.K. Mackworth"], "venue": "Artificial Intelligence 8(1), 99\u2013118", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1977}, {"title": "Structural disambiguation with constraint propagation", "author": ["H. Maruyama"], "venue": "ACL. pp. 31\u201338", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1990}, {"title": "Arc and path consistency revisited", "author": ["R. Mohr", "T.C. Henderson"], "venue": "Artificial Intelligence 28(2), 225\u2013233", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1986}, {"title": "Networks of constraints: fundamental properties and applications to picture processing", "author": ["U. Montanari"], "venue": "Information Science 7, 95\u2013132", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1974}, {"title": "PC: A new algorithm for the simple temporal problem", "author": ["L. Planken", "M. de Weerdt", "R. van der Krogt"], "venue": "ICAPS. vol. 2008, pp. 256\u2013263", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2008}, {"title": "Path consistency revisited", "author": ["M. Singh"], "venue": "International Journal on Artificial Intelligence Tools 5(1-2), 127\u2013142", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1996}, {"title": "Efficiently reasoning about qualitative constraints through variable elimination", "author": ["M. Sioutis", "Z. Long", "S. Li"], "venue": "SETN. pp. 1:1\u20131:10", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2016}, {"title": "Solving connected row convex constraints by variable elimination", "author": ["Y. Zhang", "S. Marisetti"], "venue": "Artificial Intelligence 173(12), 1204\u20131219", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2009}, {"title": "Consistency and set intersection", "author": ["Y. Zhang", "R.H.C. Yap"], "venue": "IJCAI. pp. 263\u2013270", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 29, "context": "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].", "startOffset": 76, "endOffset": 80}, {"referenceID": 27, "context": "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].", "startOffset": 115, "endOffset": 119}, {"referenceID": 13, "context": "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].", "startOffset": 140, "endOffset": 147}, {"referenceID": 30, "context": "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].", "startOffset": 140, "endOffset": 147}, {"referenceID": 25, "context": "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].", "startOffset": 171, "endOffset": 175}, {"referenceID": 16, "context": "form of local consistency, a crucial task is to determine problems that can be solved by backtrack-free search using that local consistency [17].", "startOffset": 140, "endOffset": 144}, {"referenceID": 26, "context": "[27,29,32,6,10]).", "startOffset": 0, "endOffset": 15}, {"referenceID": 28, "context": "[27,29,32,6,10]).", "startOffset": 0, "endOffset": 15}, {"referenceID": 31, "context": "[27,29,32,6,10]).", "startOffset": 0, "endOffset": 15}, {"referenceID": 5, "context": "[27,29,32,6,10]).", "startOffset": 0, "endOffset": 15}, {"referenceID": 9, "context": "[27,29,32,6,10]).", "startOffset": 0, "endOffset": 15}, {"referenceID": 1, "context": "Recently, it was shown that PC can be used to decide the satisfiability of a problem if and only if the problem does not have the ability to count [2,1]; however, it remains unclear whether backtrack-free search can be used to extract a solution for such a problem after enforcing PC.", "startOffset": 147, "endOffset": 152}, {"referenceID": 0, "context": "Recently, it was shown that PC can be used to decide the satisfiability of a problem if and only if the problem does not have the ability to count [2,1]; however, it remains unclear whether backtrack-free search can be used to extract a solution for such a problem after enforcing PC.", "startOffset": 147, "endOffset": 152}, {"referenceID": 14, "context": "Directional path-consistency (DPC) [15] is a weaker notion of PC that considers a given variable ordering and can thus be enforced more efficiently than PC.", "startOffset": 35, "endOffset": 39}, {"referenceID": 14, "context": "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].", "startOffset": 49, "endOffset": 53}, {"referenceID": 13, "context": "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].", "startOffset": 147, "endOffset": 154}, {"referenceID": 30, "context": "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].", "startOffset": 147, "endOffset": 154}, {"referenceID": 32, "context": "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].", "startOffset": 177, "endOffset": 181}, {"referenceID": 14, "context": "Dechter and Pearl [15] showed that DPC is sufficient for enabling backtrack-free search for networks with constraint graphs of regular width 2.", "startOffset": 18, "endOffset": 22}, {"referenceID": 7, "context": "We consider the aforementioned question in the context of constraint languages, which is a widely adopted approach in the study of tractability of constraint satisfaction problems [8].", "startOffset": 180, "endOffset": 183}, {"referenceID": 15, "context": "The most well-known one is the class of connected row-convex (CRC) constraints [16], which is further generalized to a larger class of tree-preserving constraints [20].", "startOffset": 79, "endOffset": 83}, {"referenceID": 19, "context": "The most well-known one is the class of connected row-convex (CRC) constraints [16], which is further generalized to a larger class of tree-preserving constraints [20].", "startOffset": 163, "endOffset": 167}, {"referenceID": 23, "context": "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].", "startOffset": 81, "endOffset": 85}, {"referenceID": 24, "context": "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].", "startOffset": 105, "endOffset": 109}, {"referenceID": 22, "context": "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].", "startOffset": 135, "endOffset": 139}, {"referenceID": 19, "context": "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].", "startOffset": 243, "endOffset": 247}, {"referenceID": 5, "context": "2: Path-Consistency [6].", "startOffset": 20, "endOffset": 23}, {"referenceID": 5, "context": "Triangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33].", "startOffset": 92, "endOffset": 101}, {"referenceID": 30, "context": "Triangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33].", "startOffset": 92, "endOffset": 101}, {"referenceID": 32, "context": "Triangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33].", "startOffset": 92, "endOffset": 101}, {"referenceID": 17, "context": "A graphG is triangulated iff it admits a perfect elimination ordering (PEO) [18].", "startOffset": 76, "endOffset": 80}, {"referenceID": 5, "context": "A constraint network N is AC if GN is AC and N is PC if the competition of GN is PC [6].", "startOffset": 84, "endOffset": 87}, {"referenceID": 18, "context": "[19] Let D = {D1, .", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "For any tuple t \u2208 R and any 1 \u2264 i \u2264 n, we denote by t[i] the value in the i-th coordinate position of t and write t as \u3008t[1], .", "startOffset": 121, "endOffset": 124}, {"referenceID": 18, "context": "[19] Given a set of binary relations \u0393 , we write \u0393 for the set of relations that can be obtained from \u0393 using some sequence of the following operations:", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] Let \u0393 be a complete set of binary relations over a domainD.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "CSP(\u0393) is log-space reducible to CSP(\u0393 ) [11].", "startOffset": 41, "endOffset": 45}, {"referenceID": 18, "context": "We will see that this is not very restrictive as, for any set \u0393 of binary relations that is closed under a majority operation \u03c6, the completion \u0393 c of \u0393 is also closed under \u03c6 [19] and weakly closed under singletons (cf.", "startOffset": 176, "endOffset": 180}, {"referenceID": 12, "context": "This section recalls the notions of directional arc-consistency (DAC) and directional path-consistency (DPC), and the strong DPC enforcing algorithm of Dechter and Pearl [13].", "startOffset": 170, "endOffset": 174}, {"referenceID": 12, "context": "[13] Let N = \u3008V,D, C\u3009 be a BCN and \u227a= (v1, .", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "In comparison with traditional PC algorithms [10], a novelty of this single pass algorithm is its explicit reference to the constraint graph of the input constraint network.", "startOffset": 45, "endOffset": 49}, {"referenceID": 12, "context": "Further, Algorithm 1 runs inO(w\u2217(\u227a) \u00b7e \u00b7 (\u03b1+\u03b2)) time [13], where e is the number of edges of the output constraint graph, w\u2217(\u227a) is the induced width of the ordered graph along \u227a, and \u03b1, \u03b2 are the runtimes of relational intersection and composition respectively.", "startOffset": 53, "endOffset": 57}, {"referenceID": 12, "context": "[13] Let (N ,\u227a) be an input to Algorithm 1, where \u227a = (v1, .", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "3: A graph coloring problem with domain Di = {red, blue} for i = 1, 2, 3, 4 [13].", "startOffset": 76, "endOffset": 80}, {"referenceID": 12, "context": "3 is taken from [13] and can be decided by Algorithm 1.", "startOffset": 16, "endOffset": 20}, {"referenceID": 12, "context": "We observe that DPC achieves (strong) DPC using the idea of variable elimination [13]: it iterates variables along the ordering \u227a\u22121, and propagates the constraints of a variable vk to subsequent variables in the ordering with the update rule Rij \u2190 Rij \u2229 (Rik \u25e6Rkj), as if vk is \u2018eliminated\u2019.", "startOffset": 81, "endOffset": 85}, {"referenceID": 2, "context": "This is important; for example, every row-convex constraint [3] network has VEP (cf.", "startOffset": 60, "endOffset": 63}, {"referenceID": 19, "context": "[20]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "The class of row-convex constraints [3] and the class of tree-convex constraints [35] have the Helly property and, thus, they have VEP by Theorem 1.", "startOffset": 36, "endOffset": 39}, {"referenceID": 34, "context": "The class of row-convex constraints [3] and the class of tree-convex constraints [35] have the Helly property and, thus, they have VEP by Theorem 1.", "startOffset": 81, "endOffset": 85}, {"referenceID": 6, "context": "[7] Let D = {D1, .", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": ", n} is said to be closed under \u03c6 if \u03c6(t1, t2, t3) = \u3008\u03c6i1(t1[1], t2[1], t3[1]), .", "startOffset": 60, "endOffset": 63}, {"referenceID": 0, "context": ", n} is said to be closed under \u03c6 if \u03c6(t1, t2, t3) = \u3008\u03c6i1(t1[1], t2[1], t3[1]), .", "startOffset": 67, "endOffset": 70}, {"referenceID": 0, "context": ", n} is said to be closed under \u03c6 if \u03c6(t1, t2, t3) = \u3008\u03c6i1(t1[1], t2[1], t3[1]), .", "startOffset": 74, "endOffset": 77}, {"referenceID": 20, "context": "[21] An undirected graph structure can often be associated to a finite domainD such that there is a bijection between the vertices in the graph and the values in D.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "A CRC constraint is a special tree-preserving constraint where related tree domains are chains [21].", "startOffset": 95, "endOffset": 99}, {"referenceID": 20, "context": "[21] Let Ti and Tj be two nonempty tree domains and mi and mj their standard majority operations.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19] Let \u0393 be a set of binary relations over a set of finite domains D = {D1, .", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "obtained by using a sequence of the Cartesian product, equality selection, and projection operations [19].", "startOffset": 101, "endOffset": 105}, {"referenceID": 33, "context": "Compared with the variable elimination algorithm for solving CRC constraints [34], DPC\u2217 enforces a weaker AC condition instead of full AC.", "startOffset": 77, "endOffset": 81}, {"referenceID": 18, "context": "As we know that if \u0393 is majority-closed, the completion of \u0393 is also majority-closed [19], and that complete majority-closed classes and complete weak VEP classes are equivalent by Theorem 4, this also proves the following result:", "startOffset": 85, "endOffset": 89}, {"referenceID": 3, "context": "These are SAC3-SDS [4] and PC2001 [5].", "startOffset": 19, "endOffset": 22}, {"referenceID": 4, "context": "These are SAC3-SDS [4] and PC2001 [5].", "startOffset": 34, "endOffset": 37}, {"referenceID": 11, "context": "SAC3-SDS is currently the best singleton arc-consistency (SAC) enforcing algorithm [12].", "startOffset": 83, "endOffset": 87}, {"referenceID": 8, "context": "Enforcing either SAC1 or PC correctly decides the consistency of a majority-closed constraint network [9,19].", "startOffset": 102, "endOffset": 108}, {"referenceID": 18, "context": "Enforcing either SAC1 or PC correctly decides the consistency of a majority-closed constraint network [9,19].", "startOffset": 102, "endOffset": 108}, {"referenceID": 21, "context": "(2) 1 Singleton linear arc-consistency (SLAC) is an alternative consistency notion that can be enforced to solve majority-closed constraint network [22], but no practical SLAC algorithms are available so far.", "startOffset": 148, "endOffset": 152}, {"referenceID": 0, "context": "\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether {\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3) holds.", "startOffset": 69, "endOffset": 72}, {"referenceID": 0, "context": "\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether {\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3) holds.", "startOffset": 76, "endOffset": 79}, {"referenceID": 0, "context": "\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether {\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3) holds.", "startOffset": 83, "endOffset": 86}, {"referenceID": 1, "context": "\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether {\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3) holds.", "startOffset": 93, "endOffset": 96}, {"referenceID": 1, "context": "\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether {\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3) holds.", "startOffset": 100, "endOffset": 103}, {"referenceID": 1, "context": "\u2022 Randomly generate constraints Rij \u2286 Di \u00d7Dj and test whether {\u3008\u2297i(tx[1], ty[1], tz[1]),\u2297j(tx[2], ty[2], tz[2])\u3009 | tx, ty, tz \u2208 Rij} \u2286 Rij (3) holds.", "startOffset": 107, "endOffset": 110}, {"referenceID": 5, "context": "We used the model in [6,16] to generate random consistent constraint networks for experiments.", "startOffset": 21, "endOffset": 27}, {"referenceID": 15, "context": "We used the model in [6,16] to generate random consistent constraint networks for experiments.", "startOffset": 21, "endOffset": 27}, {"referenceID": 2, "context": "The classes of row-convex [3] and tree-convex [35] constraints are examples of constraint classes which have the Helly property.", "startOffset": 26, "endOffset": 29}, {"referenceID": 34, "context": "The classes of row-convex [3] and tree-convex [35] constraints are examples of constraint classes which have the Helly property.", "startOffset": 46, "endOffset": 50}], "year": 2017, "abstractText": "Among the local consistency techniques used for solving constraint networks, path-consistency (PC) has received a great deal of attention. However, enforcing PC is computationally expensive and sometimes even unnecessary. Directional path-consistency (DPC) is a weaker notion of PC that considers a given variable ordering and can thus be enforced more efficiently than PC. This paper shows that DPC (the DPC enforcing algorithm of Dechter and Pearl) decides the constraint satisfaction problem (CSP) of a constraint language \u0393 if it is complete and has the variable elimination property (VEP). However, we also show that no complete VEP constraint language can have a domain with more than 2 values. We then present a simple variant of the DPC algorithm, called DPC\u2217, and show that the CSP of a constraint language can be decided by DPC\u2217 if it is closed under a majority operation. In fact, DPC\u2217 is sufficient for guaranteeing backtrack-free search for such constraint networks. Examples of majority-closed constraint classes include the classes of connected row-convex (CRC) constraints and tree-preserving constraints, which have found applications in various domains, such as scene labeling, temporal reasoning, geometric reasoning, and logical filtering. Our experimental evaluations show that DPC\u2217 significantly outperforms the state-of-the-art algorithms for solving majority-closed constraints.", "creator": "LaTeX with hyperref package"}}}